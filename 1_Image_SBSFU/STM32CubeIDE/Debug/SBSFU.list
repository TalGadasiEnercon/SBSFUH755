
SBSFU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000002a0  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text.SE_CORE_Bin 00004978  08000400  08000400  00001400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .SE_IF_Code   0000075c  08008000  08008000  00006000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000059c0  08008a00  08008a00  00007a00  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000a98  0800e3c0  0800e3c0  0000d3c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.extab    00000000  0800ee58  0800ee58  0000e188  2**0
                  CONTENTS, READONLY
  6 .ARM          00000008  0800ee58  0800ee58  0000de58  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .preinit_array 00000000  0800ee60  0800ee60  0000e188  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .init_array   00000008  0800ee60  0800ee60  0000de60  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .fini_array   00000008  0800ee68  0800ee68  0000de68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .data         00000088  20001100  0800ee70  0000e100  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .RamFunc      000000a0  20001000  08008900  00007000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          00000d60  20001188  0800eef8  0000e188  2**3
                  ALLOC
 13 ._user_heap_stack 00002000  20001ee8  0800eef8  0000eee8  2**0
                  ALLOC
 14 .ARM.attributes 0000002e  00000000  00000000  0000e188  2**0
                  CONTENTS, READONLY
 15 .debug_info   00022225  00000000  00000000  0000e1b6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00005bce  00000000  00000000  000303db  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 0000a6bb  00000000  00000000  00035fa9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000011a0  00000000  00000000  00040668  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000011fd  00000000  00000000  00041808  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00040237  00000000  00000000  00042a05  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   00027093  00000000  00000000  00082c3c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    0018975b  00000000  00000000  000a9ccf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  0023342a  2**0
                  CONTENTS, READONLY
 24 .debug_frame  00003400  00000000  00000000  00233470  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 000000dc  00000000  00000000  00236870  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .SE_IF_Code:

08008000 <SE_APP_GetActiveFwInfo>:
  * @param pFwInfo Active Firmware Info structure that will be filled.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
__root SE_ErrorStatus SE_APP_GetActiveFwInfo(SE_StatusTypeDef *peSE_Status, uint32_t SlotNumber,
                                             SE_APP_ActiveFwInfo_t *pFwInfo)
{
 8008000:	b570      	push	{r4, r5, r6, lr}
 8008002:	b086      	sub	sp, #24
 8008004:	4604      	mov	r4, r0
 8008006:	460d      	mov	r5, r1
 8008008:	4616      	mov	r6, r2
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800800a:	f000 fb28 	bl	800865e <SE_IsUnprivileged>
 800800e:	b150      	cbz	r0, 8008026 <SE_APP_GetActiveFwInfo+0x26>
  {
    uint32_t params[2] = {SlotNumber, (uint32_t)pFwInfo};
    SE_SysCall(&e_ret_status, SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, &params);
 8008010:	ab04      	add	r3, sp, #16
 8008012:	4622      	mov	r2, r4
 8008014:	2120      	movs	r1, #32
 8008016:	a803      	add	r0, sp, #12
    uint32_t params[2] = {SlotNumber, (uint32_t)pFwInfo};
 8008018:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, &params);
 800801c:	f000 fb29 	bl	8008672 <SE_SysCall>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 8008020:	9803      	ldr	r0, [sp, #12]
 8008022:	b006      	add	sp, #24
 8008024:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 8008026:	a804      	add	r0, sp, #16
 8008028:	f000 fb10 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, primask_bit, SlotNumber, pFwInfo);
 800802c:	4621      	mov	r1, r4
 800802e:	462b      	mov	r3, r5
 8008030:	9a04      	ldr	r2, [sp, #16]
 8008032:	4c04      	ldr	r4, [pc, #16]	@ (8008044 <SE_APP_GetActiveFwInfo+0x44>)
 8008034:	2020      	movs	r0, #32
 8008036:	9600      	str	r6, [sp, #0]
 8008038:	47a0      	blx	r4
 800803a:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 800803c:	9804      	ldr	r0, [sp, #16]
 800803e:	f000 fb0a 	bl	8008656 <SE_ExitSecureMode>
 8008042:	e7ed      	b.n	8008020 <SE_APP_GetActiveFwInfo+0x20>
 8008044:	08000405 	.word	0x08000405

08008048 <SE_APP_SVC_Handler>:


#ifdef SFU_ISOLATE_SE_WITH_MPU
__root void SE_APP_SVC_Handler(uint32_t *args)
{
  SE_SVC_Handler(args);
 8008048:	f000 bb16 	b.w	8008678 <SE_SVC_Handler>

0800804c <SE_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param uSystemCoreClock System clock value.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Init(SE_StatusTypeDef *peSE_Status, uint32_t uSystemCoreClock)
{
 800804c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800804e:	4604      	mov	r4, r0
 8008050:	460d      	mov	r5, r1
}
#elif defined(__GNUC__)
static inline uint32_t get_LR(void)
{
  register uint32_t result;
  __asm volatile("MOV %0, LR\n" : "=r"(result));
 8008052:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008054:	4b0c      	ldr	r3, [pc, #48]	@ (8008088 <SE_Init+0x3c>)
 8008056:	429a      	cmp	r2, r3
 8008058:	d314      	bcc.n	8008084 <SE_Init+0x38>
 800805a:	4672      	mov	r2, lr
 800805c:	4b0b      	ldr	r3, [pc, #44]	@ (800808c <SE_Init+0x40>)
 800805e:	429a      	cmp	r2, r3
 8008060:	d810      	bhi.n	8008084 <SE_Init+0x38>

  /* Check the pointers allocation */
  if (peSE_Status == NULL)
 8008062:	b178      	cbz	r0, 8008084 <SE_Init+0x38>

  /* Set the CallGate function pointer */
  SET_CALLGATE();

  /* Enter Secure Mode */
  SE_EnterSecureMode(&primask_bit);
 8008064:	a801      	add	r0, sp, #4
 8008066:	f000 faf1 	bl	800864c <SE_EnterSecureMode>

  /* Secure Engine Call */
  e_ret_status = (*SE_CallGatePtr)(SE_INIT_ID, peSE_Status, primask_bit, uSystemCoreClock);
 800806a:	4621      	mov	r1, r4
 800806c:	462b      	mov	r3, r5
 800806e:	4c08      	ldr	r4, [pc, #32]	@ (8008090 <SE_Init+0x44>)
 8008070:	9a01      	ldr	r2, [sp, #4]
 8008072:	2000      	movs	r0, #0
 8008074:	47a0      	blx	r4
 8008076:	4604      	mov	r4, r0

  /* Exit Secure Mode */
  SE_ExitSecureMode(primask_bit);
 8008078:	9801      	ldr	r0, [sp, #4]
 800807a:	f000 faec 	bl	8008656 <SE_ExitSecureMode>


  return e_ret_status;
}
 800807e:	4620      	mov	r0, r4
 8008080:	b003      	add	sp, #12
 8008082:	bd30      	pop	{r4, r5, pc}
  __IS_SFU_RESERVED();
 8008084:	4c03      	ldr	r4, [pc, #12]	@ (8008094 <SE_Init+0x48>)
 8008086:	e7fa      	b.n	800807e <SE_Init+0x32>
 8008088:	08008a00 	.word	0x08008a00
 800808c:	0801ffff 	.word	0x0801ffff
 8008090:	08000405 	.word	0x08000405
 8008094:	00018799 	.word	0x00018799

08008098 <SE_Startup>:
  *        This function must be called only one time so an internal check is executed.
  * @param None.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Startup(void)
{
 8008098:	b538      	push	{r3, r4, r5, lr}
 800809a:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  static uint8_t b_startup_already_done = 0U;
  static SE_ErrorStatus(*SE_StartupPtr)(void);            /*!< Secure Engine STARTUP  pointer function*/

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 800809c:	4b0a      	ldr	r3, [pc, #40]	@ (80080c8 <SE_Startup+0x30>)
 800809e:	429a      	cmp	r2, r3
 80080a0:	d30e      	bcc.n	80080c0 <SE_Startup+0x28>
 80080a2:	4672      	mov	r2, lr
 80080a4:	4b09      	ldr	r3, [pc, #36]	@ (80080cc <SE_Startup+0x34>)
 80080a6:	429a      	cmp	r2, r3
 80080a8:	d80a      	bhi.n	80080c0 <SE_Startup+0x28>

  /* Need to be sure to execute this initialization only one time! */
  if (b_startup_already_done == 0U)
 80080aa:	4d09      	ldr	r5, [pc, #36]	@ (80080d0 <SE_Startup+0x38>)
 80080ac:	4c09      	ldr	r4, [pc, #36]	@ (80080d4 <SE_Startup+0x3c>)
 80080ae:	782b      	ldrb	r3, [r5, #0]
 80080b0:	b943      	cbnz	r3, 80080c4 <SE_Startup+0x2c>
  {
    /* Secure Core Initialization */
    SE_StartupPtr = (SE_ErrorStatus(*)(void))((uint32_t) SE_STARTUP_REGION_ROM_START + 1U);
 80080b2:	4b09      	ldr	r3, [pc, #36]	@ (80080d8 <SE_Startup+0x40>)
    e_ret_status = (*SE_StartupPtr)();
 80080b4:	4798      	blx	r3
    if (e_ret_status == SE_SUCCESS)
 80080b6:	42a0      	cmp	r0, r4
 80080b8:	d101      	bne.n	80080be <SE_Startup+0x26>
    {
      b_startup_already_done = 1U;
 80080ba:	2301      	movs	r3, #1
 80080bc:	702b      	strb	r3, [r5, #0]
    /* This function has been already successfully called */
    e_ret_status = SE_SUCCESS;
  }

  return e_ret_status;
}
 80080be:	bd38      	pop	{r3, r4, r5, pc}
  __IS_SFU_RESERVED();
 80080c0:	4806      	ldr	r0, [pc, #24]	@ (80080dc <SE_Startup+0x44>)
 80080c2:	e7fc      	b.n	80080be <SE_Startup+0x26>
    e_ret_status = SE_SUCCESS;
 80080c4:	4620      	mov	r0, r4
 80080c6:	e7fa      	b.n	80080be <SE_Startup+0x26>
 80080c8:	08008a00 	.word	0x08008a00
 80080cc:	0801ffff 	.word	0x0801ffff
 80080d0:	20001d98 	.word	0x20001d98
 80080d4:	0012310f 	.word	0x0012310f
 80080d8:	08000901 	.word	0x08000901
 80080dc:	00018799 	.word	0x00018799

080080e0 <SE_LockRestrictServices>:
  * @brief call by SFU to lock part of Secure Engine services
  * @param  pSE_Status Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_LockRestrictServices(SE_StatusTypeDef *pSE_Status)
{
 80080e0:	b513      	push	{r0, r1, r4, lr}
 80080e2:	4604      	mov	r4, r0
 80080e4:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80080e6:	4b12      	ldr	r3, [pc, #72]	@ (8008130 <SE_LockRestrictServices+0x50>)
 80080e8:	429a      	cmp	r2, r3
 80080ea:	d31e      	bcc.n	800812a <SE_LockRestrictServices+0x4a>
 80080ec:	4672      	mov	r2, lr
 80080ee:	4b11      	ldr	r3, [pc, #68]	@ (8008134 <SE_LockRestrictServices+0x54>)
 80080f0:	429a      	cmp	r2, r3
 80080f2:	d81a      	bhi.n	800812a <SE_LockRestrictServices+0x4a>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80080f4:	f000 fab3 	bl	800865e <SE_IsUnprivileged>
 80080f8:	b148      	cbz	r0, 800810e <SE_LockRestrictServices+0x2e>
  {
    SE_SysCall(&e_ret_status, SE_LOCK_RESTRICT_SERVICES, pSE_Status, NULL);
 80080fa:	2300      	movs	r3, #0
 80080fc:	4622      	mov	r2, r4
 80080fe:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8008102:	4668      	mov	r0, sp
 8008104:	f000 fab5 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_LOCK_RESTRICT_SERVICES, pSE_Status, primask_bit);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008108:	9800      	ldr	r0, [sp, #0]
}
 800810a:	b002      	add	sp, #8
 800810c:	bd10      	pop	{r4, pc}
    SE_EnterSecureMode(&primask_bit);
 800810e:	a801      	add	r0, sp, #4
 8008110:	f000 fa9c 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_LOCK_RESTRICT_SERVICES, pSE_Status, primask_bit);
 8008114:	9a01      	ldr	r2, [sp, #4]
 8008116:	4621      	mov	r1, r4
 8008118:	4b07      	ldr	r3, [pc, #28]	@ (8008138 <SE_LockRestrictServices+0x58>)
 800811a:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800811e:	4798      	blx	r3
 8008120:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 8008122:	9801      	ldr	r0, [sp, #4]
 8008124:	f000 fa97 	bl	8008656 <SE_ExitSecureMode>
 8008128:	e7ee      	b.n	8008108 <SE_LockRestrictServices+0x28>
  __IS_SFU_RESERVED();
 800812a:	4804      	ldr	r0, [pc, #16]	@ (800813c <SE_LockRestrictServices+0x5c>)
 800812c:	e7ed      	b.n	800810a <SE_LockRestrictServices+0x2a>
 800812e:	bf00      	nop
 8008130:	08008a00 	.word	0x08008a00
 8008134:	0801ffff 	.word	0x0801ffff
 8008138:	08000405 	.word	0x08000405
 800813c:	00018799 	.word	0x00018799

08008140 <SE_CM0_Update>:
  * @brief call by SFU to trigg FUS or wireless stack update process managed by CM0
  * @param  pSE_Status Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CM0_Update(SE_StatusTypeDef *pSE_Status)
{
 8008140:	b513      	push	{r0, r1, r4, lr}
 8008142:	4604      	mov	r4, r0
 8008144:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008146:	4b12      	ldr	r3, [pc, #72]	@ (8008190 <SE_CM0_Update+0x50>)
 8008148:	429a      	cmp	r2, r3
 800814a:	d31e      	bcc.n	800818a <SE_CM0_Update+0x4a>
 800814c:	4672      	mov	r2, lr
 800814e:	4b11      	ldr	r3, [pc, #68]	@ (8008194 <SE_CM0_Update+0x54>)
 8008150:	429a      	cmp	r2, r3
 8008152:	d81a      	bhi.n	800818a <SE_CM0_Update+0x4a>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008154:	f000 fa83 	bl	800865e <SE_IsUnprivileged>
 8008158:	b148      	cbz	r0, 800816e <SE_CM0_Update+0x2e>
  {
    SE_SysCall(&e_ret_status, SE_CM0_UPDATE, pSE_Status, NULL);
 800815a:	2300      	movs	r3, #0
 800815c:	4622      	mov	r2, r4
 800815e:	f44f 7190 	mov.w	r1, #288	@ 0x120
 8008162:	4668      	mov	r0, sp
 8008164:	f000 fa85 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_CM0_UPDATE, pSE_Status, primask_bit);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008168:	9800      	ldr	r0, [sp, #0]
}
 800816a:	b002      	add	sp, #8
 800816c:	bd10      	pop	{r4, pc}
    SE_EnterSecureMode(&primask_bit);
 800816e:	a801      	add	r0, sp, #4
 8008170:	f000 fa6c 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CM0_UPDATE, pSE_Status, primask_bit);
 8008174:	9a01      	ldr	r2, [sp, #4]
 8008176:	4621      	mov	r1, r4
 8008178:	4b07      	ldr	r3, [pc, #28]	@ (8008198 <SE_CM0_Update+0x58>)
 800817a:	f44f 7090 	mov.w	r0, #288	@ 0x120
 800817e:	4798      	blx	r3
 8008180:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 8008182:	9801      	ldr	r0, [sp, #4]
 8008184:	f000 fa67 	bl	8008656 <SE_ExitSecureMode>
 8008188:	e7ee      	b.n	8008168 <SE_CM0_Update+0x28>
  __IS_SFU_RESERVED();
 800818a:	4804      	ldr	r0, [pc, #16]	@ (800819c <SE_CM0_Update+0x5c>)
 800818c:	e7ed      	b.n	800816a <SE_CM0_Update+0x2a>
 800818e:	bf00      	nop
 8008190:	08008a00 	.word	0x08008a00
 8008194:	0801ffff 	.word	0x0801ffff
 8008198:	08000405 	.word	0x08000405
 800819c:	00018799 	.word	0x00018799

080081a0 <SE_ExtFlash_Decrypt_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxSE_Metadata Metadata that will be used to fill the Crypto Init structure.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_ExtFlash_Decrypt_Init(SE_StatusTypeDef *pSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata)
{
 80081a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80081a2:	4604      	mov	r4, r0
 80081a4:	460d      	mov	r5, r1
 80081a6:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80081a8:	4b12      	ldr	r3, [pc, #72]	@ (80081f4 <SE_ExtFlash_Decrypt_Init+0x54>)
 80081aa:	429a      	cmp	r2, r3
 80081ac:	d320      	bcc.n	80081f0 <SE_ExtFlash_Decrypt_Init+0x50>
 80081ae:	4672      	mov	r2, lr
 80081b0:	4b11      	ldr	r3, [pc, #68]	@ (80081f8 <SE_ExtFlash_Decrypt_Init+0x58>)
 80081b2:	429a      	cmp	r2, r3
 80081b4:	d81c      	bhi.n	80081f0 <SE_ExtFlash_Decrypt_Init+0x50>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80081b6:	f000 fa52 	bl	800865e <SE_IsUnprivileged>
 80081ba:	b150      	cbz	r0, 80081d2 <SE_ExtFlash_Decrypt_Init+0x32>
  {
    uint32_t params[1] = {(uint32_t)pxSE_Metadata};
    SE_SysCall(&e_ret_status, SE_EXTFLASH_DECRYPT_INIT, pSE_Status, &params);
 80081bc:	ab01      	add	r3, sp, #4
 80081be:	4622      	mov	r2, r4
 80081c0:	f44f 7188 	mov.w	r1, #272	@ 0x110
 80081c4:	4668      	mov	r0, sp
    uint32_t params[1] = {(uint32_t)pxSE_Metadata};
 80081c6:	9501      	str	r5, [sp, #4]
    SE_SysCall(&e_ret_status, SE_EXTFLASH_DECRYPT_INIT, pSE_Status, &params);
 80081c8:	f000 fa53 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_EXTFLASH_DECRYPT_INIT, pSE_Status, primask_bit, pxSE_Metadata);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 80081cc:	9800      	ldr	r0, [sp, #0]
}
 80081ce:	b003      	add	sp, #12
 80081d0:	bd30      	pop	{r4, r5, pc}
    SE_EnterSecureMode(&primask_bit);
 80081d2:	a801      	add	r0, sp, #4
 80081d4:	f000 fa3a 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_EXTFLASH_DECRYPT_INIT, pSE_Status, primask_bit, pxSE_Metadata);
 80081d8:	4621      	mov	r1, r4
 80081da:	462b      	mov	r3, r5
 80081dc:	9a01      	ldr	r2, [sp, #4]
 80081de:	4c07      	ldr	r4, [pc, #28]	@ (80081fc <SE_ExtFlash_Decrypt_Init+0x5c>)
 80081e0:	f44f 7088 	mov.w	r0, #272	@ 0x110
 80081e4:	47a0      	blx	r4
 80081e6:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 80081e8:	9801      	ldr	r0, [sp, #4]
 80081ea:	f000 fa34 	bl	8008656 <SE_ExitSecureMode>
 80081ee:	e7ed      	b.n	80081cc <SE_ExtFlash_Decrypt_Init+0x2c>
  __IS_SFU_RESERVED();
 80081f0:	4803      	ldr	r0, [pc, #12]	@ (8008200 <SE_ExtFlash_Decrypt_Init+0x60>)
 80081f2:	e7ec      	b.n	80081ce <SE_ExtFlash_Decrypt_Init+0x2e>
 80081f4:	08008a00 	.word	0x08008a00
 80081f8:	0801ffff 	.word	0x0801ffff
 80081fc:	08000405 	.word	0x08000405
 8008200:	00018799 	.word	0x00018799

08008204 <SE_SFU_IMG_Read>:
  * @param  Length: number of bytes to read from flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Read(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, const uint8_t *pSource,
                               uint32_t Length)
{
 8008204:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008206:	4604      	mov	r4, r0
 8008208:	b087      	sub	sp, #28
 800820a:	460d      	mov	r5, r1
 800820c:	4616      	mov	r6, r2
 800820e:	461f      	mov	r7, r3
 8008210:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008212:	4b14      	ldr	r3, [pc, #80]	@ (8008264 <SE_SFU_IMG_Read+0x60>)
 8008214:	429a      	cmp	r2, r3
 8008216:	d322      	bcc.n	800825e <SE_SFU_IMG_Read+0x5a>
 8008218:	4672      	mov	r2, lr
 800821a:	4b13      	ldr	r3, [pc, #76]	@ (8008268 <SE_SFU_IMG_Read+0x64>)
 800821c:	429a      	cmp	r2, r3
 800821e:	d81e      	bhi.n	800825e <SE_SFU_IMG_Read+0x5a>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008220:	f000 fa1d 	bl	800865e <SE_IsUnprivileged>
 8008224:	b158      	cbz	r0, 800823e <SE_SFU_IMG_Read+0x3a>
  {

    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
    SE_SysCall(&e_ret_status, SE_IMG_READ, pSE_Status, &params);
 8008226:	ab03      	add	r3, sp, #12
 8008228:	4622      	mov	r2, r4
 800822a:	2192      	movs	r1, #146	@ 0x92
 800822c:	a802      	add	r0, sp, #8
    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
 800822e:	9705      	str	r7, [sp, #20]
 8008230:	e9cd 5603 	strd	r5, r6, [sp, #12]
    SE_SysCall(&e_ret_status, SE_IMG_READ, pSE_Status, &params);
 8008234:	f000 fa1d 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008238:	9802      	ldr	r0, [sp, #8]
}
 800823a:	b007      	add	sp, #28
 800823c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SE_EnterSecureMode(&primask_bit);
 800823e:	a803      	add	r0, sp, #12
 8008240:	f000 fa04 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_READ, pSE_Status, primask_bit, pDestination, pSource, Length);;
 8008244:	4621      	mov	r1, r4
 8008246:	462b      	mov	r3, r5
 8008248:	9a03      	ldr	r2, [sp, #12]
 800824a:	4c08      	ldr	r4, [pc, #32]	@ (800826c <SE_SFU_IMG_Read+0x68>)
 800824c:	2092      	movs	r0, #146	@ 0x92
 800824e:	e9cd 6700 	strd	r6, r7, [sp]
 8008252:	47a0      	blx	r4
 8008254:	9002      	str	r0, [sp, #8]
    SE_ExitSecureMode(primask_bit);
 8008256:	9803      	ldr	r0, [sp, #12]
 8008258:	f000 f9fd 	bl	8008656 <SE_ExitSecureMode>
 800825c:	e7ec      	b.n	8008238 <SE_SFU_IMG_Read+0x34>
  __IS_SFU_RESERVED();
 800825e:	4804      	ldr	r0, [pc, #16]	@ (8008270 <SE_SFU_IMG_Read+0x6c>)
 8008260:	e7eb      	b.n	800823a <SE_SFU_IMG_Read+0x36>
 8008262:	bf00      	nop
 8008264:	08008a00 	.word	0x08008a00
 8008268:	0801ffff 	.word	0x0801ffff
 800826c:	08000405 	.word	0x08000405
 8008270:	00018799 	.word	0x00018799

08008274 <SE_SFU_IMG_Write>:
  * @param  Length: number of bytes to write to flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Write(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, const uint8_t *pSource,
                                uint32_t Length)
{
 8008274:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008276:	4604      	mov	r4, r0
 8008278:	b087      	sub	sp, #28
 800827a:	460d      	mov	r5, r1
 800827c:	4616      	mov	r6, r2
 800827e:	461f      	mov	r7, r3
 8008280:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008282:	4b14      	ldr	r3, [pc, #80]	@ (80082d4 <SE_SFU_IMG_Write+0x60>)
 8008284:	429a      	cmp	r2, r3
 8008286:	d322      	bcc.n	80082ce <SE_SFU_IMG_Write+0x5a>
 8008288:	4672      	mov	r2, lr
 800828a:	4b13      	ldr	r3, [pc, #76]	@ (80082d8 <SE_SFU_IMG_Write+0x64>)
 800828c:	429a      	cmp	r2, r3
 800828e:	d81e      	bhi.n	80082ce <SE_SFU_IMG_Write+0x5a>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008290:	f000 f9e5 	bl	800865e <SE_IsUnprivileged>
 8008294:	b158      	cbz	r0, 80082ae <SE_SFU_IMG_Write+0x3a>
  {
    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
    SE_SysCall(&e_ret_status, SE_IMG_WRITE, pSE_Status, &params);
 8008296:	ab03      	add	r3, sp, #12
 8008298:	4622      	mov	r2, r4
 800829a:	2193      	movs	r1, #147	@ 0x93
 800829c:	a802      	add	r0, sp, #8
    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
 800829e:	9705      	str	r7, [sp, #20]
 80082a0:	e9cd 5603 	strd	r5, r6, [sp, #12]
    SE_SysCall(&e_ret_status, SE_IMG_WRITE, pSE_Status, &params);
 80082a4:	f000 f9e5 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_WRITE, pSE_Status, primask_bit, pDestination, pSource, Length);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 80082a8:	9802      	ldr	r0, [sp, #8]
}
 80082aa:	b007      	add	sp, #28
 80082ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SE_EnterSecureMode(&primask_bit);
 80082ae:	a803      	add	r0, sp, #12
 80082b0:	f000 f9cc 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_WRITE, pSE_Status, primask_bit, pDestination, pSource, Length);
 80082b4:	4621      	mov	r1, r4
 80082b6:	462b      	mov	r3, r5
 80082b8:	9a03      	ldr	r2, [sp, #12]
 80082ba:	4c08      	ldr	r4, [pc, #32]	@ (80082dc <SE_SFU_IMG_Write+0x68>)
 80082bc:	2093      	movs	r0, #147	@ 0x93
 80082be:	e9cd 6700 	strd	r6, r7, [sp]
 80082c2:	47a0      	blx	r4
 80082c4:	9002      	str	r0, [sp, #8]
    SE_ExitSecureMode(primask_bit);
 80082c6:	9803      	ldr	r0, [sp, #12]
 80082c8:	f000 f9c5 	bl	8008656 <SE_ExitSecureMode>
 80082cc:	e7ec      	b.n	80082a8 <SE_SFU_IMG_Write+0x34>
  __IS_SFU_RESERVED();
 80082ce:	4804      	ldr	r0, [pc, #16]	@ (80082e0 <SE_SFU_IMG_Write+0x6c>)
 80082d0:	e7eb      	b.n	80082aa <SE_SFU_IMG_Write+0x36>
 80082d2:	bf00      	nop
 80082d4:	08008a00 	.word	0x08008a00
 80082d8:	0801ffff 	.word	0x0801ffff
 80082dc:	08000405 	.word	0x08000405
 80082e0:	00018799 	.word	0x00018799

080082e4 <SE_SFU_IMG_Erase>:
  * @param  pDestination: pointer to flash area to erase.
  * @param  Length: number of bytes to erase in flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Erase(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, uint32_t Length)
{
 80082e4:	b570      	push	{r4, r5, r6, lr}
 80082e6:	4604      	mov	r4, r0
 80082e8:	b086      	sub	sp, #24
 80082ea:	460d      	mov	r5, r1
 80082ec:	4616      	mov	r6, r2
 80082ee:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80082f0:	4b12      	ldr	r3, [pc, #72]	@ (800833c <SE_SFU_IMG_Erase+0x58>)
 80082f2:	429a      	cmp	r2, r3
 80082f4:	d320      	bcc.n	8008338 <SE_SFU_IMG_Erase+0x54>
 80082f6:	4672      	mov	r2, lr
 80082f8:	4b11      	ldr	r3, [pc, #68]	@ (8008340 <SE_SFU_IMG_Erase+0x5c>)
 80082fa:	429a      	cmp	r2, r3
 80082fc:	d81c      	bhi.n	8008338 <SE_SFU_IMG_Erase+0x54>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80082fe:	f000 f9ae 	bl	800865e <SE_IsUnprivileged>
 8008302:	b150      	cbz	r0, 800831a <SE_SFU_IMG_Erase+0x36>
  {
    uint32_t params[2] = {(uint32_t)pDestination, (uint32_t)Length};
    SE_SysCall(&e_ret_status, SE_IMG_ERASE, pSE_Status, &params);
 8008304:	ab04      	add	r3, sp, #16
 8008306:	4622      	mov	r2, r4
 8008308:	2194      	movs	r1, #148	@ 0x94
 800830a:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pDestination, (uint32_t)Length};
 800830c:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_IMG_ERASE, pSE_Status, &params);
 8008310:	f000 f9af 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_ERASE, pSE_Status, primask_bit, pDestination, Length);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008314:	9803      	ldr	r0, [sp, #12]
}
 8008316:	b006      	add	sp, #24
 8008318:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 800831a:	a804      	add	r0, sp, #16
 800831c:	f000 f996 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_ERASE, pSE_Status, primask_bit, pDestination, Length);
 8008320:	4621      	mov	r1, r4
 8008322:	462b      	mov	r3, r5
 8008324:	9a04      	ldr	r2, [sp, #16]
 8008326:	4c07      	ldr	r4, [pc, #28]	@ (8008344 <SE_SFU_IMG_Erase+0x60>)
 8008328:	2094      	movs	r0, #148	@ 0x94
 800832a:	9600      	str	r6, [sp, #0]
 800832c:	47a0      	blx	r4
 800832e:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 8008330:	9804      	ldr	r0, [sp, #16]
 8008332:	f000 f990 	bl	8008656 <SE_ExitSecureMode>
 8008336:	e7ed      	b.n	8008314 <SE_SFU_IMG_Erase+0x30>
  __IS_SFU_RESERVED();
 8008338:	4803      	ldr	r0, [pc, #12]	@ (8008348 <SE_SFU_IMG_Erase+0x64>)
 800833a:	e7ec      	b.n	8008316 <SE_SFU_IMG_Erase+0x32>
 800833c:	08008a00 	.word	0x08008a00
 8008340:	0801ffff 	.word	0x0801ffff
 8008344:	08000405 	.word	0x08000405
 8008348:	00018799 	.word	0x00018799

0800834c <SE_Decrypt_Init>:
  * @param SE_FwType Type of Fw Image.
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata, uint32_t SE_FwType)
{
 800834c:	b570      	push	{r4, r5, r6, lr}
 800834e:	4605      	mov	r5, r0
 8008350:	b086      	sub	sp, #24
 8008352:	460e      	mov	r6, r1
 8008354:	4614      	mov	r4, r2
 8008356:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008358:	4b13      	ldr	r3, [pc, #76]	@ (80083a8 <SE_Decrypt_Init+0x5c>)
 800835a:	429a      	cmp	r2, r3
 800835c:	d322      	bcc.n	80083a4 <SE_Decrypt_Init+0x58>
 800835e:	4672      	mov	r2, lr
 8008360:	4b12      	ldr	r3, [pc, #72]	@ (80083ac <SE_Decrypt_Init+0x60>)
 8008362:	429a      	cmp	r2, r3
 8008364:	d81e      	bhi.n	80083a4 <SE_Decrypt_Init+0x58>

  /* Check the parameter */
  if ((SE_FwType != SE_FW_IMAGE_COMPLETE) && (SE_FwType != SE_FW_IMAGE_PARTIAL))
 8008366:	2c01      	cmp	r4, #1
 8008368:	d81c      	bhi.n	80083a4 <SE_Decrypt_Init+0x58>
  {
    return SE_ERROR;
  }

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800836a:	f000 f978 	bl	800865e <SE_IsUnprivileged>
 800836e:	b150      	cbz	r0, 8008386 <SE_Decrypt_Init+0x3a>
  {
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, &params);
 8008370:	ab04      	add	r3, sp, #16
 8008372:	462a      	mov	r2, r5
 8008374:	2104      	movs	r1, #4
 8008376:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
 8008378:	e9cd 6404 	strd	r6, r4, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, &params);
 800837c:	f000 f979 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008380:	9803      	ldr	r0, [sp, #12]
}
 8008382:	b006      	add	sp, #24
 8008384:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 8008386:	a804      	add	r0, sp, #16
 8008388:	f000 f960 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, primask_bit, pxSE_Metadata, SE_FwType);
 800838c:	9400      	str	r4, [sp, #0]
 800838e:	4633      	mov	r3, r6
 8008390:	9a04      	ldr	r2, [sp, #16]
 8008392:	4629      	mov	r1, r5
 8008394:	4c06      	ldr	r4, [pc, #24]	@ (80083b0 <SE_Decrypt_Init+0x64>)
 8008396:	2004      	movs	r0, #4
 8008398:	47a0      	blx	r4
 800839a:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 800839c:	9804      	ldr	r0, [sp, #16]
 800839e:	f000 f95a 	bl	8008656 <SE_ExitSecureMode>
 80083a2:	e7ed      	b.n	8008380 <SE_Decrypt_Init+0x34>
  __IS_SFU_RESERVED();
 80083a4:	4803      	ldr	r0, [pc, #12]	@ (80083b4 <SE_Decrypt_Init+0x68>)
 80083a6:	e7ec      	b.n	8008382 <SE_Decrypt_Init+0x36>
 80083a8:	08008a00 	.word	0x08008a00
 80083ac:	0801ffff 	.word	0x0801ffff
 80083b0:	08000405 	.word	0x08000405
 80083b4:	00018799 	.word	0x00018799

080083b8 <SE_Decrypt_Append>:
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                 uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 80083b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80083bc:	b08a      	sub	sp, #40	@ 0x28
 80083be:	4604      	mov	r4, r0
 80083c0:	460d      	mov	r5, r1
 80083c2:	4616      	mov	r6, r2
 80083c4:	461f      	mov	r7, r3
 80083c6:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 80083ca:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80083cc:	4b15      	ldr	r3, [pc, #84]	@ (8008424 <SE_Decrypt_Append+0x6c>)
 80083ce:	429a      	cmp	r2, r3
 80083d0:	d325      	bcc.n	800841e <SE_Decrypt_Append+0x66>
 80083d2:	4672      	mov	r2, lr
 80083d4:	4b14      	ldr	r3, [pc, #80]	@ (8008428 <SE_Decrypt_Append+0x70>)
 80083d6:	429a      	cmp	r2, r3
 80083d8:	d821      	bhi.n	800841e <SE_Decrypt_Append+0x66>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80083da:	f000 f940 	bl	800865e <SE_IsUnprivileged>
 80083de:	b168      	cbz	r0, 80083fc <SE_Decrypt_Append+0x44>
  {
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, &params);
 80083e0:	ab06      	add	r3, sp, #24
 80083e2:	4622      	mov	r2, r4
 80083e4:	2105      	movs	r1, #5
 80083e6:	a805      	add	r0, sp, #20
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 80083e8:	e9cd 5606 	strd	r5, r6, [sp, #24]
 80083ec:	e9cd 7808 	strd	r7, r8, [sp, #32]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, &params);
 80083f0:	f000 f93f 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 80083f4:	9805      	ldr	r0, [sp, #20]
}
 80083f6:	b00a      	add	sp, #40	@ 0x28
 80083f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SE_EnterSecureMode(&primask_bit);
 80083fc:	a806      	add	r0, sp, #24
 80083fe:	f000 f925 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, primask_bit, pInputBuffer, InputSize,
 8008402:	4621      	mov	r1, r4
 8008404:	462b      	mov	r3, r5
 8008406:	9a06      	ldr	r2, [sp, #24]
 8008408:	4c08      	ldr	r4, [pc, #32]	@ (800842c <SE_Decrypt_Append+0x74>)
 800840a:	2005      	movs	r0, #5
 800840c:	9600      	str	r6, [sp, #0]
 800840e:	e9cd 7801 	strd	r7, r8, [sp, #4]
 8008412:	47a0      	blx	r4
 8008414:	9005      	str	r0, [sp, #20]
    SE_ExitSecureMode(primask_bit);
 8008416:	9806      	ldr	r0, [sp, #24]
 8008418:	f000 f91d 	bl	8008656 <SE_ExitSecureMode>
 800841c:	e7ea      	b.n	80083f4 <SE_Decrypt_Append+0x3c>
  __IS_SFU_RESERVED();
 800841e:	4804      	ldr	r0, [pc, #16]	@ (8008430 <SE_Decrypt_Append+0x78>)
 8008420:	e7e9      	b.n	80083f6 <SE_Decrypt_Append+0x3e>
 8008422:	bf00      	nop
 8008424:	08008a00 	.word	0x08008a00
 8008428:	0801ffff 	.word	0x0801ffff
 800842c:	08000405 	.word	0x08000405
 8008430:	00018799 	.word	0x00018799

08008434 <SE_Decrypt_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008434:	b570      	push	{r4, r5, r6, lr}
 8008436:	4604      	mov	r4, r0
 8008438:	b086      	sub	sp, #24
 800843a:	460d      	mov	r5, r1
 800843c:	4616      	mov	r6, r2
 800843e:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008440:	4b12      	ldr	r3, [pc, #72]	@ (800848c <SE_Decrypt_Finish+0x58>)
 8008442:	429a      	cmp	r2, r3
 8008444:	d320      	bcc.n	8008488 <SE_Decrypt_Finish+0x54>
 8008446:	4672      	mov	r2, lr
 8008448:	4b11      	ldr	r3, [pc, #68]	@ (8008490 <SE_Decrypt_Finish+0x5c>)
 800844a:	429a      	cmp	r2, r3
 800844c:	d81c      	bhi.n	8008488 <SE_Decrypt_Finish+0x54>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800844e:	f000 f906 	bl	800865e <SE_IsUnprivileged>
 8008452:	b150      	cbz	r0, 800846a <SE_Decrypt_Finish+0x36>
  {
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, &params);
 8008454:	ab04      	add	r3, sp, #16
 8008456:	4622      	mov	r2, r4
 8008458:	2106      	movs	r1, #6
 800845a:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 800845c:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, &params);
 8008460:	f000 f907 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008464:	9803      	ldr	r0, [sp, #12]
}
 8008466:	b006      	add	sp, #24
 8008468:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 800846a:	a804      	add	r0, sp, #16
 800846c:	f000 f8ee 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, primask_bit, pOutputBuffer,
 8008470:	4621      	mov	r1, r4
 8008472:	462b      	mov	r3, r5
 8008474:	9a04      	ldr	r2, [sp, #16]
 8008476:	4c07      	ldr	r4, [pc, #28]	@ (8008494 <SE_Decrypt_Finish+0x60>)
 8008478:	2006      	movs	r0, #6
 800847a:	9600      	str	r6, [sp, #0]
 800847c:	47a0      	blx	r4
 800847e:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 8008480:	9804      	ldr	r0, [sp, #16]
 8008482:	f000 f8e8 	bl	8008656 <SE_ExitSecureMode>
 8008486:	e7ed      	b.n	8008464 <SE_Decrypt_Finish+0x30>
  __IS_SFU_RESERVED();
 8008488:	4803      	ldr	r0, [pc, #12]	@ (8008498 <SE_Decrypt_Finish+0x64>)
 800848a:	e7ec      	b.n	8008466 <SE_Decrypt_Finish+0x32>
 800848c:	08008a00 	.word	0x08008a00
 8008490:	0801ffff 	.word	0x0801ffff
 8008494:	08000405 	.word	0x08000405
 8008498:	00018799 	.word	0x00018799

0800849c <SE_AuthenticateFW_Init>:
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata,
                                      uint32_t SE_FwType)
{
 800849c:	b570      	push	{r4, r5, r6, lr}
 800849e:	4605      	mov	r5, r0
 80084a0:	b086      	sub	sp, #24
 80084a2:	460e      	mov	r6, r1
 80084a4:	4614      	mov	r4, r2
 80084a6:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80084a8:	4b13      	ldr	r3, [pc, #76]	@ (80084f8 <SE_AuthenticateFW_Init+0x5c>)
 80084aa:	429a      	cmp	r2, r3
 80084ac:	d322      	bcc.n	80084f4 <SE_AuthenticateFW_Init+0x58>
 80084ae:	4672      	mov	r2, lr
 80084b0:	4b12      	ldr	r3, [pc, #72]	@ (80084fc <SE_AuthenticateFW_Init+0x60>)
 80084b2:	429a      	cmp	r2, r3
 80084b4:	d81e      	bhi.n	80084f4 <SE_AuthenticateFW_Init+0x58>

  /* Check the parameter */
  if ((SE_FwType != SE_FW_IMAGE_COMPLETE) && (SE_FwType != SE_FW_IMAGE_PARTIAL))
 80084b6:	2c01      	cmp	r4, #1
 80084b8:	d81c      	bhi.n	80084f4 <SE_AuthenticateFW_Init+0x58>
  {
    return SE_ERROR;
  }

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80084ba:	f000 f8d0 	bl	800865e <SE_IsUnprivileged>
 80084be:	b150      	cbz	r0, 80084d6 <SE_AuthenticateFW_Init+0x3a>
  {
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, &params);
 80084c0:	ab04      	add	r3, sp, #16
 80084c2:	462a      	mov	r2, r5
 80084c4:	2107      	movs	r1, #7
 80084c6:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
 80084c8:	e9cd 6404 	strd	r6, r4, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, &params);
 80084cc:	f000 f8d1 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 80084d0:	9803      	ldr	r0, [sp, #12]
}
 80084d2:	b006      	add	sp, #24
 80084d4:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 80084d6:	a804      	add	r0, sp, #16
 80084d8:	f000 f8b8 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, primask_bit, pxSE_Metadata,
 80084dc:	9400      	str	r4, [sp, #0]
 80084de:	4633      	mov	r3, r6
 80084e0:	9a04      	ldr	r2, [sp, #16]
 80084e2:	4629      	mov	r1, r5
 80084e4:	4c06      	ldr	r4, [pc, #24]	@ (8008500 <SE_AuthenticateFW_Init+0x64>)
 80084e6:	2007      	movs	r0, #7
 80084e8:	47a0      	blx	r4
 80084ea:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 80084ec:	9804      	ldr	r0, [sp, #16]
 80084ee:	f000 f8b2 	bl	8008656 <SE_ExitSecureMode>
 80084f2:	e7ed      	b.n	80084d0 <SE_AuthenticateFW_Init+0x34>
  __IS_SFU_RESERVED();
 80084f4:	4803      	ldr	r0, [pc, #12]	@ (8008504 <SE_AuthenticateFW_Init+0x68>)
 80084f6:	e7ec      	b.n	80084d2 <SE_AuthenticateFW_Init+0x36>
 80084f8:	08008a00 	.word	0x08008a00
 80084fc:	0801ffff 	.word	0x0801ffff
 8008500:	08000405 	.word	0x08000405
 8008504:	00018799 	.word	0x00018799

08008508 <SE_AuthenticateFW_Append>:
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                        uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008508:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800850c:	b08a      	sub	sp, #40	@ 0x28
 800850e:	4604      	mov	r4, r0
 8008510:	460d      	mov	r5, r1
 8008512:	4616      	mov	r6, r2
 8008514:	461f      	mov	r7, r3
 8008516:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 800851a:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 800851c:	4b15      	ldr	r3, [pc, #84]	@ (8008574 <SE_AuthenticateFW_Append+0x6c>)
 800851e:	429a      	cmp	r2, r3
 8008520:	d325      	bcc.n	800856e <SE_AuthenticateFW_Append+0x66>
 8008522:	4672      	mov	r2, lr
 8008524:	4b14      	ldr	r3, [pc, #80]	@ (8008578 <SE_AuthenticateFW_Append+0x70>)
 8008526:	429a      	cmp	r2, r3
 8008528:	d821      	bhi.n	800856e <SE_AuthenticateFW_Append+0x66>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800852a:	f000 f898 	bl	800865e <SE_IsUnprivileged>
 800852e:	b168      	cbz	r0, 800854c <SE_AuthenticateFW_Append+0x44>
  {
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, &params);
 8008530:	ab06      	add	r3, sp, #24
 8008532:	4622      	mov	r2, r4
 8008534:	2108      	movs	r1, #8
 8008536:	a805      	add	r0, sp, #20
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 8008538:	e9cd 5606 	strd	r5, r6, [sp, #24]
 800853c:	e9cd 7808 	strd	r7, r8, [sp, #32]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, &params);
 8008540:	f000 f897 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 8008544:	9805      	ldr	r0, [sp, #20]
}
 8008546:	b00a      	add	sp, #40	@ 0x28
 8008548:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SE_EnterSecureMode(&primask_bit);
 800854c:	a806      	add	r0, sp, #24
 800854e:	f000 f87d 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, primask_bit, pInputBuffer,
 8008552:	4621      	mov	r1, r4
 8008554:	462b      	mov	r3, r5
 8008556:	9a06      	ldr	r2, [sp, #24]
 8008558:	4c08      	ldr	r4, [pc, #32]	@ (800857c <SE_AuthenticateFW_Append+0x74>)
 800855a:	2008      	movs	r0, #8
 800855c:	9600      	str	r6, [sp, #0]
 800855e:	e9cd 7801 	strd	r7, r8, [sp, #4]
 8008562:	47a0      	blx	r4
 8008564:	9005      	str	r0, [sp, #20]
    SE_ExitSecureMode(primask_bit);
 8008566:	9806      	ldr	r0, [sp, #24]
 8008568:	f000 f875 	bl	8008656 <SE_ExitSecureMode>
 800856c:	e7ea      	b.n	8008544 <SE_AuthenticateFW_Append+0x3c>
  __IS_SFU_RESERVED();
 800856e:	4804      	ldr	r0, [pc, #16]	@ (8008580 <SE_AuthenticateFW_Append+0x78>)
 8008570:	e7e9      	b.n	8008546 <SE_AuthenticateFW_Append+0x3e>
 8008572:	bf00      	nop
 8008574:	08008a00 	.word	0x08008a00
 8008578:	0801ffff 	.word	0x0801ffff
 800857c:	08000405 	.word	0x08000405
 8008580:	00018799 	.word	0x00018799

08008584 <SE_AuthenticateFW_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008584:	b570      	push	{r4, r5, r6, lr}
 8008586:	4604      	mov	r4, r0
 8008588:	b086      	sub	sp, #24
 800858a:	460d      	mov	r5, r1
 800858c:	4616      	mov	r6, r2
 800858e:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008590:	4b12      	ldr	r3, [pc, #72]	@ (80085dc <SE_AuthenticateFW_Finish+0x58>)
 8008592:	429a      	cmp	r2, r3
 8008594:	d320      	bcc.n	80085d8 <SE_AuthenticateFW_Finish+0x54>
 8008596:	4672      	mov	r2, lr
 8008598:	4b11      	ldr	r3, [pc, #68]	@ (80085e0 <SE_AuthenticateFW_Finish+0x5c>)
 800859a:	429a      	cmp	r2, r3
 800859c:	d81c      	bhi.n	80085d8 <SE_AuthenticateFW_Finish+0x54>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800859e:	f000 f85e 	bl	800865e <SE_IsUnprivileged>
 80085a2:	b150      	cbz	r0, 80085ba <SE_AuthenticateFW_Finish+0x36>
  {
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, &params);
 80085a4:	ab04      	add	r3, sp, #16
 80085a6:	4622      	mov	r2, r4
 80085a8:	2109      	movs	r1, #9
 80085aa:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 80085ac:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, &params);
 80085b0:	f000 f85f 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 80085b4:	9803      	ldr	r0, [sp, #12]
}
 80085b6:	b006      	add	sp, #24
 80085b8:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 80085ba:	a804      	add	r0, sp, #16
 80085bc:	f000 f846 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, primask_bit, pOutputBuffer,
 80085c0:	4621      	mov	r1, r4
 80085c2:	462b      	mov	r3, r5
 80085c4:	9a04      	ldr	r2, [sp, #16]
 80085c6:	4c07      	ldr	r4, [pc, #28]	@ (80085e4 <SE_AuthenticateFW_Finish+0x60>)
 80085c8:	2009      	movs	r0, #9
 80085ca:	9600      	str	r6, [sp, #0]
 80085cc:	47a0      	blx	r4
 80085ce:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 80085d0:	9804      	ldr	r0, [sp, #16]
 80085d2:	f000 f840 	bl	8008656 <SE_ExitSecureMode>
 80085d6:	e7ed      	b.n	80085b4 <SE_AuthenticateFW_Finish+0x30>
  __IS_SFU_RESERVED();
 80085d8:	4803      	ldr	r0, [pc, #12]	@ (80085e8 <SE_AuthenticateFW_Finish+0x64>)
 80085da:	e7ec      	b.n	80085b6 <SE_AuthenticateFW_Finish+0x32>
 80085dc:	08008a00 	.word	0x08008a00
 80085e0:	0801ffff 	.word	0x0801ffff
 80085e4:	08000405 	.word	0x08000405
 80085e8:	00018799 	.word	0x00018799

080085ec <SE_VerifyHeaderSignature>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxFwRawHeader pointer to RawHeader Buffer.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_VerifyHeaderSignature(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxFwRawHeader)
{
 80085ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80085ee:	4604      	mov	r4, r0
 80085f0:	460d      	mov	r5, r1
 80085f2:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80085f4:	4b11      	ldr	r3, [pc, #68]	@ (800863c <SE_VerifyHeaderSignature+0x50>)
 80085f6:	429a      	cmp	r2, r3
 80085f8:	d31e      	bcc.n	8008638 <SE_VerifyHeaderSignature+0x4c>
 80085fa:	4672      	mov	r2, lr
 80085fc:	4b10      	ldr	r3, [pc, #64]	@ (8008640 <SE_VerifyHeaderSignature+0x54>)
 80085fe:	429a      	cmp	r2, r3
 8008600:	d81a      	bhi.n	8008638 <SE_VerifyHeaderSignature+0x4c>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008602:	f000 f82c 	bl	800865e <SE_IsUnprivileged>
 8008606:	b148      	cbz	r0, 800861c <SE_VerifyHeaderSignature+0x30>
  {
    uint32_t params[1] = {(uint32_t)pxFwRawHeader};
    SE_SysCall(&e_ret_status, SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, &params);
 8008608:	ab01      	add	r3, sp, #4
 800860a:	4622      	mov	r2, r4
 800860c:	2110      	movs	r1, #16
 800860e:	4668      	mov	r0, sp
    uint32_t params[1] = {(uint32_t)pxFwRawHeader};
 8008610:	9501      	str	r5, [sp, #4]
    SE_SysCall(&e_ret_status, SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, &params);
 8008612:	f000 f82e 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 8008616:	9800      	ldr	r0, [sp, #0]

}
 8008618:	b003      	add	sp, #12
 800861a:	bd30      	pop	{r4, r5, pc}
    SE_EnterSecureMode(&primask_bit);
 800861c:	a801      	add	r0, sp, #4
 800861e:	f000 f815 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, primask_bit, pxFwRawHeader);
 8008622:	4621      	mov	r1, r4
 8008624:	462b      	mov	r3, r5
 8008626:	9a01      	ldr	r2, [sp, #4]
 8008628:	4c06      	ldr	r4, [pc, #24]	@ (8008644 <SE_VerifyHeaderSignature+0x58>)
 800862a:	2010      	movs	r0, #16
 800862c:	47a0      	blx	r4
 800862e:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 8008630:	9801      	ldr	r0, [sp, #4]
 8008632:	f000 f810 	bl	8008656 <SE_ExitSecureMode>
 8008636:	e7ee      	b.n	8008616 <SE_VerifyHeaderSignature+0x2a>
  __IS_SFU_RESERVED();
 8008638:	4803      	ldr	r0, [pc, #12]	@ (8008648 <SE_VerifyHeaderSignature+0x5c>)
 800863a:	e7ed      	b.n	8008618 <SE_VerifyHeaderSignature+0x2c>
 800863c:	08008a00 	.word	0x08008a00
 8008640:	0801ffff 	.word	0x0801ffff
 8008644:	08000405 	.word	0x08000405
 8008648:	00018799 	.word	0x00018799

0800864c <SE_EnterSecureMode>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800864c:	f3ef 8310 	mrs	r3, PRIMASK
  */
void SE_EnterSecureMode(uint32_t *pPrimaskBit)
{
#if !defined(CKS_ENABLED)
  /* Disable interrupts */
  *pPrimaskBit = __get_PRIMASK();
 8008650:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8008652:	b672      	cpsid	i
  __disable_irq();
#endif /* !CKS_ENABLED */
}
 8008654:	4770      	bx	lr

08008656 <SE_ExitSecureMode>:
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8008656:	f380 8810 	msr	PRIMASK, r0
  __ASM volatile ("cpsie i" : : : "memory");
 800865a:	b662      	cpsie	i
#if !defined(CKS_ENABLED)
  /* Re-enable the interrupts */
  __set_PRIMASK(PrimaskBit);
  __enable_irq();
#endif /* !CKS_ENABLED */
}
 800865c:	4770      	bx	lr

0800865e <SE_IsUnprivileged>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800865e:	f3ef 8305 	mrs	r3, IPSR
  * @param void
  * @retval 0 if we are in privileged mode, 1 if we are in non-privileged mode
  */
uint32_t SE_IsUnprivileged(void)
{
  return ((__get_IPSR() == 0U) && ((__get_CONTROL() & 1U) == 1U));
 8008662:	b923      	cbnz	r3, 800866e <SE_IsUnprivileged+0x10>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 8008664:	f3ef 8014 	mrs	r0, CONTROL
 8008668:	f000 0001 	and.w	r0, r0, #1
 800866c:	4770      	bx	lr
 800866e:	2000      	movs	r0, #0
}
 8008670:	4770      	bx	lr

08008672 <SE_SysCall>:
  /*
    * You cannot directly change to privileged mode from unprivileged mode without going through an exception,
    * for example an SVC.
    * Handled by @ref MPU_SVC_Handler()  and finally @ref SE_SVC_Handler()
    */
  __ASM __IO("SVC #0");    /* 0 is the hard-coded value to indicate a Secure Engine syscall */
 8008672:	df00      	svc	0
}
 8008674:	4770      	bx	lr
	...

08008678 <SE_SVC_Handler>:
  * @note When this function is entered, privileged mode has already been entered.
  *       When leaving this function, the unprivileged mode is automatically enabled.
  * @note This function is exported to the MPU SVC handler (see @ref MPU_SVC_Handler).
  */
void SE_SVC_Handler(uint32_t *args)
{
 8008678:	b530      	push	{r4, r5, lr}
 800867a:	b087      	sub	sp, #28
 800867c:	4601      	mov	r1, r0
  SE_ErrorStatus ret;
  SE_ErrorStatus *pRet = (SE_ErrorStatus *)(args[0]);
 800867e:	6805      	ldr	r5, [r0, #0]

  /* Set the CallGate function pointer */
  SET_CALLGATE();

  /*Enter Secure Mode*/
  SE_EnterSecureMode(&primask_bit);
 8008680:	a805      	add	r0, sp, #20
  SET_CALLGATE();
 8008682:	4c32      	ldr	r4, [pc, #200]	@ (800874c <SE_SVC_Handler+0xd4>)
  SE_EnterSecureMode(&primask_bit);
 8008684:	f7ff ffe2 	bl	800864c <SE_EnterSecureMode>

  switch (args[1]) /* main case for short operations that can be done under interrupts */
 8008688:	6848      	ldr	r0, [r1, #4]
 800868a:	2893      	cmp	r0, #147	@ 0x93
 800868c:	d81e      	bhi.n	80086cc <SE_SVC_Handler+0x54>
 800868e:	2891      	cmp	r0, #145	@ 0x91
 8008690:	d845      	bhi.n	800871e <SE_SVC_Handler+0xa6>
 8008692:	2820      	cmp	r0, #32
 8008694:	d80e      	bhi.n	80086b4 <SE_SVC_Handler+0x3c>
 8008696:	2803      	cmp	r0, #3
 8008698:	d90a      	bls.n	80086b0 <SE_SVC_Handler+0x38>
 800869a:	1f02      	subs	r2, r0, #4
 800869c:	2301      	movs	r3, #1
 800869e:	4093      	lsls	r3, r2
 80086a0:	4a2b      	ldr	r2, [pc, #172]	@ (8008750 <SE_SVC_Handler+0xd8>)
 80086a2:	4213      	tst	r3, r2
 80086a4:	d10a      	bne.n	80086bc <SE_SVC_Handler+0x44>
 80086a6:	f013 0f12 	tst.w	r3, #18
 80086aa:	d142      	bne.n	8008732 <SE_SVC_Handler+0xba>
 80086ac:	2810      	cmp	r0, #16
 80086ae:	d030      	beq.n	8008712 <SE_SVC_Handler+0x9a>
 80086b0:	4c28      	ldr	r4, [pc, #160]	@ (8008754 <SE_SVC_Handler+0xdc>)
 80086b2:	e018      	b.n	80086e6 <SE_SVC_Handler+0x6e>
 80086b4:	f1a0 0360 	sub.w	r3, r0, #96	@ 0x60
 80086b8:	2b01      	cmp	r3, #1
 80086ba:	d8f9      	bhi.n	80086b0 <SE_SVC_Handler+0x38>
    case SE_SYS_SAVE_DISABLE_IRQ:
    case SE_SYS_RESTORE_ENABLE_IRQ:
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
                              (SE_StatusTypeDef *)args[2],
                              primask_bit,
                              (void *)(((uint32_t *)args[3])[0]),
 80086bc:	68cb      	ldr	r3, [r1, #12]
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 80086be:	685a      	ldr	r2, [r3, #4]
 80086c0:	9200      	str	r2, [sp, #0]
 80086c2:	9a05      	ldr	r2, [sp, #20]
 80086c4:	681b      	ldr	r3, [r3, #0]
 80086c6:	6889      	ldr	r1, [r1, #8]
 80086c8:	47a0      	blx	r4
 80086ca:	e00b      	b.n	80086e4 <SE_SVC_Handler+0x6c>
  switch (args[1]) /* main case for short operations that can be done under interrupts */
 80086cc:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 80086d0:	d005      	beq.n	80086de <SE_SVC_Handler+0x66>
 80086d2:	f5b0 7f88 	cmp.w	r0, #272	@ 0x110
 80086d6:	d01c      	beq.n	8008712 <SE_SVC_Handler+0x9a>
 80086d8:	2894      	cmp	r0, #148	@ 0x94
 80086da:	d1e9      	bne.n	80086b0 <SE_SVC_Handler+0x38>
 80086dc:	e7ee      	b.n	80086bc <SE_SVC_Handler+0x44>
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 80086de:	9a05      	ldr	r2, [sp, #20]
 80086e0:	6889      	ldr	r1, [r1, #8]
 80086e2:	47a0      	blx	r4
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 80086e4:	4604      	mov	r4, r0
      ret = SE_ERROR;
#endif /* KMS_ENABLED */
      break;
  }
  /*  Check return value address  */
  if ((SFU_LL_Buffer_in_ram((void *)pRet, sizeof(*pRet)) == SFU_SUCCESS)
 80086e6:	2104      	movs	r1, #4
 80086e8:	4628      	mov	r0, r5
 80086ea:	f002 f911 	bl	800a910 <SFU_LL_Buffer_in_ram>
 80086ee:	4b1a      	ldr	r3, [pc, #104]	@ (8008758 <SE_SVC_Handler+0xe0>)
 80086f0:	4298      	cmp	r0, r3
 80086f2:	d108      	bne.n	8008706 <SE_SVC_Handler+0x8e>
      && (SFU_LL_BufferCheck_in_se_ram((void *)pRet, sizeof(*pRet)) == SFU_ERROR))
 80086f4:	2104      	movs	r1, #4
 80086f6:	4628      	mov	r0, r5
 80086f8:	f002 f8f0 	bl	800a8dc <SFU_LL_BufferCheck_in_se_ram>
 80086fc:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 8008700:	4298      	cmp	r0, r3
  {
    *pRet = ret;
 8008702:	bf08      	it	eq
 8008704:	602c      	streq	r4, [r5, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8008706:	9b05      	ldr	r3, [sp, #20]
 8008708:	f383 8810 	msr	PRIMASK, r3
  __ASM volatile ("cpsie i" : : : "memory");
 800870c:	b662      	cpsie	i
  SE_ExitSecureMode(primask_bit);

  /*
    * End of the privileged operation execution: switching to unprivileged mode automatically.
    */
}
 800870e:	b007      	add	sp, #28
 8008710:	bd30      	pop	{r4, r5, pc}
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 8008712:	68cb      	ldr	r3, [r1, #12]
 8008714:	9a05      	ldr	r2, [sp, #20]
 8008716:	681b      	ldr	r3, [r3, #0]
 8008718:	6889      	ldr	r1, [r1, #8]
 800871a:	47a0      	blx	r4
 800871c:	e7e2      	b.n	80086e4 <SE_SVC_Handler+0x6c>
                              (void *)(((uint32_t *)args[3])[0]),
 800871e:	68cb      	ldr	r3, [r1, #12]
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 8008720:	689a      	ldr	r2, [r3, #8]
 8008722:	9201      	str	r2, [sp, #4]
 8008724:	685a      	ldr	r2, [r3, #4]
 8008726:	9200      	str	r2, [sp, #0]
 8008728:	9a05      	ldr	r2, [sp, #20]
 800872a:	681b      	ldr	r3, [r3, #0]
 800872c:	6889      	ldr	r1, [r1, #8]
 800872e:	47a0      	blx	r4
 8008730:	e7d8      	b.n	80086e4 <SE_SVC_Handler+0x6c>
                              (void *)(((uint32_t *)args[3])[0]),
 8008732:	68cb      	ldr	r3, [r1, #12]
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 8008734:	68da      	ldr	r2, [r3, #12]
 8008736:	9202      	str	r2, [sp, #8]
 8008738:	689a      	ldr	r2, [r3, #8]
 800873a:	9201      	str	r2, [sp, #4]
 800873c:	685a      	ldr	r2, [r3, #4]
 800873e:	9200      	str	r2, [sp, #0]
 8008740:	9a05      	ldr	r2, [sp, #20]
 8008742:	681b      	ldr	r3, [r3, #0]
 8008744:	6889      	ldr	r1, [r1, #8]
 8008746:	47a0      	blx	r4
 8008748:	e7cc      	b.n	80086e4 <SE_SVC_Handler+0x6c>
 800874a:	bf00      	nop
 800874c:	08000405 	.word	0x08000405
 8008750:	1000002d 	.word	0x1000002d
 8008754:	00018799 	.word	0x00018799
 8008758:	00122f11 	.word	0x00122f11

Disassembly of section .text:

08008a00 <__do_global_dtors_aux>:
 8008a00:	b510      	push	{r4, lr}
 8008a02:	4c05      	ldr	r4, [pc, #20]	@ (8008a18 <__do_global_dtors_aux+0x18>)
 8008a04:	7823      	ldrb	r3, [r4, #0]
 8008a06:	b933      	cbnz	r3, 8008a16 <__do_global_dtors_aux+0x16>
 8008a08:	4b04      	ldr	r3, [pc, #16]	@ (8008a1c <__do_global_dtors_aux+0x1c>)
 8008a0a:	b113      	cbz	r3, 8008a12 <__do_global_dtors_aux+0x12>
 8008a0c:	4804      	ldr	r0, [pc, #16]	@ (8008a20 <__do_global_dtors_aux+0x20>)
 8008a0e:	f3af 8000 	nop.w
 8008a12:	2301      	movs	r3, #1
 8008a14:	7023      	strb	r3, [r4, #0]
 8008a16:	bd10      	pop	{r4, pc}
 8008a18:	20001188 	.word	0x20001188
 8008a1c:	00000000 	.word	0x00000000
 8008a20:	0800e3a0 	.word	0x0800e3a0

08008a24 <frame_dummy>:
 8008a24:	b508      	push	{r3, lr}
 8008a26:	4b03      	ldr	r3, [pc, #12]	@ (8008a34 <frame_dummy+0x10>)
 8008a28:	b11b      	cbz	r3, 8008a32 <frame_dummy+0xe>
 8008a2a:	4903      	ldr	r1, [pc, #12]	@ (8008a38 <frame_dummy+0x14>)
 8008a2c:	4803      	ldr	r0, [pc, #12]	@ (8008a3c <frame_dummy+0x18>)
 8008a2e:	f3af 8000 	nop.w
 8008a32:	bd08      	pop	{r3, pc}
 8008a34:	00000000 	.word	0x00000000
 8008a38:	2000118c 	.word	0x2000118c
 8008a3c:	0800e3a0 	.word	0x0800e3a0

08008a40 <SVC_Handler>:
        .syntax unified
        .weak  MPU_SVC_Handler
        .global SVC_Handler
        .type  SVC_Handler, %function
SVC_Handler:
        MRS r0, PSP
 8008a40:	f3ef 8009 	mrs	r0, PSP
        B MPU_SVC_Handler
 8008a44:	f001 be0c 	b.w	800a660 <MPU_SVC_Handler>
	...

08008a50 <memchr>:
 8008a50:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8008a54:	2a10      	cmp	r2, #16
 8008a56:	db2b      	blt.n	8008ab0 <memchr+0x60>
 8008a58:	f010 0f07 	tst.w	r0, #7
 8008a5c:	d008      	beq.n	8008a70 <memchr+0x20>
 8008a5e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008a62:	3a01      	subs	r2, #1
 8008a64:	428b      	cmp	r3, r1
 8008a66:	d02d      	beq.n	8008ac4 <memchr+0x74>
 8008a68:	f010 0f07 	tst.w	r0, #7
 8008a6c:	b342      	cbz	r2, 8008ac0 <memchr+0x70>
 8008a6e:	d1f6      	bne.n	8008a5e <memchr+0xe>
 8008a70:	b4f0      	push	{r4, r5, r6, r7}
 8008a72:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8008a76:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 8008a7a:	f022 0407 	bic.w	r4, r2, #7
 8008a7e:	f07f 0700 	mvns.w	r7, #0
 8008a82:	2300      	movs	r3, #0
 8008a84:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8008a88:	3c08      	subs	r4, #8
 8008a8a:	ea85 0501 	eor.w	r5, r5, r1
 8008a8e:	ea86 0601 	eor.w	r6, r6, r1
 8008a92:	fa85 f547 	uadd8	r5, r5, r7
 8008a96:	faa3 f587 	sel	r5, r3, r7
 8008a9a:	fa86 f647 	uadd8	r6, r6, r7
 8008a9e:	faa5 f687 	sel	r6, r5, r7
 8008aa2:	b98e      	cbnz	r6, 8008ac8 <memchr+0x78>
 8008aa4:	d1ee      	bne.n	8008a84 <memchr+0x34>
 8008aa6:	bcf0      	pop	{r4, r5, r6, r7}
 8008aa8:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8008aac:	f002 0207 	and.w	r2, r2, #7
 8008ab0:	b132      	cbz	r2, 8008ac0 <memchr+0x70>
 8008ab2:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008ab6:	3a01      	subs	r2, #1
 8008ab8:	ea83 0301 	eor.w	r3, r3, r1
 8008abc:	b113      	cbz	r3, 8008ac4 <memchr+0x74>
 8008abe:	d1f8      	bne.n	8008ab2 <memchr+0x62>
 8008ac0:	2000      	movs	r0, #0
 8008ac2:	4770      	bx	lr
 8008ac4:	3801      	subs	r0, #1
 8008ac6:	4770      	bx	lr
 8008ac8:	2d00      	cmp	r5, #0
 8008aca:	bf06      	itte	eq
 8008acc:	4635      	moveq	r5, r6
 8008ace:	3803      	subeq	r0, #3
 8008ad0:	3807      	subne	r0, #7
 8008ad2:	f015 0f01 	tst.w	r5, #1
 8008ad6:	d107      	bne.n	8008ae8 <memchr+0x98>
 8008ad8:	3001      	adds	r0, #1
 8008ada:	f415 7f80 	tst.w	r5, #256	@ 0x100
 8008ade:	bf02      	ittt	eq
 8008ae0:	3001      	addeq	r0, #1
 8008ae2:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8008ae6:	3001      	addeq	r0, #1
 8008ae8:	bcf0      	pop	{r4, r5, r6, r7}
 8008aea:	3801      	subs	r0, #1
 8008aec:	4770      	bx	lr
 8008aee:	bf00      	nop

08008af0 <__aeabi_uldivmod>:
 8008af0:	b953      	cbnz	r3, 8008b08 <__aeabi_uldivmod+0x18>
 8008af2:	b94a      	cbnz	r2, 8008b08 <__aeabi_uldivmod+0x18>
 8008af4:	2900      	cmp	r1, #0
 8008af6:	bf08      	it	eq
 8008af8:	2800      	cmpeq	r0, #0
 8008afa:	bf1c      	itt	ne
 8008afc:	f04f 31ff 	movne.w	r1, #4294967295
 8008b00:	f04f 30ff 	movne.w	r0, #4294967295
 8008b04:	f000 b988 	b.w	8008e18 <__aeabi_idiv0>
 8008b08:	f1ad 0c08 	sub.w	ip, sp, #8
 8008b0c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8008b10:	f000 f806 	bl	8008b20 <__udivmoddi4>
 8008b14:	f8dd e004 	ldr.w	lr, [sp, #4]
 8008b18:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008b1c:	b004      	add	sp, #16
 8008b1e:	4770      	bx	lr

08008b20 <__udivmoddi4>:
 8008b20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008b24:	9d08      	ldr	r5, [sp, #32]
 8008b26:	468e      	mov	lr, r1
 8008b28:	4604      	mov	r4, r0
 8008b2a:	4688      	mov	r8, r1
 8008b2c:	2b00      	cmp	r3, #0
 8008b2e:	d14a      	bne.n	8008bc6 <__udivmoddi4+0xa6>
 8008b30:	428a      	cmp	r2, r1
 8008b32:	4617      	mov	r7, r2
 8008b34:	d962      	bls.n	8008bfc <__udivmoddi4+0xdc>
 8008b36:	fab2 f682 	clz	r6, r2
 8008b3a:	b14e      	cbz	r6, 8008b50 <__udivmoddi4+0x30>
 8008b3c:	f1c6 0320 	rsb	r3, r6, #32
 8008b40:	fa01 f806 	lsl.w	r8, r1, r6
 8008b44:	fa20 f303 	lsr.w	r3, r0, r3
 8008b48:	40b7      	lsls	r7, r6
 8008b4a:	ea43 0808 	orr.w	r8, r3, r8
 8008b4e:	40b4      	lsls	r4, r6
 8008b50:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008b54:	fa1f fc87 	uxth.w	ip, r7
 8008b58:	fbb8 f1fe 	udiv	r1, r8, lr
 8008b5c:	0c23      	lsrs	r3, r4, #16
 8008b5e:	fb0e 8811 	mls	r8, lr, r1, r8
 8008b62:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8008b66:	fb01 f20c 	mul.w	r2, r1, ip
 8008b6a:	429a      	cmp	r2, r3
 8008b6c:	d909      	bls.n	8008b82 <__udivmoddi4+0x62>
 8008b6e:	18fb      	adds	r3, r7, r3
 8008b70:	f101 30ff 	add.w	r0, r1, #4294967295
 8008b74:	f080 80ea 	bcs.w	8008d4c <__udivmoddi4+0x22c>
 8008b78:	429a      	cmp	r2, r3
 8008b7a:	f240 80e7 	bls.w	8008d4c <__udivmoddi4+0x22c>
 8008b7e:	3902      	subs	r1, #2
 8008b80:	443b      	add	r3, r7
 8008b82:	1a9a      	subs	r2, r3, r2
 8008b84:	b2a3      	uxth	r3, r4
 8008b86:	fbb2 f0fe 	udiv	r0, r2, lr
 8008b8a:	fb0e 2210 	mls	r2, lr, r0, r2
 8008b8e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008b92:	fb00 fc0c 	mul.w	ip, r0, ip
 8008b96:	459c      	cmp	ip, r3
 8008b98:	d909      	bls.n	8008bae <__udivmoddi4+0x8e>
 8008b9a:	18fb      	adds	r3, r7, r3
 8008b9c:	f100 32ff 	add.w	r2, r0, #4294967295
 8008ba0:	f080 80d6 	bcs.w	8008d50 <__udivmoddi4+0x230>
 8008ba4:	459c      	cmp	ip, r3
 8008ba6:	f240 80d3 	bls.w	8008d50 <__udivmoddi4+0x230>
 8008baa:	443b      	add	r3, r7
 8008bac:	3802      	subs	r0, #2
 8008bae:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8008bb2:	eba3 030c 	sub.w	r3, r3, ip
 8008bb6:	2100      	movs	r1, #0
 8008bb8:	b11d      	cbz	r5, 8008bc2 <__udivmoddi4+0xa2>
 8008bba:	40f3      	lsrs	r3, r6
 8008bbc:	2200      	movs	r2, #0
 8008bbe:	e9c5 3200 	strd	r3, r2, [r5]
 8008bc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008bc6:	428b      	cmp	r3, r1
 8008bc8:	d905      	bls.n	8008bd6 <__udivmoddi4+0xb6>
 8008bca:	b10d      	cbz	r5, 8008bd0 <__udivmoddi4+0xb0>
 8008bcc:	e9c5 0100 	strd	r0, r1, [r5]
 8008bd0:	2100      	movs	r1, #0
 8008bd2:	4608      	mov	r0, r1
 8008bd4:	e7f5      	b.n	8008bc2 <__udivmoddi4+0xa2>
 8008bd6:	fab3 f183 	clz	r1, r3
 8008bda:	2900      	cmp	r1, #0
 8008bdc:	d146      	bne.n	8008c6c <__udivmoddi4+0x14c>
 8008bde:	4573      	cmp	r3, lr
 8008be0:	d302      	bcc.n	8008be8 <__udivmoddi4+0xc8>
 8008be2:	4282      	cmp	r2, r0
 8008be4:	f200 8105 	bhi.w	8008df2 <__udivmoddi4+0x2d2>
 8008be8:	1a84      	subs	r4, r0, r2
 8008bea:	eb6e 0203 	sbc.w	r2, lr, r3
 8008bee:	2001      	movs	r0, #1
 8008bf0:	4690      	mov	r8, r2
 8008bf2:	2d00      	cmp	r5, #0
 8008bf4:	d0e5      	beq.n	8008bc2 <__udivmoddi4+0xa2>
 8008bf6:	e9c5 4800 	strd	r4, r8, [r5]
 8008bfa:	e7e2      	b.n	8008bc2 <__udivmoddi4+0xa2>
 8008bfc:	2a00      	cmp	r2, #0
 8008bfe:	f000 8090 	beq.w	8008d22 <__udivmoddi4+0x202>
 8008c02:	fab2 f682 	clz	r6, r2
 8008c06:	2e00      	cmp	r6, #0
 8008c08:	f040 80a4 	bne.w	8008d54 <__udivmoddi4+0x234>
 8008c0c:	1a8a      	subs	r2, r1, r2
 8008c0e:	0c03      	lsrs	r3, r0, #16
 8008c10:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008c14:	b280      	uxth	r0, r0
 8008c16:	b2bc      	uxth	r4, r7
 8008c18:	2101      	movs	r1, #1
 8008c1a:	fbb2 fcfe 	udiv	ip, r2, lr
 8008c1e:	fb0e 221c 	mls	r2, lr, ip, r2
 8008c22:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008c26:	fb04 f20c 	mul.w	r2, r4, ip
 8008c2a:	429a      	cmp	r2, r3
 8008c2c:	d907      	bls.n	8008c3e <__udivmoddi4+0x11e>
 8008c2e:	18fb      	adds	r3, r7, r3
 8008c30:	f10c 38ff 	add.w	r8, ip, #4294967295
 8008c34:	d202      	bcs.n	8008c3c <__udivmoddi4+0x11c>
 8008c36:	429a      	cmp	r2, r3
 8008c38:	f200 80e0 	bhi.w	8008dfc <__udivmoddi4+0x2dc>
 8008c3c:	46c4      	mov	ip, r8
 8008c3e:	1a9b      	subs	r3, r3, r2
 8008c40:	fbb3 f2fe 	udiv	r2, r3, lr
 8008c44:	fb0e 3312 	mls	r3, lr, r2, r3
 8008c48:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8008c4c:	fb02 f404 	mul.w	r4, r2, r4
 8008c50:	429c      	cmp	r4, r3
 8008c52:	d907      	bls.n	8008c64 <__udivmoddi4+0x144>
 8008c54:	18fb      	adds	r3, r7, r3
 8008c56:	f102 30ff 	add.w	r0, r2, #4294967295
 8008c5a:	d202      	bcs.n	8008c62 <__udivmoddi4+0x142>
 8008c5c:	429c      	cmp	r4, r3
 8008c5e:	f200 80ca 	bhi.w	8008df6 <__udivmoddi4+0x2d6>
 8008c62:	4602      	mov	r2, r0
 8008c64:	1b1b      	subs	r3, r3, r4
 8008c66:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 8008c6a:	e7a5      	b.n	8008bb8 <__udivmoddi4+0x98>
 8008c6c:	f1c1 0620 	rsb	r6, r1, #32
 8008c70:	408b      	lsls	r3, r1
 8008c72:	fa22 f706 	lsr.w	r7, r2, r6
 8008c76:	431f      	orrs	r7, r3
 8008c78:	fa0e f401 	lsl.w	r4, lr, r1
 8008c7c:	fa20 f306 	lsr.w	r3, r0, r6
 8008c80:	fa2e fe06 	lsr.w	lr, lr, r6
 8008c84:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8008c88:	4323      	orrs	r3, r4
 8008c8a:	fa00 f801 	lsl.w	r8, r0, r1
 8008c8e:	fa1f fc87 	uxth.w	ip, r7
 8008c92:	fbbe f0f9 	udiv	r0, lr, r9
 8008c96:	0c1c      	lsrs	r4, r3, #16
 8008c98:	fb09 ee10 	mls	lr, r9, r0, lr
 8008c9c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8008ca0:	fb00 fe0c 	mul.w	lr, r0, ip
 8008ca4:	45a6      	cmp	lr, r4
 8008ca6:	fa02 f201 	lsl.w	r2, r2, r1
 8008caa:	d909      	bls.n	8008cc0 <__udivmoddi4+0x1a0>
 8008cac:	193c      	adds	r4, r7, r4
 8008cae:	f100 3aff 	add.w	sl, r0, #4294967295
 8008cb2:	f080 809c 	bcs.w	8008dee <__udivmoddi4+0x2ce>
 8008cb6:	45a6      	cmp	lr, r4
 8008cb8:	f240 8099 	bls.w	8008dee <__udivmoddi4+0x2ce>
 8008cbc:	3802      	subs	r0, #2
 8008cbe:	443c      	add	r4, r7
 8008cc0:	eba4 040e 	sub.w	r4, r4, lr
 8008cc4:	fa1f fe83 	uxth.w	lr, r3
 8008cc8:	fbb4 f3f9 	udiv	r3, r4, r9
 8008ccc:	fb09 4413 	mls	r4, r9, r3, r4
 8008cd0:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8008cd4:	fb03 fc0c 	mul.w	ip, r3, ip
 8008cd8:	45a4      	cmp	ip, r4
 8008cda:	d908      	bls.n	8008cee <__udivmoddi4+0x1ce>
 8008cdc:	193c      	adds	r4, r7, r4
 8008cde:	f103 3eff 	add.w	lr, r3, #4294967295
 8008ce2:	f080 8082 	bcs.w	8008dea <__udivmoddi4+0x2ca>
 8008ce6:	45a4      	cmp	ip, r4
 8008ce8:	d97f      	bls.n	8008dea <__udivmoddi4+0x2ca>
 8008cea:	3b02      	subs	r3, #2
 8008cec:	443c      	add	r4, r7
 8008cee:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8008cf2:	eba4 040c 	sub.w	r4, r4, ip
 8008cf6:	fba0 ec02 	umull	lr, ip, r0, r2
 8008cfa:	4564      	cmp	r4, ip
 8008cfc:	4673      	mov	r3, lr
 8008cfe:	46e1      	mov	r9, ip
 8008d00:	d362      	bcc.n	8008dc8 <__udivmoddi4+0x2a8>
 8008d02:	d05f      	beq.n	8008dc4 <__udivmoddi4+0x2a4>
 8008d04:	b15d      	cbz	r5, 8008d1e <__udivmoddi4+0x1fe>
 8008d06:	ebb8 0203 	subs.w	r2, r8, r3
 8008d0a:	eb64 0409 	sbc.w	r4, r4, r9
 8008d0e:	fa04 f606 	lsl.w	r6, r4, r6
 8008d12:	fa22 f301 	lsr.w	r3, r2, r1
 8008d16:	431e      	orrs	r6, r3
 8008d18:	40cc      	lsrs	r4, r1
 8008d1a:	e9c5 6400 	strd	r6, r4, [r5]
 8008d1e:	2100      	movs	r1, #0
 8008d20:	e74f      	b.n	8008bc2 <__udivmoddi4+0xa2>
 8008d22:	fbb1 fcf2 	udiv	ip, r1, r2
 8008d26:	0c01      	lsrs	r1, r0, #16
 8008d28:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 8008d2c:	b280      	uxth	r0, r0
 8008d2e:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 8008d32:	463b      	mov	r3, r7
 8008d34:	4638      	mov	r0, r7
 8008d36:	463c      	mov	r4, r7
 8008d38:	46b8      	mov	r8, r7
 8008d3a:	46be      	mov	lr, r7
 8008d3c:	2620      	movs	r6, #32
 8008d3e:	fbb1 f1f7 	udiv	r1, r1, r7
 8008d42:	eba2 0208 	sub.w	r2, r2, r8
 8008d46:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 8008d4a:	e766      	b.n	8008c1a <__udivmoddi4+0xfa>
 8008d4c:	4601      	mov	r1, r0
 8008d4e:	e718      	b.n	8008b82 <__udivmoddi4+0x62>
 8008d50:	4610      	mov	r0, r2
 8008d52:	e72c      	b.n	8008bae <__udivmoddi4+0x8e>
 8008d54:	f1c6 0220 	rsb	r2, r6, #32
 8008d58:	fa2e f302 	lsr.w	r3, lr, r2
 8008d5c:	40b7      	lsls	r7, r6
 8008d5e:	40b1      	lsls	r1, r6
 8008d60:	fa20 f202 	lsr.w	r2, r0, r2
 8008d64:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008d68:	430a      	orrs	r2, r1
 8008d6a:	fbb3 f8fe 	udiv	r8, r3, lr
 8008d6e:	b2bc      	uxth	r4, r7
 8008d70:	fb0e 3318 	mls	r3, lr, r8, r3
 8008d74:	0c11      	lsrs	r1, r2, #16
 8008d76:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8008d7a:	fb08 f904 	mul.w	r9, r8, r4
 8008d7e:	40b0      	lsls	r0, r6
 8008d80:	4589      	cmp	r9, r1
 8008d82:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8008d86:	b280      	uxth	r0, r0
 8008d88:	d93e      	bls.n	8008e08 <__udivmoddi4+0x2e8>
 8008d8a:	1879      	adds	r1, r7, r1
 8008d8c:	f108 3cff 	add.w	ip, r8, #4294967295
 8008d90:	d201      	bcs.n	8008d96 <__udivmoddi4+0x276>
 8008d92:	4589      	cmp	r9, r1
 8008d94:	d81f      	bhi.n	8008dd6 <__udivmoddi4+0x2b6>
 8008d96:	eba1 0109 	sub.w	r1, r1, r9
 8008d9a:	fbb1 f9fe 	udiv	r9, r1, lr
 8008d9e:	fb09 f804 	mul.w	r8, r9, r4
 8008da2:	fb0e 1119 	mls	r1, lr, r9, r1
 8008da6:	b292      	uxth	r2, r2
 8008da8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8008dac:	4542      	cmp	r2, r8
 8008dae:	d229      	bcs.n	8008e04 <__udivmoddi4+0x2e4>
 8008db0:	18ba      	adds	r2, r7, r2
 8008db2:	f109 31ff 	add.w	r1, r9, #4294967295
 8008db6:	d2c4      	bcs.n	8008d42 <__udivmoddi4+0x222>
 8008db8:	4542      	cmp	r2, r8
 8008dba:	d2c2      	bcs.n	8008d42 <__udivmoddi4+0x222>
 8008dbc:	f1a9 0102 	sub.w	r1, r9, #2
 8008dc0:	443a      	add	r2, r7
 8008dc2:	e7be      	b.n	8008d42 <__udivmoddi4+0x222>
 8008dc4:	45f0      	cmp	r8, lr
 8008dc6:	d29d      	bcs.n	8008d04 <__udivmoddi4+0x1e4>
 8008dc8:	ebbe 0302 	subs.w	r3, lr, r2
 8008dcc:	eb6c 0c07 	sbc.w	ip, ip, r7
 8008dd0:	3801      	subs	r0, #1
 8008dd2:	46e1      	mov	r9, ip
 8008dd4:	e796      	b.n	8008d04 <__udivmoddi4+0x1e4>
 8008dd6:	eba7 0909 	sub.w	r9, r7, r9
 8008dda:	4449      	add	r1, r9
 8008ddc:	f1a8 0c02 	sub.w	ip, r8, #2
 8008de0:	fbb1 f9fe 	udiv	r9, r1, lr
 8008de4:	fb09 f804 	mul.w	r8, r9, r4
 8008de8:	e7db      	b.n	8008da2 <__udivmoddi4+0x282>
 8008dea:	4673      	mov	r3, lr
 8008dec:	e77f      	b.n	8008cee <__udivmoddi4+0x1ce>
 8008dee:	4650      	mov	r0, sl
 8008df0:	e766      	b.n	8008cc0 <__udivmoddi4+0x1a0>
 8008df2:	4608      	mov	r0, r1
 8008df4:	e6fd      	b.n	8008bf2 <__udivmoddi4+0xd2>
 8008df6:	443b      	add	r3, r7
 8008df8:	3a02      	subs	r2, #2
 8008dfa:	e733      	b.n	8008c64 <__udivmoddi4+0x144>
 8008dfc:	f1ac 0c02 	sub.w	ip, ip, #2
 8008e00:	443b      	add	r3, r7
 8008e02:	e71c      	b.n	8008c3e <__udivmoddi4+0x11e>
 8008e04:	4649      	mov	r1, r9
 8008e06:	e79c      	b.n	8008d42 <__udivmoddi4+0x222>
 8008e08:	eba1 0109 	sub.w	r1, r1, r9
 8008e0c:	46c4      	mov	ip, r8
 8008e0e:	fbb1 f9fe 	udiv	r9, r1, lr
 8008e12:	fb09 f804 	mul.w	r8, r9, r4
 8008e16:	e7c4      	b.n	8008da2 <__udivmoddi4+0x282>

08008e18 <__aeabi_idiv0>:
 8008e18:	4770      	bx	lr
 8008e1a:	bf00      	nop

08008e1c <main>:
  * @brief  main function
  * @param  None
  * @retval int
  */
int main(void)
{
 8008e1c:	b530      	push	{r4, r5, lr}
 8008e1e:	b09d      	sub	sp, #116	@ 0x74
#endif /* SFU_MPU_PROTECT_ENABLE */

  /* MCU Configuration--------------------------------------------------------*/
  /* This part is NOT secure (security mechanisms NOT enabled yet)            */
  /* Reset of all peripherals, Initializes the Flash interface and the Systick*/
  (void) HAL_Init();
 8008e20:	f002 f9ce 	bl	800b1c0 <HAL_Init>
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;
  
  /*!< Supply configuration update enable */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 8008e24:	2002      	movs	r0, #2
 8008e26:	f003 f883 	bl	800bf30 <HAL_PWREx_ConfigSupply>

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8008e2a:	2300      	movs	r3, #0
 8008e2c:	9300      	str	r3, [sp, #0]
 8008e2e:	4b26      	ldr	r3, [pc, #152]	@ (8008ec8 <main+0xac>)
 8008e30:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8008e32:	f022 0201 	bic.w	r2, r2, #1
 8008e36:	62da      	str	r2, [r3, #44]	@ 0x2c
 8008e38:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008e3a:	f003 0301 	and.w	r3, r3, #1
 8008e3e:	9300      	str	r3, [sp, #0]
 8008e40:	4b22      	ldr	r3, [pc, #136]	@ (8008ecc <main+0xb0>)
 8008e42:	699a      	ldr	r2, [r3, #24]
 8008e44:	f442 4240 	orr.w	r2, r2, #49152	@ 0xc000
 8008e48:	619a      	str	r2, [r3, #24]
 8008e4a:	699a      	ldr	r2, [r3, #24]
 8008e4c:	f402 4240 	and.w	r2, r2, #49152	@ 0xc000
 8008e50:	9200      	str	r2, [sp, #0]
 8008e52:	9a00      	ldr	r2, [sp, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8008e54:	699a      	ldr	r2, [r3, #24]
 8008e56:	0490      	lsls	r0, r2, #18
 8008e58:	d5fc      	bpl.n	8008e54 <main+0x38>
  
  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8008e5a:	2101      	movs	r1, #1
 8008e5c:	f44f 23a0 	mov.w	r3, #327680	@ 0x50000
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8008e60:	2202      	movs	r2, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;

  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 400;
 8008e62:	2404      	movs	r4, #4
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLQ = 4;

  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 8008e64:	2508      	movs	r5, #8
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8008e66:	a809      	add	r0, sp, #36	@ 0x24
  RCC_OscInitStruct.PLL.PLLP = 2;
 8008e68:	9216      	str	r2, [sp, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 8008e6a:	9519      	str	r5, [sp, #100]	@ 0x64
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8008e6c:	e9cd 1309 	strd	r1, r3, [sp, #36]	@ 0x24
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 8008e70:	2300      	movs	r3, #0
  RCC_OscInitStruct.PLL.PLLN = 400;
 8008e72:	f44f 71c8 	mov.w	r1, #400	@ 0x190
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 8008e76:	930c      	str	r3, [sp, #48]	@ 0x30
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
 8008e78:	9310      	str	r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8008e7a:	931b      	str	r3, [sp, #108]	@ 0x6c
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 8008e7c:	931a      	str	r3, [sp, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8008e7e:	e9cd 2212 	strd	r2, r2, [sp, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLN = 400;
 8008e82:	e9cd 4114 	strd	r4, r1, [sp, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8008e86:	e9cd 4217 	strd	r4, r2, [sp, #92]	@ 0x5c
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8008e8a:	f003 f875 	bl	800bf78 <HAL_RCC_OscConfig>
  if(ret != HAL_OK)
 8008e8e:	b100      	cbz	r0, 8008e92 <main+0x76>
 8008e90:	e7fe      	b.n	8008e90 <main+0x74>
  
/* Select PLL as system clock source and configure  bus clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \
                                 RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1);

  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8008e92:	223f      	movs	r2, #63	@ 0x3f
 8008e94:	2303      	movs	r3, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;  
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2; 
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2; 
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2; 
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8008e96:	4621      	mov	r1, r4
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8008e98:	e9cd 2301 	strd	r2, r3, [sp, #4]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;  
 8008e9c:	2340      	movs	r3, #64	@ 0x40
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2; 
 8008e9e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 8008ea2:	e9cd 0503 	strd	r0, r5, [sp, #12]
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8008ea6:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2; 
 8008ea8:	e9cd 3305 	strd	r3, r3, [sp, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2; 
 8008eac:	e9cd 2307 	strd	r2, r3, [sp, #28]
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8008eb0:	f003 fbac 	bl	800c60c <HAL_RCC_ClockConfig>
  if(ret != HAL_OK)
 8008eb4:	4604      	mov	r4, r0
 8008eb6:	b100      	cbz	r0, 8008eba <main+0x9e>
 8008eb8:	e7fe      	b.n	8008eb8 <main+0x9c>
  (void)SFU_BOOT_RunSecureBootService(); /* no need to take care of the returned value as we reboot in all cases */
 8008eba:	f000 fb1d 	bl	80094f8 <SFU_BOOT_RunSecureBootService>
  SFU_BOOT_ForceReboot();
 8008ebe:	f000 fa69 	bl	8009394 <SFU_BOOT_ForceReboot>
}
 8008ec2:	4620      	mov	r0, r4
 8008ec4:	b01d      	add	sp, #116	@ 0x74
 8008ec6:	bd30      	pop	{r4, r5, pc}
 8008ec8:	58000400 	.word	0x58000400
 8008ecc:	58024800 	.word	0x58024800

08008ed0 <HAL_MspInit>:
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008ed0:	4b18      	ldr	r3, [pc, #96]	@ (8008f34 <HAL_MspInit+0x64>)
{
 8008ed2:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008ed4:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008ed8:	2003      	movs	r0, #3
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008eda:	f042 0202 	orr.w	r2, r2, #2
 8008ede:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
 8008ee2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8008ee6:	f003 0302 	and.w	r3, r3, #2
 8008eea:	9301      	str	r3, [sp, #4]
 8008eec:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008eee:	f002 f9c7 	bl	800b280 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0U, 0U);
 8008ef2:	2200      	movs	r2, #0
 8008ef4:	f06f 000b 	mvn.w	r0, #11
 8008ef8:	4611      	mov	r1, r2
 8008efa:	f002 f9d3 	bl	800b2a4 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0U, 0U);
 8008efe:	2200      	movs	r2, #0
 8008f00:	f06f 000a 	mvn.w	r0, #10
 8008f04:	4611      	mov	r1, r2
 8008f06:	f002 f9cd 	bl	800b2a4 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0U, 0U);
 8008f0a:	2200      	movs	r2, #0
 8008f0c:	f06f 0009 	mvn.w	r0, #9
 8008f10:	4611      	mov	r1, r2
 8008f12:	f002 f9c7 	bl	800b2a4 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0U, 0U);
 8008f16:	2200      	movs	r2, #0
 8008f18:	f06f 0003 	mvn.w	r0, #3
 8008f1c:	4611      	mov	r1, r2
 8008f1e:	f002 f9c1 	bl	800b2a4 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0U, 0U);
 8008f22:	2200      	movs	r2, #0
 8008f24:	f04f 30ff 	mov.w	r0, #4294967295
 8008f28:	4611      	mov	r1, r2

}
 8008f2a:	b003      	add	sp, #12
 8008f2c:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_SetPriority(SysTick_IRQn, 0U, 0U);
 8008f30:	f002 b9b8 	b.w	800b2a4 <HAL_NVIC_SetPriority>
 8008f34:	58024400 	.word	0x58024400

08008f38 <HAL_UART_MspInit>:
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
  SFU_LL_UART_MspInit(huart);
 8008f38:	f001 bc82 	b.w	800a840 <SFU_LL_UART_MspInit>

08008f3c <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 8008f3c:	e7fe      	b.n	8008f3c <UsageFault_Handler>

08008f3e <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}
 8008f3e:	4770      	bx	lr

08008f40 <PendSV_Handler>:
/**
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
 8008f40:	4770      	bx	lr

08008f42 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 8008f42:	f002 b96b 	b.w	800b21c <HAL_IncTick>

08008f46 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

int _read (int file, char *ptr, int len)
{
 8008f46:	b570      	push	{r4, r5, r6, lr}
 8008f48:	460d      	mov	r5, r1
 8008f4a:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f4c:	460e      	mov	r6, r1
 8008f4e:	1b73      	subs	r3, r6, r5
 8008f50:	429c      	cmp	r4, r3
 8008f52:	dc01      	bgt.n	8008f58 <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 8008f54:	4620      	mov	r0, r4
 8008f56:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 8008f58:	f3af 8000 	nop.w
 8008f5c:	f806 0b01 	strb.w	r0, [r6], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f60:	e7f5      	b.n	8008f4e <_read+0x8>

08008f62 <_write>:

int _write(int file, char *ptr, int len)
{
 8008f62:	b570      	push	{r4, r5, r6, lr}
 8008f64:	460d      	mov	r5, r1
 8008f66:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f68:	460e      	mov	r6, r1
 8008f6a:	1b73      	subs	r3, r6, r5
 8008f6c:	429c      	cmp	r4, r3
 8008f6e:	dc01      	bgt.n	8008f74 <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 8008f70:	4620      	mov	r0, r4
 8008f72:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 8008f74:	f816 0b01 	ldrb.w	r0, [r6], #1
 8008f78:	f000 fd27 	bl	80099ca <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f7c:	e7f5      	b.n	8008f6a <_write+0x8>
	...

08008f80 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8008f80:	4a0a      	ldr	r2, [pc, #40]	@ (8008fac <_sbrk+0x2c>)
 8008f82:	6811      	ldr	r1, [r2, #0]
{
 8008f84:	b508      	push	{r3, lr}
 8008f86:	4603      	mov	r3, r0
	if (heap_end == 0)
 8008f88:	b909      	cbnz	r1, 8008f8e <_sbrk+0xe>
		heap_end = &end;
 8008f8a:	4909      	ldr	r1, [pc, #36]	@ (8008fb0 <_sbrk+0x30>)
 8008f8c:	6011      	str	r1, [r2, #0]

	prev_heap_end = heap_end;
 8008f8e:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 8008f90:	4669      	mov	r1, sp
 8008f92:	4403      	add	r3, r0
 8008f94:	428b      	cmp	r3, r1
 8008f96:	d906      	bls.n	8008fa6 <_sbrk+0x26>
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8008f98:	f004 fcb8 	bl	800d90c <__errno>
 8008f9c:	230c      	movs	r3, #12
 8008f9e:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 8008fa0:	f04f 30ff 	mov.w	r0, #4294967295
	}

	heap_end += incr;

	return (caddr_t) prev_heap_end;
}
 8008fa4:	bd08      	pop	{r3, pc}
	heap_end += incr;
 8008fa6:	6013      	str	r3, [r2, #0]
	return (caddr_t) prev_heap_end;
 8008fa8:	e7fc      	b.n	8008fa4 <_sbrk+0x24>
 8008faa:	bf00      	nop
 8008fac:	200011a4 	.word	0x200011a4
 8008fb0:	20001ee8 	.word	0x20001ee8

08008fb4 <_close>:

int _close(int file)
{
	return -1;
}
 8008fb4:	f04f 30ff 	mov.w	r0, #4294967295
 8008fb8:	4770      	bx	lr

08008fba <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8008fba:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
	return 0;
}
 8008fbe:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 8008fc0:	604b      	str	r3, [r1, #4]
}
 8008fc2:	4770      	bx	lr

08008fc4 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8008fc4:	2001      	movs	r0, #1
 8008fc6:	4770      	bx	lr

08008fc8 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8008fc8:	2000      	movs	r0, #0
 8008fca:	4770      	bx	lr

08008fcc <SFU_BOOT_SM_HandleCriticalFailure>:
  * @param  None
  * @note   After a Critical Failure a Reboot will be called.
  * @retval None
  */
static void SFU_BOOT_SM_HandleCriticalFailure(void)
{
 8008fcc:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: HANDLE CRITICAL FAILURE");
 8008fce:	4805      	ldr	r0, [pc, #20]	@ (8008fe4 <SFU_BOOT_SM_HandleCriticalFailure+0x18>)
 8008fd0:	f004 fa42 	bl	800d458 <iprintf>

  /* It's not possible to continue without compromising the stability or the security of the solution.
     The State Machine needs to be aborted and a Reset must be triggered */
  SFU_SET_SM_IF_CURR_STATE(SFU_ERROR, SFU_STATE_REBOOT_STATE_MACHINE, SFU_STATE_REBOOT_STATE_MACHINE);
 8008fd4:	4b04      	ldr	r3, [pc, #16]	@ (8008fe8 <SFU_BOOT_SM_HandleCriticalFailure+0x1c>)
 8008fd6:	785a      	ldrb	r2, [r3, #1]
 8008fd8:	b2d2      	uxtb	r2, r2
 8008fda:	701a      	strb	r2, [r3, #0]
 8008fdc:	2207      	movs	r2, #7
 8008fde:	705a      	strb	r2, [r3, #1]
}
 8008fe0:	bd08      	pop	{r3, pc}
 8008fe2:	bf00      	nop
 8008fe4:	0800e53e 	.word	0x0800e53e
 8008fe8:	200011ac 	.word	0x200011ac

08008fec <SFU_BOOT_SM_VerifyUserFwSignature>:
{
 8008fec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8008ff0:	4e39      	ldr	r6, [pc, #228]	@ (80090d8 <SFU_BOOT_SM_VerifyUserFwSignature+0xec>)
  TRACE("\r\n= [SBOOT] STATE: VERIFY USER FW SIGNATURE");
 8008ff2:	483a      	ldr	r0, [pc, #232]	@ (80090dc <SFU_BOOT_SM_VerifyUserFwSignature+0xf0>)
 8008ff4:	f004 fa30 	bl	800d458 <iprintf>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8008ff8:	6832      	ldr	r2, [r6, #0]
 8008ffa:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 8008ffe:	429a      	cmp	r2, r3
 8009000:	d001      	beq.n	8009006 <SFU_BOOT_SM_VerifyUserFwSignature+0x1a>
 8009002:	f000 fd21 	bl	8009a48 <SFU_EXCPT_Security_Error>
  FLOW_CONTROL_INIT(uFlowProtectValue, FLOW_CTRL_INIT_VALUE);
 8009006:	f245 7376 	movw	r3, #22390	@ 0x5776
 800900a:	6033      	str	r3, [r6, #0]
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 800900c:	f001 feb0 	bl	800ad70 <SFU_LL_SECU_CheckApplyStaticProtections>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 8009010:	6832      	ldr	r2, [r6, #0]
 8009012:	f243 03f1 	movw	r3, #12529	@ 0x30f1
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 8009016:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 8009018:	429a      	cmp	r2, r3
 800901a:	d001      	beq.n	8009020 <SFU_BOOT_SM_VerifyUserFwSignature+0x34>
 800901c:	f000 fd14 	bl	8009a48 <SFU_EXCPT_Security_Error>
  if (e_ret_status == SFU_SUCCESS)
 8009020:	4b2f      	ldr	r3, [pc, #188]	@ (80090e0 <SFU_BOOT_SM_VerifyUserFwSignature+0xf4>)
 8009022:	429c      	cmp	r4, r3
 8009024:	d103      	bne.n	800902e <SFU_BOOT_SM_VerifyUserFwSignature+0x42>
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_THIRD_CONFIGURATION);
 8009026:	2002      	movs	r0, #2
 8009028:	f001 ff10 	bl	800ae4c <SFU_LL_SECU_CheckApplyRuntimeProtections>
 800902c:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 800902e:	6832      	ldr	r2, [r6, #0]
 8009030:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 8009034:	429a      	cmp	r2, r3
 8009036:	d001      	beq.n	800903c <SFU_BOOT_SM_VerifyUserFwSignature+0x50>
 8009038:	f000 fd06 	bl	8009a48 <SFU_EXCPT_Security_Error>
  if (e_ret_status != SFU_SUCCESS)
 800903c:	4b28      	ldr	r3, [pc, #160]	@ (80090e0 <SFU_BOOT_SM_VerifyUserFwSignature+0xf4>)
 800903e:	429c      	cmp	r4, r3
 8009040:	d005      	beq.n	800904e <SFU_BOOT_SM_VerifyUserFwSignature+0x62>
    SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009042:	4b28      	ldr	r3, [pc, #160]	@ (80090e4 <SFU_BOOT_SM_VerifyUserFwSignature+0xf8>)
 8009044:	785a      	ldrb	r2, [r3, #1]
 8009046:	b2d2      	uxtb	r2, r2
 8009048:	701a      	strb	r2, [r3, #0]
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_EXECUTE_USER_FW, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 800904a:	2206      	movs	r2, #6
 800904c:	e03a      	b.n	80090c4 <SFU_BOOT_SM_VerifyUserFwSignature+0xd8>
 800904e:	f8df 9098 	ldr.w	r9, [pc, #152]	@ 80090e8 <SFU_BOOT_SM_VerifyUserFwSignature+0xfc>
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 8009052:	2300      	movs	r3, #0
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 8009054:	1c5d      	adds	r5, r3, #1
 8009056:	f859 3f04 	ldr.w	r3, [r9, #4]!
 800905a:	b33b      	cbz	r3, 80090ac <SFU_BOOT_SM_VerifyUserFwSignature+0xc0>
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 800905c:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 80090e0 <SFU_BOOT_SM_VerifyUserFwSignature+0xf4>
 8009060:	4628      	mov	r0, r5
 8009062:	f001 f833 	bl	800a0cc <SFU_IMG_DetectFW>
 8009066:	4607      	mov	r7, r0
 8009068:	4540      	cmp	r0, r8
 800906a:	d12e      	bne.n	80090ca <SFU_BOOT_SM_VerifyUserFwSignature+0xde>
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 800906c:	f245 7376 	movw	r3, #22390	@ 0x5776
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009070:	4628      	mov	r0, r5
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 8009072:	6073      	str	r3, [r6, #4]
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009074:	f001 f814 	bl	800a0a0 <SFU_IMG_VerifyActiveImgMetadata>
        if (SFU_SUCCESS == e_ret_status)
 8009078:	42b8      	cmp	r0, r7
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 800907a:	4604      	mov	r4, r0
        if (SFU_SUCCESS == e_ret_status)
 800907c:	d10b      	bne.n	8009096 <SFU_BOOT_SM_VerifyUserFwSignature+0xaa>
          e_ret_status = SFU_IMG_VerifyActiveImg(SLOT_ACTIVE_1 + i);
 800907e:	4628      	mov	r0, r5
 8009080:	f000 ff42 	bl	8009f08 <SFU_IMG_VerifyActiveImg>
          if (SFU_SUCCESS == e_ret_status)
 8009084:	42b8      	cmp	r0, r7
          e_ret_status = SFU_IMG_VerifyActiveImg(SLOT_ACTIVE_1 + i);
 8009086:	4604      	mov	r4, r0
          if (SFU_SUCCESS == e_ret_status)
 8009088:	d105      	bne.n	8009096 <SFU_BOOT_SM_VerifyUserFwSignature+0xaa>
            e_ret_status = SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i);
 800908a:	4628      	mov	r0, r5
 800908c:	f000 ff4c 	bl	8009f28 <SFU_IMG_VerifyActiveSlot>
        if (SFU_SUCCESS != e_ret_status)
 8009090:	4540      	cmp	r0, r8
            e_ret_status = SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i);
 8009092:	4604      	mov	r4, r0
        if (SFU_SUCCESS != e_ret_status)
 8009094:	d003      	beq.n	800909e <SFU_BOOT_SM_VerifyUserFwSignature+0xb2>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 8009096:	4628      	mov	r0, r5
 8009098:	f000 ff22 	bl	8009ee0 <SFU_IMG_InvalidateCurrentFirmware>
 800909c:	e006      	b.n	80090ac <SFU_BOOT_SM_VerifyUserFwSignature+0xc0>
          FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 800909e:	6872      	ldr	r2, [r6, #4]
 80090a0:	f248 435a 	movw	r3, #33882	@ 0x845a
 80090a4:	429a      	cmp	r2, r3
 80090a6:	d001      	beq.n	80090ac <SFU_BOOT_SM_VerifyUserFwSignature+0xc0>
 80090a8:	f000 fcce 	bl	8009a48 <SFU_EXCPT_Security_Error>
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 80090ac:	2d02      	cmp	r5, #2
 80090ae:	f04f 0301 	mov.w	r3, #1
 80090b2:	d1cf      	bne.n	8009054 <SFU_BOOT_SM_VerifyUserFwSignature+0x68>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_EXECUTE_USER_FW, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 80090b4:	4b0b      	ldr	r3, [pc, #44]	@ (80090e4 <SFU_BOOT_SM_VerifyUserFwSignature+0xf8>)
 80090b6:	785a      	ldrb	r2, [r3, #1]
 80090b8:	b2d2      	uxtb	r2, r2
 80090ba:	701a      	strb	r2, [r3, #0]
 80090bc:	4a08      	ldr	r2, [pc, #32]	@ (80090e0 <SFU_BOOT_SM_VerifyUserFwSignature+0xf4>)
 80090be:	4294      	cmp	r4, r2
 80090c0:	d1c3      	bne.n	800904a <SFU_BOOT_SM_VerifyUserFwSignature+0x5e>
 80090c2:	2205      	movs	r2, #5
 80090c4:	705a      	strb	r2, [r3, #1]
}
 80090c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 80090ca:	4628      	mov	r0, r5
 80090cc:	f000 ff3e 	bl	8009f4c <SFU_IMG_VerifyEmptyActiveSlot>
 80090d0:	4540      	cmp	r0, r8
 80090d2:	d0eb      	beq.n	80090ac <SFU_BOOT_SM_VerifyUserFwSignature+0xc0>
 80090d4:	e7df      	b.n	8009096 <SFU_BOOT_SM_VerifyUserFwSignature+0xaa>
 80090d6:	bf00      	nop
 80090d8:	20001100 	.word	0x20001100
 80090dc:	0800e569 	.word	0x0800e569
 80090e0:	00122f11 	.word	0x00122f11
 80090e4:	200011ac 	.word	0x200011ac
 80090e8:	0800e424 	.word	0x0800e424

080090ec <SFU_BOOT_SM_CheckUserFwStatus>:
{
 80090ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (initialDeviceStatusCheck == 1U)
 80090f0:	4c34      	ldr	r4, [pc, #208]	@ (80091c4 <SFU_BOOT_SM_CheckUserFwStatus+0xd8>)
 80090f2:	6863      	ldr	r3, [r4, #4]
 80090f4:	2b01      	cmp	r3, #1
 80090f6:	d102      	bne.n	80090fe <SFU_BOOT_SM_CheckUserFwStatus+0x12>
    TRACE("\r\n= [SBOOT] STATE: CHECK USER FW STATUS");
 80090f8:	4833      	ldr	r0, [pc, #204]	@ (80091c8 <SFU_BOOT_SM_CheckUserFwStatus+0xdc>)
 80090fa:	f004 f9ad 	bl	800d458 <iprintf>
  m_ActiveSlotToExecute = 0U;
 80090fe:	2300      	movs	r3, #0
    if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
 8009100:	2001      	movs	r0, #1
  m_ActiveSlotToExecute = 0U;
 8009102:	60a3      	str	r3, [r4, #8]
    if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
 8009104:	f000 ffe2 	bl	800a0cc <SFU_IMG_DetectFW>
 8009108:	4b30      	ldr	r3, [pc, #192]	@ (80091cc <SFU_BOOT_SM_CheckUserFwStatus+0xe0>)
 800910a:	4298      	cmp	r0, r3
 800910c:	d109      	bne.n	8009122 <SFU_BOOT_SM_CheckUserFwStatus+0x36>
      m_ActiveSlotToExecute = MASTER_SLOT;
 800910e:	2101      	movs	r1, #1
      TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009110:	482f      	ldr	r0, [pc, #188]	@ (80091d0 <SFU_BOOT_SM_CheckUserFwStatus+0xe4>)
      m_ActiveSlotToExecute = MASTER_SLOT;
 8009112:	60a1      	str	r1, [r4, #8]
      TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009114:	f004 f9a0 	bl	800d458 <iprintf>
      SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_SIGNATURE);
 8009118:	7863      	ldrb	r3, [r4, #1]
 800911a:	b2db      	uxtb	r3, r3
 800911c:	7023      	strb	r3, [r4, #0]
 800911e:	2304      	movs	r3, #4
 8009120:	7063      	strb	r3, [r4, #1]
  if (m_ActiveSlotToExecute == 0U)
 8009122:	68a5      	ldr	r5, [r4, #8]
 8009124:	2d00      	cmp	r5, #0
 8009126:	d14b      	bne.n	80091c0 <SFU_BOOT_SM_CheckUserFwStatus+0xd4>
 8009128:	4f2a      	ldr	r7, [pc, #168]	@ (80091d4 <SFU_BOOT_SM_CheckUserFwStatus+0xe8>)
 800912a:	46b8      	mov	r8, r7
      if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)         /* Slot configured ? */
 800912c:	f857 3f04 	ldr.w	r3, [r7, #4]!
 8009130:	1c6e      	adds	r6, r5, #1
 8009132:	b17b      	cbz	r3, 8009154 <SFU_BOOT_SM_CheckUserFwStatus+0x68>
        if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009134:	4630      	mov	r0, r6
 8009136:	f000 ffc9 	bl	800a0cc <SFU_IMG_DetectFW>
 800913a:	4b24      	ldr	r3, [pc, #144]	@ (80091cc <SFU_BOOT_SM_CheckUserFwStatus+0xe0>)
 800913c:	4298      	cmp	r0, r3
 800913e:	d109      	bne.n	8009154 <SFU_BOOT_SM_CheckUserFwStatus+0x68>
          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009140:	4631      	mov	r1, r6
 8009142:	4823      	ldr	r0, [pc, #140]	@ (80091d0 <SFU_BOOT_SM_CheckUserFwStatus+0xe4>)
          m_ActiveSlotToExecute = SLOT_ACTIVE_1 + i;
 8009144:	60a6      	str	r6, [r4, #8]
          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009146:	f004 f987 	bl	800d458 <iprintf>
          SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_SIGNATURE);
 800914a:	7863      	ldrb	r3, [r4, #1]
 800914c:	b2db      	uxtb	r3, r3
 800914e:	7023      	strb	r3, [r4, #0]
 8009150:	2304      	movs	r3, #4
 8009152:	7063      	strb	r3, [r4, #1]
    for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 8009154:	2e02      	cmp	r6, #2
 8009156:	f04f 0501 	mov.w	r5, #1
 800915a:	d1e7      	bne.n	800912c <SFU_BOOT_SM_CheckUserFwStatus+0x40>
  if (m_ActiveSlotToExecute == 0U)
 800915c:	68a3      	ldr	r3, [r4, #8]
 800915e:	bb7b      	cbnz	r3, 80091c0 <SFU_BOOT_SM_CheckUserFwStatus+0xd4>
      if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)       /* Slot configured ? */
 8009160:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8009164:	b163      	cbz	r3, 8009180 <SFU_BOOT_SM_CheckUserFwStatus+0x94>
        if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009166:	4628      	mov	r0, r5
 8009168:	f000 fef0 	bl	8009f4c <SFU_IMG_VerifyEmptyActiveSlot>
 800916c:	4b17      	ldr	r3, [pc, #92]	@ (80091cc <SFU_BOOT_SM_CheckUserFwStatus+0xe0>)
 800916e:	4298      	cmp	r0, r3
 8009170:	d006      	beq.n	8009180 <SFU_BOOT_SM_CheckUserFwStatus+0x94>
          TRACE("\r\n\t  Slot SLOT_ACTIVE_%d not empty : erasing ...", SLOT_ACTIVE_1 + i);
 8009172:	4629      	mov	r1, r5
 8009174:	4818      	ldr	r0, [pc, #96]	@ (80091d8 <SFU_BOOT_SM_CheckUserFwStatus+0xec>)
 8009176:	f004 f96f 	bl	800d458 <iprintf>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 800917a:	4628      	mov	r0, r5
 800917c:	f000 feb0 	bl	8009ee0 <SFU_IMG_InvalidateCurrentFirmware>
      if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)       /* Slot configured ? */
 8009180:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8009184:	b163      	cbz	r3, 80091a0 <SFU_BOOT_SM_CheckUserFwStatus+0xb4>
        if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009186:	2002      	movs	r0, #2
 8009188:	f000 fee0 	bl	8009f4c <SFU_IMG_VerifyEmptyActiveSlot>
 800918c:	4b0f      	ldr	r3, [pc, #60]	@ (80091cc <SFU_BOOT_SM_CheckUserFwStatus+0xe0>)
 800918e:	4298      	cmp	r0, r3
 8009190:	d006      	beq.n	80091a0 <SFU_BOOT_SM_CheckUserFwStatus+0xb4>
          TRACE("\r\n\t  Slot SLOT_ACTIVE_%d not empty : erasing ...", SLOT_ACTIVE_1 + i);
 8009192:	2102      	movs	r1, #2
 8009194:	4810      	ldr	r0, [pc, #64]	@ (80091d8 <SFU_BOOT_SM_CheckUserFwStatus+0xec>)
 8009196:	f004 f95f 	bl	800d458 <iprintf>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 800919a:	2002      	movs	r0, #2
 800919c:	f000 fea0 	bl	8009ee0 <SFU_IMG_InvalidateCurrentFirmware>
    if (initialDeviceStatusCheck == 1U)
 80091a0:	6863      	ldr	r3, [r4, #4]
 80091a2:	2b01      	cmp	r3, #1
 80091a4:	d107      	bne.n	80091b6 <SFU_BOOT_SM_CheckUserFwStatus+0xca>
      TRACE("\r\n\t  No valid FW found in the active slots nor new FW to be installed");
 80091a6:	480d      	ldr	r0, [pc, #52]	@ (80091dc <SFU_BOOT_SM_CheckUserFwStatus+0xf0>)
 80091a8:	f004 f956 	bl	800d458 <iprintf>
      TRACE("\r\n\t  Waiting for the local download to start... ");
 80091ac:	480c      	ldr	r0, [pc, #48]	@ (80091e0 <SFU_BOOT_SM_CheckUserFwStatus+0xf4>)
 80091ae:	f004 f953 	bl	800d458 <iprintf>
      initialDeviceStatusCheck = 0U;
 80091b2:	2300      	movs	r3, #0
 80091b4:	6063      	str	r3, [r4, #4]
    SFU_SET_SM_CURR_STATE(SFU_STATE_CHECK_NEW_FW_TO_DOWNLOAD);
 80091b6:	7863      	ldrb	r3, [r4, #1]
 80091b8:	b2db      	uxtb	r3, r3
 80091ba:	7023      	strb	r3, [r4, #0]
 80091bc:	2301      	movs	r3, #1
 80091be:	7063      	strb	r3, [r4, #1]
}
 80091c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80091c4:	200011ac 	.word	0x200011ac
 80091c8:	0800e595 	.word	0x0800e595
 80091cc:	00122f11 	.word	0x00122f11
 80091d0:	0800e5bd 	.word	0x0800e5bd
 80091d4:	0800e424 	.word	0x0800e424
 80091d8:	0800e5ee 	.word	0x0800e5ee
 80091dc:	0800e61f 	.word	0x0800e61f
 80091e0:	0800e665 	.word	0x0800e665

080091e4 <SFU_BOOT_SM_DownloadNewUserFw>:
{
 80091e4:	b530      	push	{r4, r5, lr}
  SFU_LOADER_StatusTypeDef  e_ret_status_app = SFU_LOADER_ERR_COM;
 80091e6:	2301      	movs	r3, #1
{
 80091e8:	b085      	sub	sp, #20
  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
 80091ea:	4826      	ldr	r0, [pc, #152]	@ (8009284 <SFU_BOOT_SM_DownloadNewUserFw+0xa0>)
  SFU_LOADER_StatusTypeDef  e_ret_status_app = SFU_LOADER_ERR_COM;
 80091ec:	f88d 3007 	strb.w	r3, [sp, #7]
  uint32_t                  u_size = 0;
 80091f0:	2300      	movs	r3, #0
  if (e_ret_status == SFU_SUCCESS)
 80091f2:	4d25      	ldr	r5, [pc, #148]	@ (8009288 <SFU_BOOT_SM_DownloadNewUserFw+0xa4>)
  uint32_t                  u_size = 0;
 80091f4:	9303      	str	r3, [sp, #12]
  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
 80091f6:	f004 f92f 	bl	800d458 <iprintf>
  e_ret_status = SFU_LOADER_DownloadNewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
 80091fa:	aa03      	add	r2, sp, #12
 80091fc:	a902      	add	r1, sp, #8
 80091fe:	f10d 0007 	add.w	r0, sp, #7
 8009202:	f001 f85f 	bl	800a2c4 <SFU_LOADER_DownloadNewUserFw>
  if (e_ret_status == SFU_SUCCESS)
 8009206:	42a8      	cmp	r0, r5
  e_ret_status = SFU_LOADER_DownloadNewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
 8009208:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 800920a:	d120      	bne.n	800924e <SFU_BOOT_SM_DownloadNewUserFw+0x6a>
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, (uint8_t *) SlotStartAdd[dwl_slot],
 800920c:	4b1f      	ldr	r3, [pc, #124]	@ (800928c <SFU_BOOT_SM_DownloadNewUserFw+0xa8>)
 800920e:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 8009212:	9902      	ldr	r1, [sp, #8]
 8009214:	481e      	ldr	r0, [pc, #120]	@ (8009290 <SFU_BOOT_SM_DownloadNewUserFw+0xac>)
 8009216:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800921a:	f001 fbaf 	bl	800a97c <SFU_LL_FLASH_Read>
  if (e_ret_status == SFU_SUCCESS)
 800921e:	42a8      	cmp	r0, r5
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, (uint8_t *) SlotStartAdd[dwl_slot],
 8009220:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 8009222:	d114      	bne.n	800924e <SFU_BOOT_SM_DownloadNewUserFw+0x6a>
    if (SFU_IMG_Validation(dwl_slot, &fw_image_header_validated) != SFU_SUCCESS)
 8009224:	491a      	ldr	r1, [pc, #104]	@ (8009290 <SFU_BOOT_SM_DownloadNewUserFw+0xac>)
 8009226:	9802      	ldr	r0, [sp, #8]
 8009228:	f000 feda 	bl	8009fe0 <SFU_IMG_Validation>
 800922c:	42a0      	cmp	r0, r4
 800922e:	d002      	beq.n	8009236 <SFU_BOOT_SM_DownloadNewUserFw+0x52>
      (void) SFU_IMG_InvalidateCurrentFirmware(dwl_slot);
 8009230:	9802      	ldr	r0, [sp, #8]
 8009232:	f000 fe55 	bl	8009ee0 <SFU_IMG_InvalidateCurrentFirmware>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_REBOOT_STATE_MACHINE, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009236:	4b17      	ldr	r3, [pc, #92]	@ (8009294 <SFU_BOOT_SM_DownloadNewUserFw+0xb0>)
 8009238:	785a      	ldrb	r2, [r3, #1]
 800923a:	b2d2      	uxtb	r2, r2
 800923c:	701a      	strb	r2, [r3, #0]
 800923e:	4a12      	ldr	r2, [pc, #72]	@ (8009288 <SFU_BOOT_SM_DownloadNewUserFw+0xa4>)
 8009240:	4294      	cmp	r4, r2
 8009242:	bf0c      	ite	eq
 8009244:	2207      	moveq	r2, #7
 8009246:	2206      	movne	r2, #6
 8009248:	705a      	strb	r2, [r3, #1]
}
 800924a:	b005      	add	sp, #20
 800924c:	bd30      	pop	{r4, r5, pc}
    (void) SFU_IMG_InvalidateCurrentFirmware(dwl_slot);
 800924e:	9802      	ldr	r0, [sp, #8]
 8009250:	f000 fe46 	bl	8009ee0 <SFU_IMG_InvalidateCurrentFirmware>
    switch (e_ret_status_app)
 8009254:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009258:	3b01      	subs	r3, #1
 800925a:	2b05      	cmp	r3, #5
 800925c:	d8eb      	bhi.n	8009236 <SFU_BOOT_SM_DownloadNewUserFw+0x52>
 800925e:	e8df f003 	tbb	[pc, r3]
 8009262:	0b03      	.short	0x0b03
 8009264:	0f0d0709 	.word	0x0f0d0709
        SFU_EXCPT_SetError(SFU_EXCPT_COM_ERR);
 8009268:	2006      	movs	r0, #6
        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 800926a:	f000 fbbb 	bl	80099e4 <SFU_EXCPT_SetError>
        break;
 800926e:	e7e2      	b.n	8009236 <SFU_BOOT_SM_DownloadNewUserFw+0x52>
        SFU_EXCPT_SetError(SFU_EXCPT_VERSION_ERR);
 8009270:	200f      	movs	r0, #15
 8009272:	e7fa      	b.n	800926a <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_FW_TOO_BIG);
 8009274:	2005      	movs	r0, #5
 8009276:	e7f8      	b.n	800926a <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_HEADER_AUTH_ERR);
 8009278:	2007      	movs	r0, #7
 800927a:	e7f6      	b.n	800926a <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_FLASH_ERR);
 800927c:	200a      	movs	r0, #10
 800927e:	e7f4      	b.n	800926a <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 8009280:	2008      	movs	r0, #8
 8009282:	e7f2      	b.n	800926a <SFU_BOOT_SM_DownloadNewUserFw+0x86>
 8009284:	0800e696 	.word	0x0800e696
 8009288:	00122f11 	.word	0x00122f11
 800928c:	0800e424 	.word	0x0800e424
 8009290:	20001600 	.word	0x20001600
 8009294:	200011ac 	.word	0x200011ac

08009298 <SFU_BOOT_SM_CheckNewFwToDownload>:
{
 8009298:	b510      	push	{r4, lr}
  if (initialDeviceStatusCheck == 1U)
 800929a:	4c0d      	ldr	r4, [pc, #52]	@ (80092d0 <SFU_BOOT_SM_CheckNewFwToDownload+0x38>)
 800929c:	6863      	ldr	r3, [r4, #4]
 800929e:	2b01      	cmp	r3, #1
 80092a0:	d00a      	beq.n	80092b8 <SFU_BOOT_SM_CheckNewFwToDownload+0x20>
    e_ret_status = SFU_SUCCESS;
 80092a2:	4a0c      	ldr	r2, [pc, #48]	@ (80092d4 <SFU_BOOT_SM_CheckNewFwToDownload+0x3c>)
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_DOWNLOAD_NEW_USER_FW, SFU_STATE_VERIFY_USER_FW_STATUS);
 80092a4:	7863      	ldrb	r3, [r4, #1]
 80092a6:	b2db      	uxtb	r3, r3
 80092a8:	7023      	strb	r3, [r4, #0]
 80092aa:	4b0a      	ldr	r3, [pc, #40]	@ (80092d4 <SFU_BOOT_SM_CheckNewFwToDownload+0x3c>)
 80092ac:	429a      	cmp	r2, r3
 80092ae:	bf0c      	ite	eq
 80092b0:	2302      	moveq	r3, #2
 80092b2:	2303      	movne	r3, #3
 80092b4:	7063      	strb	r3, [r4, #1]
}
 80092b6:	bd10      	pop	{r4, pc}
    TRACE("\r\n= [SBOOT] STATE: CHECK NEW FIRMWARE TO DOWNLOAD");
 80092b8:	4807      	ldr	r0, [pc, #28]	@ (80092d8 <SFU_BOOT_SM_CheckNewFwToDownload+0x40>)
 80092ba:	f004 f8cd 	bl	800d458 <iprintf>
    if (0U != BUTTON_PUSHED())
 80092be:	2000      	movs	r0, #0
 80092c0:	f001 fedc 	bl	800b07c <BSP_PB_GetState>
 80092c4:	2801      	cmp	r0, #1
 80092c6:	d0ec      	beq.n	80092a2 <SFU_BOOT_SM_CheckNewFwToDownload+0xa>
      e_ret_status = SFU_ERROR;
 80092c8:	f641 72e1 	movw	r2, #8161	@ 0x1fe1
 80092cc:	e7ea      	b.n	80092a4 <SFU_BOOT_SM_CheckNewFwToDownload+0xc>
 80092ce:	bf00      	nop
 80092d0:	200011ac 	.word	0x200011ac
 80092d4:	00122f11 	.word	0x00122f11
 80092d8:	0800e6c4 	.word	0x0800e6c4

080092dc <SFU_BOOT_SM_CheckStatusOnReset>:
{
 80092dc:	b507      	push	{r0, r1, r2, lr}
  TRACE("\r\n= [SBOOT] STATE: CHECK STATUS ON RESET");
 80092de:	4818      	ldr	r0, [pc, #96]	@ (8009340 <SFU_BOOT_SM_CheckStatusOnReset+0x64>)
 80092e0:	f004 f8ba 	bl	800d458 <iprintf>
  * @param  None
  * @retval None
  */
static void SFU_BOOT_ManageResetSources(void)
{
  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
 80092e4:	2300      	movs	r3, #0

  /* Check the wakeup sources */
  SFU_LL_SECU_GetResetSources(&e_wakeup_source_id);
 80092e6:	f10d 0007 	add.w	r0, sp, #7
  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
 80092ea:	f88d 3007 	strb.w	r3, [sp, #7]
  SFU_LL_SECU_GetResetSources(&e_wakeup_source_id);
 80092ee:	f001 fddd 	bl	800aeac <SFU_LL_SECU_GetResetSources>
  switch (e_wakeup_source_id)
 80092f2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80092f6:	3b01      	subs	r3, #1
 80092f8:	2b05      	cmp	r3, #5
 80092fa:	d81e      	bhi.n	800933a <SFU_BOOT_SM_CheckStatusOnReset+0x5e>
 80092fc:	e8df f003 	tbb	[pc, r3]
 8009300:	17151303 	.word	0x17151303
 8009304:	1b19      	.short	0x1b19
       * Please note that the example of reset causes handling below is only a basic example to illustrate the way the
       * RCC_CSR flags can be used to do so.
       */

    case SFU_RESET_WDG_RESET:
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by a Watchdog reset!");
 8009306:	480f      	ldr	r0, [pc, #60]	@ (8009344 <SFU_BOOT_SM_CheckStatusOnReset+0x68>)
         ...
      */
      break;

    default:
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
 8009308:	f004 f8a6 	bl	800d458 <iprintf>
      */
      break;
  }

  /* Once the reset sources has been managed and a possible error has been set, clear the reset sources */
  SFU_LL_SECU_ClearResetSources();
 800930c:	f001 fdf0 	bl	800aef0 <SFU_LL_SECU_ClearResetSources>
  SFU_MPU_EnterUnprivilegedMode();
 8009310:	f001 f9c0 	bl	800a694 <SFU_MPU_EnterUnprivilegedMode>
  SFU_SET_SM_CURR_STATE(SFU_STATE_CHECK_NEW_FW_TO_DOWNLOAD);
 8009314:	4b0c      	ldr	r3, [pc, #48]	@ (8009348 <SFU_BOOT_SM_CheckStatusOnReset+0x6c>)
 8009316:	785a      	ldrb	r2, [r3, #1]
 8009318:	b2d2      	uxtb	r2, r2
 800931a:	701a      	strb	r2, [r3, #0]
 800931c:	2201      	movs	r2, #1
 800931e:	705a      	strb	r2, [r3, #1]
}
 8009320:	b003      	add	sp, #12
 8009322:	f85d fb04 	ldr.w	pc, [sp], #4
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a LowPower reset!");
 8009326:	4809      	ldr	r0, [pc, #36]	@ (800934c <SFU_BOOT_SM_CheckStatusOnReset+0x70>)
 8009328:	e7ee      	b.n	8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Hardware reset!");
 800932a:	4809      	ldr	r0, [pc, #36]	@ (8009350 <SFU_BOOT_SM_CheckStatusOnReset+0x74>)
 800932c:	e7ec      	b.n	8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a BOR reset!");
 800932e:	4809      	ldr	r0, [pc, #36]	@ (8009354 <SFU_BOOT_SM_CheckStatusOnReset+0x78>)
 8009330:	e7ea      	b.n	8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Software reset!");
 8009332:	4809      	ldr	r0, [pc, #36]	@ (8009358 <SFU_BOOT_SM_CheckStatusOnReset+0x7c>)
 8009334:	e7e8      	b.n	8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Option Bytes reload!");
 8009336:	4809      	ldr	r0, [pc, #36]	@ (800935c <SFU_BOOT_SM_CheckStatusOnReset+0x80>)
 8009338:	e7e6      	b.n	8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
 800933a:	4809      	ldr	r0, [pc, #36]	@ (8009360 <SFU_BOOT_SM_CheckStatusOnReset+0x84>)
 800933c:	e7e4      	b.n	8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
 800933e:	bf00      	nop
 8009340:	0800e6f6 	.word	0x0800e6f6
 8009344:	0800e71f 	.word	0x0800e71f
 8009348:	200011ac 	.word	0x200011ac
 800934c:	0800e75e 	.word	0x0800e75e
 8009350:	0800e79a 	.word	0x0800e79a
 8009354:	0800e7d6 	.word	0x0800e7d6
 8009358:	0800e80d 	.word	0x0800e80d
 800935c:	0800e849 	.word	0x0800e849
 8009360:	0800e88e 	.word	0x0800e88e

08009364 <SFU_BOOT_DeInit.isra.0>:
static SFU_ErrorStatus SFU_BOOT_DeInit(void)
 8009364:	b538      	push	{r3, r4, r5, lr}
  if (SFU_EXCPT_DeInit() != SFU_SUCCESS)
 8009366:	f000 fb97 	bl	8009a98 <SFU_EXCPT_DeInit>
 800936a:	4b09      	ldr	r3, [pc, #36]	@ (8009390 <SFU_BOOT_DeInit.isra.0+0x2c>)
 800936c:	4605      	mov	r5, r0
 800936e:	4298      	cmp	r0, r3
 8009370:	d10c      	bne.n	800938c <SFU_BOOT_DeInit.isra.0+0x28>
  if (SFU_LOADER_DeInit() != SFU_SUCCESS)
 8009372:	f000 ffa3 	bl	800a2bc <SFU_LOADER_DeInit>
 8009376:	42a8      	cmp	r0, r5
 8009378:	4604      	mov	r4, r0
 800937a:	d107      	bne.n	800938c <SFU_BOOT_DeInit.isra.0+0x28>
  if (SFU_COM_DeInit() != SFU_SUCCESS)
 800937c:	f000 fb14 	bl	80099a8 <SFU_COM_DeInit>
 8009380:	42a0      	cmp	r0, r4
 8009382:	d103      	bne.n	800938c <SFU_BOOT_DeInit.isra.0+0x28>
}
 8009384:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (SFU_LL_DeInit() != SFU_SUCCESS)
 8009388:	f001 b9ae 	b.w	800a6e8 <SFU_LL_DeInit>
}
 800938c:	bd38      	pop	{r3, r4, r5, pc}
 800938e:	bf00      	nop
 8009390:	00122f11 	.word	0x00122f11

08009394 <SFU_BOOT_ForceReboot>:
{
 8009394:	b508      	push	{r3, lr}
  TRACE("\r\n========= End of Execution ==========");
 8009396:	480d      	ldr	r0, [pc, #52]	@ (80093cc <SFU_BOOT_ForceReboot+0x38>)
 8009398:	f004 f85e 	bl	800d458 <iprintf>
  TRACE("\r\n\r\n\r\n");
 800939c:	480c      	ldr	r0, [pc, #48]	@ (80093d0 <SFU_BOOT_ForceReboot+0x3c>)
 800939e:	f004 f8c3 	bl	800d528 <puts>
  if (0U != SFU_MPU_IsUnprivileged())
 80093a2:	f001 f96d 	bl	800a680 <SFU_MPU_IsUnprivileged>
 80093a6:	b120      	cbz	r0, 80093b2 <SFU_BOOT_ForceReboot+0x1e>
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 80093a8:	2002      	movs	r0, #2
}
 80093aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 80093ae:	f001 b963 	b.w	800a678 <SFU_MPU_SysCall>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80093b2:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80093b6:	4907      	ldr	r1, [pc, #28]	@ (80093d4 <SFU_BOOT_ForceReboot+0x40>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80093b8:	4b07      	ldr	r3, [pc, #28]	@ (80093d8 <SFU_BOOT_ForceReboot+0x44>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80093ba:	68ca      	ldr	r2, [r1, #12]
 80093bc:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80093c0:	4313      	orrs	r3, r2
 80093c2:	60cb      	str	r3, [r1, #12]
 80093c4:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 80093c8:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 80093ca:	e7fd      	b.n	80093c8 <SFU_BOOT_ForceReboot+0x34>
 80093cc:	0800e8d4 	.word	0x0800e8d4
 80093d0:	0800e8fc 	.word	0x0800e8fc
 80093d4:	e000ed00 	.word	0xe000ed00
 80093d8:	05fa0004 	.word	0x05fa0004

080093dc <SFU_BOOT_SM_RebootStateMachine>:
{
 80093dc:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: REBOOT STATE MACHINE");
 80093de:	4804      	ldr	r0, [pc, #16]	@ (80093f0 <SFU_BOOT_SM_RebootStateMachine+0x14>)
 80093e0:	f004 f83a 	bl	800d458 <iprintf>
  (void)SFU_BOOT_DeInit();
 80093e4:	f7ff ffbe 	bl	8009364 <SFU_BOOT_DeInit.isra.0>
}
 80093e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SFU_BOOT_ForceReboot();
 80093ec:	f7ff bfd2 	b.w	8009394 <SFU_BOOT_ForceReboot>
 80093f0:	0800e902 	.word	0x0800e902

080093f4 <SFU_BOOT_SM_ExecuteUserFw>:
{
 80093f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  SE_StatusTypeDef e_se_status = SE_KO;
 80093f6:	4b39      	ldr	r3, [pc, #228]	@ (80094dc <SFU_BOOT_SM_ExecuteUserFw+0xe8>)
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 80093f8:	4d39      	ldr	r5, [pc, #228]	@ (80094e0 <SFU_BOOT_SM_ExecuteUserFw+0xec>)
  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
 80093fa:	483a      	ldr	r0, [pc, #232]	@ (80094e4 <SFU_BOOT_SM_ExecuteUserFw+0xf0>)
  SE_StatusTypeDef e_se_status = SE_KO;
 80093fc:	9301      	str	r3, [sp, #4]
  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
 80093fe:	f004 f82b 	bl	800d458 <iprintf>
  (void) SFU_LL_SECU_IWDG_Refresh();
 8009402:	f001 fd7f 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 8009406:	686a      	ldr	r2, [r5, #4]
 8009408:	f248 435a 	movw	r3, #33882	@ 0x845a
 800940c:	429a      	cmp	r2, r3
 800940e:	d001      	beq.n	8009414 <SFU_BOOT_SM_ExecuteUserFw+0x20>
 8009410:	f000 fb1a 	bl	8009a48 <SFU_EXCPT_Security_Error>
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 8009414:	4f34      	ldr	r7, [pc, #208]	@ (80094e8 <SFU_BOOT_SM_ExecuteUserFw+0xf4>)
{
 8009416:	2300      	movs	r3, #0
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 8009418:	1c5c      	adds	r4, r3, #1
 800941a:	f857 3f04 	ldr.w	r3, [r7, #4]!
 800941e:	b333      	cbz	r3, 800946e <SFU_BOOT_SM_ExecuteUserFw+0x7a>
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009420:	4620      	mov	r0, r4
 8009422:	f000 fe53 	bl	800a0cc <SFU_IMG_DetectFW>
 8009426:	4b31      	ldr	r3, [pc, #196]	@ (80094ec <SFU_BOOT_SM_ExecuteUserFw+0xf8>)
 8009428:	4606      	mov	r6, r0
 800942a:	4298      	cmp	r0, r3
 800942c:	d11f      	bne.n	800946e <SFU_BOOT_SM_ExecuteUserFw+0x7a>
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 800942e:	f245 7376 	movw	r3, #22390	@ 0x5776
        if (SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009432:	4620      	mov	r0, r4
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 8009434:	606b      	str	r3, [r5, #4]
        if (SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009436:	f000 fe33 	bl	800a0a0 <SFU_IMG_VerifyActiveImgMetadata>
 800943a:	42b0      	cmp	r0, r6
 800943c:	d001      	beq.n	8009442 <SFU_BOOT_SM_ExecuteUserFw+0x4e>
          SFU_EXCPT_Security_Error();
 800943e:	f000 fb03 	bl	8009a48 <SFU_EXCPT_Security_Error>
        if (SFU_IMG_ControlActiveImgTag(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009442:	4e2a      	ldr	r6, [pc, #168]	@ (80094ec <SFU_BOOT_SM_ExecuteUserFw+0xf8>)
 8009444:	4620      	mov	r0, r4
 8009446:	f000 fd8f 	bl	8009f68 <SFU_IMG_ControlActiveImgTag>
 800944a:	42b0      	cmp	r0, r6
 800944c:	d001      	beq.n	8009452 <SFU_BOOT_SM_ExecuteUserFw+0x5e>
          SFU_EXCPT_Security_Error();
 800944e:	f000 fafb 	bl	8009a48 <SFU_EXCPT_Security_Error>
        if (SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009452:	4620      	mov	r0, r4
 8009454:	f000 fd68 	bl	8009f28 <SFU_IMG_VerifyActiveSlot>
 8009458:	42b0      	cmp	r0, r6
 800945a:	d001      	beq.n	8009460 <SFU_BOOT_SM_ExecuteUserFw+0x6c>
          SFU_EXCPT_Security_Error();
 800945c:	f000 faf4 	bl	8009a48 <SFU_EXCPT_Security_Error>
        FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 8009460:	686a      	ldr	r2, [r5, #4]
 8009462:	f248 435a 	movw	r3, #33882	@ 0x845a
 8009466:	429a      	cmp	r2, r3
 8009468:	d001      	beq.n	800946e <SFU_BOOT_SM_ExecuteUserFw+0x7a>
 800946a:	f000 faed 	bl	8009a48 <SFU_EXCPT_Security_Error>
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 800946e:	2c02      	cmp	r4, #2
 8009470:	f04f 0301 	mov.w	r3, #1
 8009474:	d1d0      	bne.n	8009418 <SFU_BOOT_SM_ExecuteUserFw+0x24>
  e_ret_status = SFU_LL_FLASH_Config_Exe(m_ActiveSlotToExecute);
 8009476:	4c1e      	ldr	r4, [pc, #120]	@ (80094f0 <SFU_BOOT_SM_ExecuteUserFw+0xfc>)
 8009478:	68a0      	ldr	r0, [r4, #8]
 800947a:	f001 fa8d 	bl	800a998 <SFU_LL_FLASH_Config_Exe>
  if (e_ret_status != SFU_SUCCESS)
 800947e:	4b1b      	ldr	r3, [pc, #108]	@ (80094ec <SFU_BOOT_SM_ExecuteUserFw+0xf8>)
 8009480:	4298      	cmp	r0, r3
 8009482:	d11d      	bne.n	80094c0 <SFU_BOOT_SM_ExecuteUserFw+0xcc>
    if (SE_LockRestrictServices(&e_se_status) == SE_SUCCESS)
 8009484:	a801      	add	r0, sp, #4
 8009486:	f7fe fe2b 	bl	80080e0 <SE_LockRestrictServices>
 800948a:	4b1a      	ldr	r3, [pc, #104]	@ (80094f4 <SFU_BOOT_SM_ExecuteUserFw+0x100>)
 800948c:	4607      	mov	r7, r0
 800948e:	4298      	cmp	r0, r3
 8009490:	d122      	bne.n	80094d8 <SFU_BOOT_SM_ExecuteUserFw+0xe4>
      if (SE_LockRestrictServices(&e_se_status) == SE_SUCCESS)
 8009492:	a801      	add	r0, sp, #4
 8009494:	f7fe fe24 	bl	80080e0 <SE_LockRestrictServices>
 8009498:	42b8      	cmp	r0, r7
 800949a:	d11d      	bne.n	80094d8 <SFU_BOOT_SM_ExecuteUserFw+0xe4>
        (void)SFU_BOOT_DeInit(); /* the return value is not checked, we will always try launching the UserApp */
 800949c:	f7ff ff62 	bl	8009364 <SFU_BOOT_DeInit.isra.0>
        FLOW_CONTROL_STEP(uFlowCryptoValue, FLOW_STEP_LOCK_SERVICE, FLOW_CTRL_LOCK_SERVICE);
 80094a0:	686a      	ldr	r2, [r5, #4]
 80094a2:	f482 4334 	eor.w	r3, r2, #46080	@ 0xb400
 80094a6:	f083 03ab 	eor.w	r3, r3, #171	@ 0xab
 80094aa:	606b      	str	r3, [r5, #4]
 80094ac:	f248 435a 	movw	r3, #33882	@ 0x845a
 80094b0:	429a      	cmp	r2, r3
 80094b2:	d001      	beq.n	80094b8 <SFU_BOOT_SM_ExecuteUserFw+0xc4>
 80094b4:	f000 fac8 	bl	8009a48 <SFU_EXCPT_Security_Error>
        e_ret_status = SFU_IMG_LaunchActiveImg(m_ActiveSlotToExecute);
 80094b8:	68a0      	ldr	r0, [r4, #8]
 80094ba:	f000 fd73 	bl	8009fa4 <SFU_IMG_LaunchActiveImg>
        while (1 == 1)
 80094be:	e7fe      	b.n	80094be <SFU_BOOT_SM_ExecuteUserFw+0xca>
    SFU_EXCPT_SetError(SFU_EXCPT_FLASH_CFG_ERR);
 80094c0:	200b      	movs	r0, #11
        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SERVICES_ERR);
 80094c2:	f000 fa8f 	bl	80099e4 <SFU_EXCPT_SetError>
        SFU_BOOT_ForceReboot();
 80094c6:	f7ff ff65 	bl	8009394 <SFU_BOOT_ForceReboot>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_HANDLE_CRITICAL_FAILURE, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 80094ca:	7863      	ldrb	r3, [r4, #1]
 80094cc:	b2db      	uxtb	r3, r3
 80094ce:	7023      	strb	r3, [r4, #0]
 80094d0:	2306      	movs	r3, #6
 80094d2:	7063      	strb	r3, [r4, #1]
}
 80094d4:	b003      	add	sp, #12
 80094d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SERVICES_ERR);
 80094d8:	2004      	movs	r0, #4
 80094da:	e7f2      	b.n	80094c2 <SFU_BOOT_SM_ExecuteUserFw+0xce>
 80094dc:	0013023d 	.word	0x0013023d
 80094e0:	20001100 	.word	0x20001100
 80094e4:	0800e92a 	.word	0x0800e92a
 80094e8:	0800e424 	.word	0x0800e424
 80094ec:	00122f11 	.word	0x00122f11
 80094f0:	200011ac 	.word	0x200011ac
 80094f4:	0012310f 	.word	0x0012310f

080094f8 <SFU_BOOT_RunSecureBootService>:
{
 80094f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (SE_Startup() == SE_SUCCESS)
 80094fa:	f7fe fdcd 	bl	8008098 <SE_Startup>
 80094fe:	4b3c      	ldr	r3, [pc, #240]	@ (80095f0 <SFU_BOOT_RunSecureBootService+0xf8>)
 8009500:	4604      	mov	r4, r0
 8009502:	4298      	cmp	r0, r3
 8009504:	d171      	bne.n	80095ea <SFU_BOOT_RunSecureBootService+0xf2>
  (void) SFU_COM_Init();
 8009506:	f000 fa3f 	bl	8009988 <SFU_COM_Init>
  if (SFU_LL_SECU_CheckApplyStaticProtections() == SFU_SUCCESS)
 800950a:	f001 fc31 	bl	800ad70 <SFU_LL_SECU_CheckApplyStaticProtections>
 800950e:	4b39      	ldr	r3, [pc, #228]	@ (80095f4 <SFU_BOOT_RunSecureBootService+0xfc>)
 8009510:	4606      	mov	r6, r0
 8009512:	4298      	cmp	r0, r3
 8009514:	d005      	beq.n	8009522 <SFU_BOOT_RunSecureBootService+0x2a>
    TRACE("\r\n= [SBOOT] System Security Check failed! Rebooting...");
 8009516:	4838      	ldr	r0, [pc, #224]	@ (80095f8 <SFU_BOOT_RunSecureBootService+0x100>)
 8009518:	f003 ff9e 	bl	800d458 <iprintf>
      e_ret_code = SFU_BOOT_SECIPS_CFG_FAIL;
 800951c:	2001      	movs	r0, #1
}
 800951e:	b003      	add	sp, #12
 8009520:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_INITIAL_CONFIGURATION);
 8009522:	2000      	movs	r0, #0
 8009524:	f001 fc92 	bl	800ae4c <SFU_LL_SECU_CheckApplyRuntimeProtections>
  if (SFU_BOOT_CheckApplySecurityProtections() != SFU_SUCCESS)
 8009528:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_INITIAL_CONFIGURATION);
 800952a:	4605      	mov	r5, r0
  if (SFU_BOOT_CheckApplySecurityProtections() != SFU_SUCCESS)
 800952c:	d1f3      	bne.n	8009516 <SFU_BOOT_RunSecureBootService+0x1e>
    TRACE("\r\n= [SBOOT] System Security Check successfully passed. Starting...");
 800952e:	4833      	ldr	r0, [pc, #204]	@ (80095fc <SFU_BOOT_RunSecureBootService+0x104>)
 8009530:	f003 ff92 	bl	800d458 <iprintf>
  (void) BSP_LED_Init(SFU_STATUS_LED);
 8009534:	2000      	movs	r0, #0
 8009536:	f001 fd13 	bl	800af60 <BSP_LED_Init>
  BUTTON_INIT();
 800953a:	2100      	movs	r1, #0
  initialDeviceStatusCheck = 1U;
 800953c:	4f30      	ldr	r7, [pc, #192]	@ (8009600 <SFU_BOOT_RunSecureBootService+0x108>)
  BUTTON_INIT();
 800953e:	4608      	mov	r0, r1
 8009540:	f001 fd5c 	bl	800affc <BSP_PB_Init>
  initialDeviceStatusCheck = 1U;
 8009544:	2301      	movs	r3, #1
 8009546:	607b      	str	r3, [r7, #4]
  if (SFU_LL_Init() != SFU_SUCCESS)
 8009548:	f001 f910 	bl	800a76c <SFU_LL_Init>
 800954c:	42a8      	cmp	r0, r5
 800954e:	4606      	mov	r6, r0
 8009550:	d134      	bne.n	80095bc <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_LL_FLASH_Init() != SFU_SUCCESS)
 8009552:	f001 f9f7 	bl	800a944 <SFU_LL_FLASH_Init>
 8009556:	42b0      	cmp	r0, r6
 8009558:	4605      	mov	r5, r0
 800955a:	d12f      	bne.n	80095bc <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_COM_Init() != SFU_SUCCESS)
 800955c:	f000 fa14 	bl	8009988 <SFU_COM_Init>
 8009560:	42a8      	cmp	r0, r5
 8009562:	4606      	mov	r6, r0
 8009564:	d12a      	bne.n	80095bc <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_LOADER_Init() != SFU_SUCCESS)
 8009566:	f000 fea5 	bl	800a2b4 <SFU_LOADER_Init>
 800956a:	42b0      	cmp	r0, r6
 800956c:	4605      	mov	r5, r0
 800956e:	d125      	bne.n	80095bc <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_EXCPT_Init() != SFU_SUCCESS)
 8009570:	f000 fa8e 	bl	8009a90 <SFU_EXCPT_Init>
 8009574:	42a8      	cmp	r0, r5
 8009576:	d121      	bne.n	80095bc <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_IMG_InitImageHandling() != SFU_IMG_INIT_OK)
 8009578:	f000 fc34 	bl	8009de4 <SFU_IMG_InitImageHandling>
 800957c:	b9f0      	cbnz	r0, 80095bc <SFU_BOOT_RunSecureBootService+0xc4>
  TRACE("\r\n\r\n");
 800957e:	4821      	ldr	r0, [pc, #132]	@ (8009604 <SFU_BOOT_RunSecureBootService+0x10c>)
 8009580:	f003 ffd2 	bl	800d528 <puts>
  TRACE("\r\n======================================================================");
 8009584:	4820      	ldr	r0, [pc, #128]	@ (8009608 <SFU_BOOT_RunSecureBootService+0x110>)
 8009586:	f003 ff67 	bl	800d458 <iprintf>
  TRACE("\r\n=              (C) COPYRIGHT 2017 STMicroelectronics                 =");
 800958a:	4820      	ldr	r0, [pc, #128]	@ (800960c <SFU_BOOT_RunSecureBootService+0x114>)
 800958c:	f003 ff64 	bl	800d458 <iprintf>
  TRACE("\r\n=                                                                    =");
 8009590:	481f      	ldr	r0, [pc, #124]	@ (8009610 <SFU_BOOT_RunSecureBootService+0x118>)
 8009592:	f003 ff61 	bl	800d458 <iprintf>
  TRACE("\r\n=              Secure Boot and Secure Firmware Update                =");
 8009596:	481f      	ldr	r0, [pc, #124]	@ (8009614 <SFU_BOOT_RunSecureBootService+0x11c>)
 8009598:	f003 ff5e 	bl	800d458 <iprintf>
  TRACE("\r\n======================================================================");
 800959c:	481a      	ldr	r0, [pc, #104]	@ (8009608 <SFU_BOOT_RunSecureBootService+0x110>)
 800959e:	f003 ff5b 	bl	800d458 <iprintf>
  TRACE("\r\n\r\n");
 80095a2:	4818      	ldr	r0, [pc, #96]	@ (8009604 <SFU_BOOT_RunSecureBootService+0x10c>)
 80095a4:	f003 ffc0 	bl	800d528 <puts>
  if (SE_Init(&e_se_status, SystemCoreClock) != SE_SUCCESS)
 80095a8:	4b1b      	ldr	r3, [pc, #108]	@ (8009618 <SFU_BOOT_RunSecureBootService+0x120>)
 80095aa:	a801      	add	r0, sp, #4
 80095ac:	6819      	ldr	r1, [r3, #0]
 80095ae:	f7fe fd4d 	bl	800804c <SE_Init>
 80095b2:	42a0      	cmp	r0, r4
 80095b4:	d004      	beq.n	80095c0 <SFU_BOOT_RunSecureBootService+0xc8>
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION CRITICAL FAILURE!");
 80095b6:	4819      	ldr	r0, [pc, #100]	@ (800961c <SFU_BOOT_RunSecureBootService+0x124>)
 80095b8:	f003 ff4e 	bl	800d458 <iprintf>
        e_ret_code = SFU_BOOT_INIT_FAIL;
 80095bc:	2002      	movs	r0, #2
 80095be:	e7ae      	b.n	800951e <SFU_BOOT_RunSecureBootService+0x26>
    if (SFU_BOOT_SecuritySafetyCheck() == SFU_SUCCESS)
 80095c0:	4c0c      	ldr	r4, [pc, #48]	@ (80095f4 <SFU_BOOT_RunSecureBootService+0xfc>)
      fnStateMachineFunction = fnStateMachineTable[(uint8_t)m_StateMachineContext.CurrState];
 80095c2:	4d17      	ldr	r5, [pc, #92]	@ (8009620 <SFU_BOOT_RunSecureBootService+0x128>)
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION SUCCESSFUL");
 80095c4:	4817      	ldr	r0, [pc, #92]	@ (8009624 <SFU_BOOT_RunSecureBootService+0x12c>)
 80095c6:	f003 ff47 	bl	800d458 <iprintf>
  e_ret_status = SFU_LL_SECU_IWDG_Refresh();
 80095ca:	f001 fc9b 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
    if (SFU_BOOT_SecuritySafetyCheck() == SFU_SUCCESS)
 80095ce:	42a0      	cmp	r0, r4
 80095d0:	d006      	beq.n	80095e0 <SFU_BOOT_RunSecureBootService+0xe8>
  SFU_EXCPT_SetError(SFU_EXCPT_UNKNOWN);
 80095d2:	2010      	movs	r0, #16
 80095d4:	f000 fa06 	bl	80099e4 <SFU_EXCPT_SetError>
  SFU_BOOT_ForceReboot();
 80095d8:	f7ff fedc 	bl	8009394 <SFU_BOOT_ForceReboot>
  SFU_BOOT_InitErrorTypeDef e_ret_code = SFU_BOOT_INIT_ERROR;
 80095dc:	2003      	movs	r0, #3
  return e_ret_status;
 80095de:	e79e      	b.n	800951e <SFU_BOOT_RunSecureBootService+0x26>
      fnStateMachineFunction = fnStateMachineTable[(uint8_t)m_StateMachineContext.CurrState];
 80095e0:	787b      	ldrb	r3, [r7, #1]
      fnStateMachineFunction();
 80095e2:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80095e6:	4798      	blx	r3
 80095e8:	e7ef      	b.n	80095ca <SFU_BOOT_RunSecureBootService+0xd2>
    e_ret_code = SFU_BOOT_SECENG_INIT_FAIL;
 80095ea:	2000      	movs	r0, #0
 80095ec:	e797      	b.n	800951e <SFU_BOOT_RunSecureBootService+0x26>
 80095ee:	bf00      	nop
 80095f0:	0012310f 	.word	0x0012310f
 80095f4:	00122f11 	.word	0x00122f11
 80095f8:	0800e953 	.word	0x0800e953
 80095fc:	0800e98a 	.word	0x0800e98a
 8009600:	200011ac 	.word	0x200011ac
 8009604:	0800e8fe 	.word	0x0800e8fe
 8009608:	0800e9cd 	.word	0x0800e9cd
 800960c:	0800ea16 	.word	0x0800ea16
 8009610:	0800ea5f 	.word	0x0800ea5f
 8009614:	0800eaa8 	.word	0x0800eaa8
 8009618:	20001120 	.word	0x20001120
 800961c:	0800eaf1 	.word	0x0800eaf1
 8009620:	0800e3c0 	.word	0x0800e3c0
 8009624:	0800eb2c 	.word	0x0800eb2c

08009628 <MemManage_Handler>:
  * @param  None
  * @retval None
  */
void SFU_CALLBACK_MEMORYFAULT(void)
{
  SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_MEMORY_FAULT);
 8009628:	2001      	movs	r0, #1
 800962a:	f000 b9e9 	b.w	8009a00 <SFU_EXCPT_IrqExceptionHandler>

0800962e <SFU_COM_Serial_PutByte>:
  * @brief  Transmit a byte to the COM Port.
  * @param  uParam: The byte to be sent.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_Serial_PutByte(uint8_t uParam)
{
 800962e:	b507      	push	{r0, r1, r2, lr}
  return SFU_LL_UART_Transmit(&uParam, 1U, SFU_COM_LOADER_SERIAL_TIME_OUT);
 8009630:	2264      	movs	r2, #100	@ 0x64
 8009632:	2101      	movs	r1, #1
{
 8009634:	f88d 0007 	strb.w	r0, [sp, #7]
  return SFU_LL_UART_Transmit(&uParam, 1U, SFU_COM_LOADER_SERIAL_TIME_OUT);
 8009638:	f10d 0007 	add.w	r0, sp, #7
 800963c:	f001 f8c8 	bl	800a7d0 <SFU_LL_UART_Transmit>
}
 8009640:	b003      	add	sp, #12
 8009642:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009648 <SFU_COM_YMODEM_Receive>:
{
 8009648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800964c:	b08b      	sub	sp, #44	@ 0x2c
  if ((peCOMStatus == NULL) || (puSize == NULL))
 800964e:	4604      	mov	r4, r0
{
 8009650:	9102      	str	r1, [sp, #8]
  if ((peCOMStatus == NULL) || (puSize == NULL))
 8009652:	2800      	cmp	r0, #0
 8009654:	f000 8133 	beq.w	80098be <SFU_COM_YMODEM_Receive+0x276>
 8009658:	2900      	cmp	r1, #0
 800965a:	f000 8130 	beq.w	80098be <SFU_COM_YMODEM_Receive+0x276>
  *peCOMStatus = SFU_COM_YMODEM_OK;
 800965e:	2500      	movs	r5, #0
  /* This operation could last long. Need to refresh the Watchdog if enabled. It could be implemented as a callback*/
  (void) SFU_LL_SECU_IWDG_Refresh();

  eRetStatus = SFU_LL_UART_Receive(&char1, 1, uTimeout);

  if (eRetStatus == SFU_SUCCESS)
 8009660:	f8df 8318 	ldr.w	r8, [pc, #792]	@ 800997c <SFU_COM_YMODEM_Receive+0x334>
  *peCOMStatus = SFU_COM_YMODEM_OK;
 8009664:	462f      	mov	r7, r5
 8009666:	7005      	strb	r5, [r0, #0]
  uint32_t session_begin = 0U;
 8009668:	9501      	str	r5, [sp, #4]
  while ((session_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 800966a:	7826      	ldrb	r6, [r4, #0]
 800966c:	2e00      	cmp	r6, #0
 800966e:	f040 812e 	bne.w	80098ce <SFU_COM_YMODEM_Receive+0x286>
        break;
      default:
        status = HAL_ERROR;
        break;
    }
    *pData = char1;
 8009672:	f8df 9310 	ldr.w	r9, [pc, #784]	@ 8009984 <SFU_COM_YMODEM_Receive+0x33c>
 8009676:	e14e      	b.n	8009916 <SFU_COM_YMODEM_Receive+0x2ce>
    switch (char1)
 8009678:	2b61      	cmp	r3, #97	@ 0x61
 800967a:	d004      	beq.n	8009686 <SFU_COM_YMODEM_Receive+0x3e>
 800967c:	2b72      	cmp	r3, #114	@ 0x72
 800967e:	d019      	beq.n	80096b4 <SFU_COM_YMODEM_Receive+0x6c>
 8009680:	2b41      	cmp	r3, #65	@ 0x41
 8009682:	f040 816a 	bne.w	800995a <SFU_COM_YMODEM_Receive+0x312>
        status = HAL_BUSY;
 8009686:	f04f 0a02 	mov.w	sl, #2
  uint32_t packet_size = 0U;
 800968a:	f04f 0b00 	mov.w	fp, #0
 800968e:	e021      	b.n	80096d4 <SFU_COM_YMODEM_Receive+0x8c>
        if ((SFU_LL_UART_Receive(&char1, 1U, uTimeout) == SFU_SUCCESS) && (char1 == SFU_COM_YMODEM_CA))
 8009690:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 8009694:	2101      	movs	r1, #1
 8009696:	f10d 0013 	add.w	r0, sp, #19
 800969a:	f001 f8ad 	bl	800a7f8 <SFU_LL_UART_Receive>
 800969e:	4540      	cmp	r0, r8
 80096a0:	f040 815b 	bne.w	800995a <SFU_COM_YMODEM_Receive+0x312>
 80096a4:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80096a8:	2b18      	cmp	r3, #24
 80096aa:	f040 8156 	bne.w	800995a <SFU_COM_YMODEM_Receive+0x312>
          packet_size = 2U;
 80096ae:	f04f 0b02 	mov.w	fp, #2
 80096b2:	e00f      	b.n	80096d4 <SFU_COM_YMODEM_Receive+0x8c>
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);             /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 80096b4:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 80096b8:	2101      	movs	r1, #1
 80096ba:	f10d 0013 	add.w	r0, sp, #19
        packet_size = 3U;
 80096be:	f04f 0b03 	mov.w	fp, #3
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);             /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 80096c2:	f001 f899 	bl	800a7f8 <SFU_LL_UART_Receive>
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);
 80096c6:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 80096ca:	2101      	movs	r1, #1
 80096cc:	f10d 0013 	add.w	r0, sp, #19
 80096d0:	f001 f892 	bl	800a7f8 <SFU_LL_UART_Receive>
    *pData = char1;
 80096d4:	f89d 2013 	ldrb.w	r2, [sp, #19]

    if (packet_size >= SFU_COM_YMODEM_PACKET_SIZE)
 80096d8:	f1bb 0f7f 	cmp.w	fp, #127	@ 0x7f
    *pData = char1;
 80096dc:	f889 2000 	strb.w	r2, [r9]
    if (packet_size >= SFU_COM_YMODEM_PACKET_SIZE)
 80096e0:	d942      	bls.n	8009768 <SFU_COM_YMODEM_Receive+0x120>
    {

#ifndef MINICOM_YMODEM
      eRetStatus = SFU_LL_UART_Receive(&pData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX],
 80096e2:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 80096e6:	f10b 0104 	add.w	r1, fp, #4
 80096ea:	48a2      	ldr	r0, [pc, #648]	@ (8009974 <SFU_COM_YMODEM_Receive+0x32c>)
 80096ec:	f001 f884 	bl	800a7f8 <SFU_LL_UART_Receive>
        eRetStatus = SFU_SUCCESS;
      }
#endif /* MINICOM_YMODEM */

      /* Simple packet sanity check */
      if (eRetStatus == SFU_SUCCESS)
 80096f0:	4540      	cmp	r0, r8
 80096f2:	d140      	bne.n	8009776 <SFU_COM_YMODEM_Receive+0x12e>
      {
        status = HAL_OK;

        if (pData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX] != ((pData[SFU_COM_YMODEM_PACKET_CNUMBER_INDEX]) ^
 80096f4:	f899 2003 	ldrb.w	r2, [r9, #3]
 80096f8:	f899 1002 	ldrb.w	r1, [r9, #2]
 80096fc:	43d2      	mvns	r2, r2
 80096fe:	b2d2      	uxtb	r2, r2
 8009700:	4291      	cmp	r1, r2
 8009702:	d138      	bne.n	8009776 <SFU_COM_YMODEM_Receive+0x12e>
          status = HAL_ERROR;
        }
        else
        {
          /* Check packet CRC*/
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 8009704:	eb09 020b 	add.w	r2, r9, fp
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];

          /*Configure CRC with 16-bit polynomial*/
          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT) == SFU_SUCCESS)
 8009708:	2002      	movs	r0, #2
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 800970a:	7913      	ldrb	r3, [r2, #4]
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];
 800970c:	f892 a005 	ldrb.w	sl, [r2, #5]
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 8009710:	9303      	str	r3, [sp, #12]
          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT) == SFU_SUCCESS)
 8009712:	f000 ffed 	bl	800a6f0 <SFU_LL_CRC_Config>
 8009716:	4540      	cmp	r0, r8
 8009718:	d12d      	bne.n	8009776 <SFU_COM_YMODEM_Receive+0x12e>
          {
            if (SFU_LL_CRC_Calculate((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKET_DATA_INDEX], packet_size) != crc)
 800971a:	4659      	mov	r1, fp
 800971c:	4896      	ldr	r0, [pc, #600]	@ (8009978 <SFU_COM_YMODEM_Receive+0x330>)
 800971e:	f001 f827 	bl	800a770 <SFU_LL_CRC_Calculate>
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];
 8009722:	9b03      	ldr	r3, [sp, #12]
 8009724:	eb0a 2a03 	add.w	sl, sl, r3, lsl #8
            if (SFU_LL_CRC_Calculate((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKET_DATA_INDEX], packet_size) != crc)
 8009728:	4582      	cmp	sl, r0
 800972a:	d124      	bne.n	8009776 <SFU_COM_YMODEM_Receive+0x12e>
              if (m_aPacketData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX] != (packets_received & 0x000000FFU))
 800972c:	f899 1002 	ldrb.w	r1, [r9, #2]
 8009730:	b2f2      	uxtb	r2, r6
 8009732:	4291      	cmp	r1, r2
 8009734:	d134      	bne.n	80097a0 <SFU_COM_YMODEM_Receive+0x158>
                if (packets_received == 0U)
 8009736:	2e00      	cmp	r6, #0
 8009738:	f040 80d1 	bne.w	80098de <SFU_COM_YMODEM_Receive+0x296>
                  if (m_aPacketData[SFU_COM_YMODEM_PACKET_DATA_INDEX] != 0U)
 800973c:	f899 3004 	ldrb.w	r3, [r9, #4]
 8009740:	2b00      	cmp	r3, #0
 8009742:	f000 80c1 	beq.w	80098c8 <SFU_COM_YMODEM_Receive+0x280>
 8009746:	2341      	movs	r3, #65	@ 0x41
                    file_ptr = m_aPacketData + SFU_COM_YMODEM_PACKET_DATA_INDEX;
 8009748:	4a8b      	ldr	r2, [pc, #556]	@ (8009978 <SFU_COM_YMODEM_Receive+0x330>)
                    while ((*file_ptr != 0U) && (i < SFU_COM_YMODEM_FILE_NAME_LENGTH))
 800974a:	f812 1b01 	ldrb.w	r1, [r2], #1
 800974e:	b109      	cbz	r1, 8009754 <SFU_COM_YMODEM_Receive+0x10c>
 8009750:	3b01      	subs	r3, #1
 8009752:	d1fa      	bne.n	800974a <SFU_COM_YMODEM_Receive+0x102>
 8009754:	a905      	add	r1, sp, #20
                    file_ptr = m_aPacketData + SFU_COM_YMODEM_PACKET_DATA_INDEX;
 8009756:	2300      	movs	r3, #0
 8009758:	460f      	mov	r7, r1
 800975a:	e033      	b.n	80097c4 <SFU_COM_YMODEM_Receive+0x17c>
        packet_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800975c:	f44f 6b80 	mov.w	fp, #1024	@ 0x400
 8009760:	e7b8      	b.n	80096d4 <SFU_COM_YMODEM_Receive+0x8c>
    switch (char1)
 8009762:	f04f 0b80 	mov.w	fp, #128	@ 0x80
 8009766:	e7b5      	b.n	80096d4 <SFU_COM_YMODEM_Receive+0x8c>
      switch (ReceivePacket(m_aPacketData, &packet_length, SFU_COM_YMODEM_DOWNLOAD_TIMEOUT))
 8009768:	f1ba 0f00 	cmp.w	sl, #0
 800976c:	d012      	beq.n	8009794 <SFU_COM_YMODEM_Receive+0x14c>
 800976e:	f1ba 0f02 	cmp.w	sl, #2
 8009772:	f000 80c8 	beq.w	8009906 <SFU_COM_YMODEM_Receive+0x2be>
          if (session_begin > 0U)
 8009776:	9b01      	ldr	r3, [sp, #4]
 8009778:	b103      	cbz	r3, 800977c <SFU_COM_YMODEM_Receive+0x134>
            errors ++;
 800977a:	3701      	adds	r7, #1
          if (errors > SFU_COM_YMODEM_MAX_ERRORS)
 800977c:	2f03      	cmp	r7, #3
 800977e:	f240 80ef 	bls.w	8009960 <SFU_COM_YMODEM_Receive+0x318>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 8009782:	2018      	movs	r0, #24
 8009784:	f7ff ff53 	bl	800962e <SFU_COM_Serial_PutByte>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 8009788:	2018      	movs	r0, #24
 800978a:	f7ff ff50 	bl	800962e <SFU_COM_Serial_PutByte>
            *peCOMStatus = SFU_COM_YMODEM_ABORT;
 800978e:	2302      	movs	r3, #2
 8009790:	7023      	strb	r3, [r4, #0]
 8009792:	e0c0      	b.n	8009916 <SFU_COM_YMODEM_Receive+0x2ce>
          switch (packet_length)
 8009794:	f1bb 0f02 	cmp.w	fp, #2
 8009798:	d004      	beq.n	80097a4 <SFU_COM_YMODEM_Receive+0x15c>
 800979a:	f1bb 0f03 	cmp.w	fp, #3
 800979e:	d107      	bne.n	80097b0 <SFU_COM_YMODEM_Receive+0x168>
          errors = 0U;
 80097a0:	2700      	movs	r7, #0
 80097a2:	e0b8      	b.n	8009916 <SFU_COM_YMODEM_Receive+0x2ce>
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 80097a4:	2006      	movs	r0, #6
 80097a6:	f7ff ff42 	bl	800962e <SFU_COM_Serial_PutByte>
              *peCOMStatus = SFU_COM_YMODEM_ABORT;
 80097aa:	f884 b000 	strb.w	fp, [r4]
              break;
 80097ae:	e7f7      	b.n	80097a0 <SFU_COM_YMODEM_Receive+0x158>
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 80097b0:	2006      	movs	r0, #6
              *puSize = filesize;
 80097b2:	4657      	mov	r7, sl
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 80097b4:	f7ff ff3b 	bl	800962e <SFU_COM_Serial_PutByte>
              *puSize = filesize;
 80097b8:	9b02      	ldr	r3, [sp, #8]
 80097ba:	601d      	str	r5, [r3, #0]
  while ((session_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 80097bc:	e755      	b.n	800966a <SFU_COM_YMODEM_Receive+0x22>
                      i++;
 80097be:	3301      	adds	r3, #1
                      file_size[i] = *file_ptr;
 80097c0:	f807 0b01 	strb.w	r0, [r7], #1
                    while ((*file_ptr != (uint8_t) ' ') && (i < SFU_COM_YMODEM_FILE_SIZE_LENGTH))
 80097c4:	5cd0      	ldrb	r0, [r2, r3]
 80097c6:	2820      	cmp	r0, #32
 80097c8:	d001      	beq.n	80097ce <SFU_COM_YMODEM_Receive+0x186>
 80097ca:	2b10      	cmp	r3, #16
 80097cc:	d1f7      	bne.n	80097be <SFU_COM_YMODEM_Receive+0x176>
                    file_size[i] = (uint8_t) '\0';
 80097ce:	3328      	adds	r3, #40	@ 0x28
 80097d0:	eb0d 0203 	add.w	r2, sp, r3
 80097d4:	2300      	movs	r3, #0
 80097d6:	f802 3c14 	strb.w	r3, [r2, #-20]
  if ((pInputStr[0] == (uint8_t)'0') && ((pInputStr[1] == (uint8_t)'x') || (pInputStr[1] == (uint8_t)'X')))
 80097da:	f89d 2014 	ldrb.w	r2, [sp, #20]
 80097de:	2a30      	cmp	r2, #48	@ 0x30
 80097e0:	d105      	bne.n	80097ee <SFU_COM_YMODEM_Receive+0x1a6>
 80097e2:	f89d 2015 	ldrb.w	r2, [sp, #21]
 80097e6:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
 80097ea:	2a58      	cmp	r2, #88	@ 0x58
 80097ec:	d03f      	beq.n	800986e <SFU_COM_YMODEM_Receive+0x226>
 80097ee:	462f      	mov	r7, r5
 80097f0:	4618      	mov	r0, r3
        val = (val * 10U) + digit;
 80097f2:	250a      	movs	r5, #10
      if (pInputStr[i] == (uint8_t)'\0')
 80097f4:	f811 2b01 	ldrb.w	r2, [r1], #1
 80097f8:	b132      	cbz	r2, 8009808 <SFU_COM_YMODEM_Receive+0x1c0>
      else if (((pInputStr[i] == (uint8_t)'k') || (pInputStr[i] == (uint8_t)'K')) && (i > 0U))
 80097fa:	f002 0cdf 	and.w	ip, r2, #223	@ 0xdf
 80097fe:	f1bc 0f4b 	cmp.w	ip, #75	@ 0x4b
 8009802:	d137      	bne.n	8009874 <SFU_COM_YMODEM_Receive+0x22c>
 8009804:	b1f8      	cbz	r0, 8009846 <SFU_COM_YMODEM_Receive+0x1fe>
        val = val << 10U;
 8009806:	029b      	lsls	r3, r3, #10
        *pIntNum = val;
 8009808:	461f      	mov	r7, r3
        res = 1U;
 800980a:	2201      	movs	r2, #1
 800980c:	e040      	b.n	8009890 <SFU_COM_YMODEM_Receive+0x248>
        digit = CONVERTHEX(pInputStr[i]);
 800980e:	3a37      	subs	r2, #55	@ 0x37
 8009810:	b2d2      	uxtb	r2, r2
      i++;
 8009812:	3301      	adds	r3, #1
        val = (val << 4U) + digit;
 8009814:	eb02 1707 	add.w	r7, r2, r7, lsl #4
    while ((i < 11U) && (pInputStr[i] != (uint8_t)'\0'))
 8009818:	2b0b      	cmp	r3, #11
 800981a:	d00d      	beq.n	8009838 <SFU_COM_YMODEM_Receive+0x1f0>
 800981c:	5cca      	ldrb	r2, [r1, r3]
 800981e:	b15a      	cbz	r2, 8009838 <SFU_COM_YMODEM_Receive+0x1f0>
      if (ISVALIDHEX(pInputStr[i]))
 8009820:	f1a2 0041 	sub.w	r0, r2, #65	@ 0x41
 8009824:	2805      	cmp	r0, #5
 8009826:	d9f2      	bls.n	800980e <SFU_COM_YMODEM_Receive+0x1c6>
 8009828:	f1a2 0061 	sub.w	r0, r2, #97	@ 0x61
 800982c:	2805      	cmp	r0, #5
 800982e:	d91c      	bls.n	800986a <SFU_COM_YMODEM_Receive+0x222>
 8009830:	3a30      	subs	r2, #48	@ 0x30
 8009832:	b2d2      	uxtb	r2, r2
 8009834:	2a09      	cmp	r2, #9
 8009836:	d9ec      	bls.n	8009812 <SFU_COM_YMODEM_Receive+0x1ca>
    if (pInputStr[i] == (uint8_t)'\0')
 8009838:	3328      	adds	r3, #40	@ 0x28
 800983a:	446b      	add	r3, sp
 800983c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
 8009840:	2b00      	cmp	r3, #0
 8009842:	bf18      	it	ne
 8009844:	462f      	movne	r7, r5
                    if (SFU_COM_YMODEM_HeaderPktRxCpltCallback((uint32_t) filesize) == SFU_SUCCESS)
 8009846:	4638      	mov	r0, r7
 8009848:	f000 fda6 	bl	800a398 <SFU_COM_YMODEM_HeaderPktRxCpltCallback>
 800984c:	4540      	cmp	r0, r8
 800984e:	d125      	bne.n	800989c <SFU_COM_YMODEM_Receive+0x254>
                      (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 8009850:	2006      	movs	r0, #6
 8009852:	f7ff feec 	bl	800962e <SFU_COM_Serial_PutByte>
                      (void) SFU_LL_UART_Flush();
 8009856:	f000 ffe3 	bl	800a820 <SFU_LL_UART_Flush>
                      (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CRC16);
 800985a:	2043      	movs	r0, #67	@ 0x43
 800985c:	f7ff fee7 	bl	800962e <SFU_COM_Serial_PutByte>
                session_begin = 1;
 8009860:	2301      	movs	r3, #1
                packets_received ++;
 8009862:	3601      	adds	r6, #1
 8009864:	463d      	mov	r5, r7
                session_begin = 1;
 8009866:	9301      	str	r3, [sp, #4]
 8009868:	e79a      	b.n	80097a0 <SFU_COM_YMODEM_Receive+0x158>
        digit = CONVERTHEX(pInputStr[i]);
 800986a:	3a57      	subs	r2, #87	@ 0x57
 800986c:	e7d0      	b.n	8009810 <SFU_COM_YMODEM_Receive+0x1c8>
 800986e:	461f      	mov	r7, r3
 8009870:	2302      	movs	r3, #2
 8009872:	e7d3      	b.n	800981c <SFU_COM_YMODEM_Receive+0x1d4>
      else if (((pInputStr[i] == (uint8_t)'m') || (pInputStr[i] == (uint8_t)'M')) && (i > 0U))
 8009874:	f1bc 0f4d 	cmp.w	ip, #77	@ 0x4d
 8009878:	d103      	bne.n	8009882 <SFU_COM_YMODEM_Receive+0x23a>
 800987a:	2800      	cmp	r0, #0
 800987c:	d0e3      	beq.n	8009846 <SFU_COM_YMODEM_Receive+0x1fe>
        val = val << 20U;
 800987e:	051b      	lsls	r3, r3, #20
        res = 1U;
 8009880:	e7c2      	b.n	8009808 <SFU_COM_YMODEM_Receive+0x1c0>
      else if (ISVALIDDEC(pInputStr[i]))
 8009882:	3a30      	subs	r2, #48	@ 0x30
 8009884:	b2d2      	uxtb	r2, r2
 8009886:	2a09      	cmp	r2, #9
 8009888:	d8dd      	bhi.n	8009846 <SFU_COM_YMODEM_Receive+0x1fe>
        val = (val * 10U) + digit;
 800988a:	fb05 2303 	mla	r3, r5, r3, r2
 800988e:	2200      	movs	r2, #0
      i++;
 8009890:	3001      	adds	r0, #1
    while ((i < 11U) && (res != 1U))
 8009892:	280b      	cmp	r0, #11
 8009894:	d0d7      	beq.n	8009846 <SFU_COM_YMODEM_Receive+0x1fe>
 8009896:	2a00      	cmp	r2, #0
 8009898:	d0ac      	beq.n	80097f4 <SFU_COM_YMODEM_Receive+0x1ac>
 800989a:	e7d4      	b.n	8009846 <SFU_COM_YMODEM_Receive+0x1fe>
                      tmp = SFU_COM_YMODEM_CA;
 800989c:	2318      	movs	r3, #24
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 800989e:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 80098a2:	2101      	movs	r1, #1
 80098a4:	f10d 0013 	add.w	r0, sp, #19
                      tmp = SFU_COM_YMODEM_CA;
 80098a8:	f88d 3013 	strb.w	r3, [sp, #19]
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 80098ac:	f000 ff90 	bl	800a7d0 <SFU_LL_UART_Transmit>
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 80098b0:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 80098b4:	2101      	movs	r1, #1
 80098b6:	f10d 0013 	add.w	r0, sp, #19
 80098ba:	f000 ff89 	bl	800a7d0 <SFU_LL_UART_Transmit>
    return SFU_ERROR;
 80098be:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
}
 80098c2:	b00b      	add	sp, #44	@ 0x2c
 80098c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 80098c8:	2006      	movs	r0, #6
 80098ca:	f7ff feb0 	bl	800962e <SFU_COM_Serial_PutByte>
  (void) BSP_LED_Off(SFU_STATUS_LED);
 80098ce:	2000      	movs	r0, #0
 80098d0:	f001 fb78 	bl	800afc4 <BSP_LED_Off>
  if (*peCOMStatus == SFU_COM_YMODEM_OK)
 80098d4:	7823      	ldrb	r3, [r4, #0]
 80098d6:	2b00      	cmp	r3, #0
 80098d8:	d1f1      	bne.n	80098be <SFU_COM_YMODEM_Receive+0x276>
    return SFU_SUCCESS;
 80098da:	4828      	ldr	r0, [pc, #160]	@ (800997c <SFU_COM_YMODEM_Receive+0x334>)
 80098dc:	e7f1      	b.n	80098c2 <SFU_COM_YMODEM_Receive+0x27a>
                  if (SFU_COM_YMODEM_DataPktRxCpltCallback(&m_aPacketData[SFU_COM_YMODEM_PACKET_DATA_INDEX],
 80098de:	4659      	mov	r1, fp
 80098e0:	4825      	ldr	r0, [pc, #148]	@ (8009978 <SFU_COM_YMODEM_Receive+0x330>)
 80098e2:	f000 fd6d 	bl	800a3c0 <SFU_COM_YMODEM_DataPktRxCpltCallback>
 80098e6:	4540      	cmp	r0, r8
 80098e8:	d104      	bne.n	80098f4 <SFU_COM_YMODEM_Receive+0x2ac>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 80098ea:	2006      	movs	r0, #6
 80098ec:	f7ff fe9f 	bl	800962e <SFU_COM_Serial_PutByte>
    if (pInputStr[i] == (uint8_t)'\0')
 80098f0:	462f      	mov	r7, r5
 80098f2:	e7b5      	b.n	8009860 <SFU_COM_YMODEM_Receive+0x218>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 80098f4:	2018      	movs	r0, #24
 80098f6:	f7ff fe9a 	bl	800962e <SFU_COM_Serial_PutByte>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 80098fa:	2018      	movs	r0, #24
 80098fc:	f7ff fe97 	bl	800962e <SFU_COM_Serial_PutByte>
                    *peCOMStatus = SFU_COM_YMODEM_DATA;
 8009900:	2304      	movs	r3, #4
 8009902:	7023      	strb	r3, [r4, #0]
 8009904:	e7f4      	b.n	80098f0 <SFU_COM_YMODEM_Receive+0x2a8>
          (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 8009906:	2018      	movs	r0, #24
 8009908:	f7ff fe91 	bl	800962e <SFU_COM_Serial_PutByte>
          (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800990c:	2018      	movs	r0, #24
 800990e:	f7ff fe8e 	bl	800962e <SFU_COM_Serial_PutByte>
          *peCOMStatus = SFU_COM_YMODEM_ABORT;
 8009912:	f884 a000 	strb.w	sl, [r4]
    while ((file_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 8009916:	f894 a000 	ldrb.w	sl, [r4]
 800991a:	f1ba 0f00 	cmp.w	sl, #0
 800991e:	f47f aea4 	bne.w	800966a <SFU_COM_YMODEM_Receive+0x22>
  (void) SFU_LL_SECU_IWDG_Refresh();
 8009922:	f001 faef 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
  eRetStatus = SFU_LL_UART_Receive(&char1, 1, uTimeout);
 8009926:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 800992a:	2101      	movs	r1, #1
 800992c:	f10d 0013 	add.w	r0, sp, #19
 8009930:	f000 ff62 	bl	800a7f8 <SFU_LL_UART_Receive>
  if (eRetStatus == SFU_SUCCESS)
 8009934:	4540      	cmp	r0, r8
 8009936:	f47f af1e 	bne.w	8009776 <SFU_COM_YMODEM_Receive+0x12e>
    switch (char1)
 800993a:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800993e:	2b18      	cmp	r3, #24
 8009940:	f43f aea6 	beq.w	8009690 <SFU_COM_YMODEM_Receive+0x48>
 8009944:	f63f ae98 	bhi.w	8009678 <SFU_COM_YMODEM_Receive+0x30>
 8009948:	2b02      	cmp	r3, #2
 800994a:	f43f af07 	beq.w	800975c <SFU_COM_YMODEM_Receive+0x114>
 800994e:	2b04      	cmp	r3, #4
 8009950:	f43f ae9b 	beq.w	800968a <SFU_COM_YMODEM_Receive+0x42>
 8009954:	2b01      	cmp	r3, #1
 8009956:	f43f af04 	beq.w	8009762 <SFU_COM_YMODEM_Receive+0x11a>
          status = HAL_ERROR;
 800995a:	f04f 0a01 	mov.w	sl, #1
 800995e:	e694      	b.n	800968a <SFU_COM_YMODEM_Receive+0x42>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CRC16); /* Ask for a packet */
 8009960:	2043      	movs	r0, #67	@ 0x43
 8009962:	f7ff fe64 	bl	800962e <SFU_COM_Serial_PutByte>
            TRACE("\b.");                                 /* Replace C char by . on display console */
 8009966:	4806      	ldr	r0, [pc, #24]	@ (8009980 <SFU_COM_YMODEM_Receive+0x338>)
 8009968:	f003 fd76 	bl	800d458 <iprintf>
            (void) BSP_LED_Toggle(SFU_STATUS_LED);
 800996c:	2000      	movs	r0, #0
 800996e:	f001 fb37 	bl	800afe0 <BSP_LED_Toggle>
 8009972:	e7d0      	b.n	8009916 <SFU_COM_YMODEM_Receive+0x2ce>
 8009974:	200011ba 	.word	0x200011ba
 8009978:	200011bc 	.word	0x200011bc
 800997c:	00122f11 	.word	0x00122f11
 8009980:	0800eb60 	.word	0x0800eb60
 8009984:	200011b8 	.word	0x200011b8

08009988 <SFU_COM_Init>:
  * @brief  SFU Com Init function.
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_Init(void)
{
 8009988:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
 800998a:	4b06      	ldr	r3, [pc, #24]	@ (80099a4 <SFU_COM_Init+0x1c>)
 800998c:	2202      	movs	r2, #2
 800998e:	6818      	ldr	r0, [r3, #0]
 8009990:	2300      	movs	r3, #0
 8009992:	6880      	ldr	r0, [r0, #8]
 8009994:	4619      	mov	r1, r3
 8009996:	f003 fdcf 	bl	800d538 <setvbuf>
#endif /* __GNUC__ */
  return SFU_LL_UART_Init();
}
 800999a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return SFU_LL_UART_Init();
 800999e:	f000 beef 	b.w	800a780 <SFU_LL_UART_Init>
 80099a2:	bf00      	nop
 80099a4:	20001138 	.word	0x20001138

080099a8 <SFU_COM_DeInit>:
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_DeInit(void)
{
  return SFU_LL_UART_DeInit();
 80099a8:	f000 bf0e 	b.w	800a7c8 <SFU_LL_UART_DeInit>

080099ac <SFU_COM_Serial_PutString>:
SFU_ErrorStatus SFU_COM_Serial_PutString(uint8_t *pString)
{
  uint16_t length = 0U;

  /* Check the pointers allocation */
  if (pString == NULL)
 80099ac:	b150      	cbz	r0, 80099c4 <SFU_COM_Serial_PutString+0x18>
 80099ae:	2300      	movs	r3, #0
  {
    return SFU_ERROR;
  }

  while (pString[length] != (uint8_t)'\0')
 80099b0:	b29a      	uxth	r2, r3
 80099b2:	4619      	mov	r1, r3
 80099b4:	3301      	adds	r3, #1
 80099b6:	5c82      	ldrb	r2, [r0, r2]
 80099b8:	2a00      	cmp	r2, #0
 80099ba:	d1f9      	bne.n	80099b0 <SFU_COM_Serial_PutString+0x4>
  {
    length++;
  }

  return SFU_LL_UART_Transmit(pString, length, SFU_COM_TRACE_SERIAL_TIME_OUT);
 80099bc:	2264      	movs	r2, #100	@ 0x64
 80099be:	b289      	uxth	r1, r1
 80099c0:	f000 bf06 	b.w	800a7d0 <SFU_LL_UART_Transmit>

}
 80099c4:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 80099c8:	4770      	bx	lr

080099ca <__io_putchar>:
  * @brief  Retargets the C library printf function to SFU UART.
  * @param  None
  * @retval ch
  */
PUTCHAR_PROTOTYPE
{
 80099ca:	b507      	push	{r0, r1, r2, lr}
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART1 and Loop until the end of transmission */
  (void) SFU_LL_UART_Transmit((uint8_t *)&ch, 1U, 0xFFFFU);
 80099cc:	f64f 72ff 	movw	r2, #65535	@ 0xffff
{
 80099d0:	9001      	str	r0, [sp, #4]
  (void) SFU_LL_UART_Transmit((uint8_t *)&ch, 1U, 0xFFFFU);
 80099d2:	2101      	movs	r1, #1
 80099d4:	a801      	add	r0, sp, #4
 80099d6:	f000 fefb 	bl	800a7d0 <SFU_LL_UART_Transmit>

  return ch;
}
 80099da:	9801      	ldr	r0, [sp, #4]
 80099dc:	b003      	add	sp, #12
 80099de:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080099e4 <SFU_EXCPT_SetError>:
  * @param  Error Error code.
  * @retval None
  */
void SFU_EXCPT_SetError(SFU_EXCPT_IdTypeDef eExceptionId)
{
  if (eExceptionId <= SFU_EXCPT_UNKNOWN)
 80099e4:	2810      	cmp	r0, #16
 80099e6:	d805      	bhi.n	80099f4 <SFU_EXCPT_SetError+0x10>
  {
#ifdef SFU_DEBUG_MODE
    TRACE("\r\n\t%s",m_aErrorStrings[(uint32_t) eExceptionId]);
 80099e8:	4b03      	ldr	r3, [pc, #12]	@ (80099f8 <SFU_EXCPT_SetError+0x14>)
 80099ea:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80099ee:	4803      	ldr	r0, [pc, #12]	@ (80099fc <SFU_EXCPT_SetError+0x18>)
 80099f0:	f003 bd32 	b.w	800d458 <iprintf>
#endif /* SFU_DEBUG_MODE */
  }
}
 80099f4:	4770      	bx	lr
 80099f6:	bf00      	nop
 80099f8:	0800e3e0 	.word	0x0800e3e0
 80099fc:	0800eb63 	.word	0x0800eb63

08009a00 <SFU_EXCPT_IrqExceptionHandler>:
  *         it's not possible to continue without compromising the stability or
  *         the security of the solution. A System Reset is forced at the end.
  * @retval None
  */
void SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_IdTypeDef eExceptionId)
{
 8009a00:	b510      	push	{r4, lr}
 8009a02:	b0a6      	sub	sp, #152	@ 0x98
#ifdef SFU_DEBUG_MODE
  uint8_t message[150];
  uint32_t i = 0U;

  /* Avoid warning with cast frombetween char* and uint8_t* */
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 8009a04:	4b0e      	ldr	r3, [pc, #56]	@ (8009a40 <SFU_EXCPT_IrqExceptionHandler+0x40>)
 8009a06:	466a      	mov	r2, sp
 8009a08:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
  uint32_t i = 0U;
 8009a0c:	2300      	movs	r3, #0
 8009a0e:	4614      	mov	r4, r2
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 8009a10:	5cc1      	ldrb	r1, [r0, r3]
 8009a12:	b109      	cbz	r1, 8009a18 <SFU_EXCPT_IrqExceptionHandler+0x18>
 8009a14:	2b95      	cmp	r3, #149	@ 0x95
 8009a16:	d10e      	bne.n	8009a36 <SFU_EXCPT_IrqExceptionHandler+0x36>
  {
    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
    i++;
  }
  message[i] = 0U;
 8009a18:	3398      	adds	r3, #152	@ 0x98
 8009a1a:	2200      	movs	r2, #0

  /* Print relevant error message */
  TRACE_IRQ((uint8_t *)"\r\n\t  ");
 8009a1c:	4809      	ldr	r0, [pc, #36]	@ (8009a44 <SFU_EXCPT_IrqExceptionHandler+0x44>)
  message[i] = 0U;
 8009a1e:	446b      	add	r3, sp
 8009a20:	f803 2c98 	strb.w	r2, [r3, #-152]
  TRACE_IRQ((uint8_t *)"\r\n\t  ");
 8009a24:	f7ff ffc2 	bl	80099ac <SFU_COM_Serial_PutString>
  TRACE_IRQ(message);
 8009a28:	4620      	mov	r0, r4
 8009a2a:	f7ff ffbf 	bl	80099ac <SFU_COM_Serial_PutString>
  /* Try to take an action */
  SFU_EXCPT_RuntimeExceptionHandler(eExceptionId);

  /* It's not possible to continue without compromising the stability or the security of the solution.
  The State Machine needs to be aborted and a Reset must be triggered */
  SFU_BOOT_ForceReboot();
 8009a2e:	f7ff fcb1 	bl	8009394 <SFU_BOOT_ForceReboot>
}
 8009a32:	b026      	add	sp, #152	@ 0x98
 8009a34:	bd10      	pop	{r4, pc}
    i++;
 8009a36:	3301      	adds	r3, #1
    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
 8009a38:	f802 1b01 	strb.w	r1, [r2], #1
    i++;
 8009a3c:	e7e8      	b.n	8009a10 <SFU_EXCPT_IrqExceptionHandler+0x10>
 8009a3e:	bf00      	nop
 8009a40:	0800e3e0 	.word	0x0800e3e0
 8009a44:	0800eb69 	.word	0x0800eb69

08009a48 <SFU_EXCPT_Security_Error>:
  *         This parameter can be a value of @ref SFU_EXCPT_ID_Structure_definition.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */

void SFU_EXCPT_Security_Error(void)
{
 8009a48:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] Security issue : execution stopped !");
 8009a4a:	480e      	ldr	r0, [pc, #56]	@ (8009a84 <SFU_EXCPT_Security_Error+0x3c>)
 8009a4c:	f003 fd04 	bl	800d458 <iprintf>
  HAL_Delay(1000);
 8009a50:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8009a54:	f001 fbf4 	bl	800b240 <HAL_Delay>
  /* While(1) by-passed by an fault injection attack ==> Reset */
  if (0U != SFU_MPU_IsUnprivileged())
 8009a58:	f000 fe12 	bl	800a680 <SFU_MPU_IsUnprivileged>
 8009a5c:	b120      	cbz	r0, 8009a68 <SFU_EXCPT_Security_Error+0x20>
  {
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 8009a5e:	2002      	movs	r0, #2
  }
  else
  {
    NVIC_SystemReset();
  }
}
 8009a60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 8009a64:	f000 be08 	b.w	800a678 <SFU_MPU_SysCall>
 8009a68:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009a6c:	4906      	ldr	r1, [pc, #24]	@ (8009a88 <SFU_EXCPT_Security_Error+0x40>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009a6e:	4b07      	ldr	r3, [pc, #28]	@ (8009a8c <SFU_EXCPT_Security_Error+0x44>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009a70:	68ca      	ldr	r2, [r1, #12]
 8009a72:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009a76:	4313      	orrs	r3, r2
 8009a78:	60cb      	str	r3, [r1, #12]
 8009a7a:	f3bf 8f4f 	dsb	sy
    __NOP();
 8009a7e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8009a80:	e7fd      	b.n	8009a7e <SFU_EXCPT_Security_Error+0x36>
 8009a82:	bf00      	nop
 8009a84:	0800eb6f 	.word	0x0800eb6f
 8009a88:	e000ed00 	.word	0xe000ed00
 8009a8c:	05fa0004 	.word	0x05fa0004

08009a90 <SFU_EXCPT_Init>:
       ...
  */
  e_ret_status = SFU_SUCCESS;

  return e_ret_status;
}
 8009a90:	4800      	ldr	r0, [pc, #0]	@ (8009a94 <SFU_EXCPT_Init+0x4>)
 8009a92:	4770      	bx	lr
 8009a94:	00122f11 	.word	0x00122f11

08009a98 <SFU_EXCPT_DeInit>:
/**
  * @brief  SFU Exception DeInitialization.
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_EXCPT_DeInit(void)
 8009a98:	4800      	ldr	r0, [pc, #0]	@ (8009a9c <SFU_EXCPT_DeInit+0x4>)
 8009a9a:	4770      	bx	lr
 8009a9c:	00122f11 	.word	0x00122f11

08009aa0 <MemoryCompare>:
  * @retval SFU_ SUCCESS if equal, a SFU_error otherwise.
  */
SFU_ErrorStatus MemoryCompare(uint8_t *pAdd1, uint8_t *pAdd2, uint32_t Size)
{
  /* Use of __IO to force recheck of these variables values */
  uint8_t __IO result = 0x00U;
 8009aa0:	2300      	movs	r3, #0
{
 8009aa2:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t __IO result = 0x00U;
 8009aa4:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t __IO i;
  uint32_t tmp;

  for (i = 0U; i < Size; i++)
 8009aa8:	9301      	str	r3, [sp, #4]
 8009aaa:	9b01      	ldr	r3, [sp, #4]
 8009aac:	4293      	cmp	r3, r2
 8009aae:	d311      	bcc.n	8009ad4 <MemoryCompare+0x34>
    tmp = pAdd1[i];
    tmp ^= pAdd2[i];
    result |= tmp;
  }

  if ((result == 0x00U) && (i == Size)) /* Add check that loop exited normally without any fault injection */
 8009ab0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009ab4:	b9db      	cbnz	r3, 8009aee <MemoryCompare+0x4e>
 8009ab6:	9b01      	ldr	r3, [sp, #4]
 8009ab8:	4293      	cmp	r3, r2
 8009aba:	d118      	bne.n	8009aee <MemoryCompare+0x4e>
  {
    return (((result != 0x00U) || (i != Size))? SFU_ERROR : SFU_SUCCESS);
 8009abc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009ac0:	b9ab      	cbnz	r3, 8009aee <MemoryCompare+0x4e>
 8009ac2:	9901      	ldr	r1, [sp, #4]
 8009ac4:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 8009ac8:	4b0a      	ldr	r3, [pc, #40]	@ (8009af4 <MemoryCompare+0x54>)
 8009aca:	4291      	cmp	r1, r2
 8009acc:	bf08      	it	eq
 8009ace:	4618      	moveq	r0, r3
  }
  else
  {
    return SFU_ERROR;
  }
}
 8009ad0:	b003      	add	sp, #12
 8009ad2:	bd30      	pop	{r4, r5, pc}
    tmp = pAdd1[i];
 8009ad4:	9c01      	ldr	r4, [sp, #4]
    tmp ^= pAdd2[i];
 8009ad6:	9d01      	ldr	r5, [sp, #4]
    result |= tmp;
 8009ad8:	5d04      	ldrb	r4, [r0, r4]
 8009ada:	5d4d      	ldrb	r5, [r1, r5]
 8009adc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009ae0:	406c      	eors	r4, r5
 8009ae2:	4323      	orrs	r3, r4
 8009ae4:	f88d 3003 	strb.w	r3, [sp, #3]
  for (i = 0U; i < Size; i++)
 8009ae8:	9b01      	ldr	r3, [sp, #4]
 8009aea:	3301      	adds	r3, #1
 8009aec:	e7dc      	b.n	8009aa8 <MemoryCompare+0x8>
    return (((result != 0x00U) || (i != Size))? SFU_ERROR : SFU_SUCCESS);
 8009aee:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 8009af2:	e7ed      	b.n	8009ad0 <MemoryCompare+0x30>
 8009af4:	00122f11 	.word	0x00122f11

08009af8 <VerifyFwSignatureScatter>:
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SFU_ErrorStatus VerifyFwSignatureScatter(SE_StatusTypeDef *pSeStatus, uint32_t SlotNumber,
                                         SE_FwRawHeaderTypeDef *pSE_Metadata,
                                         SE_Ex_PayloadDescTypeDef  *pSE_Payload, uint32_t SE_FwType)
{
 8009af8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009afc:	f6ad 0d4c 	subw	sp, sp, #2124	@ 0x84c
 8009b00:	461c      	mov	r4, r3
  /* Variables to handle FW image size and tag */
  uint32_t fw_size;
  uint8_t *fw_tag;

  /* Check the pointers allocation */
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 8009b02:	4605      	mov	r5, r0
{
 8009b04:	9107      	str	r1, [sp, #28]
 8009b06:	4611      	mov	r1, r2
 8009b08:	f8dd 2870 	ldr.w	r2, [sp, #2160]	@ 0x870
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 8009b0c:	b930      	cbnz	r0, 8009b1c <VerifyFwSignatureScatter+0x24>
  {
    return SFU_ERROR;
 8009b0e:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
  else
  {
    sfu_ret_status = SFU_ERROR;
  }
  return sfu_ret_status;
}
 8009b12:	4638      	mov	r0, r7
 8009b14:	f60d 0d4c 	addw	sp, sp, #2124	@ 0x84c
 8009b18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 8009b1c:	2900      	cmp	r1, #0
 8009b1e:	d0f6      	beq.n	8009b0e <VerifyFwSignatureScatter+0x16>
 8009b20:	2b00      	cmp	r3, #0
 8009b22:	d0f4      	beq.n	8009b0e <VerifyFwSignatureScatter+0x16>
  if ((pSE_Payload->pPayload[0] == 0U) || ((pSE_Payload->pPayload[1] == 0U) && (pSE_Payload->PayloadSize[1] != 0U)))
 8009b24:	681b      	ldr	r3, [r3, #0]
 8009b26:	2b00      	cmp	r3, #0
 8009b28:	d0f1      	beq.n	8009b0e <VerifyFwSignatureScatter+0x16>
 8009b2a:	6863      	ldr	r3, [r4, #4]
 8009b2c:	b913      	cbnz	r3, 8009b34 <VerifyFwSignatureScatter+0x3c>
 8009b2e:	68e3      	ldr	r3, [r4, #12]
 8009b30:	2b00      	cmp	r3, #0
 8009b32:	d1ec      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
  if (SE_FwType == SE_FW_IMAGE_COMPLETE)
 8009b34:	2a00      	cmp	r2, #0
 8009b36:	f040 8096 	bne.w	8009c66 <VerifyFwSignatureScatter+0x16e>
    fw_size = pSE_Metadata->FwSize;
 8009b3a:	688b      	ldr	r3, [r1, #8]
 8009b3c:	9302      	str	r3, [sp, #8]
    fw_tag = pSE_Metadata->FwTag;
 8009b3e:	f101 0314 	add.w	r3, r1, #20
    fw_tag = pSE_Metadata->PartialFwTag;
 8009b42:	9303      	str	r3, [sp, #12]
  if ((pSE_Payload->PayloadSize[0] + pSE_Payload->PayloadSize[1]) != fw_size)
 8009b44:	9e02      	ldr	r6, [sp, #8]
 8009b46:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 8009b4a:	4403      	add	r3, r0
 8009b4c:	42b3      	cmp	r3, r6
 8009b4e:	d1de      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
    scatter_nb = 2U;
 8009b50:	2800      	cmp	r0, #0
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b52:	f8df b1bc 	ldr.w	fp, [pc, #444]	@ 8009d10 <VerifyFwSignatureScatter+0x218>
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 8009b56:	4628      	mov	r0, r5
    scatter_nb = 2U;
 8009b58:	bf0c      	ite	eq
 8009b5a:	2601      	moveq	r6, #1
 8009b5c:	2602      	movne	r6, #2
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 8009b5e:	f7fe fc9d 	bl	800849c <SE_AuthenticateFW_Init>
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b62:	4558      	cmp	r0, fp
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 8009b64:	4603      	mov	r3, r0
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b66:	d1d2      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
 8009b68:	6829      	ldr	r1, [r5, #0]
 8009b6a:	4a62      	ldr	r2, [pc, #392]	@ (8009cf4 <VerifyFwSignatureScatter+0x1fc>)
 8009b6c:	4291      	cmp	r1, r2
 8009b6e:	d1ce      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
 8009b70:	eb04 0286 	add.w	r2, r4, r6, lsl #2
  uint32_t fw_verified_total_size = 0; /* number of bytes that have been processed during authentication check */
 8009b74:	f04f 0800 	mov.w	r8, #0
  SFU_ErrorStatus sfu_ret_status = SFU_SUCCESS;
 8009b78:	4e5f      	ldr	r6, [pc, #380]	@ (8009cf8 <VerifyFwSignatureScatter+0x200>)
      fw_chunk_size = CHUNK_SIZE_SIGN_VERIFICATION;
 8009b7a:	af09      	add	r7, sp, #36	@ 0x24
 8009b7c:	9206      	str	r2, [sp, #24]
      payloadsize = pSE_Payload->PayloadSize[j];
 8009b7e:	68a2      	ldr	r2, [r4, #8]
      i = 0;
 8009b80:	f04f 0a00 	mov.w	sl, #0
      ppayload = pSE_Payload->pPayload[j];
 8009b84:	f854 9b04 	ldr.w	r9, [r4], #4
      payloadsize = pSE_Payload->PayloadSize[j];
 8009b88:	9204      	str	r2, [sp, #16]
      fw_chunk_size = CHUNK_SIZE_SIGN_VERIFICATION;
 8009b8a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8009b8e:	603a      	str	r2, [r7, #0]
      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERIFICATION)) && (*pSeStatus == SE_OK) &&
 8009b90:	9a04      	ldr	r2, [sp, #16]
 8009b92:	0a92      	lsrs	r2, r2, #10
 8009b94:	9205      	str	r2, [sp, #20]
 8009b96:	9a05      	ldr	r2, [sp, #20]
 8009b98:	4552      	cmp	r2, sl
 8009b9a:	d006      	beq.n	8009baa <VerifyFwSignatureScatter+0xb2>
 8009b9c:	682a      	ldr	r2, [r5, #0]
 8009b9e:	4955      	ldr	r1, [pc, #340]	@ (8009cf4 <VerifyFwSignatureScatter+0x1fc>)
 8009ba0:	428a      	cmp	r2, r1
 8009ba2:	d102      	bne.n	8009baa <VerifyFwSignatureScatter+0xb2>
 8009ba4:	4a54      	ldr	r2, [pc, #336]	@ (8009cf8 <VerifyFwSignatureScatter+0x200>)
 8009ba6:	4296      	cmp	r6, r2
 8009ba8:	d065      	beq.n	8009c76 <VerifyFwSignatureScatter+0x17e>
      fw_chunk_size = pSE_Payload->pPayload[j] + pSE_Payload->PayloadSize[j] - ppayload;
 8009baa:	f854 2c04 	ldr.w	r2, [r4, #-4]
 8009bae:	6861      	ldr	r1, [r4, #4]
 8009bb0:	440a      	add	r2, r1
 8009bb2:	eba2 0209 	sub.w	r2, r2, r9
 8009bb6:	603a      	str	r2, [r7, #0]
      if ((fw_chunk_size != 0U) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009bb8:	b1da      	cbz	r2, 8009bf2 <VerifyFwSignatureScatter+0xfa>
 8009bba:	455b      	cmp	r3, fp
 8009bbc:	d119      	bne.n	8009bf2 <VerifyFwSignatureScatter+0xfa>
 8009bbe:	6828      	ldr	r0, [r5, #0]
 8009bc0:	494c      	ldr	r1, [pc, #304]	@ (8009cf4 <VerifyFwSignatureScatter+0x1fc>)
 8009bc2:	4288      	cmp	r0, r1
 8009bc4:	d115      	bne.n	8009bf2 <VerifyFwSignatureScatter+0xfa>
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009bc6:	4649      	mov	r1, r9
 8009bc8:	f50d 6089 	add.w	r0, sp, #1096	@ 0x448
 8009bcc:	f000 fed6 	bl	800a97c <SFU_LL_FLASH_Read>
        if (sfu_ret_status == SFU_SUCCESS)
 8009bd0:	4b49      	ldr	r3, [pc, #292]	@ (8009cf8 <VerifyFwSignatureScatter+0x200>)
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009bd2:	4606      	mov	r6, r0
        if (sfu_ret_status == SFU_SUCCESS)
 8009bd4:	4298      	cmp	r0, r3
 8009bd6:	d16d      	bne.n	8009cb4 <VerifyFwSignatureScatter+0x1bc>
          se_ret_status = SE_AuthenticateFW_Append(pSeStatus, fw_image_chunk,
 8009bd8:	9a04      	ldr	r2, [sp, #16]
 8009bda:	ab12      	add	r3, sp, #72	@ 0x48
 8009bdc:	f50d 6189 	add.w	r1, sp, #1096	@ 0x448
 8009be0:	4628      	mov	r0, r5
 8009be2:	eba2 228a 	sub.w	r2, r2, sl, lsl #10
 8009be6:	9700      	str	r7, [sp, #0]
 8009be8:	f7fe fc8e 	bl	8008508 <SE_AuthenticateFW_Append>
 8009bec:	4603      	mov	r3, r0
        fw_verified_total_size += fw_chunk_size;
 8009bee:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8009bf0:	4490      	add	r8, r2
    for (j = 0; j < scatter_nb; j++)
 8009bf2:	9a06      	ldr	r2, [sp, #24]
 8009bf4:	4294      	cmp	r4, r2
 8009bf6:	d1c2      	bne.n	8009b7e <VerifyFwSignatureScatter+0x86>
  if ((sfu_ret_status == SFU_SUCCESS) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009bf8:	4a3f      	ldr	r2, [pc, #252]	@ (8009cf8 <VerifyFwSignatureScatter+0x200>)
 8009bfa:	4296      	cmp	r6, r2
 8009bfc:	d187      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
 8009bfe:	455b      	cmp	r3, fp
 8009c00:	d185      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
 8009c02:	682c      	ldr	r4, [r5, #0]
 8009c04:	4a3b      	ldr	r2, [pc, #236]	@ (8009cf4 <VerifyFwSignatureScatter+0x1fc>)
 8009c06:	4294      	cmp	r4, r2
 8009c08:	d181      	bne.n	8009b0e <VerifyFwSignatureScatter+0x16>
    if (fw_verified_total_size <= fw_size)
 8009c0a:	9a02      	ldr	r2, [sp, #8]
 8009c0c:	4590      	cmp	r8, r2
 8009c0e:	f63f af7e 	bhi.w	8009b0e <VerifyFwSignatureScatter+0x16>
      fw_tag_len = sizeof(fw_tag_output);
 8009c12:	2220      	movs	r2, #32
      se_ret_status =   SE_AuthenticateFW_Finish(pSeStatus, fw_tag_output, (int32_t *)&fw_tag_len);
 8009c14:	a90a      	add	r1, sp, #40	@ 0x28
 8009c16:	4628      	mov	r0, r5
 8009c18:	9302      	str	r3, [sp, #8]
      fw_tag_len = sizeof(fw_tag_output);
 8009c1a:	9208      	str	r2, [sp, #32]
      se_ret_status =   SE_AuthenticateFW_Finish(pSeStatus, fw_tag_output, (int32_t *)&fw_tag_len);
 8009c1c:	446a      	add	r2, sp
 8009c1e:	f7fe fcb1 	bl	8008584 <SE_AuthenticateFW_Finish>
      if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK) && (fw_tag_len == SE_TAG_LEN))
 8009c22:	9b02      	ldr	r3, [sp, #8]
 8009c24:	4298      	cmp	r0, r3
 8009c26:	f47f af72 	bne.w	8009b0e <VerifyFwSignatureScatter+0x16>
 8009c2a:	682b      	ldr	r3, [r5, #0]
 8009c2c:	42a3      	cmp	r3, r4
 8009c2e:	f47f af6e 	bne.w	8009b0e <VerifyFwSignatureScatter+0x16>
 8009c32:	9a08      	ldr	r2, [sp, #32]
 8009c34:	2a20      	cmp	r2, #32
 8009c36:	f47f af6a 	bne.w	8009b0e <VerifyFwSignatureScatter+0x16>
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 8009c3a:	9903      	ldr	r1, [sp, #12]
 8009c3c:	a80a      	add	r0, sp, #40	@ 0x28
 8009c3e:	f7ff ff2f 	bl	8009aa0 <MemoryCompare>
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c42:	9b07      	ldr	r3, [sp, #28]
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 8009c44:	42b0      	cmp	r0, r6
 8009c46:	4607      	mov	r7, r0
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c48:	f103 34ff 	add.w	r4, r3, #4294967295
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 8009c4c:	d038      	beq.n	8009cc0 <VerifyFwSignatureScatter+0x1c8>
          *pSeStatus = SE_SIGNATURE_ERR;
 8009c4e:	4b2b      	ldr	r3, [pc, #172]	@ (8009cfc <VerifyFwSignatureScatter+0x204>)
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c50:	2c02      	cmp	r4, #2
          *pSeStatus = SE_SIGNATURE_ERR;
 8009c52:	602b      	str	r3, [r5, #0]
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c54:	f63f af5b 	bhi.w	8009b0e <VerifyFwSignatureScatter+0x16>
            (void) memset(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], 0x00, SE_TAG_LEN);
 8009c58:	4829      	ldr	r0, [pc, #164]	@ (8009d00 <VerifyFwSignatureScatter+0x208>)
 8009c5a:	2100      	movs	r1, #0
 8009c5c:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 8009c60:	f003 fe06 	bl	800d870 <memset>
 8009c64:	e753      	b.n	8009b0e <VerifyFwSignatureScatter+0x16>
  else if (SE_FwType == SE_FW_IMAGE_PARTIAL)
 8009c66:	2a01      	cmp	r2, #1
 8009c68:	f47f af51 	bne.w	8009b0e <VerifyFwSignatureScatter+0x16>
    fw_size = pSE_Metadata->PartialFwSize;
 8009c6c:	690b      	ldr	r3, [r1, #16]
 8009c6e:	9302      	str	r3, [sp, #8]
    fw_tag = pSE_Metadata->PartialFwTag;
 8009c70:	f101 0334 	add.w	r3, r1, #52	@ 0x34
 8009c74:	e765      	b.n	8009b42 <VerifyFwSignatureScatter+0x4a>
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009c76:	683a      	ldr	r2, [r7, #0]
 8009c78:	4649      	mov	r1, r9
 8009c7a:	f50d 6089 	add.w	r0, sp, #1096	@ 0x448
 8009c7e:	f000 fe7d 	bl	800a97c <SFU_LL_FLASH_Read>
        if (sfu_ret_status == SFU_SUCCESS)
 8009c82:	4b1d      	ldr	r3, [pc, #116]	@ (8009cf8 <VerifyFwSignatureScatter+0x200>)
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009c84:	4606      	mov	r6, r0
        if (sfu_ret_status == SFU_SUCCESS)
 8009c86:	4298      	cmp	r0, r3
 8009c88:	d10e      	bne.n	8009ca8 <VerifyFwSignatureScatter+0x1b0>
          se_ret_status = SE_AuthenticateFW_Append(pSeStatus, fw_image_chunk, (int32_t)fw_chunk_size,
 8009c8a:	9700      	str	r7, [sp, #0]
 8009c8c:	ab12      	add	r3, sp, #72	@ 0x48
 8009c8e:	683a      	ldr	r2, [r7, #0]
 8009c90:	f50d 6189 	add.w	r1, sp, #1096	@ 0x448
 8009c94:	4628      	mov	r0, r5
 8009c96:	f7fe fc37 	bl	8008508 <SE_AuthenticateFW_Append>
 8009c9a:	4603      	mov	r3, r0
        ppayload += fw_chunk_size;
 8009c9c:	683a      	ldr	r2, [r7, #0]
        i++;
 8009c9e:	f10a 0a01 	add.w	sl, sl, #1
        ppayload += fw_chunk_size;
 8009ca2:	4491      	add	r9, r2
        fw_verified_total_size += fw_chunk_size;
 8009ca4:	4490      	add	r8, r2
        i++;
 8009ca6:	e776      	b.n	8009b96 <VerifyFwSignatureScatter+0x9e>
          *pSeStatus = SE_ERR_FLASH_READ;
 8009ca8:	4b16      	ldr	r3, [pc, #88]	@ (8009d04 <VerifyFwSignatureScatter+0x20c>)
          sfu_ret_status = SFU_ERROR;
 8009caa:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
          *pSeStatus = SE_ERR_FLASH_READ;
 8009cae:	602b      	str	r3, [r5, #0]
          se_ret_status = SE_ERROR;
 8009cb0:	4b15      	ldr	r3, [pc, #84]	@ (8009d08 <VerifyFwSignatureScatter+0x210>)
 8009cb2:	e7f3      	b.n	8009c9c <VerifyFwSignatureScatter+0x1a4>
          *pSeStatus = SE_ERR_FLASH_READ;
 8009cb4:	4b13      	ldr	r3, [pc, #76]	@ (8009d04 <VerifyFwSignatureScatter+0x20c>)
          sfu_ret_status = SFU_ERROR;
 8009cb6:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
          *pSeStatus = SE_ERR_FLASH_READ;
 8009cba:	602b      	str	r3, [r5, #0]
          se_ret_status = SE_ERROR;
 8009cbc:	4b12      	ldr	r3, [pc, #72]	@ (8009d08 <VerifyFwSignatureScatter+0x210>)
 8009cbe:	e796      	b.n	8009bee <VerifyFwSignatureScatter+0xf6>
          FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009cc0:	4a12      	ldr	r2, [pc, #72]	@ (8009d0c <VerifyFwSignatureScatter+0x214>)
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009cc2:	2c02      	cmp	r4, #2
          FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009cc4:	6813      	ldr	r3, [r2, #0]
 8009cc6:	f483 432a 	eor.w	r3, r3, #43520	@ 0xaa00
 8009cca:	f083 03b5 	eor.w	r3, r3, #181	@ 0xb5
 8009cce:	6013      	str	r3, [r2, #0]
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009cd0:	f63f af1f 	bhi.w	8009b12 <VerifyFwSignatureScatter+0x1a>
            (void) memcpy(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], fw_tag_output, SE_TAG_LEN);
 8009cd4:	4a0a      	ldr	r2, [pc, #40]	@ (8009d00 <VerifyFwSignatureScatter+0x208>)
 8009cd6:	ab0a      	add	r3, sp, #40	@ 0x28
 8009cd8:	ad12      	add	r5, sp, #72	@ 0x48
 8009cda:	eb02 1244 	add.w	r2, r2, r4, lsl #5
 8009cde:	461c      	mov	r4, r3
 8009ce0:	3208      	adds	r2, #8
 8009ce2:	cc03      	ldmia	r4!, {r0, r1}
 8009ce4:	42ac      	cmp	r4, r5
 8009ce6:	f842 0c08 	str.w	r0, [r2, #-8]
 8009cea:	f842 1c04 	str.w	r1, [r2, #-4]
 8009cee:	4623      	mov	r3, r4
 8009cf0:	d1f5      	bne.n	8009cde <VerifyFwSignatureScatter+0x1e6>
 8009cf2:	e70e      	b.n	8009b12 <VerifyFwSignatureScatter+0x1a>
 8009cf4:	0012e223 	.word	0x0012e223
 8009cf8:	00122f11 	.word	0x00122f11
 8009cfc:	00146ac1 	.word	0x00146ac1
 8009d00:	200015c0 	.word	0x200015c0
 8009d04:	0014b817 	.word	0x0014b817
 8009d08:	00018799 	.word	0x00018799
 8009d0c:	20001104 	.word	0x20001104
 8009d10:	0012310f 	.word	0x0012310f

08009d14 <VerifyFwSignature>:
  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
  */
SFU_ErrorStatus VerifyFwSignature(SE_StatusTypeDef  *pSeStatus, uint32_t SlotNumber,
                                  SE_FwRawHeaderTypeDef *pFwImageHeader,
                                  uint32_t SE_FwType)
{
 8009d14:	b570      	push	{r4, r5, r6, lr}
  SE_Ex_PayloadDescTypeDef  pse_payload;
  uint32_t fw_size;
  uint32_t fw_offset;

  /*  put it OK, to discriminate error in SFU FWIMG parts */
  *pSeStatus = SE_OK;
 8009d16:	4c10      	ldr	r4, [pc, #64]	@ (8009d58 <VerifyFwSignature+0x44>)
{
 8009d18:	b086      	sub	sp, #24
  *pSeStatus = SE_OK;
 8009d1a:	6004      	str	r4, [r0, #0]

  /* Check the parameters value */
  if (pFwImageHeader == NULL)
 8009d1c:	b1c2      	cbz	r2, 8009d50 <VerifyFwSignature+0x3c>
  {
    return SFU_ERROR;
  }
  if ((SE_FwType != SE_FW_IMAGE_PARTIAL) && (SE_FwType != SE_FW_IMAGE_COMPLETE))
 8009d1e:	2b01      	cmp	r3, #1
 8009d20:	d816      	bhi.n	8009d50 <VerifyFwSignature+0x3c>
      fw_size = 0U;
      fw_offset = 0U;
      break;
  }

  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009d22:	4c0e      	ldr	r4, [pc, #56]	@ (8009d5c <VerifyFwSignature+0x48>)
      fw_offset = 0U;
 8009d24:	bf1c      	itt	ne
 8009d26:	2600      	movne	r6, #0
      fw_size = pFwImageHeader->FwSize;
 8009d28:	6895      	ldrne	r5, [r2, #8]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009d2a:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
  pse_payload.PayloadSize[0] = fw_size;
  pse_payload.pPayload[1] = 0U;
  pse_payload.PayloadSize[1] = 0U;

  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 8009d2e:	9300      	str	r3, [sp, #0]
 8009d30:	ab02      	add	r3, sp, #8
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009d32:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
      fw_offset = pFwImageHeader->PartialFwOffset;
 8009d36:	bf08      	it	eq
 8009d38:	e9d2 6503 	ldrdeq	r6, r5, [r2, #12]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009d3c:	4434      	add	r4, r6
  pse_payload.PayloadSize[0] = fw_size;
 8009d3e:	9504      	str	r5, [sp, #16]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009d40:	9402      	str	r4, [sp, #8]
  pse_payload.pPayload[1] = 0U;
 8009d42:	2400      	movs	r4, #0
 8009d44:	9403      	str	r4, [sp, #12]
  pse_payload.PayloadSize[1] = 0U;
 8009d46:	9405      	str	r4, [sp, #20]
  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 8009d48:	f7ff fed6 	bl	8009af8 <VerifyFwSignatureScatter>
}
 8009d4c:	b006      	add	sp, #24
 8009d4e:	bd70      	pop	{r4, r5, r6, pc}
    return SFU_ERROR;
 8009d50:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 8009d54:	e7fa      	b.n	8009d4c <VerifyFwSignature+0x38>
 8009d56:	bf00      	nop
 8009d58:	0012e223 	.word	0x0012e223
 8009d5c:	0800e424 	.word	0x0800e424

08009d60 <VerifySlot>:
  uint32_t length;
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check is already clean */
  pdata = pSlotBegin + SFU_IMG_IMAGE_OFFSET + uFwSize;
  length = uSlotSize - SFU_IMG_IMAGE_OFFSET - uFwSize;
 8009d60:	f5a1 6380 	sub.w	r3, r1, #1024	@ 0x400
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 8009d64:	2100      	movs	r1, #0
{
 8009d66:	b410      	push	{r4}
  pdata = pSlotBegin + SFU_IMG_IMAGE_OFFSET + uFwSize;
 8009d68:	f502 6480 	add.w	r4, r2, #1024	@ 0x400
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 8009d6c:	1a9b      	subs	r3, r3, r2
 8009d6e:	f04f 32ff 	mov.w	r2, #4294967295
 8009d72:	4420      	add	r0, r4

  return e_ret_status;
}
 8009d74:	f85d 4b04 	ldr.w	r4, [sp], #4
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 8009d78:	f000 be07 	b.w	800a98a <SFU_LL_FLASH_Compare>

08009d7c <CleanUpSlot>:
  * @param  uSlotSize Size of a slot.
  * @param  uOffset Offset in the slot to start cleanup, until end of the slot.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus CleanUpSlot(uint8_t *pSlotBegin, uint32_t uSlotSize, uint32_t uOffset)
{
 8009d7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009d7e:	4606      	mov	r6, r0
 8009d80:	460f      	mov	r7, r1
 8009d82:	4615      	mov	r5, r2
 8009d84:	b093      	sub	sp, #76	@ 0x4c
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 8009d86:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
  SFU_LL_FLASH_write_t pattern;
  SFU_LL_FLASH_write_t value;
  SFU_FLASH_StatusTypeDef flash_if_info;

  /* Clean-up pattern initialization */
  (void) memset((void *)&pattern, 0x00, sizeof(SFU_LL_FLASH_write_t));
 8009d8a:	2220      	movs	r2, #32

  /* Cleaning operation */
  slot_begin = (uint32_t) pSlotBegin;
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 8009d8c:	4435      	add	r5, r6
 8009d8e:	443e      	add	r6, r7
  {
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));

    if (e_ret_status == SFU_SUCCESS)
 8009d90:	4f13      	ldr	r7, [pc, #76]	@ (8009de0 <CleanUpSlot+0x64>)
  (void) memset((void *)&pattern, 0x00, sizeof(SFU_LL_FLASH_write_t));
 8009d92:	2100      	movs	r1, #0
 8009d94:	a802      	add	r0, sp, #8
 8009d96:	f003 fd6b 	bl	800d870 <memset>
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 8009d9a:	42ae      	cmp	r6, r5
 8009d9c:	d802      	bhi.n	8009da4 <CleanUpSlot+0x28>
    {
      (void) SFU_LL_SECU_IWDG_Refresh();
    }
  }
  return e_ret_status;
}
 8009d9e:	4620      	mov	r0, r4
 8009da0:	b013      	add	sp, #76	@ 0x4c
 8009da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));
 8009da4:	2220      	movs	r2, #32
 8009da6:	4629      	mov	r1, r5
 8009da8:	a80a      	add	r0, sp, #40	@ 0x28
 8009daa:	f000 fde7 	bl	800a97c <SFU_LL_FLASH_Read>
    if (e_ret_status == SFU_SUCCESS)
 8009dae:	42b8      	cmp	r0, r7
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));
 8009db0:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 8009db2:	d105      	bne.n	8009dc0 <CleanUpSlot+0x44>
      if (memcmp((void *) &value, (void *) &pattern, sizeof(SFU_LL_FLASH_write_t)) != 0)
 8009db4:	2220      	movs	r2, #32
 8009db6:	a902      	add	r1, sp, #8
 8009db8:	a80a      	add	r0, sp, #40	@ 0x28
 8009dba:	f003 fd49 	bl	800d850 <memcmp>
 8009dbe:	b138      	cbz	r0, 8009dd0 <CleanUpSlot+0x54>
      e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *) pdata, (uint8_t *) &pattern,
 8009dc0:	2320      	movs	r3, #32
 8009dc2:	aa02      	add	r2, sp, #8
 8009dc4:	4629      	mov	r1, r5
 8009dc6:	f10d 0007 	add.w	r0, sp, #7
 8009dca:	f000 fdd0 	bl	800a96e <SFU_LL_FLASH_Write>
 8009dce:	4604      	mov	r4, r0
    if ((pdata % 0x1000U) == 0U)
 8009dd0:	f3c5 030b 	ubfx	r3, r5, #0, #12
 8009dd4:	b90b      	cbnz	r3, 8009dda <CleanUpSlot+0x5e>
      (void) SFU_LL_SECU_IWDG_Refresh();
 8009dd6:	f001 f895 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 8009dda:	3520      	adds	r5, #32
 8009ddc:	e7dd      	b.n	8009d9a <CleanUpSlot+0x1e>
 8009dde:	bf00      	nop
 8009de0:	00122f11 	.word	0x00122f11

08009de4 <SFU_IMG_InitImageHandling>:
  *        Must be called first (and once) before calling the other Image handling services.
  * @param  None.
  * @retval SFU_IMG_InitStatusTypeDef SFU_IMG_INIT_OK if successful, an error code otherwise.
  */
SFU_IMG_InitStatusTypeDef SFU_IMG_InitImageHandling(void)
{
 8009de4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
#if defined(__GNUC__)
    __IO uint32_t start_add;
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009de6:	4e33      	ldr	r6, [pc, #204]	@ (8009eb4 <SFU_IMG_InitImageHandling+0xd0>)
  (void) memset((uint8_t *) &fw_image_header_validated, 0xFE, sizeof(fw_image_header_validated));
 8009de8:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 8009dec:	21fe      	movs	r1, #254	@ 0xfe
 8009dee:	4832      	ldr	r0, [pc, #200]	@ (8009eb8 <SFU_IMG_InitImageHandling+0xd4>)
 8009df0:	f003 fd3e 	bl	800d870 <memset>
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009df4:	9601      	str	r6, [sp, #4]
    if (start_add != 0U)
 8009df6:	9801      	ldr	r0, [sp, #4]
 8009df8:	b140      	cbz	r0, 8009e0c <SFU_IMG_InitImageHandling+0x28>
#else
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
#endif /* (__GNUC__) */
    {
      if (!IS_ALIGNED(SlotStartAdd[SLOT_ACTIVE_1 + i]))
 8009dfa:	f3c6 0010 	ubfx	r0, r6, #0, #17
 8009dfe:	b128      	cbz	r0, 8009e0c <SFU_IMG_InitImageHandling+0x28>
      {
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d (%x) is not properly aligned\r\n",
 8009e00:	4632      	mov	r2, r6
 8009e02:	2101      	movs	r1, #1
 8009e04:	482d      	ldr	r0, [pc, #180]	@ (8009ebc <SFU_IMG_InitImageHandling+0xd8>)
 8009e06:	f003 fb27 	bl	800d458 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009e0a:	2003      	movs	r0, #3
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009e0c:	4d2c      	ldr	r5, [pc, #176]	@ (8009ec0 <SFU_IMG_InitImageHandling+0xdc>)
 8009e0e:	9501      	str	r5, [sp, #4]
    if (start_add != 0U)
 8009e10:	9b01      	ldr	r3, [sp, #4]
 8009e12:	b143      	cbz	r3, 8009e26 <SFU_IMG_InitImageHandling+0x42>
      if (!IS_ALIGNED(SlotStartAdd[SLOT_ACTIVE_1 + i]))
 8009e14:	f3c5 0310 	ubfx	r3, r5, #0, #17
 8009e18:	b12b      	cbz	r3, 8009e26 <SFU_IMG_InitImageHandling+0x42>
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d (%x) is not properly aligned\r\n",
 8009e1a:	462a      	mov	r2, r5
 8009e1c:	2102      	movs	r1, #2
 8009e1e:	4827      	ldr	r0, [pc, #156]	@ (8009ebc <SFU_IMG_InitImageHandling+0xd8>)
 8009e20:	f003 fb1a 	bl	800d458 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009e24:	2003      	movs	r0, #3
   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
#if defined(__GNUC__)
    __IO uint32_t start_add;
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009e26:	9602      	str	r6, [sp, #8]
    if (start_add != 0U)
 8009e28:	9b02      	ldr	r3, [sp, #8]
 8009e2a:	b153      	cbz	r3, 8009e42 <SFU_IMG_InitImageHandling+0x5e>
#else
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
#endif /* (__GNUC__) */
    {
      if (((SlotStartAdd[SLOT_ACTIVE_1 + i] - FLASH_BASE) / FLASH_SECTOR_SIZE) <= SFU_PROTECT_WRP_PAGE_END_1)
 8009e2c:	4b25      	ldr	r3, [pc, #148]	@ (8009ec4 <SFU_IMG_InitImageHandling+0xe0>)
 8009e2e:	4a26      	ldr	r2, [pc, #152]	@ (8009ec8 <SFU_IMG_InitImageHandling+0xe4>)
 8009e30:	0c5b      	lsrs	r3, r3, #17
 8009e32:	ebb3 4f52 	cmp.w	r3, r2, lsr #17
 8009e36:	d304      	bcc.n	8009e42 <SFU_IMG_InitImageHandling+0x5e>
      {
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
 8009e38:	2101      	movs	r1, #1
 8009e3a:	4824      	ldr	r0, [pc, #144]	@ (8009ecc <SFU_IMG_InitImageHandling+0xe8>)
 8009e3c:	f003 fb0c 	bl	800d458 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009e40:	2003      	movs	r0, #3
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009e42:	9502      	str	r5, [sp, #8]
    if (start_add != 0U)
 8009e44:	9b02      	ldr	r3, [sp, #8]
 8009e46:	b153      	cbz	r3, 8009e5e <SFU_IMG_InitImageHandling+0x7a>
      if (((SlotStartAdd[SLOT_ACTIVE_1 + i] - FLASH_BASE) / FLASH_SECTOR_SIZE) <= SFU_PROTECT_WRP_PAGE_END_1)
 8009e48:	4b1e      	ldr	r3, [pc, #120]	@ (8009ec4 <SFU_IMG_InitImageHandling+0xe0>)
 8009e4a:	4a21      	ldr	r2, [pc, #132]	@ (8009ed0 <SFU_IMG_InitImageHandling+0xec>)
 8009e4c:	0c5b      	lsrs	r3, r3, #17
 8009e4e:	ebb3 4f52 	cmp.w	r3, r2, lsr #17
 8009e52:	d304      	bcc.n	8009e5e <SFU_IMG_InitImageHandling+0x7a>
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
 8009e54:	2102      	movs	r1, #2
 8009e56:	481d      	ldr	r0, [pc, #116]	@ (8009ecc <SFU_IMG_InitImageHandling+0xe8>)
 8009e58:	f003 fafe 	bl	800d458 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009e5c:	2003      	movs	r0, #3
 8009e5e:	2209      	movs	r2, #9

  /*
   * Sanity check: let's make sure headers are under the MPU protection
   */
  /* Calculate size of image header MPU region */
  mpu_max_size = 2U;
 8009e60:	2302      	movs	r3, #2
  for (i = 0U; i < SFU_PROTECT_MPU_HEADER_SIZE; i++)
 8009e62:	3a01      	subs	r2, #1
  {
    mpu_max_size = mpu_max_size * 2U;
 8009e64:	ea4f 0343 	mov.w	r3, r3, lsl #1
  for (i = 0U; i < SFU_PROTECT_MPU_HEADER_SIZE; i++)
 8009e68:	d1fb      	bne.n	8009e62 <SFU_IMG_InitImageHandling+0x7e>

  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
#if defined(__GNUC__)
    __IO uint32_t start_add;
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009e6a:	9603      	str	r6, [sp, #12]
 8009e6c:	f023 0407 	bic.w	r4, r3, #7
    if (start_add != 0U)
 8009e70:	9b03      	ldr	r3, [sp, #12]
 8009e72:	b153      	cbz	r3, 8009e8a <SFU_IMG_InitImageHandling+0xa6>
#else
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
#endif /* (__GNUC__) */
    {
      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_MPU_HEADER_START)
 8009e74:	4b17      	ldr	r3, [pc, #92]	@ (8009ed4 <SFU_IMG_InitImageHandling+0xf0>)
            && ((SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SE_FW_HEADER_TOT_LEN) <=
 8009e76:	f503 72a0 	add.w	r2, r3, #320	@ 0x140
                (SFU_PROTECT_MPU_HEADER_START + mpu_size))))
 8009e7a:	4423      	add	r3, r4
      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_MPU_HEADER_START)
 8009e7c:	429a      	cmp	r2, r3
 8009e7e:	d904      	bls.n	8009e8a <SFU_IMG_InitImageHandling+0xa6>
      {
        TRACE("\r\n= [FWIMG] Header of SLOT_ACTIVE_%d is not under the MPU protection\r\n", i + 1U);
 8009e80:	2101      	movs	r1, #1
 8009e82:	4815      	ldr	r0, [pc, #84]	@ (8009ed8 <SFU_IMG_InitImageHandling+0xf4>)
 8009e84:	f003 fae8 	bl	800d458 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009e88:	2003      	movs	r0, #3
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009e8a:	9503      	str	r5, [sp, #12]
    if (start_add != 0U)
 8009e8c:	9b03      	ldr	r3, [sp, #12]
 8009e8e:	b143      	cbz	r3, 8009ea2 <SFU_IMG_InitImageHandling+0xbe>
      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_MPU_HEADER_START)
 8009e90:	4a12      	ldr	r2, [pc, #72]	@ (8009edc <SFU_IMG_InitImageHandling+0xf8>)
 8009e92:	4b10      	ldr	r3, [pc, #64]	@ (8009ed4 <SFU_IMG_InitImageHandling+0xf0>)
 8009e94:	429a      	cmp	r2, r3
 8009e96:	d206      	bcs.n	8009ea6 <SFU_IMG_InitImageHandling+0xc2>
        TRACE("\r\n= [FWIMG] Header of SLOT_ACTIVE_%d is not under the MPU protection\r\n", i + 1U);
 8009e98:	2102      	movs	r1, #2
 8009e9a:	480f      	ldr	r0, [pc, #60]	@ (8009ed8 <SFU_IMG_InitImageHandling+0xf4>)
 8009e9c:	f003 fadc 	bl	800d458 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009ea0:	2003      	movs	r0, #3




  return e_ret_status;
}
 8009ea2:	b004      	add	sp, #16
 8009ea4:	bd70      	pop	{r4, r5, r6, pc}
            && ((SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SE_FW_HEADER_TOT_LEN) <=
 8009ea6:	f502 72a0 	add.w	r2, r2, #320	@ 0x140
                (SFU_PROTECT_MPU_HEADER_START + mpu_size))))
 8009eaa:	4423      	add	r3, r4
      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_MPU_HEADER_START)
 8009eac:	429a      	cmp	r2, r3
 8009eae:	d8f3      	bhi.n	8009e98 <SFU_IMG_InitImageHandling+0xb4>
 8009eb0:	e7f7      	b.n	8009ea2 <SFU_IMG_InitImageHandling+0xbe>
 8009eb2:	bf00      	nop
 8009eb4:	08020200 	.word	0x08020200
 8009eb8:	20001600 	.word	0x20001600
 8009ebc:	0800ed15 	.word	0x0800ed15
 8009ec0:	08100000 	.word	0x08100000
 8009ec4:	0001ffff 	.word	0x0001ffff
 8009ec8:	00020200 	.word	0x00020200
 8009ecc:	0800ed4f 	.word	0x0800ed4f
 8009ed0:	00100000 	.word	0x00100000
 8009ed4:	08020000 	.word	0x08020000
 8009ed8:	0800ed96 	.word	0x0800ed96
 8009edc:	08020100 	.word	0x08020100

08009ee0 <SFU_IMG_InvalidateCurrentFirmware>:
  *       running the procedure).
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_SUCCESS if successful,SFU_ERROR error otherwise.
  */
SFU_ErrorStatus SFU_IMG_InvalidateCurrentFirmware(uint32_t SlotNumber)
{
 8009ee0:	b510      	push	{r4, lr}
 8009ee2:	4604      	mov	r4, r0
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Reload Watchdog */
  (void) SFU_LL_SECU_IWDG_Refresh();
 8009ee4:	f001 f80e 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>

  /* erase active slot except Header (under SECoreBin protection) for the anti-rollback check during next Fw update */
  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET);
 8009ee8:	4b06      	ldr	r3, [pc, #24]	@ (8009f04 <SFU_IMG_InvalidateCurrentFirmware+0x24>)
 8009eea:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8009eee:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8009ef2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8009ef6:	6a19      	ldr	r1, [r3, #32]
 8009ef8:	3101      	adds	r1, #1

  return (e_ret_status);
}
 8009efa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET);
 8009efe:	1a09      	subs	r1, r1, r0
 8009f00:	f7ff bf3c 	b.w	8009d7c <CleanUpSlot>
 8009f04:	0800e424 	.word	0x0800e424

08009f08 <SFU_IMG_VerifyActiveImg>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
  */
SFU_ErrorStatus SFU_IMG_VerifyActiveImg(uint32_t SlotNumber)
{
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  SE_StatusTypeDef e_se_status = SE_KO;
 8009f08:	4b05      	ldr	r3, [pc, #20]	@ (8009f20 <SFU_IMG_VerifyActiveImg+0x18>)
{
 8009f0a:	b507      	push	{r0, r1, r2, lr}
 8009f0c:	4601      	mov	r1, r0
  SE_StatusTypeDef e_se_status = SE_KO;
 8009f0e:	9301      	str	r3, [sp, #4]

  /*
   * fw_image_header_validated MUST have been populated with valid metadata first,
   */
  e_ret_status = VerifyFwSignature(&e_se_status, SlotNumber, &fw_image_header_validated, SE_FW_IMAGE_COMPLETE);
 8009f10:	4a04      	ldr	r2, [pc, #16]	@ (8009f24 <SFU_IMG_VerifyActiveImg+0x1c>)
 8009f12:	2300      	movs	r3, #0
 8009f14:	a801      	add	r0, sp, #4
 8009f16:	f7ff fefd 	bl	8009d14 <VerifyFwSignature>
    TRACE("\r\n=         SFU_IMG_VerifyActiveImg failure with se_status=%d!", e_se_status);
  }
#endif /* SFU_VERBOSE_DEBUG_MODE */

  return (e_ret_status);
}
 8009f1a:	b003      	add	sp, #12
 8009f1c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f20:	0013023d 	.word	0x0013023d
 8009f24:	20001600 	.word	0x20001600

08009f28 <SFU_IMG_VerifyActiveSlot>:
  * @note SFU_IMG_VerifyActiveImgMetadata() must have been called first to populate fw_image_header_validated.
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
  */
SFU_ErrorStatus SFU_IMG_VerifyActiveSlot(uint32_t SlotNumber)
{
 8009f28:	4602      	mov	r2, r0
  /*
   * fw_image_header_validated MUST have been populated with valid metadata first,
   */
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), fw_image_header_validated.FwSize));
 8009f2a:	4b06      	ldr	r3, [pc, #24]	@ (8009f44 <SFU_IMG_VerifyActiveSlot+0x1c>)
 8009f2c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8009f30:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8009f34:	6a19      	ldr	r1, [r3, #32]
 8009f36:	4b04      	ldr	r3, [pc, #16]	@ (8009f48 <SFU_IMG_VerifyActiveSlot+0x20>)
 8009f38:	3101      	adds	r1, #1
 8009f3a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8009f3c:	1a09      	subs	r1, r1, r0
 8009f3e:	f7ff bf0f 	b.w	8009d60 <VerifySlot>
 8009f42:	bf00      	nop
 8009f44:	0800e424 	.word	0x0800e424
 8009f48:	200015c0 	.word	0x200015c0

08009f4c <SFU_IMG_VerifyEmptyActiveSlot>:
  * @brief Verifies if no malicious code in active slot.
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
  */
SFU_ErrorStatus SFU_IMG_VerifyEmptyActiveSlot(uint32_t SlotNumber)
{
 8009f4c:	4602      	mov	r2, r0
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), 0U));
 8009f4e:	4b05      	ldr	r3, [pc, #20]	@ (8009f64 <SFU_IMG_VerifyEmptyActiveSlot+0x18>)
 8009f50:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8009f54:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8009f58:	2200      	movs	r2, #0
 8009f5a:	6a19      	ldr	r1, [r3, #32]
 8009f5c:	3101      	adds	r1, #1
 8009f5e:	1a09      	subs	r1, r1, r0
 8009f60:	f7ff befe 	b.w	8009d60 <VerifySlot>
 8009f64:	0800e424 	.word	0x0800e424

08009f68 <SFU_IMG_ControlActiveImgTag>:
  * @note   This control will be done twice for security reasons (first control done in VerifyFwSignatureScatter)
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_SUCCESS if successful,SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_IMG_ControlActiveImgTag(uint32_t SlotNumber)
{
 8009f68:	b508      	push	{r3, lr}
  /*
   * fw_image_header_validated MUST have been populated with valid metadata first,
   */
  if (MemoryCompare(fw_tag_validated[SlotNumber - SLOT_ACTIVE_1], fw_image_header_validated.FwTag,
 8009f6a:	3801      	subs	r0, #1
 8009f6c:	4b0a      	ldr	r3, [pc, #40]	@ (8009f98 <SFU_IMG_ControlActiveImgTag+0x30>)
 8009f6e:	2220      	movs	r2, #32
 8009f70:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8009f74:	eb03 1040 	add.w	r0, r3, r0, lsl #5
 8009f78:	f7ff fd92 	bl	8009aa0 <MemoryCompare>
 8009f7c:	4b07      	ldr	r3, [pc, #28]	@ (8009f9c <SFU_IMG_ControlActiveImgTag+0x34>)
 8009f7e:	4298      	cmp	r0, r3
  {
    return SFU_ERROR;
  }
  else
  {
    FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009f80:	bf09      	itett	eq
 8009f82:	4a07      	ldreq	r2, [pc, #28]	@ (8009fa0 <SFU_IMG_ControlActiveImgTag+0x38>)
    return SFU_ERROR;
 8009f84:	f641 70e1 	movwne	r0, #8161	@ 0x1fe1
    FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009f88:	6813      	ldreq	r3, [r2, #0]
 8009f8a:	f483 432a 	eoreq.w	r3, r3, #43520	@ 0xaa00
 8009f8e:	bf04      	itt	eq
 8009f90:	f083 03b5 	eoreq.w	r3, r3, #181	@ 0xb5
 8009f94:	6013      	streq	r3, [r2, #0]
    return SFU_SUCCESS;
  }

}
 8009f96:	bd08      	pop	{r3, pc}
 8009f98:	200015c0 	.word	0x200015c0
 8009f9c:	00122f11 	.word	0x00122f11
 8009fa0:	20001104 	.word	0x20001104

08009fa4 <SFU_IMG_LaunchActiveImg>:
SFU_ErrorStatus SFU_IMG_LaunchActiveImg(uint32_t SlotNumber)
{
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;

  /* Verify if authentication/integrity/lock SE service performed */
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVICE);
 8009fa4:	4b0b      	ldr	r3, [pc, #44]	@ (8009fd4 <SFU_IMG_LaunchActiveImg+0x30>)
 8009fa6:	681a      	ldr	r2, [r3, #0]
 8009fa8:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 8009fac:	429a      	cmp	r2, r3
{
 8009fae:	b510      	push	{r4, lr}
 8009fb0:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVICE);
 8009fb2:	d001      	beq.n	8009fb8 <SFU_IMG_LaunchActiveImg+0x14>
 8009fb4:	f7ff fd48 	bl	8009a48 <SFU_EXCPT_Security_Error>
   * interrupt is triggered during the SVC routine, the Systick interrupt will be served at the end of
   * the SVC routine.
   * This is a problem when the secure user memory is activated and the SBSFU code is no more accessible.
   * Systick will be re-initialized by HAL_Init() during execution of main() from UserApp.
   */
  SFU_MPU_SysCall((uint32_t)SB_SYSCALL_SYSTICK_SUSPEND);
 8009fb8:	2007      	movs	r0, #7
 8009fba:	f000 fb5d 	bl	800a678 <SFU_MPU_SysCall>

  /* this function does not return */
  /* first image identified as master image */
  SFU_MPU_SysCall((uint32_t)SB_SYSCALL_LAUNCH_APP, SlotStartAdd[SlotNumber] + SFU_IMG_IMAGE_OFFSET);
 8009fbe:	4b06      	ldr	r3, [pc, #24]	@ (8009fd8 <SFU_IMG_LaunchActiveImg+0x34>)
 8009fc0:	2001      	movs	r0, #1
 8009fc2:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 8009fc6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8009fca:	f000 fb55 	bl	800a678 <SFU_MPU_SysCall>

  /* The point below should NOT be reached */
  return (e_ret_status);
}
 8009fce:	4803      	ldr	r0, [pc, #12]	@ (8009fdc <SFU_IMG_LaunchActiveImg+0x38>)
 8009fd0:	bd10      	pop	{r4, pc}
 8009fd2:	bf00      	nop
 8009fd4:	20001104 	.word	0x20001104
 8009fd8:	0800e424 	.word	0x0800e424
 8009fdc:	00122f11 	.word	0x00122f11

08009fe0 <SFU_IMG_Validation>:
#else

  /* Nothing to do header already written */
  return SFU_SUCCESS;
#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALONE_LOADER) */
}
 8009fe0:	4800      	ldr	r0, [pc, #0]	@ (8009fe4 <SFU_IMG_Validation+0x4>)
 8009fe2:	4770      	bx	lr
 8009fe4:	00122f11 	.word	0x00122f11

08009fe8 <SFU_IMG_GetFwImageSlot>:
  * @brief  Get firmware image ID from header.
  * @param  pFwImageHeader pointer to a structure to handle the header info
  * @retval Fw Id : SLOT_ACTIVE_1 / 2 /... / SFU_NB_MAX_ACTIVE_IMAGE
  */
uint32_t SFU_IMG_GetFwImageSlot(SE_FwRawHeaderTypeDef *pFwImageHeader)
{
 8009fe8:	b510      	push	{r4, lr}
  uint32_t active_slot;

  if (memcmp(pFwImageHeader->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8009fea:	2204      	movs	r2, #4
 8009fec:	4908      	ldr	r1, [pc, #32]	@ (800a010 <SFU_IMG_GetFwImageSlot+0x28>)
{
 8009fee:	4604      	mov	r4, r0
  if (memcmp(pFwImageHeader->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8009ff0:	f003 fc2e 	bl	800d850 <memcmp>
 8009ff4:	b148      	cbz	r0, 800a00a <SFU_IMG_GetFwImageSlot+0x22>
  {
    active_slot = SLOT_ACTIVE_1;
  }
#if (SFU_NB_MAX_ACTIVE_IMAGE > 1)
  else if (memcmp(pFwImageHeader->SFUMagic, SFUM_2, strlen(SFUM_2)) == 0)
 8009ff6:	2204      	movs	r2, #4
 8009ff8:	4906      	ldr	r1, [pc, #24]	@ (800a014 <SFU_IMG_GetFwImageSlot+0x2c>)
 8009ffa:	4620      	mov	r0, r4
 8009ffc:	f003 fc28 	bl	800d850 <memcmp>
 800a000:	fab0 f080 	clz	r0, r0
 800a004:	0940      	lsrs	r0, r0, #5
 800a006:	0040      	lsls	r0, r0, #1
  {
    active_slot = SLOT_INACTIVE;
  }

  return active_slot;
}
 800a008:	bd10      	pop	{r4, pc}
    active_slot = SLOT_ACTIVE_1;
 800a00a:	2001      	movs	r0, #1
  return active_slot;
 800a00c:	e7fc      	b.n	800a008 <SFU_IMG_GetFwImageSlot+0x20>
 800a00e:	bf00      	nop
 800a010:	0800eddd 	.word	0x0800eddd
 800a014:	0800ede2 	.word	0x0800ede2

0800a018 <VerifyHeaderSignature>:
{
 800a018:	b513      	push	{r0, r1, r4, lr}
 800a01a:	4604      	mov	r4, r0
  if (SFU_IMG_GetFwImageSlot(pFwImageHeader) != SLOT_INACTIVE)
 800a01c:	f7ff ffe4 	bl	8009fe8 <SFU_IMG_GetFwImageSlot>
 800a020:	b918      	cbnz	r0, 800a02a <VerifyHeaderSignature+0x12>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a022:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
}
 800a026:	b002      	add	sp, #8
 800a028:	bd10      	pop	{r4, pc}
 800a02a:	f104 0263 	add.w	r2, r4, #99	@ 0x63
 800a02e:	f104 017f 	add.w	r1, r4, #127	@ 0x7f
  uint8_t result = 0x00U;
 800a032:	2300      	movs	r3, #0
      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
 800a034:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
 800a038:	428a      	cmp	r2, r1
      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
 800a03a:	ea43 0300 	orr.w	r3, r3, r0
    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
 800a03e:	d1f9      	bne.n	800a034 <VerifyHeaderSignature+0x1c>
    if (result == 0x00U)
 800a040:	2b00      	cmp	r3, #0
 800a042:	d1ee      	bne.n	800a022 <VerifyHeaderSignature+0xa>
      if (SE_VerifyHeaderSignature(&se_status, pFwImageHeader) == SE_SUCCESS)
 800a044:	4621      	mov	r1, r4
 800a046:	a801      	add	r0, sp, #4
 800a048:	f7fe fad0 	bl	80085ec <SE_VerifyHeaderSignature>
 800a04c:	4b05      	ldr	r3, [pc, #20]	@ (800a064 <VerifyHeaderSignature+0x4c>)
 800a04e:	4298      	cmp	r0, r3
 800a050:	d1e7      	bne.n	800a022 <VerifyHeaderSignature+0xa>
        FLOW_STEP(uFlowCryptoValue, FLOW_STEP_AUTHENTICATE);
 800a052:	4a05      	ldr	r2, [pc, #20]	@ (800a068 <VerifyHeaderSignature+0x50>)
 800a054:	4805      	ldr	r0, [pc, #20]	@ (800a06c <VerifyHeaderSignature+0x54>)
 800a056:	6813      	ldr	r3, [r2, #0]
 800a058:	f483 43f3 	eor.w	r3, r3, #31104	@ 0x7980
 800a05c:	f083 0319 	eor.w	r3, r3, #25
 800a060:	6013      	str	r3, [r2, #0]
  return e_ret_status;
 800a062:	e7e0      	b.n	800a026 <VerifyHeaderSignature+0xe>
 800a064:	0012310f 	.word	0x0012310f
 800a068:	20001104 	.word	0x20001104
 800a06c:	00122f11 	.word	0x00122f11

0800a070 <CheckAndGetFWHeader>:
  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
 800a070:	4b09      	ldr	r3, [pc, #36]	@ (800a098 <CheckAndGetFWHeader+0x28>)
 800a072:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 800a076:	eb03 0080 	add.w	r0, r3, r0, lsl #2
{
 800a07a:	b510      	push	{r4, lr}
 800a07c:	460c      	mov	r4, r1
  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
 800a07e:	6c01      	ldr	r1, [r0, #64]	@ 0x40
 800a080:	4620      	mov	r0, r4
 800a082:	f000 fc7b 	bl	800a97c <SFU_LL_FLASH_Read>
  if (e_ret_status == SFU_SUCCESS)
 800a086:	4b05      	ldr	r3, [pc, #20]	@ (800a09c <CheckAndGetFWHeader+0x2c>)
 800a088:	4298      	cmp	r0, r3
 800a08a:	d104      	bne.n	800a096 <CheckAndGetFWHeader+0x26>
    e_ret_status = VerifyHeaderSignature(pFwImageHeader);
 800a08c:	4620      	mov	r0, r4
}
 800a08e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e_ret_status = VerifyHeaderSignature(pFwImageHeader);
 800a092:	f7ff bfc1 	b.w	800a018 <VerifyHeaderSignature>
}
 800a096:	bd10      	pop	{r4, pc}
 800a098:	0800e424 	.word	0x0800e424
 800a09c:	00122f11 	.word	0x00122f11

0800a0a0 <SFU_IMG_VerifyActiveImgMetadata>:
  return (CheckAndGetFWHeader(SlotNumber, &fw_image_header_validated));
 800a0a0:	4901      	ldr	r1, [pc, #4]	@ (800a0a8 <SFU_IMG_VerifyActiveImgMetadata+0x8>)
 800a0a2:	f7ff bfe5 	b.w	800a070 <CheckAndGetFWHeader>
 800a0a6:	bf00      	nop
 800a0a8:	20001600 	.word	0x20001600

0800a0ac <SFU_IMG_GetActiveFwVersion>:
{
 800a0ac:	b500      	push	{lr}
 800a0ae:	b0d1      	sub	sp, #324	@ 0x144
  e_ret_status = CheckAndGetFWHeader(SlotNumber, &fw_image_header);
 800a0b0:	4669      	mov	r1, sp
 800a0b2:	f7ff ffdd 	bl	800a070 <CheckAndGetFWHeader>
  if (e_ret_status == SFU_SUCCESS)
 800a0b6:	4b04      	ldr	r3, [pc, #16]	@ (800a0c8 <SFU_IMG_GetActiveFwVersion+0x1c>)
 800a0b8:	4298      	cmp	r0, r3
    version = fw_image_header.FwVersion;
 800a0ba:	bf0c      	ite	eq
 800a0bc:	f8bd 0006 	ldrheq.w	r0, [sp, #6]
  uint16_t version = 0;
 800a0c0:	2000      	movne	r0, #0
}
 800a0c2:	b051      	add	sp, #324	@ 0x144
 800a0c4:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0c8:	00122f11 	.word	0x00122f11

0800a0cc <SFU_IMG_DetectFW>:
{
 800a0cc:	b570      	push	{r4, r5, r6, lr}
  pbuffer = (uint8_t *) SlotHeaderAdd[SlotNumber];
 800a0ce:	4e11      	ldr	r6, [pc, #68]	@ (800a114 <SFU_IMG_DetectFW+0x48>)
{
 800a0d0:	b0d0      	sub	sp, #320	@ 0x140
 800a0d2:	4605      	mov	r5, r0
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800a0d4:	f44f 72a0 	mov.w	r2, #320	@ 0x140
  pbuffer = (uint8_t *) SlotHeaderAdd[SlotNumber];
 800a0d8:	eb06 0380 	add.w	r3, r6, r0, lsl #2
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800a0dc:	4668      	mov	r0, sp
 800a0de:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 800a0e0:	f000 fc4c 	bl	800a97c <SFU_LL_FLASH_Read>
 800a0e4:	4b0c      	ldr	r3, [pc, #48]	@ (800a118 <SFU_IMG_DetectFW+0x4c>)
 800a0e6:	4604      	mov	r4, r0
 800a0e8:	4298      	cmp	r0, r3
 800a0ea:	d004      	beq.n	800a0f6 <SFU_IMG_DetectFW+0x2a>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a0ec:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
}
 800a0f0:	4620      	mov	r0, r4
 800a0f2:	b050      	add	sp, #320	@ 0x140
 800a0f4:	bd70      	pop	{r4, r5, r6, pc}
    if (SFU_IMG_GetFwImageSlot(p_header) != SLOT_INACTIVE)
 800a0f6:	4668      	mov	r0, sp
 800a0f8:	f7ff ff76 	bl	8009fe8 <SFU_IMG_GetFwImageSlot>
 800a0fc:	2800      	cmp	r0, #0
 800a0fe:	d0f5      	beq.n	800a0ec <SFU_IMG_DetectFW+0x20>
      if (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SFU_IMG_IMAGE_OFFSET + 0x20U, 0U) != SFU_SUCCESS)
 800a100:	2200      	movs	r2, #0
 800a102:	f44f 6184 	mov.w	r1, #1056	@ 0x420
 800a106:	f856 0025 	ldr.w	r0, [r6, r5, lsl #2]
 800a10a:	f7ff fe29 	bl	8009d60 <VerifySlot>
 800a10e:	42a0      	cmp	r0, r4
 800a110:	d1ee      	bne.n	800a0f0 <SFU_IMG_DetectFW+0x24>
 800a112:	e7eb      	b.n	800a0ec <SFU_IMG_DetectFW+0x20>
 800a114:	0800e424 	.word	0x0800e424
 800a118:	00122f11 	.word	0x00122f11

0800a11c <SFU_IMG_CheckFwVersion>:
  * @param  CandidateVersion Version of candidate image
  * @retval SFU_SUCCESS if candidate image version is allowed, SFU_ErrorStatus error otherwise.
  */
SFU_ErrorStatus SFU_IMG_CheckFwVersion(uint32_t ActiveSlot, uint16_t CurrentVersion, uint16_t CandidateVersion)
{
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a11c:	4b05      	ldr	r3, [pc, #20]	@ (800a134 <SFU_IMG_CheckFwVersion+0x18>)
 800a11e:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  UNUSED(ActiveSlot);

  /* If the header of the active firmware is not valid, the CurrentVersion is 0 */
  if (CurrentVersion == 0U)
 800a122:	b919      	cbnz	r1, 800a12c <SFU_IMG_CheckFwVersion+0x10>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a124:	2a01      	cmp	r2, #1
 800a126:	bf08      	it	eq
 800a128:	4618      	moveq	r0, r3
 800a12a:	4770      	bx	lr
 800a12c:	4291      	cmp	r1, r2
 800a12e:	bf98      	it	ls
 800a130:	4618      	movls	r0, r3
#endif /* SFU_VERBOSE_DEBUG_MODE */

  }

  return e_ret_status;
}
 800a132:	4770      	bx	lr
 800a134:	00122f11 	.word	0x00122f11

0800a138 <SFU_LOADER_VerifyFwHeader>:
#elif defined ( __GNUC__ )
__attribute__((optimize("O0")))
#endif /* __ICCARM__ */

static SFU_ErrorStatus SFU_LOADER_VerifyFwHeader(uint8_t *pBuffer)
{
 800a138:	b580      	push	{r7, lr}
 800a13a:	b08c      	sub	sp, #48	@ 0x30
 800a13c:	af00      	add	r7, sp, #0
 800a13e:	6078      	str	r0, [r7, #4]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a140:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 800a144:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint16_t                      cur_ver;
  uint16_t                      verif_ver;
  uint32_t                      active_slot;

  /*Parse the received buffer*/
  p_x_fw_raw_header = (SE_FwRawHeaderTypeDef *)(uint32_t)pBuffer;
 800a146:	687b      	ldr	r3, [r7, #4]
 800a148:	62bb      	str	r3, [r7, #40]	@ 0x28

  /*Check if the received header packet is authentic*/
  if (SE_VerifyHeaderSignature(&e_se_status, p_x_fw_raw_header) != SE_ERROR)
 800a14a:	f107 031c 	add.w	r3, r7, #28
 800a14e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800a150:	4618      	mov	r0, r3
 800a152:	f7fe fa4b 	bl	80085ec <SE_VerifyHeaderSignature>
 800a156:	4603      	mov	r3, r0
 800a158:	4a4c      	ldr	r2, [pc, #304]	@ (800a28c <SFU_LOADER_VerifyFwHeader+0x154>)
 800a15a:	4293      	cmp	r3, r2
 800a15c:	f000 808e 	beq.w	800a27c <SFU_LOADER_VerifyFwHeader+0x144>
  {
    active_slot = SFU_IMG_GetFwImageSlot(p_x_fw_raw_header);
 800a160:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800a162:	f7ff ff41 	bl	8009fe8 <SFU_IMG_GetFwImageSlot>
 800a166:	6278      	str	r0, [r7, #36]	@ 0x24
     * 1 slot per image configuration. Identify the download area.
     *   It will be based on SFU magic :
     *   - dwl slot is the active_slot if configured.
     *   - else : SLOT_ACTIVE_1
     */
    m_uDwlSlot = active_slot;
 800a168:	4a49      	ldr	r2, [pc, #292]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a16a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a16c:	6013      	str	r3, [r2, #0]
    if (SLOT_SIZE(m_uDwlSlot) == 1U)
 800a16e:	4b48      	ldr	r3, [pc, #288]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a170:	681b      	ldr	r3, [r3, #0]
 800a172:	4a48      	ldr	r2, [pc, #288]	@ (800a294 <SFU_LOADER_VerifyFwHeader+0x15c>)
 800a174:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800a178:	4b45      	ldr	r3, [pc, #276]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a17a:	681b      	ldr	r3, [r3, #0]
 800a17c:	4946      	ldr	r1, [pc, #280]	@ (800a298 <SFU_LOADER_VerifyFwHeader+0x160>)
 800a17e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800a182:	429a      	cmp	r2, r3
 800a184:	d102      	bne.n	800a18c <SFU_LOADER_VerifyFwHeader+0x54>
    {
      m_uDwlSlot = SLOT_ACTIVE_1;
 800a186:	4b42      	ldr	r3, [pc, #264]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a188:	2201      	movs	r2, #1
 800a18a:	601a      	str	r2, [r3, #0]
    }
    SFU_IMG_GetDownloadAreaInfo(m_uDwlSlot, &fw_image_flash_data);
 800a18c:	4b40      	ldr	r3, [pc, #256]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a18e:	681b      	ldr	r3, [r3, #0]
 800a190:	f107 0208 	add.w	r2, r7, #8
 800a194:	4611      	mov	r1, r2
 800a196:	4618      	mov	r0, r3
 800a198:	f000 fa8e 	bl	800a6b8 <SFU_IMG_GetDownloadAreaInfo>

    /* Assign the download flash address to be used during the YMODEM process */
    m_uDwlAreaStart = fw_image_flash_data.DownloadAddr;
 800a19c:	68fb      	ldr	r3, [r7, #12]
 800a19e:	4a3f      	ldr	r2, [pc, #252]	@ (800a29c <SFU_LOADER_VerifyFwHeader+0x164>)
 800a1a0:	6013      	str	r3, [r2, #0]
    m_uDwlAreaSize = fw_image_flash_data.MaxSizeInBytes;
 800a1a2:	68bb      	ldr	r3, [r7, #8]
 800a1a4:	4a3e      	ldr	r2, [pc, #248]	@ (800a2a0 <SFU_LOADER_VerifyFwHeader+0x168>)
 800a1a6:	6013      	str	r3, [r2, #0]
    m_uActiveHeaderStart = fw_image_flash_data.ActiveHeaderAddr;
 800a1a8:	69bb      	ldr	r3, [r7, #24]
 800a1aa:	4a3e      	ldr	r2, [pc, #248]	@ (800a2a4 <SFU_LOADER_VerifyFwHeader+0x16c>)
 800a1ac:	6013      	str	r3, [r2, #0]

    /*
     * Check if the version is allowed
     * ==> SFU_IMG_GetActiveFwVersion() returns 0 if the header of active firmware is not valid
     */
    cur_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800a1ae:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a1b0:	f7ff ff7c 	bl	800a0ac <SFU_IMG_GetActiveFwVersion>
 800a1b4:	4603      	mov	r3, r0
 800a1b6:	847b      	strh	r3, [r7, #34]	@ 0x22
    if (SFU_IMG_CheckFwVersion(active_slot, cur_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
 800a1b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a1ba:	88da      	ldrh	r2, [r3, #6]
 800a1bc:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 800a1be:	4619      	mov	r1, r3
 800a1c0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a1c2:	f7ff ffab 	bl	800a11c <SFU_IMG_CheckFwVersion>
 800a1c6:	4603      	mov	r3, r0
 800a1c8:	4a37      	ldr	r2, [pc, #220]	@ (800a2a8 <SFU_LOADER_VerifyFwHeader+0x170>)
 800a1ca:	4293      	cmp	r3, r2
 800a1cc:	d117      	bne.n	800a1fe <SFU_LOADER_VerifyFwHeader+0xc6>
    {
      /*
       * Check length : Let's make sure the Firmware image can be written in the destination slot.
       */
      if (p_x_fw_raw_header->FwSize > (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET))
 800a1ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a1d0:	689a      	ldr	r2, [r3, #8]
 800a1d2:	4b2f      	ldr	r3, [pc, #188]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a1d4:	681b      	ldr	r3, [r3, #0]
 800a1d6:	492f      	ldr	r1, [pc, #188]	@ (800a294 <SFU_LOADER_VerifyFwHeader+0x15c>)
 800a1d8:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800a1dc:	4b2c      	ldr	r3, [pc, #176]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a1de:	681b      	ldr	r3, [r3, #0]
 800a1e0:	482d      	ldr	r0, [pc, #180]	@ (800a298 <SFU_LOADER_VerifyFwHeader+0x160>)
 800a1e2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800a1e6:	1acb      	subs	r3, r1, r3
 800a1e8:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
 800a1ec:	429a      	cmp	r2, r3
 800a1ee:	d903      	bls.n	800a1f8 <SFU_LOADER_VerifyFwHeader+0xc0>
      {
        /* The firmware cannot be written in dwl slot */
        m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800a1f0:	4b2e      	ldr	r3, [pc, #184]	@ (800a2ac <SFU_LOADER_VerifyFwHeader+0x174>)
 800a1f2:	2203      	movs	r2, #3
 800a1f4:	701a      	strb	r2, [r3, #0]
 800a1f6:	e00d      	b.n	800a214 <SFU_LOADER_VerifyFwHeader+0xdc>
      }
      else
      {
        /* Installation authorized */
        e_ret_status = SFU_SUCCESS;
 800a1f8:	4b2b      	ldr	r3, [pc, #172]	@ (800a2a8 <SFU_LOADER_VerifyFwHeader+0x170>)
 800a1fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800a1fc:	e00a      	b.n	800a214 <SFU_LOADER_VerifyFwHeader+0xdc>
    }
    else
    {
      /* The installation is forbidden */
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
            p_x_fw_raw_header->FwVersion, cur_ver, SFU_FW_VERSION_START_NUM);
 800a1fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a200:	88db      	ldrh	r3, [r3, #6]
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
 800a202:	4619      	mov	r1, r3
 800a204:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 800a206:	2301      	movs	r3, #1
 800a208:	4829      	ldr	r0, [pc, #164]	@ (800a2b0 <SFU_LOADER_VerifyFwHeader+0x178>)
 800a20a:	f003 f925 	bl	800d458 <iprintf>
      m_LoaderStatus = SFU_LOADER_ERR_FW_VERSION;
 800a20e:	4b27      	ldr	r3, [pc, #156]	@ (800a2ac <SFU_LOADER_VerifyFwHeader+0x174>)
 800a210:	2204      	movs	r2, #4
 800a212:	701a      	strb	r2, [r3, #0]
    /*
     * Control of version and length is done twice to avoid basic hardware attack
     * This more important for the 1 image configuration as the installation is done during the download procedure
     * For the 2 images configuration anti-rollback will be checked again during installation process
     */
    verif_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800a214:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a216:	f7ff ff49 	bl	800a0ac <SFU_IMG_GetActiveFwVersion>
 800a21a:	4603      	mov	r3, r0
 800a21c:	843b      	strh	r3, [r7, #32]
    if (SFU_IMG_CheckFwVersion(active_slot, verif_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
 800a21e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a220:	88da      	ldrh	r2, [r3, #6]
 800a222:	8c3b      	ldrh	r3, [r7, #32]
 800a224:	4619      	mov	r1, r3
 800a226:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a228:	f7ff ff78 	bl	800a11c <SFU_IMG_CheckFwVersion>
 800a22c:	4603      	mov	r3, r0
 800a22e:	4a1e      	ldr	r2, [pc, #120]	@ (800a2a8 <SFU_LOADER_VerifyFwHeader+0x170>)
 800a230:	4293      	cmp	r3, r2
 800a232:	d117      	bne.n	800a264 <SFU_LOADER_VerifyFwHeader+0x12c>
    {
      /*
       * Check length : Let's make sure the Firmware image can be written in the destination slot.
       */
      if (p_x_fw_raw_header->FwSize > (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET))
 800a234:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a236:	689a      	ldr	r2, [r3, #8]
 800a238:	4b15      	ldr	r3, [pc, #84]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a23a:	681b      	ldr	r3, [r3, #0]
 800a23c:	4915      	ldr	r1, [pc, #84]	@ (800a294 <SFU_LOADER_VerifyFwHeader+0x15c>)
 800a23e:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800a242:	4b13      	ldr	r3, [pc, #76]	@ (800a290 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a244:	681b      	ldr	r3, [r3, #0]
 800a246:	4814      	ldr	r0, [pc, #80]	@ (800a298 <SFU_LOADER_VerifyFwHeader+0x160>)
 800a248:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800a24c:	1acb      	subs	r3, r1, r3
 800a24e:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
 800a252:	429a      	cmp	r2, r3
 800a254:	d903      	bls.n	800a25e <SFU_LOADER_VerifyFwHeader+0x126>
      {
        /* The firmware cannot be written in dwl slot */
        m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800a256:	4b15      	ldr	r3, [pc, #84]	@ (800a2ac <SFU_LOADER_VerifyFwHeader+0x174>)
 800a258:	2203      	movs	r2, #3
 800a25a:	701a      	strb	r2, [r3, #0]
 800a25c:	e011      	b.n	800a282 <SFU_LOADER_VerifyFwHeader+0x14a>
      }
      else
      {
        /* Installation authorized */
        e_ret_status = SFU_SUCCESS;
 800a25e:	4b12      	ldr	r3, [pc, #72]	@ (800a2a8 <SFU_LOADER_VerifyFwHeader+0x170>)
 800a260:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800a262:	e00e      	b.n	800a282 <SFU_LOADER_VerifyFwHeader+0x14a>
    }
    else
    {
      /* The installation is forbidden */
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
            p_x_fw_raw_header->FwVersion, verif_ver, SFU_FW_VERSION_START_NUM);
 800a264:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a266:	88db      	ldrh	r3, [r3, #6]
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
 800a268:	4619      	mov	r1, r3
 800a26a:	8c3a      	ldrh	r2, [r7, #32]
 800a26c:	2301      	movs	r3, #1
 800a26e:	4810      	ldr	r0, [pc, #64]	@ (800a2b0 <SFU_LOADER_VerifyFwHeader+0x178>)
 800a270:	f003 f8f2 	bl	800d458 <iprintf>
      m_LoaderStatus = SFU_LOADER_ERR_FW_VERSION;
 800a274:	4b0d      	ldr	r3, [pc, #52]	@ (800a2ac <SFU_LOADER_VerifyFwHeader+0x174>)
 800a276:	2204      	movs	r2, #4
 800a278:	701a      	strb	r2, [r3, #0]
 800a27a:	e002      	b.n	800a282 <SFU_LOADER_VerifyFwHeader+0x14a>
    }
  }
  else
  {
    /* Header authentication failure */
    m_LoaderStatus = SFU_LOADER_ERR_AUTH_FAILED;
 800a27c:	4b0b      	ldr	r3, [pc, #44]	@ (800a2ac <SFU_LOADER_VerifyFwHeader+0x174>)
 800a27e:	2202      	movs	r2, #2
 800a280:	701a      	strb	r2, [r3, #0]
  }

  return e_ret_status;
 800a282:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 800a284:	4618      	mov	r0, r3
 800a286:	3730      	adds	r7, #48	@ 0x30
 800a288:	46bd      	mov	sp, r7
 800a28a:	bd80      	pop	{r7, pc}
 800a28c:	00018799 	.word	0x00018799
 800a290:	2000174c 	.word	0x2000174c
 800a294:	0800e444 	.word	0x0800e444
 800a298:	0800e424 	.word	0x0800e424
 800a29c:	20001758 	.word	0x20001758
 800a2a0:	20001754 	.word	0x20001754
 800a2a4:	20001750 	.word	0x20001750
 800a2a8:	00122f11 	.word	0x00122f11
 800a2ac:	20001748 	.word	0x20001748
 800a2b0:	0800e484 	.word	0x0800e484

0800a2b4 <SFU_LOADER_Init>:
}
 800a2b4:	4800      	ldr	r0, [pc, #0]	@ (800a2b8 <SFU_LOADER_Init+0x4>)
 800a2b6:	4770      	bx	lr
 800a2b8:	00122f11 	.word	0x00122f11

0800a2bc <SFU_LOADER_DeInit>:
SFU_ErrorStatus SFU_LOADER_DeInit(void)
 800a2bc:	4800      	ldr	r0, [pc, #0]	@ (800a2c0 <SFU_LOADER_DeInit+0x4>)
 800a2be:	4770      	bx	lr
 800a2c0:	00122f11 	.word	0x00122f11

0800a2c4 <SFU_LOADER_DownloadNewUserFw>:
{
 800a2c4:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
  SFU_COM_YMODEM_StatusTypeDef e_com_status = SFU_COM_YMODEM_ERROR;
 800a2c8:	f04f 0a01 	mov.w	sl, #1
{
 800a2cc:	b08c      	sub	sp, #48	@ 0x30
  int32_t fw_tag_len = 0;
 800a2ce:	2400      	movs	r4, #0
{
 800a2d0:	4689      	mov	r9, r1
 800a2d2:	4616      	mov	r6, r2
  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
 800a2d4:	4680      	mov	r8, r0
  SFU_COM_YMODEM_StatusTypeDef e_com_status = SFU_COM_YMODEM_ERROR;
 800a2d6:	f88d a007 	strb.w	sl, [sp, #7]
  int32_t fw_tag_len = 0;
 800a2da:	9403      	str	r4, [sp, #12]
  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
 800a2dc:	b108      	cbz	r0, 800a2e2 <SFU_LOADER_DownloadNewUserFw+0x1e>
 800a2de:	b102      	cbz	r2, 800a2e2 <SFU_LOADER_DownloadNewUserFw+0x1e>
 800a2e0:	b921      	cbnz	r1, 800a2ec <SFU_LOADER_DownloadNewUserFw+0x28>
    return SFU_ERROR;
 800a2e2:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
}
 800a2e6:	b00c      	add	sp, #48	@ 0x30
 800a2e8:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
  (void) SFU_LL_SECU_IWDG_Refresh();
 800a2ec:	f000 fe0a 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
  TRACE("\r\n\t  File> Transfer> YMODEM> Send ");
 800a2f0:	481f      	ldr	r0, [pc, #124]	@ (800a370 <SFU_LOADER_DownloadNewUserFw+0xac>)
 800a2f2:	f003 f8b1 	bl	800d458 <iprintf>
  m_uDwlAreaStart = 0U;
 800a2f6:	4a1f      	ldr	r2, [pc, #124]	@ (800a374 <SFU_LOADER_DownloadNewUserFw+0xb0>)
  m_uDwlAreaAddress = 0U;
 800a2f8:	4b1f      	ldr	r3, [pc, #124]	@ (800a378 <SFU_LOADER_DownloadNewUserFw+0xb4>)
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800a2fa:	4631      	mov	r1, r6
  m_uDwlAreaStart = 0U;
 800a2fc:	6014      	str	r4, [r2, #0]
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800a2fe:	f10d 0007 	add.w	r0, sp, #7
  m_uDwlAreaSize = 0U;
 800a302:	4a1e      	ldr	r2, [pc, #120]	@ (800a37c <SFU_LOADER_DownloadNewUserFw+0xb8>)
  m_uDwlSlot = SLOT_ACTIVE_1;
 800a304:	f8df b08c 	ldr.w	fp, [pc, #140]	@ 800a394 <SFU_LOADER_DownloadNewUserFw+0xd0>
  m_uDwlAreaSize = 0U;
 800a308:	6014      	str	r4, [r2, #0]
  m_LoaderStatus = SFU_LOADER_ERR_COM;
 800a30a:	4d1d      	ldr	r5, [pc, #116]	@ (800a380 <SFU_LOADER_DownloadNewUserFw+0xbc>)
  m_uActiveHeaderStart = 0U;
 800a30c:	4a1d      	ldr	r2, [pc, #116]	@ (800a384 <SFU_LOADER_DownloadNewUserFw+0xc0>)
  m_uDwlAreaAddress = 0U;
 800a30e:	601c      	str	r4, [r3, #0]
  m_uActiveHeaderStart = 0U;
 800a310:	6014      	str	r4, [r2, #0]
  m_uDwlSlot = SLOT_ACTIVE_1;
 800a312:	f8cb a000 	str.w	sl, [fp]
  m_LoaderStatus = SFU_LOADER_ERR_COM;
 800a316:	f885 a000 	strb.w	sl, [r5]
  m_uFileSizeYmodem = 0U;
 800a31a:	e9c3 4401 	strd	r4, r4, [r3, #4]
  m_uPacketsReceived = 0U;
 800a31e:	e9c3 4403 	strd	r4, r4, [r3, #12]
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800a322:	f7ff f991 	bl	8009648 <SFU_COM_YMODEM_Receive>
 800a326:	4b18      	ldr	r3, [pc, #96]	@ (800a388 <SFU_LOADER_DownloadNewUserFw+0xc4>)
 800a328:	4298      	cmp	r0, r3
 800a32a:	d102      	bne.n	800a332 <SFU_LOADER_DownloadNewUserFw+0x6e>
    if (*pSize > 0U)
 800a32c:	6833      	ldr	r3, [r6, #0]
 800a32e:	b103      	cbz	r3, 800a332 <SFU_LOADER_DownloadNewUserFw+0x6e>
      m_LoaderStatus = SFU_LOADER_OK;
 800a330:	702c      	strb	r4, [r5, #0]
  *pDwlSlot = m_uDwlSlot;
 800a332:	f8db 3000 	ldr.w	r3, [fp]
 800a336:	f8c9 3000 	str.w	r3, [r9]
  if (m_LoaderStatus == SFU_LOADER_OK)
 800a33a:	782b      	ldrb	r3, [r5, #0]
 800a33c:	b95b      	cbnz	r3, 800a356 <SFU_LOADER_DownloadNewUserFw+0x92>
    fw_tag_len = sizeof(fw_tag_output);
 800a33e:	2320      	movs	r3, #32
    if (SE_Decrypt_Finish(&e_se_status, fw_tag_output, &fw_tag_len) != SE_SUCCESS)
 800a340:	aa03      	add	r2, sp, #12
 800a342:	a904      	add	r1, sp, #16
 800a344:	a802      	add	r0, sp, #8
    fw_tag_len = sizeof(fw_tag_output);
 800a346:	9303      	str	r3, [sp, #12]
    if (SE_Decrypt_Finish(&e_se_status, fw_tag_output, &fw_tag_len) != SE_SUCCESS)
 800a348:	f7fe f874 	bl	8008434 <SE_Decrypt_Finish>
 800a34c:	4b0f      	ldr	r3, [pc, #60]	@ (800a38c <SFU_LOADER_DownloadNewUserFw+0xc8>)
 800a34e:	4298      	cmp	r0, r3
 800a350:	d008      	beq.n	800a364 <SFU_LOADER_DownloadNewUserFw+0xa0>
      m_LoaderStatus = SFU_LOADER_ERR_CRYPTO;
 800a352:	2306      	movs	r3, #6
 800a354:	702b      	strb	r3, [r5, #0]
  *peSFU_LOADER_Status = m_LoaderStatus;
 800a356:	782b      	ldrb	r3, [r5, #0]
 800a358:	f888 3000 	strb.w	r3, [r8]
  if (m_LoaderStatus == SFU_LOADER_OK)
 800a35c:	2b00      	cmp	r3, #0
 800a35e:	d1c0      	bne.n	800a2e2 <SFU_LOADER_DownloadNewUserFw+0x1e>
    e_ret_status = SFU_SUCCESS;
 800a360:	4809      	ldr	r0, [pc, #36]	@ (800a388 <SFU_LOADER_DownloadNewUserFw+0xc4>)
 800a362:	e7c0      	b.n	800a2e6 <SFU_LOADER_DownloadNewUserFw+0x22>
    else if (e_se_status != SE_OK)
 800a364:	4b0a      	ldr	r3, [pc, #40]	@ (800a390 <SFU_LOADER_DownloadNewUserFw+0xcc>)
 800a366:	9a02      	ldr	r2, [sp, #8]
 800a368:	429a      	cmp	r2, r3
 800a36a:	d1f2      	bne.n	800a352 <SFU_LOADER_DownloadNewUserFw+0x8e>
 800a36c:	e7f3      	b.n	800a356 <SFU_LOADER_DownloadNewUserFw+0x92>
 800a36e:	bf00      	nop
 800a370:	0800e4e8 	.word	0x0800e4e8
 800a374:	20001758 	.word	0x20001758
 800a378:	20001760 	.word	0x20001760
 800a37c:	20001754 	.word	0x20001754
 800a380:	20001748 	.word	0x20001748
 800a384:	20001750 	.word	0x20001750
 800a388:	00122f11 	.word	0x00122f11
 800a38c:	0012310f 	.word	0x0012310f
 800a390:	0012e223 	.word	0x0012e223
 800a394:	2000174c 	.word	0x2000174c

0800a398 <SFU_COM_YMODEM_HeaderPktRxCpltCallback>:
{
 800a398:	b508      	push	{r3, lr}
  m_uPacketsReceived = 0U;
 800a39a:	4b07      	ldr	r3, [pc, #28]	@ (800a3b8 <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x20>)
 800a39c:	2200      	movs	r2, #0
  m_uFileSizeYmodem = uFileSize;
 800a39e:	6098      	str	r0, [r3, #8]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKET_1K_SIZE - 1U)) / SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a3a0:	f200 30ff 	addw	r0, r0, #1023	@ 0x3ff
  m_uPacketsReceived = 0U;
 800a3a4:	611a      	str	r2, [r3, #16]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKET_1K_SIZE - 1U)) / SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a3a6:	0a80      	lsrs	r0, r0, #10
 800a3a8:	60d8      	str	r0, [r3, #12]
  HAL_Delay(1000U);
 800a3aa:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800a3ae:	f000 ff47 	bl	800b240 <HAL_Delay>
}
 800a3b2:	4802      	ldr	r0, [pc, #8]	@ (800a3bc <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x24>)
 800a3b4:	bd08      	pop	{r3, pc}
 800a3b6:	bf00      	nop
 800a3b8:	20001760 	.word	0x20001760
 800a3bc:	00122f11 	.word	0x00122f11

0800a3c0 <SFU_COM_YMODEM_DataPktRxCpltCallback>:
{
 800a3c0:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  SE_StatusTypeDef e_se_status = SE_KO;
 800a3c4:	4b72      	ldr	r3, [pc, #456]	@ (800a590 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d0>)
{
 800a3c6:	b086      	sub	sp, #24
 800a3c8:	460d      	mov	r5, r1
  if (p_data == NULL)
 800a3ca:	4680      	mov	r8, r0
  SE_StatusTypeDef e_se_status = SE_KO;
 800a3cc:	9305      	str	r3, [sp, #20]
  if (p_data == NULL)
 800a3ce:	2800      	cmp	r0, #0
 800a3d0:	f000 80db 	beq.w	800a58a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ca>
  m_uPacketsReceived++;
 800a3d4:	4c6f      	ldr	r4, [pc, #444]	@ (800a594 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d4>)
 800a3d6:	6923      	ldr	r3, [r4, #16]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a3d8:	68e2      	ldr	r2, [r4, #12]
  m_uPacketsReceived++;
 800a3da:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a3dc:	4293      	cmp	r3, r2
  m_uPacketsReceived++;
 800a3de:	6123      	str	r3, [r4, #16]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a3e0:	d106      	bne.n	800a3f0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x30>
    if (0U == (m_uFileSizeYmodem % SFU_COM_YMODEM_PACKET_1K_SIZE))
 800a3e2:	68a5      	ldr	r5, [r4, #8]
 800a3e4:	f3c5 0509 	ubfx	r5, r5, #0, #10
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a3e8:	2d00      	cmp	r5, #0
 800a3ea:	bf08      	it	eq
 800a3ec:	f44f 6580 	moveq.w	r5, #1024	@ 0x400
  if (m_uPacketsReceived == 1U)
 800a3f0:	2b01      	cmp	r3, #1
 800a3f2:	d16d      	bne.n	800a4d0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x110>
    (void) memcpy(fw_header, p_data, SE_FW_HEADER_TOT_LEN);
 800a3f4:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 800a3f8:	4641      	mov	r1, r8
 800a3fa:	4867      	ldr	r0, [pc, #412]	@ (800a598 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d8>)
 800a3fc:	f003 fab3 	bl	800d966 <memcpy>
    e_ret_status = SFU_LOADER_VerifyFwHeader(p_data);
 800a400:	4640      	mov	r0, r8
 800a402:	f7ff fe99 	bl	800a138 <SFU_LOADER_VerifyFwHeader>
    if (e_ret_status == SFU_SUCCESS)
 800a406:	4b65      	ldr	r3, [pc, #404]	@ (800a59c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1dc>)
    e_ret_status = SFU_LOADER_VerifyFwHeader(p_data);
 800a408:	4606      	mov	r6, r0
    if (e_ret_status == SFU_SUCCESS)
 800a40a:	4298      	cmp	r0, r3
 800a40c:	d118      	bne.n	800a440 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x80>
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800a40e:	4b64      	ldr	r3, [pc, #400]	@ (800a5a0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e0>)
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uActiveHeaderAddress, SFU_IMG_IMAGE_OFFSET) !=
 800a410:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800a414:	f10d 000f 	add.w	r0, sp, #15
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800a418:	681b      	ldr	r3, [r3, #0]
 800a41a:	6023      	str	r3, [r4, #0]
      m_uActiveHeaderAddress = m_uActiveHeaderStart;
 800a41c:	4b61      	ldr	r3, [pc, #388]	@ (800a5a4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e4>)
 800a41e:	6819      	ldr	r1, [r3, #0]
      m_uDwlImgSize = ((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->FwSize + SFU_IMG_IMAGE_OFFSET;
 800a420:	6a23      	ldr	r3, [r4, #32]
      m_uActiveHeaderAddress = m_uActiveHeaderStart;
 800a422:	6061      	str	r1, [r4, #4]
      m_uDwlImgSize = ((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->FwSize + SFU_IMG_IMAGE_OFFSET;
 800a424:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800a428:	f8c4 3158 	str.w	r3, [r4, #344]	@ 0x158
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uActiveHeaderAddress, SFU_IMG_IMAGE_OFFSET) !=
 800a42c:	f000 fa98 	bl	800a960 <SFU_LL_FLASH_Erase_Size>
 800a430:	42b0      	cmp	r0, r6
 800a432:	4681      	mov	r9, r0
 800a434:	d016      	beq.n	800a464 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xa4>
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a436:	2305      	movs	r3, #5
        m_LoaderStatus = SFU_LOADER_ERR_CRYPTO;
 800a438:	4a5b      	ldr	r2, [pc, #364]	@ (800a5a8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e8>)
      e_ret_status = SFU_ERROR;
 800a43a:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
        m_LoaderStatus = SFU_LOADER_ERR_CRYPTO;
 800a43e:	7013      	strb	r3, [r2, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a440:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 800a444:	429a      	cmp	r2, r3
    m_uPacketsReceived = 0U;
 800a446:	bf04      	itt	eq
 800a448:	2300      	moveq	r3, #0
 800a44a:	6123      	streq	r3, [r4, #16]
  if (e_ret_status == SFU_ERROR)
 800a44c:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 800a450:	429e      	cmp	r6, r3
 800a452:	d103      	bne.n	800a45c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x9c>
    m_uFileSizeYmodem = 0U;
 800a454:	2300      	movs	r3, #0
 800a456:	60a3      	str	r3, [r4, #8]
    m_uNbrBlocksYmodem = 0U;
 800a458:	e9c4 3303 	strd	r3, r3, [r4, #12]
}
 800a45c:	4630      	mov	r0, r6
 800a45e:	b006      	add	sp, #24
 800a460:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uDwlAreaAddress, SLOT_SIZE(m_uDwlSlot)) !=
 800a464:	4b51      	ldr	r3, [pc, #324]	@ (800a5ac <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ec>)
 800a466:	f10d 000f 	add.w	r0, sp, #15
 800a46a:	4951      	ldr	r1, [pc, #324]	@ (800a5b0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f0>)
 800a46c:	681a      	ldr	r2, [r3, #0]
 800a46e:	4b51      	ldr	r3, [pc, #324]	@ (800a5b4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f4>)
 800a470:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a474:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800a478:	3301      	adds	r3, #1
 800a47a:	6821      	ldr	r1, [r4, #0]
 800a47c:	1a9a      	subs	r2, r3, r2
 800a47e:	f000 fa6f 	bl	800a960 <SFU_LL_FLASH_Erase_Size>
 800a482:	4548      	cmp	r0, r9
 800a484:	4606      	mov	r6, r0
 800a486:	d1d6      	bne.n	800a436 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x76>
      if (SE_Decrypt_Init(&e_se_status, (SE_FwRawHeaderTypeDef *)fw_header, SE_FW_IMAGE_COMPLETE) != SE_SUCCESS)
 800a488:	2200      	movs	r2, #0
 800a48a:	4943      	ldr	r1, [pc, #268]	@ (800a598 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d8>)
 800a48c:	a805      	add	r0, sp, #20
 800a48e:	f7fd ff5d 	bl	800834c <SE_Decrypt_Init>
 800a492:	4b49      	ldr	r3, [pc, #292]	@ (800a5b8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f8>)
 800a494:	4298      	cmp	r0, r3
 800a496:	d001      	beq.n	800a49c <SFU_COM_YMODEM_DataPktRxCpltCallback+0xdc>
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a498:	2306      	movs	r3, #6
 800a49a:	e7cd      	b.n	800a438 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x78>
      else if (e_se_status != SE_OK)
 800a49c:	4b47      	ldr	r3, [pc, #284]	@ (800a5bc <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1fc>)
 800a49e:	9a05      	ldr	r2, [sp, #20]
 800a4a0:	429a      	cmp	r2, r3
 800a4a2:	d1f9      	bne.n	800a498 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
        if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uActiveHeaderAddress, p_data, SE_FW_HEADER_TOT_LEN) ==
 800a4a4:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 800a4a8:	4642      	mov	r2, r8
 800a4aa:	6861      	ldr	r1, [r4, #4]
 800a4ac:	f10d 000f 	add.w	r0, sp, #15
 800a4b0:	f000 fa5d 	bl	800a96e <SFU_LL_FLASH_Write>
 800a4b4:	42b0      	cmp	r0, r6
 800a4b6:	d1be      	bne.n	800a436 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x76>
          m_uDwlAreaAddress += SE_FW_HEADER_TOT_LEN;
 800a4b8:	6823      	ldr	r3, [r4, #0]
          rx_size -= SE_FW_HEADER_TOT_LEN;
 800a4ba:	f5a5 75a0 	sub.w	r5, r5, #320	@ 0x140
          p_data += SE_FW_HEADER_TOT_LEN;
 800a4be:	f508 78a0 	add.w	r8, r8, #320	@ 0x140
          m_uDwlAreaAddress += SE_FW_HEADER_TOT_LEN;
 800a4c2:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 800a4c6:	6023      	str	r3, [r4, #0]
          m_uActiveHeaderAddress += SE_FW_HEADER_TOT_LEN;
 800a4c8:	6863      	ldr	r3, [r4, #4]
 800a4ca:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 800a4ce:	6063      	str	r3, [r4, #4]
    if (m_uDwlAreaAddress < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET))
 800a4d0:	4e33      	ldr	r6, [pc, #204]	@ (800a5a0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e0>)
 800a4d2:	6823      	ldr	r3, [r4, #0]
 800a4d4:	6830      	ldr	r0, [r6, #0]
 800a4d6:	f500 6280 	add.w	r2, r0, #1024	@ 0x400
 800a4da:	429a      	cmp	r2, r3
 800a4dc:	d91d      	bls.n	800a51a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x15a>
      if ((m_uDwlAreaAddress + rx_size) < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET))
 800a4de:	1959      	adds	r1, r3, r5
 800a4e0:	428a      	cmp	r2, r1
 800a4e2:	d90e      	bls.n	800a502 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x142>
        m_uActiveHeaderAddress += rx_size;
 800a4e4:	6863      	ldr	r3, [r4, #4]
        m_uDwlAreaAddress += rx_size;
 800a4e6:	6021      	str	r1, [r4, #0]
        m_uActiveHeaderAddress += rx_size;
 800a4e8:	442b      	add	r3, r5
 800a4ea:	6063      	str	r3, [r4, #4]
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a4ec:	2500      	movs	r5, #0
    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlImgSize))
 800a4ee:	6821      	ldr	r1, [r4, #0]
 800a4f0:	6833      	ldr	r3, [r6, #0]
 800a4f2:	f8d4 2158 	ldr.w	r2, [r4, #344]	@ 0x158
 800a4f6:	1948      	adds	r0, r1, r5
 800a4f8:	441a      	add	r2, r3
 800a4fa:	4290      	cmp	r0, r2
 800a4fc:	d923      	bls.n	800a546 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x186>
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a4fe:	2303      	movs	r3, #3
 800a500:	e79a      	b.n	800a438 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x78>
        rx_size -= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a502:	f5a3 6180 	sub.w	r1, r3, #1024	@ 0x400
        p_data += (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a506:	1ad3      	subs	r3, r2, r3
        m_uDwlAreaAddress += (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a508:	6022      	str	r2, [r4, #0]
        p_data += (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a50a:	4498      	add	r8, r3
        m_uActiveHeaderAddress += (m_uActiveHeaderStart + SFU_IMG_IMAGE_OFFSET - m_uActiveHeaderAddress);
 800a50c:	4b25      	ldr	r3, [pc, #148]	@ (800a5a4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e4>)
        rx_size -= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a50e:	1a09      	subs	r1, r1, r0
        m_uActiveHeaderAddress += (m_uActiveHeaderStart + SFU_IMG_IMAGE_OFFSET - m_uActiveHeaderAddress);
 800a510:	681b      	ldr	r3, [r3, #0]
        rx_size -= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a512:	440d      	add	r5, r1
        m_uActiveHeaderAddress += (m_uActiveHeaderStart + SFU_IMG_IMAGE_OFFSET - m_uActiveHeaderAddress);
 800a514:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800a518:	6063      	str	r3, [r4, #4]
    if (rx_size != 0U)
 800a51a:	2d00      	cmp	r5, #0
 800a51c:	d0e6      	beq.n	800a4ec <SFU_COM_YMODEM_DataPktRxCpltCallback+0x12c>
          && (SE_Decrypt_Append(&e_se_status, p_data, rx_size, fw_decrypted_chunk, &fw_decrypted_chunk_size)
 800a51e:	ab04      	add	r3, sp, #16
 800a520:	462a      	mov	r2, r5
 800a522:	4641      	mov	r1, r8
 800a524:	a805      	add	r0, sp, #20
 800a526:	9300      	str	r3, [sp, #0]
 800a528:	4b25      	ldr	r3, [pc, #148]	@ (800a5c0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x200>)
      fw_decrypted_chunk_size = rx_size;
 800a52a:	9504      	str	r5, [sp, #16]
          && (SE_Decrypt_Append(&e_se_status, p_data, rx_size, fw_decrypted_chunk, &fw_decrypted_chunk_size)
 800a52c:	f7fd ff44 	bl	80083b8 <SE_Decrypt_Append>
 800a530:	4b21      	ldr	r3, [pc, #132]	@ (800a5b8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f8>)
 800a532:	4298      	cmp	r0, r3
 800a534:	d1b0      	bne.n	800a498 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
      else if ((e_se_status != SE_OK) || (fw_decrypted_chunk_size != rx_size))
 800a536:	4b21      	ldr	r3, [pc, #132]	@ (800a5bc <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1fc>)
 800a538:	9a05      	ldr	r2, [sp, #20]
 800a53a:	429a      	cmp	r2, r3
 800a53c:	d1ac      	bne.n	800a498 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
 800a53e:	9b04      	ldr	r3, [sp, #16]
 800a540:	429d      	cmp	r5, r3
 800a542:	d1a9      	bne.n	800a498 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
 800a544:	e7d3      	b.n	800a4ee <SFU_COM_YMODEM_DataPktRxCpltCallback+0x12e>
    if ((rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)) != 0U)
 800a546:	06ea      	lsls	r2, r5, #27
 800a548:	d007      	beq.n	800a55a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x19a>
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800a54a:	f025 021f 	bic.w	r2, r5, #31
        fw_decrypted_chunk[uOldSize] = 0xFF;
 800a54e:	481c      	ldr	r0, [pc, #112]	@ (800a5c0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x200>)
 800a550:	26ff      	movs	r6, #255	@ 0xff
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800a552:	3220      	adds	r2, #32
      while (uOldSize < rx_size)
 800a554:	4295      	cmp	r5, r2
 800a556:	d315      	bcc.n	800a584 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c4>
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800a558:	4615      	mov	r5, r2
    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlAreaSize))
 800a55a:	481a      	ldr	r0, [pc, #104]	@ (800a5c4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x204>)
 800a55c:	194a      	adds	r2, r1, r5
 800a55e:	6800      	ldr	r0, [r0, #0]
 800a560:	4403      	add	r3, r0
 800a562:	429a      	cmp	r2, r3
 800a564:	d8cb      	bhi.n	800a4fe <SFU_COM_YMODEM_DataPktRxCpltCallback+0x13e>
    if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, fw_decrypted_chunk, rx_size) == SFU_SUCCESS)
 800a566:	462b      	mov	r3, r5
 800a568:	4a15      	ldr	r2, [pc, #84]	@ (800a5c0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x200>)
 800a56a:	f10d 000f 	add.w	r0, sp, #15
 800a56e:	f000 f9fe 	bl	800a96e <SFU_LL_FLASH_Write>
 800a572:	4b0a      	ldr	r3, [pc, #40]	@ (800a59c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1dc>)
 800a574:	4606      	mov	r6, r0
 800a576:	4298      	cmp	r0, r3
 800a578:	f47f af5d 	bne.w	800a436 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x76>
      m_uDwlAreaAddress += (rx_size);
 800a57c:	6823      	ldr	r3, [r4, #0]
 800a57e:	442b      	add	r3, r5
 800a580:	6023      	str	r3, [r4, #0]
 800a582:	e75d      	b.n	800a440 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x80>
        fw_decrypted_chunk[uOldSize] = 0xFF;
 800a584:	542e      	strb	r6, [r5, r0]
        uOldSize++;
 800a586:	3501      	adds	r5, #1
 800a588:	e7e4      	b.n	800a554 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x194>
    return SFU_ERROR;
 800a58a:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
 800a58e:	e765      	b.n	800a45c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x9c>
 800a590:	0013023d 	.word	0x0013023d
 800a594:	20001760 	.word	0x20001760
 800a598:	20001778 	.word	0x20001778
 800a59c:	00122f11 	.word	0x00122f11
 800a5a0:	20001758 	.word	0x20001758
 800a5a4:	20001750 	.word	0x20001750
 800a5a8:	20001748 	.word	0x20001748
 800a5ac:	2000174c 	.word	0x2000174c
 800a5b0:	0800e424 	.word	0x0800e424
 800a5b4:	0800e444 	.word	0x0800e444
 800a5b8:	0012310f 	.word	0x0012310f
 800a5bc:	0012e223 	.word	0x0012e223
 800a5c0:	200018bc 	.word	0x200018bc
 800a5c4:	20001754 	.word	0x20001754

0800a5c8 <SFU_MPU_SVC_Handler>:
  *             The first argument is the identifier of the requested operation.
  * @retval void
  */
void SFU_MPU_SVC_Handler(uint32_t *args)
{
  switch (args[0])
 800a5c8:	6803      	ldr	r3, [r0, #0]
 800a5ca:	2b06      	cmp	r3, #6
{
 800a5cc:	b570      	push	{r4, r5, r6, lr}
 800a5ce:	4604      	mov	r4, r0
  switch (args[0])
 800a5d0:	d807      	bhi.n	800a5e2 <SFU_MPU_SVC_Handler+0x1a>
 800a5d2:	2b02      	cmp	r3, #2
 800a5d4:	d839      	bhi.n	800a64a <SFU_MPU_SVC_Handler+0x82>
 800a5d6:	2b01      	cmp	r3, #1
 800a5d8:	d009      	beq.n	800a5ee <SFU_MPU_SVC_Handler+0x26>
    default:
      /* Force a reset */
      HAL_NVIC_SystemReset();
      break;
  }
}
 800a5da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      HAL_NVIC_SystemReset();
 800a5de:	f000 bea1 	b.w	800b324 <HAL_NVIC_SystemReset>
  switch (args[0])
 800a5e2:	2b07      	cmp	r3, #7
 800a5e4:	d1f9      	bne.n	800a5da <SFU_MPU_SVC_Handler+0x12>
}
 800a5e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      HAL_SuspendTick();
 800a5ea:	f000 be3b 	b.w	800b264 <HAL_SuspendTick>
  uint32_t sp_base = SE_REGION_RAM_START;
 800a5ee:	4b17      	ldr	r3, [pc, #92]	@ (800a64c <SFU_MPU_SVC_Handler+0x84>)
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800a5f0:	f3ef 8208 	mrs	r2, MSP
  if ((sp > sp_base) && (sp <= sp_top))
 800a5f4:	4293      	cmp	r3, r2
 800a5f6:	d219      	bcs.n	800a62c <SFU_MPU_SVC_Handler+0x64>
 800a5f8:	4915      	ldr	r1, [pc, #84]	@ (800a650 <SFU_MPU_SVC_Handler+0x88>)
 800a5fa:	428a      	cmp	r2, r1
 800a5fc:	d816      	bhi.n	800a62c <SFU_MPU_SVC_Handler+0x64>
      *(__IO uint32_t *)sp_base = 0U;
 800a5fe:	2100      	movs	r1, #0
 800a600:	f843 1b04 	str.w	r1, [r3], #4
    while (sp_base < sp)
 800a604:	429a      	cmp	r2, r3
 800a606:	d8fb      	bhi.n	800a600 <SFU_MPU_SVC_Handler+0x38>
      SFU_SecUserActivationInRam(args[1]);
 800a608:	6860      	ldr	r0, [r4, #4]
  while (psrc < psrc_end)
 800a60a:	4b12      	ldr	r3, [pc, #72]	@ (800a654 <SFU_MPU_SVC_Handler+0x8c>)
  pdest = (uint32_t *)SB_HDP_CODE_REGION_RAM_START;
 800a60c:	4a12      	ldr	r2, [pc, #72]	@ (800a658 <SFU_MPU_SVC_Handler+0x90>)
  while (psrc < psrc_end)
 800a60e:	4c13      	ldr	r4, [pc, #76]	@ (800a65c <SFU_MPU_SVC_Handler+0x94>)
 800a610:	42a3      	cmp	r3, r4
 800a612:	4619      	mov	r1, r3
 800a614:	d30d      	bcc.n	800a632 <SFU_MPU_SVC_Handler+0x6a>
 800a616:	4d10      	ldr	r5, [pc, #64]	@ (800a658 <SFU_MPU_SVC_Handler+0x90>)
  uint32_t result = 0U;
 800a618:	2300      	movs	r3, #0
  psrc = (uint32_t *)(SB_HDP_REGION_ROM_START);
 800a61a:	4a0e      	ldr	r2, [pc, #56]	@ (800a654 <SFU_MPU_SVC_Handler+0x8c>)
  while (psrc < psrc_end)
 800a61c:	42a2      	cmp	r2, r4
 800a61e:	d30d      	bcc.n	800a63c <SFU_MPU_SVC_Handler+0x74>
  if (result == 0U)
 800a620:	2b00      	cmp	r3, #0
 800a622:	d1da      	bne.n	800a5da <SFU_MPU_SVC_Handler+0x12>
}
 800a624:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    SFU_LL_SECU_ActivateSecUser(Address);
 800a628:	f003 bec6 	b.w	800e3b8 <__SFU_LL_SECU_ActivateSecUser_veneer>
    HAL_NVIC_SystemReset();
 800a62c:	f000 fe7a 	bl	800b324 <HAL_NVIC_SystemReset>
 800a630:	e7ea      	b.n	800a608 <SFU_MPU_SVC_Handler+0x40>
    *pdest = *psrc;
 800a632:	6809      	ldr	r1, [r1, #0]
 800a634:	3304      	adds	r3, #4
 800a636:	f842 1b04 	str.w	r1, [r2], #4
    psrc++;
 800a63a:	e7e9      	b.n	800a610 <SFU_MPU_SVC_Handler+0x48>
    result |= (*pdest ^ *psrc);
 800a63c:	f855 1b04 	ldr.w	r1, [r5], #4
 800a640:	f852 6b04 	ldr.w	r6, [r2], #4
 800a644:	4071      	eors	r1, r6
 800a646:	430b      	orrs	r3, r1
    psrc++;
 800a648:	e7e8      	b.n	800a61c <SFU_MPU_SVC_Handler+0x54>
}
 800a64a:	bd70      	pop	{r4, r5, r6, pc}
 800a64c:	20000000 	.word	0x20000000
 800a650:	20000400 	.word	0x20000400
 800a654:	08008900 	.word	0x08008900
 800a658:	20001000 	.word	0x20001000
 800a65c:	080089ff 	.word	0x080089ff

0800a660 <MPU_SVC_Handler>:
  uint8_t code = ((uint8_t *)args[6])[-2];
 800a660:	6983      	ldr	r3, [r0, #24]
 800a662:	f813 3c02 	ldrb.w	r3, [r3, #-2]
  switch (code)
 800a666:	b11b      	cbz	r3, 800a670 <MPU_SVC_Handler+0x10>
 800a668:	2b01      	cmp	r3, #1
 800a66a:	d003      	beq.n	800a674 <MPU_SVC_Handler+0x14>
      HAL_NVIC_SystemReset();
 800a66c:	f000 be5a 	b.w	800b324 <HAL_NVIC_SystemReset>
      SE_SVC_Handler(args);
 800a670:	f7fe b802 	b.w	8008678 <SE_SVC_Handler>
      SFU_MPU_SVC_Handler(args);
 800a674:	f7ff bfa8 	b.w	800a5c8 <SFU_MPU_SVC_Handler>

0800a678 <SFU_MPU_SysCall>:
  * @param syscall The identifier of the operation to be called (see @ref SFU_MPU_PrivilegedOpId)
  * @param arguments arguments of the privileged operation
  * @retval void
  */
void SFU_MPU_SysCall(uint32_t syscall, ...)
{
 800a678:	b40f      	push	{r0, r1, r2, r3}
  /*
    * You cannot directly change to privileged mode from unprivileged mode without going through an exception, for
    * example an SVC.
    * Handled by @ref MPU_SVC_Handler() and finally @ref SFU_MPU_SVC_Handler()
    */
  __ASM volatile("SVC #1");   /* 1 is the hard-coded value to indicate a SB_SFU syscall */
 800a67a:	df01      	svc	1
}
 800a67c:	b004      	add	sp, #16
 800a67e:	4770      	bx	lr

0800a680 <SFU_MPU_IsUnprivileged>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800a680:	f3ef 8305 	mrs	r3, IPSR
  * @param void
  * @retval 0 if we are in privileged mode, 1 if we are in non-privileged mode
  */
uint32_t SFU_MPU_IsUnprivileged(void)
{
  return ((__get_IPSR() == 0U) && ((__get_CONTROL() & 1U) == 1U));
 800a684:	b923      	cbnz	r3, 800a690 <SFU_MPU_IsUnprivileged+0x10>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 800a686:	f3ef 8014 	mrs	r0, CONTROL
 800a68a:	f000 0001 	and.w	r0, r0, #1
 800a68e:	4770      	bx	lr
 800a690:	2000      	movs	r0, #0
}
 800a692:	4770      	bx	lr

0800a694 <SFU_MPU_EnterUnprivilegedMode>:
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800a694:	f3ef 8308 	mrs	r3, MSP
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800a698:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800a69c:	4b05      	ldr	r3, [pc, #20]	@ (800a6b4 <SFU_MPU_EnterUnprivilegedMode+0x20>)
 800a69e:	f383 8808 	msr	MSP, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 800a6a2:	f3ef 8314 	mrs	r3, CONTROL
  */
void SFU_MPU_EnterUnprivilegedMode(void)
{
  __set_PSP(__get_MSP()); /* set up Process Stack Pointer to current stack pointer */
  __set_MSP(SE_REGION_RAM_STACK_TOP); /* change main stack to point on privileged stack */
  __set_CONTROL(__get_CONTROL() | 3U); /* bit 0 = 1: unprivileged      bit 1=1: stack=PSP */
 800a6a6:	f043 0303 	orr.w	r3, r3, #3
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 800a6aa:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
 800a6ae:	f3bf 8f6f 	isb	sy
  __ISB();
}
 800a6b2:	4770      	bx	lr
 800a6b4:	20000400 	.word	0x20000400

0800a6b8 <SFU_IMG_GetDownloadAreaInfo>:
  * @param  pArea pointer to area descriptor
  * @retval none
  */
void SFU_IMG_GetDownloadAreaInfo(uint32_t DwlSlot, SFU_FwImageFlashTypeDef *pArea)
{
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800a6b8:	4b08      	ldr	r3, [pc, #32]	@ (800a6dc <SFU_IMG_GetDownloadAreaInfo+0x24>)
 800a6ba:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
 800a6be:	4b08      	ldr	r3, [pc, #32]	@ (800a6e0 <SFU_IMG_GetDownloadAreaInfo+0x28>)
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800a6c0:	604a      	str	r2, [r1, #4]
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
 800a6c2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800a6c6:	3301      	adds	r3, #1
 800a6c8:	1a9b      	subs	r3, r3, r2
 800a6ca:	600b      	str	r3, [r1, #0]
  pArea->ImageOffsetInBytes = SFU_IMG_IMAGE_OFFSET;
 800a6cc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800a6d0:	608b      	str	r3, [r1, #8]
#if  (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LOADER)
  pArea->ActiveHeaderAddr = SlotHeaderAdd[DwlSlot];
 800a6d2:	4b04      	ldr	r3, [pc, #16]	@ (800a6e4 <SFU_IMG_GetDownloadAreaInfo+0x2c>)
 800a6d4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800a6d8:	610b      	str	r3, [r1, #16]
#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LOADER) */
}
 800a6da:	4770      	bx	lr
 800a6dc:	0800e424 	.word	0x0800e424
 800a6e0:	0800e444 	.word	0x0800e444
 800a6e4:	0800e464 	.word	0x0800e464

0800a6e8 <SFU_LL_DeInit>:

  /* ADD SRC CODE HERE
       ...
  */
  return e_ret_status;
}
 800a6e8:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a6ec:	4770      	bx	lr
	...

0800a6f0 <SFU_LL_CRC_Config>:
  * @param  eCRCConfg: SFU_CRC_ConfigTypeDef.
  *         This parameter can be a value of @ref SFU_CRC_ConfigTypeDef.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_CRC_Config(SFU_CRC_ConfigTypeDef eCRCConfg)
{
 800a6f0:	b508      	push	{r3, lr}

  /* Check the parameters */
  assert_param(IS_SFU_CRC_CONF(eCRCConfg));

  /* Switch to the selected configuration */
  CrcHandle.Instance = CRC;
 800a6f2:	4a11      	ldr	r2, [pc, #68]	@ (800a738 <SFU_LL_CRC_Config+0x48>)
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;

  switch (eCRCConfg)
 800a6f4:	2801      	cmp	r0, #1
  CrcHandle.Instance = CRC;
 800a6f6:	4b11      	ldr	r3, [pc, #68]	@ (800a73c <SFU_LL_CRC_Config+0x4c>)
 800a6f8:	601a      	str	r2, [r3, #0]
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 800a6fa:	f04f 0200 	mov.w	r2, #0
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 800a6fe:	e9c3 2205 	strd	r2, r2, [r3, #20]
  switch (eCRCConfg)
 800a702:	d004      	beq.n	800a70e <SFU_LL_CRC_Config+0x1e>
 800a704:	2802      	cmp	r0, #2
 800a706:	d00c      	beq.n	800a722 <SFU_LL_CRC_Config+0x32>
      e_ret_status = SFU_SUCCESS;
      break;

    default:
      /* Invalid parameter */
      e_ret_status = SFU_ERROR;
 800a708:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
      e_ret_status = SFU_ERROR;
    }
  }

  return e_ret_status;
}
 800a70c:	bd08      	pop	{r3, pc}
      CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800a70e:	809a      	strh	r2, [r3, #4]
 800a710:	2203      	movs	r2, #3
    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 800a712:	480a      	ldr	r0, [pc, #40]	@ (800a73c <SFU_LL_CRC_Config+0x4c>)
      CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 800a714:	621a      	str	r2, [r3, #32]
    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 800a716:	f000 fe71 	bl	800b3fc <HAL_CRC_Init>
 800a71a:	2800      	cmp	r0, #0
 800a71c:	d1f4      	bne.n	800a708 <SFU_LL_CRC_Config+0x18>
 800a71e:	4808      	ldr	r0, [pc, #32]	@ (800a740 <SFU_LL_CRC_Config+0x50>)
  return e_ret_status;
 800a720:	e7f4      	b.n	800a70c <SFU_LL_CRC_Config+0x1c>
      CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 800a722:	2108      	movs	r1, #8
 800a724:	f241 0021 	movw	r0, #4129	@ 0x1021
      CrcHandle.Init.InitValue               = 0U;
 800a728:	611a      	str	r2, [r3, #16]
 800a72a:	2201      	movs	r2, #1
      CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 800a72c:	e9c3 0102 	strd	r0, r1, [r3, #8]
      CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
 800a730:	f240 1101 	movw	r1, #257	@ 0x101
 800a734:	8099      	strh	r1, [r3, #4]
  if (e_ret_status == SFU_SUCCESS)
 800a736:	e7ec      	b.n	800a712 <SFU_LL_CRC_Config+0x22>
 800a738:	58024c00 	.word	0x58024c00
 800a73c:	20001cbc 	.word	0x20001cbc
 800a740:	00122f11 	.word	0x00122f11

0800a744 <SFU_LL_CRC_Init>:
  __HAL_RCC_CRC_CLK_ENABLE();
 800a744:	4b08      	ldr	r3, [pc, #32]	@ (800a768 <SFU_LL_CRC_Init+0x24>)
{
 800a746:	b082      	sub	sp, #8
  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAULT);
 800a748:	2001      	movs	r0, #1
  __HAL_RCC_CRC_CLK_ENABLE();
 800a74a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a74e:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 800a752:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a756:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800a75a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800a75e:	9301      	str	r3, [sp, #4]
 800a760:	9b01      	ldr	r3, [sp, #4]
}
 800a762:	b002      	add	sp, #8
  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAULT);
 800a764:	f7ff bfc4 	b.w	800a6f0 <SFU_LL_CRC_Config>
 800a768:	58024400 	.word	0x58024400

0800a76c <SFU_LL_Init>:
  e_ret_status = SFU_LL_CRC_Init();
 800a76c:	f7ff bfea 	b.w	800a744 <SFU_LL_CRC_Init>

0800a770 <SFU_LL_CRC_Calculate>:
  * @param  pBuffer: pointer to data buffer.
  * @param  BufferLength: buffer length in bytes.
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
uint32_t SFU_LL_CRC_Calculate(uint32_t pBuffer[], uint32_t BufferLength)
{
 800a770:	460a      	mov	r2, r1
  return HAL_CRC_Calculate(&CrcHandle, pBuffer, BufferLength);
 800a772:	4601      	mov	r1, r0
 800a774:	4801      	ldr	r0, [pc, #4]	@ (800a77c <SFU_LL_CRC_Calculate+0xc>)
 800a776:	f000 be7b 	b.w	800b470 <HAL_CRC_Calculate>
 800a77a:	bf00      	nop
 800a77c:	20001cbc 	.word	0x20001cbc

0800a780 <SFU_LL_UART_Init>:
  * @retval status of the Init operation
  *         SFU_ERROR : if the Init operation failed.
  *         SFU_SUCCESS : if the Init operation is successfully performed.
  */
SFU_ErrorStatus SFU_LL_UART_Init(void)
{
 800a780:	b508      	push	{r3, lr}
  - One Stop Bit
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = SFU_UART;
 800a782:	480e      	ldr	r0, [pc, #56]	@ (800a7bc <SFU_LL_UART_Init+0x3c>)
  UartHandle.Init.BaudRate = 115200U;
 800a784:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 800a788:	4a0d      	ldr	r2, [pc, #52]	@ (800a7c0 <SFU_LL_UART_Init+0x40>)
 800a78a:	e9c0 2309 	strd	r2, r3, [r0, #36]	@ 0x24
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800a78e:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 800a790:	e9c0 330b 	strd	r3, r3, [r0, #44]	@ 0x2c
  UartHandle.Init.Parity = UART_PARITY_NONE;
 800a794:	6343      	str	r3, [r0, #52]	@ 0x34
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
  if (HAL_UART_Init(&UartHandle) == HAL_OK)
 800a796:	3024      	adds	r0, #36	@ 0x24
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a798:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 800a79a:	230c      	movs	r3, #12
 800a79c:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 800a79e:	2310      	movs	r3, #16
 800a7a0:	6283      	str	r3, [r0, #40]	@ 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 800a7a2:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800a7a6:	63c3      	str	r3, [r0, #60]	@ 0x3c
  if (HAL_UART_Init(&UartHandle) == HAL_OK)
 800a7a8:	f002 fd64 	bl	800d274 <HAL_UART_Init>
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;

}
 800a7ac:	4a05      	ldr	r2, [pc, #20]	@ (800a7c4 <SFU_LL_UART_Init+0x44>)
 800a7ae:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 800a7b2:	2800      	cmp	r0, #0
 800a7b4:	bf0c      	ite	eq
 800a7b6:	4610      	moveq	r0, r2
 800a7b8:	4618      	movne	r0, r3
 800a7ba:	bd08      	pop	{r3, pc}
 800a7bc:	20001cbc 	.word	0x20001cbc
 800a7c0:	40004800 	.word	0x40004800
 800a7c4:	00122f11 	.word	0x00122f11

0800a7c8 <SFU_LL_UART_DeInit>:

  e_ret_status = SFU_SUCCESS;

  return e_ret_status;

}
 800a7c8:	4800      	ldr	r0, [pc, #0]	@ (800a7cc <SFU_LL_UART_DeInit+0x4>)
 800a7ca:	4770      	bx	lr
 800a7cc:	00122f11 	.word	0x00122f11

0800a7d0 <SFU_LL_UART_Transmit>:
  * @retval status of the write operation
  *         SFU_ERROR : if the write operation is not performed
  *         SFU_SUCCESS : if the write operation is successfully performed
  */
SFU_ErrorStatus SFU_LL_UART_Transmit(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
{
 800a7d0:	b510      	push	{r4, lr}
 800a7d2:	4613      	mov	r3, r2
 800a7d4:	460c      	mov	r4, r1
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check the pointers allocation */
  if (pData == NULL)
 800a7d6:	4601      	mov	r1, r0
 800a7d8:	b910      	cbnz	r0, 800a7e0 <SFU_LL_UART_Transmit+0x10>
  {
    return SFU_ERROR;
 800a7da:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  {
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;
}
 800a7de:	bd10      	pop	{r4, pc}
  if (HAL_UART_Transmit(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
 800a7e0:	4622      	mov	r2, r4
 800a7e2:	4803      	ldr	r0, [pc, #12]	@ (800a7f0 <SFU_LL_UART_Transmit+0x20>)
 800a7e4:	f002 fc2b 	bl	800d03e <HAL_UART_Transmit>
 800a7e8:	2800      	cmp	r0, #0
 800a7ea:	d1f6      	bne.n	800a7da <SFU_LL_UART_Transmit+0xa>
    e_ret_status = SFU_SUCCESS;
 800a7ec:	4801      	ldr	r0, [pc, #4]	@ (800a7f4 <SFU_LL_UART_Transmit+0x24>)
 800a7ee:	e7f6      	b.n	800a7de <SFU_LL_UART_Transmit+0xe>
 800a7f0:	20001ce0 	.word	0x20001ce0
 800a7f4:	00122f11 	.word	0x00122f11

0800a7f8 <SFU_LL_UART_Receive>:
  * @retval status of the read operation
  *         SFU_ERROR : if the read operation is not performed
  *         SFU_SUCCESS : if the read operation is successfully performed
  */
SFU_ErrorStatus SFU_LL_UART_Receive(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
{
 800a7f8:	b510      	push	{r4, lr}
 800a7fa:	4613      	mov	r3, r2
 800a7fc:	460c      	mov	r4, r1
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check the pointers allocation */
  if (pData == NULL)
 800a7fe:	4601      	mov	r1, r0
 800a800:	b910      	cbnz	r0, 800a808 <SFU_LL_UART_Receive+0x10>
  {
    return SFU_ERROR;
 800a802:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  {
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;
}
 800a806:	bd10      	pop	{r4, pc}
  if (HAL_UART_Receive(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
 800a808:	4622      	mov	r2, r4
 800a80a:	4803      	ldr	r0, [pc, #12]	@ (800a818 <SFU_LL_UART_Receive+0x20>)
 800a80c:	f002 fc6c 	bl	800d0e8 <HAL_UART_Receive>
 800a810:	2800      	cmp	r0, #0
 800a812:	d1f6      	bne.n	800a802 <SFU_LL_UART_Receive+0xa>
    e_ret_status = SFU_SUCCESS;
 800a814:	4801      	ldr	r0, [pc, #4]	@ (800a81c <SFU_LL_UART_Receive+0x24>)
 800a816:	e7f6      	b.n	800a806 <SFU_LL_UART_Receive+0xe>
 800a818:	20001ce0 	.word	0x20001ce0
 800a81c:	00122f11 	.word	0x00122f11

0800a820 <SFU_LL_UART_Flush>:
  * @retval status of the operation.
  */
SFU_ErrorStatus SFU_LL_UART_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 800a820:	4b05      	ldr	r3, [pc, #20]	@ (800a838 <SFU_LL_UART_Flush+0x18>)

  return SFU_SUCCESS;
}
 800a822:	4806      	ldr	r0, [pc, #24]	@ (800a83c <SFU_LL_UART_Flush+0x1c>)
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 800a824:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a826:	699a      	ldr	r2, [r3, #24]
 800a828:	f042 0208 	orr.w	r2, r2, #8
 800a82c:	619a      	str	r2, [r3, #24]
 800a82e:	699a      	ldr	r2, [r3, #24]
 800a830:	f042 0210 	orr.w	r2, r2, #16
 800a834:	619a      	str	r2, [r3, #24]
}
 800a836:	4770      	bx	lr
 800a838:	20001cbc 	.word	0x20001cbc
 800a83c:	00122f11 	.word	0x00122f11

0800a840 <SFU_LL_UART_MspInit>:
  */
void SFU_LL_UART_MspInit(UART_HandleTypeDef *huart)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == SFU_UART)
 800a840:	6802      	ldr	r2, [r0, #0]
 800a842:	4b23      	ldr	r3, [pc, #140]	@ (800a8d0 <SFU_LL_UART_MspInit+0x90>)
 800a844:	429a      	cmp	r2, r3
{
 800a846:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a848:	b089      	sub	sp, #36	@ 0x24
  if (huart->Instance == SFU_UART)
 800a84a:	d13e      	bne.n	800a8ca <SFU_LL_UART_MspInit+0x8a>
  {
    /* Peripheral Clock Enable */
    SFU_UART_CLK_ENABLE();
 800a84c:	4b21      	ldr	r3, [pc, #132]	@ (800a8d4 <SFU_LL_UART_MspInit+0x94>)
    SFU_UART_TX_GPIO_CLK_ENABLE();
    SFU_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : SFU_UART_TX_Pin  */
    GPIO_InitStruct.Pin = SFU_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a84e:	2702      	movs	r7, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a850:	2600      	movs	r6, #0
 800a852:	2503      	movs	r5, #3
    SFU_UART_CLK_ENABLE();
 800a854:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
 800a858:	2407      	movs	r4, #7
    HAL_GPIO_Init(SFU_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 800a85a:	a903      	add	r1, sp, #12
 800a85c:	481e      	ldr	r0, [pc, #120]	@ (800a8d8 <SFU_LL_UART_MspInit+0x98>)
    SFU_UART_CLK_ENABLE();
 800a85e:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 800a862:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
 800a866:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 800a86a:	f402 2280 	and.w	r2, r2, #262144	@ 0x40000
 800a86e:	9200      	str	r2, [sp, #0]
 800a870:	9a00      	ldr	r2, [sp, #0]
    SFU_UART_TX_GPIO_CLK_ENABLE();
 800a872:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a876:	f042 0208 	orr.w	r2, r2, #8
 800a87a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a87e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a882:	f002 0208 	and.w	r2, r2, #8
 800a886:	9201      	str	r2, [sp, #4]
 800a888:	9a01      	ldr	r2, [sp, #4]
    SFU_UART_RX_GPIO_CLK_ENABLE();
 800a88a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a88e:	f042 0208 	orr.w	r2, r2, #8
 800a892:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a896:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
 800a89a:	9407      	str	r4, [sp, #28]
    SFU_UART_RX_GPIO_CLK_ENABLE();
 800a89c:	f003 0308 	and.w	r3, r3, #8
 800a8a0:	9302      	str	r3, [sp, #8]
 800a8a2:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a8a4:	f44f 7380 	mov.w	r3, #256	@ 0x100
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a8a8:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a8ac:	e9cd 3703 	strd	r3, r7, [sp, #12]
    HAL_GPIO_Init(SFU_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 800a8b0:	f001 fa42 	bl	800bd38 <HAL_GPIO_Init>

    /*Configure GPIO pins : SFU_UART_RX_Pin  */
    GPIO_InitStruct.Pin = SFU_UART_RX_PIN;
 800a8b4:	f44f 7300 	mov.w	r3, #512	@ 0x200
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
    HAL_GPIO_Init(SFU_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 800a8b8:	a903      	add	r1, sp, #12
 800a8ba:	4807      	ldr	r0, [pc, #28]	@ (800a8d8 <SFU_LL_UART_MspInit+0x98>)
    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
 800a8bc:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a8be:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a8c2:	e9cd 6505 	strd	r6, r5, [sp, #20]
    HAL_GPIO_Init(SFU_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 800a8c6:	f001 fa37 	bl	800bd38 <HAL_GPIO_Init>

  }

}
 800a8ca:	b009      	add	sp, #36	@ 0x24
 800a8cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a8ce:	bf00      	nop
 800a8d0:	40004800 	.word	0x40004800
 800a8d4:	58024400 	.word	0x58024400
 800a8d8:	58020c00 	.word	0x58020c00

0800a8dc <SFU_LL_BufferCheck_in_se_ram>:
  * @param pBuff: Secure Engine protected function ID.
  * @param length: length of buffer in bytes
  * @retval SE_ErrorStatus SE_SUCCESS for buffer in se ram, SE_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_BufferCheck_in_se_ram(const void *pBuff, uint32_t length)
{
 800a8dc:	4603      	mov	r3, r0
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  uint32_t addr_start = (uint32_t)pBuff;
  uint32_t addr_end = addr_start + length - 1U;

  /* Check if length is positive with no overflow and included in the correct range */
  if ((length != 0U) && (!((0xFFFFFFFFUL - addr_start) < length))
 800a8de:	b171      	cbz	r1, 800a8fe <SFU_LL_BufferCheck_in_se_ram+0x22>
 800a8e0:	1842      	adds	r2, r0, r1
 800a8e2:	d20c      	bcs.n	800a8fe <SFU_LL_BufferCheck_in_se_ram+0x22>
  uint32_t addr_end = addr_start + length - 1U;
 800a8e4:	3901      	subs	r1, #1
      && ((addr_end  <= SE_REGION_RAM_END) && (addr_start >= SE_REGION_RAM_START)))
 800a8e6:	4a07      	ldr	r2, [pc, #28]	@ (800a904 <SFU_LL_BufferCheck_in_se_ram+0x28>)
  uint32_t addr_end = addr_start + length - 1U;
 800a8e8:	4401      	add	r1, r0
      && ((addr_end  <= SE_REGION_RAM_END) && (addr_start >= SE_REGION_RAM_START)))
 800a8ea:	4291      	cmp	r1, r2
 800a8ec:	d807      	bhi.n	800a8fe <SFU_LL_BufferCheck_in_se_ram+0x22>
  {
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
    e_ret_status = SFU_ERROR;
 800a8ee:	4906      	ldr	r1, [pc, #24]	@ (800a908 <SFU_LL_BufferCheck_in_se_ram+0x2c>)
 800a8f0:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a8f4:	4a05      	ldr	r2, [pc, #20]	@ (800a90c <SFU_LL_BufferCheck_in_se_ram+0x30>)
 800a8f6:	428b      	cmp	r3, r1
 800a8f8:	bf28      	it	cs
 800a8fa:	4610      	movcs	r0, r2
 800a8fc:	4770      	bx	lr
 800a8fe:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  }
  return e_ret_status;
}
 800a902:	4770      	bx	lr
 800a904:	20000fff 	.word	0x20000fff
 800a908:	20000000 	.word	0x20000000
 800a90c:	00122f11 	.word	0x00122f11

0800a910 <SFU_LL_Buffer_in_ram>:
  * @brief Check if an array is inside the RAM of the product
  * @param Addr : address  of array
  * @param Length : length of array in byte
  */
SFU_ErrorStatus SFU_LL_Buffer_in_ram(void *pBuff, uint32_t Length)
{
 800a910:	4603      	mov	r3, r0
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  uint32_t addr_start = (uint32_t)pBuff;
  uint32_t addr_end = addr_start + Length - 1U;

  /* Check if length is positive with no overflow and included in the correct range */
  if ((Length != 0U) && (!((0xFFFFFFFFUL - addr_start) < Length))
 800a912:	b171      	cbz	r1, 800a932 <SFU_LL_Buffer_in_ram+0x22>
 800a914:	1842      	adds	r2, r0, r1
 800a916:	d20c      	bcs.n	800a932 <SFU_LL_Buffer_in_ram+0x22>
  uint32_t addr_end = addr_start + Length - 1U;
 800a918:	3901      	subs	r1, #1
      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= SB_REGION_RAM_START)))
 800a91a:	4a07      	ldr	r2, [pc, #28]	@ (800a938 <SFU_LL_Buffer_in_ram+0x28>)
  uint32_t addr_end = addr_start + Length - 1U;
 800a91c:	4401      	add	r1, r0
      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= SB_REGION_RAM_START)))
 800a91e:	4291      	cmp	r1, r2
 800a920:	d807      	bhi.n	800a932 <SFU_LL_Buffer_in_ram+0x22>
  {
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
    e_ret_status = SFU_ERROR;
 800a922:	4906      	ldr	r1, [pc, #24]	@ (800a93c <SFU_LL_Buffer_in_ram+0x2c>)
 800a924:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a928:	4a05      	ldr	r2, [pc, #20]	@ (800a940 <SFU_LL_Buffer_in_ram+0x30>)
 800a92a:	428b      	cmp	r3, r1
 800a92c:	bf28      	it	cs
 800a92e:	4610      	movcs	r0, r2
 800a930:	4770      	bx	lr
 800a932:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  }
  return e_ret_status;
}
 800a936:	4770      	bx	lr
 800a938:	2001ffff 	.word	0x2001ffff
 800a93c:	20001100 	.word	0x20001100
 800a940:	00122f11 	.word	0x00122f11

0800a944 <SFU_LL_FLASH_Init>:
  * @brief  Initialize internal and external flash interface (OSPI/QSPI)
  * @param  none
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Init(void)
{
 800a944:	b508      	push	{r3, lr}
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;

  e_ret_status = SFU_LL_FLASH_INT_Init();
 800a946:	f000 f861 	bl	800aa0c <SFU_LL_FLASH_INT_Init>
  if (e_ret_status == SFU_SUCCESS)
 800a94a:	4b04      	ldr	r3, [pc, #16]	@ (800a95c <SFU_LL_FLASH_Init+0x18>)
 800a94c:	4298      	cmp	r0, r3
 800a94e:	d103      	bne.n	800a958 <SFU_LL_FLASH_Init+0x14>
  {
    e_ret_status = SFU_LL_FLASH_EXT_Init();
  }
  return e_ret_status;
}
 800a950:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    e_ret_status = SFU_LL_FLASH_EXT_Init();
 800a954:	f000 b82e 	b.w	800a9b4 <SFU_LL_FLASH_EXT_Init>
}
 800a958:	bd08      	pop	{r3, pc}
 800a95a:	bf00      	nop
 800a95c:	00122f11 	.word	0x00122f11

0800a960 <SFU_LL_FLASH_Erase_Size>:
  */
SFU_ErrorStatus SFU_LL_FLASH_Erase_Size(SFU_FLASH_StatusTypeDef *pFlashStatus, uint8_t *pStart, uint32_t Length)
{

  /* Check Flash start address */
  if ((uint32_t) pStart < EXTERNAL_FLASH_ADDRESS)
 800a960:	f1b1 4f10 	cmp.w	r1, #2415919104	@ 0x90000000
 800a964:	d201      	bcs.n	800a96a <SFU_LL_FLASH_Erase_Size+0xa>
  {
    return SFU_LL_FLASH_INT_Erase_Size(pFlashStatus, pStart, Length);
 800a966:	f000 b94b 	b.w	800ac00 <SFU_LL_FLASH_INT_Erase_Size>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Erase_Size(pFlashStatus, pStart, Length);
 800a96a:	f000 b827 	b.w	800a9bc <SFU_LL_FLASH_EXT_Erase_Size>

0800a96e <SFU_LL_FLASH_Write>:
  */
SFU_ErrorStatus SFU_LL_FLASH_Write(SFU_FLASH_StatusTypeDef *pFlashStatus, uint8_t  *pDestination,
                                   const uint8_t *pSource, uint32_t Length)
{
  /* Check Flash destination address */
  if ((uint32_t) pDestination < EXTERNAL_FLASH_ADDRESS)
 800a96e:	f1b1 4f10 	cmp.w	r1, #2415919104	@ 0x90000000
 800a972:	d201      	bcs.n	800a978 <SFU_LL_FLASH_Write+0xa>
  {
    return SFU_LL_FLASH_INT_Write(pFlashStatus, pDestination, pSource, Length);
 800a974:	f000 b84e 	b.w	800aa14 <SFU_LL_FLASH_INT_Write>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Write(pFlashStatus, pDestination, pSource, Length);
 800a978:	f000 b823 	b.w	800a9c2 <SFU_LL_FLASH_EXT_Write>

0800a97c <SFU_LL_FLASH_Read>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
{
  /* Check Flash source address */
  if ((uint32_t) pSource < EXTERNAL_FLASH_ADDRESS)
 800a97c:	f1b1 4f10 	cmp.w	r1, #2415919104	@ 0x90000000
 800a980:	d201      	bcs.n	800a986 <SFU_LL_FLASH_Read+0xa>
  {
    return SFU_LL_FLASH_INT_Read(pDestination, pSource, Length);
 800a982:	f000 b8bf 	b.w	800ab04 <SFU_LL_FLASH_INT_Read>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Read(pDestination, pSource, Length);
 800a986:	f000 b81f 	b.w	800a9c8 <SFU_LL_FLASH_EXT_Read>

0800a98a <SFU_LL_FLASH_Compare>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Compare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length)
{
  /* Check Flash source address */
  if ((uint32_t) pFlash < EXTERNAL_FLASH_ADDRESS)
 800a98a:	f1b0 4f10 	cmp.w	r0, #2415919104	@ 0x90000000
 800a98e:	d201      	bcs.n	800a994 <SFU_LL_FLASH_Compare+0xa>
  {
    return SFU_LL_FLASH_INT_Compare(pFlash, Pattern1, Pattern2, Length);
 800a990:	f000 b900 	b.w	800ab94 <SFU_LL_FLASH_INT_Compare>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Compare(pFlash, Pattern1, Pattern2, Length);
 800a994:	f000 b81b 	b.w	800a9ce <SFU_LL_FLASH_EXT_Compare>

0800a998 <SFU_LL_FLASH_Config_Exe>:
   * Internal flash : nothing to do
   * External flash : configure memory mapped mode
   */

  /* Check Flash address */
  if (SlotStartAdd[SlotNumber] < EXTERNAL_FLASH_ADDRESS)
 800a998:	4b04      	ldr	r3, [pc, #16]	@ (800a9ac <SFU_LL_FLASH_Config_Exe+0x14>)
 800a99a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800a99e:	f1b3 4f10 	cmp.w	r3, #2415919104	@ 0x90000000
 800a9a2:	d301      	bcc.n	800a9a8 <SFU_LL_FLASH_Config_Exe+0x10>
  {
    return SFU_SUCCESS;
  }
  else
  {
    return SFU_LL_FLASH_EXT_Config_Exe(SlotNumber);
 800a9a4:	f000 b816 	b.w	800a9d4 <SFU_LL_FLASH_EXT_Config_Exe>
  }
}
 800a9a8:	4801      	ldr	r0, [pc, #4]	@ (800a9b0 <SFU_LL_FLASH_Config_Exe+0x18>)
 800a9aa:	4770      	bx	lr
 800a9ac:	0800e424 	.word	0x0800e424
 800a9b0:	00122f11 	.word	0x00122f11

0800a9b4 <SFU_LL_FLASH_EXT_Init>:
       systematically during startup phase */

SFU_ErrorStatus SFU_LL_FLASH_EXT_Init(void)
{
  return SFU_SUCCESS;
}
 800a9b4:	4800      	ldr	r0, [pc, #0]	@ (800a9b8 <SFU_LL_FLASH_EXT_Init+0x4>)
 800a9b6:	4770      	bx	lr
 800a9b8:	00122f11 	.word	0x00122f11

0800a9bc <SFU_LL_FLASH_EXT_Erase_Size>:
{
  UNUSED(pFlashStatus);
  UNUSED(pStart);
  UNUSED(Length);
  return SFU_ERROR;
}
 800a9bc:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a9c0:	4770      	bx	lr

0800a9c2 <SFU_LL_FLASH_EXT_Write>:
  UNUSED(pFlashStatus);
  UNUSED(pDestination);
  UNUSED(pSource);
  UNUSED(Length);
  return SFU_ERROR;
}
 800a9c2:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a9c6:	4770      	bx	lr

0800a9c8 <SFU_LL_FLASH_EXT_Read>:

SFU_ErrorStatus SFU_LL_FLASH_EXT_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
 800a9c8:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a9cc:	4770      	bx	lr

0800a9ce <SFU_LL_FLASH_EXT_Compare>:
  UNUSED(pFlash);
  UNUSED(Pattern1);
  UNUSED(Pattern2);
  UNUSED(Length);
  return SFU_ERROR;
}
 800a9ce:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a9d2:	4770      	bx	lr

0800a9d4 <SFU_LL_FLASH_EXT_Config_Exe>:
SFU_ErrorStatus SFU_LL_FLASH_EXT_Config_Exe(uint32_t SlotNumber)
{
  UNUSED(SlotNumber);
  return SFU_SUCCESS;
}
 800a9d4:	4800      	ldr	r0, [pc, #0]	@ (800a9d8 <SFU_LL_FLASH_EXT_Config_Exe+0x4>)
 800a9d6:	4770      	bx	lr
 800a9d8:	00122f11 	.word	0x00122f11

0800a9dc <SFU_LL_FLASH_INT_Clear_Error>:
  * @brief  Clear error flags raised during previous operation
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
static SFU_ErrorStatus SFU_LL_FLASH_INT_Clear_Error(void)
{
 800a9dc:	b508      	push	{r3, lr}
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Unlock the Program memory */
  if (HAL_FLASH_Unlock() == HAL_OK)
 800a9de:	f000 fd93 	bl	800b508 <HAL_FLASH_Unlock>
 800a9e2:	b110      	cbz	r0, 800a9ea <SFU_LL_FLASH_INT_Clear_Error+0xe>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a9e4:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
    }
  }

  return e_ret_status;

}
 800a9e8:	bd08      	pop	{r3, pc}
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS_BANK1);
 800a9ea:	4b05      	ldr	r3, [pc, #20]	@ (800aa00 <SFU_LL_FLASH_INT_Clear_Error+0x24>)
 800a9ec:	4a05      	ldr	r2, [pc, #20]	@ (800aa04 <SFU_LL_FLASH_INT_Clear_Error+0x28>)
 800a9ee:	615a      	str	r2, [r3, #20]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS_BANK2);
 800a9f0:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
    if (HAL_FLASH_Lock() == HAL_OK)
 800a9f4:	f000 fdae 	bl	800b554 <HAL_FLASH_Lock>
 800a9f8:	2800      	cmp	r0, #0
 800a9fa:	d1f3      	bne.n	800a9e4 <SFU_LL_FLASH_INT_Clear_Error+0x8>
      e_ret_status = SFU_SUCCESS;
 800a9fc:	4802      	ldr	r0, [pc, #8]	@ (800aa08 <SFU_LL_FLASH_INT_Clear_Error+0x2c>)
  return e_ret_status;
 800a9fe:	e7f3      	b.n	800a9e8 <SFU_LL_FLASH_INT_Clear_Error+0xc>
 800aa00:	52002000 	.word	0x52002000
 800aa04:	17ee0000 	.word	0x17ee0000
 800aa08:	00122f11 	.word	0x00122f11

0800aa0c <SFU_LL_FLASH_INT_Init>:
}
 800aa0c:	4800      	ldr	r0, [pc, #0]	@ (800aa10 <SFU_LL_FLASH_INT_Init+0x4>)
 800aa0e:	4770      	bx	lr
 800aa10:	00122f11 	.word	0x00122f11

0800aa14 <SFU_LL_FLASH_INT_Write>:
{
 800aa14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800aa18:	4690      	mov	r8, r2
 800aa1a:	b085      	sub	sp, #20
 800aa1c:	461f      	mov	r7, r3
  uint32_t destination = (uint32_t)pDestination;
 800aa1e:	4689      	mov	r9, r1
  if ((pFlashStatus == NULL) || (pSource == NULL))
 800aa20:	4606      	mov	r6, r0
 800aa22:	2800      	cmp	r0, #0
 800aa24:	d045      	beq.n	800aab2 <SFU_LL_FLASH_INT_Write+0x9e>
 800aa26:	2a00      	cmp	r2, #0
 800aa28:	d043      	beq.n	800aab2 <SFU_LL_FLASH_INT_Write+0x9e>
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800aa2a:	4833      	ldr	r0, [pc, #204]	@ (800aaf8 <SFU_LL_FLASH_INT_Write+0xe4>)
 800aa2c:	6842      	ldr	r2, [r0, #4]
 800aa2e:	4291      	cmp	r1, r2
 800aa30:	d323      	bcc.n	800aa7a <SFU_LL_FLASH_INT_Write+0x66>
        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800aa32:	18cb      	adds	r3, r1, r3
 800aa34:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800aa38:	4293      	cmp	r3, r2
 800aa3a:	bf8c      	ite	hi
 800aa3c:	2300      	movhi	r3, #0
 800aa3e:	2301      	movls	r3, #1
 800aa40:	6882      	ldr	r2, [r0, #8]
 800aa42:	4291      	cmp	r1, r2
 800aa44:	d304      	bcc.n	800aa50 <SFU_LL_FLASH_INT_Write+0x3c>
        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800aa46:	19c8      	adds	r0, r1, r7
 800aa48:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800aa4c:	4290      	cmp	r0, r2
 800aa4e:	d900      	bls.n	800aa52 <SFU_LL_FLASH_INT_Write+0x3e>
  if ((inside_header == 1U) && (Length != 0U))
 800aa50:	b1ab      	cbz	r3, 800aa7e <SFU_LL_FLASH_INT_Write+0x6a>
 800aa52:	b1a7      	cbz	r7, 800aa7e <SFU_LL_FLASH_INT_Write+0x6a>
    SE_ErrorStatus se_ret_status = SE_SFU_IMG_Write(&se_status, (uint8_t *)destination, pSource, Length);
 800aa54:	463b      	mov	r3, r7
 800aa56:	4642      	mov	r2, r8
 800aa58:	a803      	add	r0, sp, #12
      *pFlashStatus = SFU_FLASH_SUCCESS;
 800aa5a:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
    SE_ErrorStatus se_ret_status = SE_SFU_IMG_Write(&se_status, (uint8_t *)destination, pSource, Length);
 800aa5e:	f7fd fc09 	bl	8008274 <SE_SFU_IMG_Write>
    if (se_ret_status == SE_SUCCESS)
 800aa62:	4b26      	ldr	r3, [pc, #152]	@ (800aafc <SFU_LL_FLASH_INT_Write+0xe8>)
      *pFlashStatus = SFU_FLASH_SUCCESS;
 800aa64:	4a26      	ldr	r2, [pc, #152]	@ (800ab00 <SFU_LL_FLASH_INT_Write+0xec>)
 800aa66:	4298      	cmp	r0, r3
 800aa68:	bf12      	itee	ne
 800aa6a:	2300      	movne	r3, #0
 800aa6c:	2305      	moveq	r3, #5
 800aa6e:	4614      	moveq	r4, r2
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800aa70:	7033      	strb	r3, [r6, #0]
}
 800aa72:	4620      	mov	r0, r4
 800aa74:	b005      	add	sp, #20
 800aa76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint32_t inside_header = 0U;
 800aa7a:	2300      	movs	r3, #0
 800aa7c:	e7e0      	b.n	800aa40 <SFU_LL_FLASH_INT_Write+0x2c>
    *pFlashStatus = SFU_FLASH_ERROR;
 800aa7e:	2300      	movs	r3, #0
 800aa80:	7033      	strb	r3, [r6, #0]
    e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800aa82:	f7ff ffab 	bl	800a9dc <SFU_LL_FLASH_INT_Clear_Error>
    if (e_ret_status == SFU_SUCCESS)
 800aa86:	4b1e      	ldr	r3, [pc, #120]	@ (800ab00 <SFU_LL_FLASH_INT_Write+0xec>)
    e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800aa88:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 800aa8a:	4298      	cmp	r0, r3
 800aa8c:	d1f1      	bne.n	800aa72 <SFU_LL_FLASH_INT_Write+0x5e>
      if (HAL_FLASH_Unlock() != HAL_OK)
 800aa8e:	f000 fd3b 	bl	800b508 <HAL_FLASH_Unlock>
 800aa92:	4605      	mov	r5, r0
 800aa94:	b980      	cbnz	r0, 800aab8 <SFU_LL_FLASH_INT_Write+0xa4>
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800aa96:	46a2      	mov	sl, r4
          *pFlashStatus = SFU_FLASH_ERROR;
 800aa98:	4683      	mov	fp, r0
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800aa9a:	42bd      	cmp	r5, r7
 800aa9c:	d203      	bcs.n	800aaa6 <SFU_LL_FLASH_INT_Write+0x92>
 800aa9e:	4554      	cmp	r4, sl
 800aaa0:	d00c      	beq.n	800aabc <SFU_LL_FLASH_INT_Write+0xa8>
 800aaa2:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
        if (HAL_FLASH_Lock() != HAL_OK)
 800aaa6:	f000 fd55 	bl	800b554 <HAL_FLASH_Lock>
 800aaaa:	2800      	cmp	r0, #0
 800aaac:	d0e1      	beq.n	800aa72 <SFU_LL_FLASH_INT_Write+0x5e>
          *pFlashStatus = SFU_FLASH_ERR_HAL;
 800aaae:	2301      	movs	r3, #1
 800aab0:	7033      	strb	r3, [r6, #0]
    return SFU_ERROR;
 800aab2:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
 800aab6:	e7dc      	b.n	800aa72 <SFU_LL_FLASH_INT_Write+0x5e>
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800aab8:	2301      	movs	r3, #1
 800aaba:	e7d9      	b.n	800aa70 <SFU_LL_FLASH_INT_Write+0x5c>
          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, destination, (source + i)) == HAL_OK)
 800aabc:	eb08 0305 	add.w	r3, r8, r5
 800aac0:	4649      	mov	r1, r9
 800aac2:	2001      	movs	r0, #1
          *pFlashStatus = SFU_FLASH_ERROR;
 800aac4:	f886 b000 	strb.w	fp, [r6]
          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, destination, (source + i)) == HAL_OK)
 800aac8:	461a      	mov	r2, r3
 800aaca:	9301      	str	r3, [sp, #4]
 800aacc:	f000 fdd4 	bl	800b678 <HAL_FLASH_Program>
 800aad0:	b960      	cbnz	r0, 800aaec <SFU_LL_FLASH_INT_Write+0xd8>
            if (memcmp((void *)destination, (void *)(source + i), sizeof(SFU_LL_FLASH_write_t)) != 0)
 800aad2:	9b01      	ldr	r3, [sp, #4]
 800aad4:	2220      	movs	r2, #32
 800aad6:	4648      	mov	r0, r9
 800aad8:	4619      	mov	r1, r3
 800aada:	f002 feb9 	bl	800d850 <memcmp>
 800aade:	b948      	cbnz	r0, 800aaf4 <SFU_LL_FLASH_INT_Write+0xe0>
              destination = destination + sizeof(SFU_LL_FLASH_write_t);
 800aae0:	f109 0920 	add.w	r9, r9, #32
 800aae4:	2305      	movs	r3, #5
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800aae6:	3520      	adds	r5, #32
              *pFlashStatus = SFU_FLASH_SUCCESS;
 800aae8:	7033      	strb	r3, [r6, #0]
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800aaea:	e7d6      	b.n	800aa9a <SFU_LL_FLASH_INT_Write+0x86>
 800aaec:	2303      	movs	r3, #3
            e_ret_status = SFU_ERROR;
 800aaee:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
 800aaf2:	e7f8      	b.n	800aae6 <SFU_LL_FLASH_INT_Write+0xd2>
 800aaf4:	2304      	movs	r3, #4
 800aaf6:	e7fa      	b.n	800aaee <SFU_LL_FLASH_INT_Write+0xda>
 800aaf8:	0800e464 	.word	0x0800e464
 800aafc:	0012310f 	.word	0x0012310f
 800ab00:	00122f11 	.word	0x00122f11

0800ab04 <SFU_LL_FLASH_INT_Read>:
{
 800ab04:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800ab06:	4d1f      	ldr	r5, [pc, #124]	@ (800ab84 <SFU_LL_FLASH_INT_Read+0x80>)
{
 800ab08:	4613      	mov	r3, r2
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800ab0a:	686c      	ldr	r4, [r5, #4]
 800ab0c:	42a1      	cmp	r1, r4
 800ab0e:	d322      	bcc.n	800ab56 <SFU_LL_FLASH_INT_Read+0x52>
        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800ab10:	188a      	adds	r2, r1, r2
 800ab12:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800ab16:	42a2      	cmp	r2, r4
 800ab18:	bf8c      	ite	hi
 800ab1a:	2200      	movhi	r2, #0
 800ab1c:	2201      	movls	r2, #1
 800ab1e:	68ad      	ldr	r5, [r5, #8]
 800ab20:	4c19      	ldr	r4, [pc, #100]	@ (800ab88 <SFU_LL_FLASH_INT_Read+0x84>)
 800ab22:	42a9      	cmp	r1, r5
 800ab24:	d304      	bcc.n	800ab30 <SFU_LL_FLASH_INT_Read+0x2c>
        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800ab26:	18ce      	adds	r6, r1, r3
 800ab28:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800ab2c:	42ae      	cmp	r6, r5
 800ab2e:	d900      	bls.n	800ab32 <SFU_LL_FLASH_INT_Read+0x2e>
  if (inside_header == 1U)
 800ab30:	b1ca      	cbz	r2, 800ab66 <SFU_LL_FLASH_INT_Read+0x62>
    DoubleECC_Error_Counter = 0U;
 800ab32:	2200      	movs	r2, #0
 800ab34:	6022      	str	r2, [r4, #0]
    se_ret_status = SE_SFU_IMG_Read(&se_status, pDestination, (uint8_t *)source, Length);
 800ab36:	460a      	mov	r2, r1
 800ab38:	4601      	mov	r1, r0
 800ab3a:	a801      	add	r0, sp, #4
 800ab3c:	f7fd fb62 	bl	8008204 <SE_SFU_IMG_Read>
    if ((se_ret_status == SE_SUCCESS) && (DoubleECC_Error_Counter == 0U))
 800ab40:	4b12      	ldr	r3, [pc, #72]	@ (800ab8c <SFU_LL_FLASH_INT_Read+0x88>)
 800ab42:	4298      	cmp	r0, r3
 800ab44:	d109      	bne.n	800ab5a <SFU_LL_FLASH_INT_Read+0x56>
    if (DoubleECC_Error_Counter == 0U)
 800ab46:	6822      	ldr	r2, [r4, #0]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800ab48:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800ab4c:	4b10      	ldr	r3, [pc, #64]	@ (800ab90 <SFU_LL_FLASH_INT_Read+0x8c>)
 800ab4e:	2a00      	cmp	r2, #0
 800ab50:	bf08      	it	eq
 800ab52:	4618      	moveq	r0, r3
 800ab54:	e003      	b.n	800ab5e <SFU_LL_FLASH_INT_Read+0x5a>
  uint32_t inside_header = 0U;
 800ab56:	2200      	movs	r2, #0
 800ab58:	e7e1      	b.n	800ab1e <SFU_LL_FLASH_INT_Read+0x1a>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800ab5a:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
    DoubleECC_Error_Counter = 0U;
 800ab5e:	2300      	movs	r3, #0
 800ab60:	6023      	str	r3, [r4, #0]
}
 800ab62:	b002      	add	sp, #8
 800ab64:	bd70      	pop	{r4, r5, r6, pc}
    DoubleECC_Error_Counter = 0U;
 800ab66:	2200      	movs	r2, #0
 800ab68:	3901      	subs	r1, #1
 800ab6a:	4403      	add	r3, r0
 800ab6c:	6022      	str	r2, [r4, #0]
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800ab6e:	4298      	cmp	r0, r3
 800ab70:	d0e9      	beq.n	800ab46 <SFU_LL_FLASH_INT_Read+0x42>
 800ab72:	6822      	ldr	r2, [r4, #0]
 800ab74:	2a00      	cmp	r2, #0
 800ab76:	d1e6      	bne.n	800ab46 <SFU_LL_FLASH_INT_Read+0x42>
      *pDestination = *pSource;
 800ab78:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800ab7c:	f800 2b01 	strb.w	r2, [r0], #1
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800ab80:	e7f5      	b.n	800ab6e <SFU_LL_FLASH_INT_Read+0x6a>
 800ab82:	bf00      	nop
 800ab84:	0800e464 	.word	0x0800e464
 800ab88:	20001d74 	.word	0x20001d74
 800ab8c:	0012310f 	.word	0x0012310f
 800ab90:	00122f11 	.word	0x00122f11

0800ab94 <SFU_LL_FLASH_INT_Compare>:
{
 800ab94:	b570      	push	{r4, r5, r6, lr}
  DoubleECC_Error_Counter = 0U;
 800ab96:	4d0a      	ldr	r5, [pc, #40]	@ (800abc0 <SFU_LL_FLASH_INT_Compare+0x2c>)
 800ab98:	2400      	movs	r4, #0
 800ab9a:	602c      	str	r4, [r5, #0]
  for ( i = 0U; i < Length; i += 4U)
 800ab9c:	429c      	cmp	r4, r3
 800ab9e:	d305      	bcc.n	800abac <SFU_LL_FLASH_INT_Compare+0x18>
  if (i != Length)
 800aba0:	d10b      	bne.n	800abba <SFU_LL_FLASH_INT_Compare+0x26>
  if (DoubleECC_Error_Counter != 0U)
 800aba2:	682b      	ldr	r3, [r5, #0]
 800aba4:	b94b      	cbnz	r3, 800abba <SFU_LL_FLASH_INT_Compare+0x26>
  return SFU_SUCCESS;
 800aba6:	4807      	ldr	r0, [pc, #28]	@ (800abc4 <SFU_LL_FLASH_INT_Compare+0x30>)
  DoubleECC_Error_Counter = 0U;
 800aba8:	602b      	str	r3, [r5, #0]
}
 800abaa:	bd70      	pop	{r4, r5, r6, pc}
    if ((*(uint32_t *)(flash + i) != Pattern1) &&  (*(uint32_t *)(flash + i) != Pattern2))
 800abac:	5906      	ldr	r6, [r0, r4]
 800abae:	428e      	cmp	r6, r1
 800abb0:	d001      	beq.n	800abb6 <SFU_LL_FLASH_INT_Compare+0x22>
 800abb2:	4296      	cmp	r6, r2
 800abb4:	d101      	bne.n	800abba <SFU_LL_FLASH_INT_Compare+0x26>
  for ( i = 0U; i < Length; i += 4U)
 800abb6:	3404      	adds	r4, #4
 800abb8:	e7f0      	b.n	800ab9c <SFU_LL_FLASH_INT_Compare+0x8>
      return SFU_ERROR;
 800abba:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800abbe:	e7f4      	b.n	800abaa <SFU_LL_FLASH_INT_Compare+0x16>
 800abc0:	20001d74 	.word	0x20001d74
 800abc4:	00122f11 	.word	0x00122f11

0800abc8 <SFU_LL_FLASH_INT_GetSector>:
  if (Add < (FLASH_BASE + (SFU_FLASH_BANK_SIZE)))
 800abc8:	f1b0 6f01 	cmp.w	r0, #135266304	@ 0x8100000
    sector = (Add - FLASH_BASE) / FLASH_SECTOR_SIZE;
 800abcc:	bf34      	ite	cc
 800abce:	f100 4078 	addcc.w	r0, r0, #4160749568	@ 0xf8000000
    sector = (Add - (FLASH_BASE + (SFU_FLASH_BANK_SIZE))) / FLASH_SECTOR_SIZE;
 800abd2:	f1a0 6001 	subcs.w	r0, r0, #135266304	@ 0x8100000
 800abd6:	0c40      	lsrs	r0, r0, #17
}
 800abd8:	4770      	bx	lr
	...

0800abdc <SFU_LL_FLASH_INT_GetBank>:
  if (READ_BIT(FLASH->OPTCCR, FLASH_OPTCR_SWAP_BANK) == 0U)
 800abdc:	4b07      	ldr	r3, [pc, #28]	@ (800abfc <SFU_LL_FLASH_INT_GetBank+0x20>)
 800abde:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800abe0:	2b00      	cmp	r3, #0
 800abe2:	db05      	blt.n	800abf0 <SFU_LL_FLASH_INT_GetBank+0x14>
      bank = FLASH_BANK_2;
 800abe4:	f1b0 6f01 	cmp.w	r0, #135266304	@ 0x8100000
 800abe8:	bf34      	ite	cc
 800abea:	2001      	movcc	r0, #1
 800abec:	2002      	movcs	r0, #2
 800abee:	4770      	bx	lr
      bank = FLASH_BANK_1;
 800abf0:	f1b0 6f01 	cmp.w	r0, #135266304	@ 0x8100000
 800abf4:	bf34      	ite	cc
 800abf6:	2002      	movcc	r0, #2
 800abf8:	2001      	movcs	r0, #1
}
 800abfa:	4770      	bx	lr
 800abfc:	52002000 	.word	0x52002000

0800ac00 <SFU_LL_FLASH_INT_Erase_Size>:
{
 800ac00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t sector_error = 0U;
 800ac04:	2300      	movs	r3, #0
{
 800ac06:	b086      	sub	sp, #24
 800ac08:	460c      	mov	r4, r1
 800ac0a:	4690      	mov	r8, r2
  if (pFlashStatus == NULL)
 800ac0c:	4606      	mov	r6, r0
  uint32_t sector_error = 0U;
 800ac0e:	9300      	str	r3, [sp, #0]
  if (pFlashStatus == NULL)
 800ac10:	2800      	cmp	r0, #0
 800ac12:	d045      	beq.n	800aca0 <SFU_LL_FLASH_INT_Erase_Size+0xa0>
  *pFlashStatus = SFU_FLASH_SUCCESS;
 800ac14:	2305      	movs	r3, #5
 800ac16:	7003      	strb	r3, [r0, #0]
  e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800ac18:	f7ff fee0 	bl	800a9dc <SFU_LL_FLASH_INT_Clear_Error>
  if (e_ret_status == SFU_SUCCESS)
 800ac1c:	4b36      	ldr	r3, [pc, #216]	@ (800acf8 <SFU_LL_FLASH_INT_Erase_Size+0xf8>)
  e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800ac1e:	4607      	mov	r7, r0
  if (e_ret_status == SFU_SUCCESS)
 800ac20:	4298      	cmp	r0, r3
 800ac22:	d13f      	bne.n	800aca4 <SFU_LL_FLASH_INT_Erase_Size+0xa4>
    if (HAL_FLASH_Unlock() == HAL_OK)
 800ac24:	f000 fc70 	bl	800b508 <HAL_FLASH_Unlock>
 800ac28:	2800      	cmp	r0, #0
 800ac2a:	d162      	bne.n	800acf2 <SFU_LL_FLASH_INT_Erase_Size+0xf2>
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800ac2c:	f04f 0a02 	mov.w	sl, #2
        if (SFU_LL_FLASH_INT_GetBank(start + length - 1U) == bank_number)
 800ac30:	44a0      	add	r8, r4
        first_sector = SFU_LL_FLASH_INT_GetSector(start);
 800ac32:	4620      	mov	r0, r4
 800ac34:	f7ff ffc8 	bl	800abc8 <SFU_LL_FLASH_INT_GetSector>
 800ac38:	4605      	mov	r5, r0
        if (SFU_LL_FLASH_INT_GetBank(start + length - 1U) == bank_number)
 800ac3a:	f108 31ff 	add.w	r1, r8, #4294967295
        bank_number = SFU_LL_FLASH_INT_GetBank(start);
 800ac3e:	4620      	mov	r0, r4
 800ac40:	f7ff ffcc 	bl	800abdc <SFU_LL_FLASH_INT_GetBank>
 800ac44:	4602      	mov	r2, r0
        if (SFU_LL_FLASH_INT_GetBank(start + length - 1U) == bank_number)
 800ac46:	4608      	mov	r0, r1
 800ac48:	f7ff ffc8 	bl	800abdc <SFU_LL_FLASH_INT_GetBank>
 800ac4c:	4290      	cmp	r0, r2
 800ac4e:	4603      	mov	r3, r0
 800ac50:	d12c      	bne.n	800acac <SFU_LL_FLASH_INT_Erase_Size+0xac>
          nb_sectors = SFU_LL_FLASH_INT_GetSector(start + length - 1U) - first_sector + 1U;
 800ac52:	f1c5 0401 	rsb	r4, r5, #1
          p_erase_init.TypeErase     = FLASH_TYPEERASE_SECTORS;
 800ac56:	2200      	movs	r2, #0
          nb_sectors = SFU_LL_FLASH_INT_GetSector(start + length - 1U) - first_sector + 1U;
 800ac58:	4608      	mov	r0, r1
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800ac5a:	f04f 0802 	mov.w	r8, #2
          nb_sectors = SFU_LL_FLASH_INT_GetSector(start + length - 1U) - first_sector + 1U;
 800ac5e:	f7ff ffb3 	bl	800abc8 <SFU_LL_FLASH_INT_GetSector>
 800ac62:	4404      	add	r4, r0
          p_erase_init.Banks         = bank_number;
 800ac64:	e9cd 2301 	strd	r2, r3, [sp, #4]
          p_erase_init.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
 800ac68:	2320      	movs	r3, #32
 800ac6a:	9305      	str	r3, [sp, #20]
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800ac6c:	2c02      	cmp	r4, #2
 800ac6e:	4623      	mov	r3, r4
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800ac70:	4669      	mov	r1, sp
 800ac72:	a801      	add	r0, sp, #4
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800ac74:	bf28      	it	cs
 800ac76:	2302      	movcs	r3, #2
            p_erase_init.NbSectors = chunk_nb_sectors;
 800ac78:	e9cd 5303 	strd	r5, r3, [sp, #12]
            nb_sectors -= chunk_nb_sectors;
 800ac7c:	1ae4      	subs	r4, r4, r3
            first_sector += chunk_nb_sectors;
 800ac7e:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800ac80:	f000 ffc8 	bl	800bc14 <HAL_FLASHEx_Erase>
 800ac84:	b118      	cbz	r0, 800ac8e <SFU_LL_FLASH_INT_Erase_Size+0x8e>
              e_ret_status = SFU_ERROR;
 800ac86:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800ac8a:	f886 8000 	strb.w	r8, [r6]
            SFU_LL_SECU_IWDG_Refresh(); /* calling this function which checks the compiler switch */
 800ac8e:	f000 f939 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
          } while (nb_sectors > 0U);
 800ac92:	2c00      	cmp	r4, #0
 800ac94:	d1ea      	bne.n	800ac6c <SFU_LL_FLASH_INT_Erase_Size+0x6c>
      if (HAL_FLASH_Lock() != HAL_OK)
 800ac96:	f000 fc5d 	bl	800b554 <HAL_FLASH_Lock>
 800ac9a:	b118      	cbz	r0, 800aca4 <SFU_LL_FLASH_INT_Erase_Size+0xa4>
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800ac9c:	2301      	movs	r3, #1
 800ac9e:	7033      	strb	r3, [r6, #0]
    return SFU_ERROR;
 800aca0:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
}
 800aca4:	4638      	mov	r0, r7
 800aca6:	b006      	add	sp, #24
 800aca8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          p_erase_init.TypeErase     = FLASH_TYPEERASE_SECTORS;
 800acac:	2300      	movs	r3, #0
          nb_sectors = SFU_LL_FLASH_INT_GetSector(startbank2 - 1U) - first_sector + 1U;
 800acae:	f1c5 0908 	rsb	r9, r5, #8
          length = length  - (startbank2 - start);
 800acb2:	f1a8 6801 	sub.w	r8, r8, #135266304	@ 0x8100000
          p_erase_init.TypeErase     = FLASH_TYPEERASE_SECTORS;
 800acb6:	f04f 6401 	mov.w	r4, #135266304	@ 0x8100000
          p_erase_init.Banks         = bank_number;
 800acba:	e9cd 3201 	strd	r3, r2, [sp, #4]
          p_erase_init.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
 800acbe:	2320      	movs	r3, #32
 800acc0:	9305      	str	r3, [sp, #20]
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800acc2:	464b      	mov	r3, r9
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800acc4:	4669      	mov	r1, sp
 800acc6:	a801      	add	r0, sp, #4
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800acc8:	2b02      	cmp	r3, #2
 800acca:	bf28      	it	cs
 800accc:	2302      	movcs	r3, #2
            p_erase_init.NbSectors = chunk_nb_sectors;
 800acce:	e9cd 5303 	strd	r5, r3, [sp, #12]
            nb_sectors -= chunk_nb_sectors;
 800acd2:	eba9 0903 	sub.w	r9, r9, r3
            first_sector += chunk_nb_sectors;
 800acd6:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800acd8:	f000 ff9c 	bl	800bc14 <HAL_FLASHEx_Erase>
 800acdc:	b118      	cbz	r0, 800ace6 <SFU_LL_FLASH_INT_Erase_Size+0xe6>
              e_ret_status = SFU_ERROR;
 800acde:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800ace2:	f886 a000 	strb.w	sl, [r6]
            SFU_LL_SECU_IWDG_Refresh(); /* calling this function which checks the compiler switch */
 800ace6:	f000 f90d 	bl	800af04 <SFU_LL_SECU_IWDG_Refresh>
          } while (nb_sectors > 0U);
 800acea:	f1b9 0f00 	cmp.w	r9, #0
 800acee:	d1e8      	bne.n	800acc2 <SFU_LL_FLASH_INT_Erase_Size+0xc2>
 800acf0:	e79e      	b.n	800ac30 <SFU_LL_FLASH_INT_Erase_Size+0x30>
      *pFlashStatus = SFU_FLASH_ERR_HAL;
 800acf2:	2301      	movs	r3, #1
 800acf4:	7033      	strb	r3, [r6, #0]
 800acf6:	e7d5      	b.n	800aca4 <SFU_LL_FLASH_INT_Erase_Size+0xa4>
 800acf8:	00122f11 	.word	0x00122f11

0800acfc <NMI_Handler>:
  * @param  None.
  * @retval None.
  */
void NMI_Handler(void)
{
  while (1 == 1)
 800acfc:	e7fe      	b.n	800acfc <NMI_Handler>
	...

0800ad00 <HardFault_Handler>:
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;

  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_DBECCE_BANK1RR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_DBECCE_BANK2RR))
 800ad00:	4b19      	ldr	r3, [pc, #100]	@ (800ad68 <HardFault_Handler+0x68>)
 800ad02:	691a      	ldr	r2, [r3, #16]
 800ad04:	0152      	lsls	r2, r2, #5
 800ad06:	d403      	bmi.n	800ad10 <HardFault_Handler+0x10>
 800ad08:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 800ad0c:	0150      	lsls	r0, r2, #5
 800ad0e:	d528      	bpl.n	800ad62 <HardFault_Handler+0x62>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_DBECCE_BANK1RR);
 800ad10:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 800ad14:	615a      	str	r2, [r3, #20]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_DBECCE_BANK2RR);
 800ad16:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114

    /* Memorize error to ignore the read value */
    DoubleECC_Error_Counter++;
 800ad1a:	4a14      	ldr	r2, [pc, #80]	@ (800ad6c <HardFault_Handler+0x6c>)
 800ad1c:	6813      	ldr	r3, [r2, #0]
 800ad1e:	3301      	adds	r3, #1
 800ad20:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 800ad22:	4673      	mov	r3, lr

    lr = get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 800ad24:	f003 030f 	and.w	r3, r3, #15
 800ad28:	2b0d      	cmp	r3, #13
 800ad2a:	d114      	bne.n	800ad56 <HardFault_Handler+0x56>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800ad2c:	f3ef 8209 	mrs	r2, PSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 800ad30:	e9d2 3106 	ldrd	r3, r1, [r2, #24]
 800ad34:	01c9      	lsls	r1, r1, #7
 800ad36:	d50c      	bpl.n	800ad52 <HardFault_Handler+0x52>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 800ad38:	f023 0101 	bic.w	r1, r3, #1
 800ad3c:	8809      	ldrh	r1, [r1, #0]
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 800ad3e:	f401 4068 	and.w	r0, r1, #59392	@ 0xe800
 800ad42:	f5b0 4f68 	cmp.w	r0, #59392	@ 0xe800
 800ad46:	d004      	beq.n	800ad52 <HardFault_Handler+0x52>
 800ad48:	f401 4178 	and.w	r1, r1, #63488	@ 0xf800
 800ad4c:	f5b1 4f70 	cmp.w	r1, #61440	@ 0xf000
 800ad50:	d104      	bne.n	800ad5c <HardFault_Handler+0x5c>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 800ad52:	3304      	adds	r3, #4
 800ad54:	e003      	b.n	800ad5e <HardFault_Handler+0x5e>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800ad56:	f3ef 8208 	mrs	r2, MSP
  return(result);
 800ad5a:	e7e9      	b.n	800ad30 <HardFault_Handler+0x30>
        *(p_sp + 6U) += 2U;
 800ad5c:	3302      	adds	r3, #2
      *(p_sp + 6U) += 4U;
 800ad5e:	6193      	str	r3, [r2, #24]
  }
  else
  {
    SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_HARD_FAULT);
  }
}
 800ad60:	4770      	bx	lr
    SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_HARD_FAULT);
 800ad62:	2002      	movs	r0, #2
 800ad64:	f7fe be4c 	b.w	8009a00 <SFU_EXCPT_IrqExceptionHandler>
 800ad68:	52002000 	.word	0x52002000
 800ad6c:	20001d74 	.word	0x20001d74

0800ad70 <SFU_LL_SECU_CheckApplyStaticProtections>:
  *         flash sections in order to maximize the security level for the specific MCU.
  * @retval uint32_t CRC (returned value is the combination of all the applied protections.
  *         If different from SFU_STD_PROTECTION_ALL, 1 or more protections cannot be applied)
  */
SFU_ErrorStatus SFU_LL_SECU_CheckApplyStaticProtections(void)
{
 800ad70:	b510      	push	{r4, lr}
 800ad72:	b092      	sub	sp, #72	@ 0x48

  /* Unlock the Options Bytes *************************************************/
  (void) HAL_FLASH_OB_Unlock();

  /* Get Option Bytes status for FLASH_BANK_1: WRP, PCRoP, SecureArea **********/
  flash_option_bytes.Banks = FLASH_BANK_1;
 800ad74:	2401      	movs	r4, #1
  (void) HAL_FLASH_Unlock();
 800ad76:	f000 fbc7 	bl	800b508 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_ALL_ERRORS_BANK1);
 800ad7a:	4b2f      	ldr	r3, [pc, #188]	@ (800ae38 <SFU_LL_SECU_CheckApplyStaticProtections+0xc8>)
 800ad7c:	4a2f      	ldr	r2, [pc, #188]	@ (800ae3c <SFU_LL_SECU_CheckApplyStaticProtections+0xcc>)
 800ad7e:	615a      	str	r2, [r3, #20]
  (void) HAL_FLASH_OB_Unlock();
 800ad80:	f000 fc00 	bl	800b584 <HAL_FLASH_OB_Unlock>
  (void) HAL_FLASHEx_OBGetConfig(&flash_option_bytes);
 800ad84:	a801      	add	r0, sp, #4
  flash_option_bytes.Banks = FLASH_BANK_1;
 800ad86:	9408      	str	r4, [sp, #32]
  (void) HAL_FLASHEx_OBGetConfig(&flash_option_bytes);
 800ad88:	f000 feb8 	bl	800bafc <HAL_FLASHEx_OBGetConfig>

  /* Check/Apply RDP_Level 1. This is the minimum protection allowed */
  /* if RDP_Level 2 is already applied it's not possible to modify the OptionBytes anymore */
  if (flash_option_bytes.RDPLevel == OB_RDP_LEVEL_2)
 800ad8c:	9b04      	ldr	r3, [sp, #16]
 800ad8e:	f5b3 4f4c 	cmp.w	r3, #52224	@ 0xcc00
 800ad92:	9b07      	ldr	r3, [sp, #28]
 800ad94:	d121      	bne.n	800adda <SFU_LL_SECU_CheckApplyStaticProtections+0x6a>
  /*
   * The Flash interface allows swapping bank 1 and bank 2 memory mapping.
   * Check that we do not swap Bank1 and Bank2.
   * Bank swapping is controlled by the SWAP_BANK bit located in the FLASH_OPTCR register.
   */
  if ((psFlashOptionBytes->USERConfig & OB_SWAP_BANK_ENABLE) == OB_SWAP_BANK_DISABLE)
 800ad96:	2b00      	cmp	r3, #0
 800ad98:	4c29      	ldr	r4, [pc, #164]	@ (800ae40 <SFU_LL_SECU_CheckApplyStaticProtections+0xd0>)
 800ad9a:	da05      	bge.n	800ada8 <SFU_LL_SECU_CheckApplyStaticProtections+0x38>
      TRACE("\r\n= [SBOOT] Flash configuration failed! Product blocked.");
 800ad9c:	4829      	ldr	r0, [pc, #164]	@ (800ae44 <SFU_LL_SECU_CheckApplyStaticProtections+0xd4>)
 800ad9e:	f002 fb5b 	bl	800d458 <iprintf>
  }

  if (e_ret_status == SFU_SUCCESS)
  {
    /* Execution stopped if flow control failed */
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800ada2:	f7fe fe51 	bl	8009a48 <SFU_EXCPT_Security_Error>
  }
  return e_ret_status;
 800ada6:	e009      	b.n	800adbc <SFU_LL_SECU_CheckApplyStaticProtections+0x4c>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800ada8:	6822      	ldr	r2, [r4, #0]
 800adaa:	f482 43cf 	eor.w	r3, r2, #26496	@ 0x6780
 800adae:	f083 0307 	eor.w	r3, r3, #7
 800adb2:	6023      	str	r3, [r4, #0]
 800adb4:	f245 7376 	movw	r3, #22390	@ 0x5776
 800adb8:	429a      	cmp	r2, r3
 800adba:	d1f2      	bne.n	800ada2 <SFU_LL_SECU_CheckApplyStaticProtections+0x32>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_RDP, FLOW_CTRL_RDP);
 800adbc:	6822      	ldr	r2, [r4, #0]
 800adbe:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 800adc2:	429a      	cmp	r2, r3
 800adc4:	d001      	beq.n	800adca <SFU_LL_SECU_CheckApplyStaticProtections+0x5a>
 800adc6:	f7fe fe3f 	bl	8009a48 <SFU_EXCPT_Security_Error>
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
 800adca:	4c1f      	ldr	r4, [pc, #124]	@ (800ae48 <SFU_LL_SECU_CheckApplyStaticProtections+0xd8>)
  (void) HAL_FLASH_OB_Lock();
 800adcc:	f000 fbec 	bl	800b5a8 <HAL_FLASH_OB_Lock>
  (void) HAL_FLASH_Lock();
 800add0:	f000 fbc0 	bl	800b554 <HAL_FLASH_Lock>
}
 800add4:	4620      	mov	r0, r4
 800add6:	b012      	add	sp, #72	@ 0x48
 800add8:	bd10      	pop	{r4, pc}
  if ((psFlashOptionBytes->USERConfig & OB_SWAP_BANK_ENABLE) == OB_SWAP_BANK_DISABLE)
 800adda:	2b00      	cmp	r3, #0
 800addc:	db09      	blt.n	800adf2 <SFU_LL_SECU_CheckApplyStaticProtections+0x82>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800adde:	4918      	ldr	r1, [pc, #96]	@ (800ae40 <SFU_LL_SECU_CheckApplyStaticProtections+0xd0>)
 800ade0:	680a      	ldr	r2, [r1, #0]
 800ade2:	f482 43cf 	eor.w	r3, r2, #26496	@ 0x6780
 800ade6:	f083 0307 	eor.w	r3, r3, #7
 800adea:	600b      	str	r3, [r1, #0]
 800adec:	f245 7376 	movw	r3, #22390	@ 0x5776
 800adf0:	e7e7      	b.n	800adc2 <SFU_LL_SECU_CheckApplyStaticProtections+0x52>
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
#if defined(SECBOOT_OB_DEV_MODE)
    if (HAL_FLASHEx_OBProgram(psFlashOptionBytes) == HAL_OK)
 800adf2:	a801      	add	r0, sp, #4
 800adf4:	f000 fd64 	bl	800b8c0 <HAL_FLASHEx_OBProgram>
 800adf8:	b110      	cbz	r0, 800ae00 <SFU_LL_SECU_CheckApplyStaticProtections+0x90>
    e_ret_status = SFU_LL_SECU_SetFlashConfiguration(&flash_option_bytes, &is_protection_to_be_applied);
 800adfa:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
 800adfe:	e7e5      	b.n	800adcc <SFU_LL_SECU_CheckApplyStaticProtections+0x5c>
    {
      /* Making sure bank 1 is selected */
      psFlashOptionBytes->Banks = FLASH_BANK_1;
      psFlashOptionBytes->OptionType = OPTIONBYTE_USER;
 800ae00:	2304      	movs	r3, #4
      psFlashOptionBytes->Banks = FLASH_BANK_1;
 800ae02:	9408      	str	r4, [sp, #32]
      psFlashOptionBytes->OptionType = OPTIONBYTE_USER;
 800ae04:	9301      	str	r3, [sp, #4]
      psFlashOptionBytes->USERType = OB_USER_SWAP_BANK;
 800ae06:	f44f 7380 	mov.w	r3, #256	@ 0x100
      psFlashOptionBytes->USERConfig = OB_SWAP_BANK_DISABLE;
 800ae0a:	e9cd 3006 	strd	r3, r0, [sp, #24]
      if (HAL_FLASHEx_OBProgram(psFlashOptionBytes) == HAL_OK)
 800ae0e:	a801      	add	r0, sp, #4
 800ae10:	f000 fd56 	bl	800b8c0 <HAL_FLASHEx_OBProgram>
 800ae14:	2800      	cmp	r0, #0
 800ae16:	d1f0      	bne.n	800adfa <SFU_LL_SECU_CheckApplyStaticProtections+0x8a>
      {
        *pbIsProtectionToBeApplied |= 1U;
        e_ret_status = SFU_SUCCESS;
        /* Execution stopped if flow control failed */
        FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800ae18:	4909      	ldr	r1, [pc, #36]	@ (800ae40 <SFU_LL_SECU_CheckApplyStaticProtections+0xd0>)
 800ae1a:	680a      	ldr	r2, [r1, #0]
 800ae1c:	f482 43cf 	eor.w	r3, r2, #26496	@ 0x6780
 800ae20:	f083 0307 	eor.w	r3, r3, #7
 800ae24:	600b      	str	r3, [r1, #0]
 800ae26:	f245 7376 	movw	r3, #22390	@ 0x5776
 800ae2a:	429a      	cmp	r2, r3
 800ae2c:	d001      	beq.n	800ae32 <SFU_LL_SECU_CheckApplyStaticProtections+0xc2>
 800ae2e:	f7fe fe0b 	bl	8009a48 <SFU_EXCPT_Security_Error>
        (void) HAL_FLASH_OB_Launch();
 800ae32:	f000 fce7 	bl	800b804 <HAL_FLASH_OB_Launch>
 800ae36:	e7c8      	b.n	800adca <SFU_LL_SECU_CheckApplyStaticProtections+0x5a>
 800ae38:	52002000 	.word	0x52002000
 800ae3c:	17ee0000 	.word	0x17ee0000
 800ae40:	20001100 	.word	0x20001100
 800ae44:	0800ede7 	.word	0x0800ede7
 800ae48:	00122f11 	.word	0x00122f11

0800ae4c <SFU_LL_SECU_CheckApplyRuntimeProtections>:
{
 800ae4c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  if (uStep == SFU_INITIAL_CONFIGURATION)
 800ae4e:	bb10      	cbnz	r0, 800ae96 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x4a>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable clock of DBG GPIO port */
  SFU_DBG_CLK_ENABLE();
 800ae50:	4b13      	ldr	r3, [pc, #76]	@ (800aea0 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x54>)
  GPIO_InitStruct.Pin = SFU_DBG_SWCLK_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF0_SWJ;
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ae52:	a901      	add	r1, sp, #4
  SFU_DBG_CLK_ENABLE();
 800ae54:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800ae58:	f042 0201 	orr.w	r2, r2, #1
 800ae5c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ae60:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
  SFU_DBG_CLK_ENABLE();
 800ae64:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800ae68:	f003 0301 	and.w	r3, r3, #1
 800ae6c:	9300      	str	r3, [sp, #0]
 800ae6e:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ae70:	2302      	movs	r3, #2
 800ae72:	e9cd 2301 	strd	r2, r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800ae76:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ae78:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = GPIO_AF0_SWJ;
 800ae7a:	e9cd 3004 	strd	r3, r0, [sp, #16]
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ae7e:	4809      	ldr	r0, [pc, #36]	@ (800aea4 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x58>)
 800ae80:	f000 ff5a 	bl	800bd38 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SFU_DBG_SWDIO_PIN;
 800ae84:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ae88:	a901      	add	r1, sp, #4
 800ae8a:	4806      	ldr	r0, [pc, #24]	@ (800aea4 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x58>)
  GPIO_InitStruct.Pin = SFU_DBG_SWDIO_PIN;
 800ae8c:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800ae8e:	2301      	movs	r3, #1
 800ae90:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ae92:	f000 ff51 	bl	800bd38 <HAL_GPIO_Init>
}
 800ae96:	4804      	ldr	r0, [pc, #16]	@ (800aea8 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x5c>)
 800ae98:	b007      	add	sp, #28
 800ae9a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae9e:	bf00      	nop
 800aea0:	58024400 	.word	0x58024400
 800aea4:	58020000 	.word	0x58020000
 800aea8:	00122f11 	.word	0x00122f11

0800aeac <SFU_LL_SECU_GetResetSources>:
  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDG1RST) != RESET) ||
 800aeac:	4b0f      	ldr	r3, [pc, #60]	@ (800aeec <SFU_LL_SECU_GetResetSources+0x40>)
 800aeae:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
 800aeb2:	0151      	lsls	r1, r2, #5
 800aeb4:	d414      	bmi.n	800aee0 <SFU_LL_SECU_GetResetSources+0x34>
      (__HAL_RCC_GET_FLAG(RCC_FLAG_WWDG1RST) != RESET))
 800aeb6:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDG1RST) != RESET) ||
 800aeba:	00d2      	lsls	r2, r2, #3
 800aebc:	d410      	bmi.n	800aee0 <SFU_LL_SECU_GetResetSources+0x34>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_LPWR1RST) != RESET)
 800aebe:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
 800aec2:	0051      	lsls	r1, r2, #1
 800aec4:	d40e      	bmi.n	800aee4 <SFU_LL_SECU_GetResetSources+0x38>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST) != RESET)
 800aec6:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
 800aeca:	01d2      	lsls	r2, r2, #7
 800aecc:	d40c      	bmi.n	800aee8 <SFU_LL_SECU_GetResetSources+0x3c>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
 800aece:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 800aed2:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 800aed6:	bf14      	ite	ne
 800aed8:	2303      	movne	r3, #3
 800aeda:	2300      	moveq	r3, #0
    *peResetpSourceId = SFU_RESET_WDG_RESET;
 800aedc:	7003      	strb	r3, [r0, #0]
}
 800aede:	4770      	bx	lr
 800aee0:	2301      	movs	r3, #1
 800aee2:	e7fb      	b.n	800aedc <SFU_LL_SECU_GetResetSources+0x30>
 800aee4:	2302      	movs	r3, #2
 800aee6:	e7f9      	b.n	800aedc <SFU_LL_SECU_GetResetSources+0x30>
 800aee8:	2305      	movs	r3, #5
 800aeea:	e7f7      	b.n	800aedc <SFU_LL_SECU_GetResetSources+0x30>
 800aeec:	58024400 	.word	0x58024400

0800aef0 <SFU_LL_SECU_ClearResetSources>:
  __HAL_RCC_CLEAR_RESET_FLAGS();
 800aef0:	4a03      	ldr	r2, [pc, #12]	@ (800af00 <SFU_LL_SECU_ClearResetSources+0x10>)
 800aef2:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
 800aef6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800aefa:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
}
 800aefe:	4770      	bx	lr
 800af00:	58024400 	.word	0x58024400

0800af04 <SFU_LL_SECU_IWDG_Refresh>:
}
 800af04:	4800      	ldr	r0, [pc, #0]	@ (800af08 <SFU_LL_SECU_IWDG_Refresh+0x4>)
 800af06:	4770      	bx	lr
 800af08:	00122f11 	.word	0x00122f11

0800af0c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 800af0c:	f8df d034 	ldr.w	sp, [pc, #52]	@ 800af44 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800af10:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800af12:	e003      	b.n	800af1c <LoopCopyDataInit>

0800af14 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800af14:	4b0c      	ldr	r3, [pc, #48]	@ (800af48 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800af16:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800af18:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800af1a:	3104      	adds	r1, #4

0800af1c <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800af1c:	480b      	ldr	r0, [pc, #44]	@ (800af4c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800af1e:	4b0c      	ldr	r3, [pc, #48]	@ (800af50 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800af20:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800af22:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800af24:	d3f6      	bcc.n	800af14 <CopyDataInit>
  ldr  r2, =_sbss
 800af26:	4a0b      	ldr	r2, [pc, #44]	@ (800af54 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800af28:	e002      	b.n	800af30 <LoopFillZerobss>

0800af2a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800af2a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800af2c:	f842 3b04 	str.w	r3, [r2], #4

0800af30 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 800af30:	4b09      	ldr	r3, [pc, #36]	@ (800af58 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800af32:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800af34:	d3f9      	bcc.n	800af2a <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit
 800af36:	f000 f8ad 	bl	800b094 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800af3a:	f002 fced 	bl	800d918 <__libc_init_array>
/* Call the application entry point.*/
  bl  main
 800af3e:	f7fd ff6d 	bl	8008e1c <main>
  bx  lr
 800af42:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 800af44:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 800af48:	0800ee70 	.word	0x0800ee70
  ldr  r0, =_sdata
 800af4c:	20001100 	.word	0x20001100
  ldr  r3, =_edata
 800af50:	20001188 	.word	0x20001188
  ldr  r2, =_sbss
 800af54:	20001188 	.word	0x20001188
  ldr  r3, = _ebss
 800af58:	20001ee8 	.word	0x20001ee8

0800af5c <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800af5c:	e7fe      	b.n	800af5c <ADC3_IRQHandler>
	...

0800af60 <BSP_LED_Init>:
void BSP_LED_Init(Led_TypeDef Led)
{
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 800af60:	4b15      	ldr	r3, [pc, #84]	@ (800afb8 <BSP_LED_Init+0x58>)
 800af62:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800af66:	f042 0202 	orr.w	r2, r2, #2
{
 800af6a:	b570      	push	{r4, r5, r6, lr}
 800af6c:	b088      	sub	sp, #32
  LEDx_GPIO_CLK_ENABLE(Led);
 800af6e:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800af72:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800af76:	f003 0302 	and.w	r3, r3, #2
 800af7a:	b9c8      	cbnz	r0, 800afb0 <BSP_LED_Init+0x50>
 800af7c:	9301      	str	r3, [sp, #4]
 800af7e:	9b01      	ldr	r3, [sp, #4]

  /* Configure the GPIO_LED pin */
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800af80:	4b0e      	ldr	r3, [pc, #56]	@ (800afbc <BSP_LED_Init+0x5c>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800af82:	2600      	movs	r6, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;

  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800af84:	4c0e      	ldr	r4, [pc, #56]	@ (800afc0 <BSP_LED_Init+0x60>)
 800af86:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800af88:	f833 5010 	ldrh.w	r5, [r3, r0, lsl #1]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800af8c:	2301      	movs	r3, #1
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800af8e:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800af92:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800af94:	6860      	ldr	r0, [r4, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800af96:	e9cd 3604 	strd	r3, r6, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800af9a:	2303      	movs	r3, #3
 800af9c:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800af9e:	f000 fecb 	bl	800bd38 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 800afa2:	4632      	mov	r2, r6
 800afa4:	4629      	mov	r1, r5
 800afa6:	6860      	ldr	r0, [r4, #4]
 800afa8:	f000 ffb4 	bl	800bf14 <HAL_GPIO_WritePin>
}
 800afac:	b008      	add	sp, #32
 800afae:	bd70      	pop	{r4, r5, r6, pc}
  LEDx_GPIO_CLK_ENABLE(Led);
 800afb0:	9302      	str	r3, [sp, #8]
 800afb2:	9b02      	ldr	r3, [sp, #8]
 800afb4:	e7e4      	b.n	800af80 <BSP_LED_Init+0x20>
 800afb6:	bf00      	nop
 800afb8:	58024400 	.word	0x58024400
 800afbc:	0800e50c 	.word	0x0800e50c
 800afc0:	20001108 	.word	0x20001108

0800afc4 <BSP_LED_Off>:
  *     @arg  LED3
  * @retval None
  */
void BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 800afc4:	4b04      	ldr	r3, [pc, #16]	@ (800afd8 <BSP_LED_Off+0x14>)
 800afc6:	2200      	movs	r2, #0
 800afc8:	4904      	ldr	r1, [pc, #16]	@ (800afdc <BSP_LED_Off+0x18>)
 800afca:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800afce:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
 800afd2:	6858      	ldr	r0, [r3, #4]
 800afd4:	f000 bf9e 	b.w	800bf14 <HAL_GPIO_WritePin>
 800afd8:	20001108 	.word	0x20001108
 800afdc:	0800e50c 	.word	0x0800e50c

0800afe0 <BSP_LED_Toggle>:
  *     @arg  LED3
  * @retval None
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 800afe0:	4b04      	ldr	r3, [pc, #16]	@ (800aff4 <BSP_LED_Toggle+0x14>)
 800afe2:	4a05      	ldr	r2, [pc, #20]	@ (800aff8 <BSP_LED_Toggle+0x18>)
 800afe4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800afe8:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
 800afec:	6858      	ldr	r0, [r3, #4]
 800afee:	f000 bf96 	b.w	800bf1e <HAL_GPIO_TogglePin>
 800aff2:	bf00      	nop
 800aff4:	20001108 	.word	0x20001108
 800aff8:	0800e50c 	.word	0x0800e50c

0800affc <BSP_PB_Init>:
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800affc:	4b1d      	ldr	r3, [pc, #116]	@ (800b074 <BSP_PB_Init+0x78>)
 800affe:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800b002:	f042 0204 	orr.w	r2, r2, #4
{
 800b006:	b510      	push	{r4, lr}
 800b008:	b086      	sub	sp, #24
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800b00a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800b00e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800b012:	f003 0304 	and.w	r3, r3, #4
 800b016:	9300      	str	r3, [sp, #0]
 800b018:	9b00      	ldr	r3, [sp, #0]

  if(ButtonMode == BUTTON_MODE_GPIO)
 800b01a:	b981      	cbnz	r1, 800b03e <BSP_PB_Init+0x42>
  {
    /* Configure Button pin as input */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 800b01c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800b020:	2202      	movs	r2, #2
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800b022:	e9cd 3101 	strd	r3, r1, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800b026:	2303      	movs	r3, #3
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800b028:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800b02a:	e9cd 2303 	strd	r2, r3, [sp, #12]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800b02e:	4b12      	ldr	r3, [pc, #72]	@ (800b078 <BSP_PB_Init+0x7c>)
 800b030:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800b034:	6918      	ldr	r0, [r3, #16]
 800b036:	f000 fe7f 	bl	800bd38 <HAL_GPIO_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
  }
}
 800b03a:	b006      	add	sp, #24
 800b03c:	bd10      	pop	{r4, pc}
  if(ButtonMode == BUTTON_MODE_EXTI)
 800b03e:	2901      	cmp	r1, #1
 800b040:	d1fb      	bne.n	800b03a <BSP_PB_Init+0x3e>
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 800b042:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800b046:	2400      	movs	r4, #0
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800b048:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 800b04a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800b04c:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 800b050:	e9cd 3402 	strd	r3, r4, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800b054:	4b08      	ldr	r3, [pc, #32]	@ (800b078 <BSP_PB_Init+0x7c>)
 800b056:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800b05a:	6918      	ldr	r0, [r3, #16]
 800b05c:	f000 fe6c 	bl	800bd38 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 800b060:	4622      	mov	r2, r4
 800b062:	210f      	movs	r1, #15
 800b064:	2028      	movs	r0, #40	@ 0x28
 800b066:	f000 f91d 	bl	800b2a4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 800b06a:	2028      	movs	r0, #40	@ 0x28
 800b06c:	f000 f94c 	bl	800b308 <HAL_NVIC_EnableIRQ>
}
 800b070:	e7e3      	b.n	800b03a <BSP_PB_Init+0x3e>
 800b072:	bf00      	nop
 800b074:	58024400 	.word	0x58024400
 800b078:	20001108 	.word	0x20001108

0800b07c <BSP_PB_GetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_USER
  * @retval The Button GPIO pin value.
  */
uint32_t BSP_PB_GetState(Button_TypeDef Button)
{
 800b07c:	b508      	push	{r3, lr}
  return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 800b07e:	4b04      	ldr	r3, [pc, #16]	@ (800b090 <BSP_PB_GetState+0x14>)
 800b080:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800b084:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800b088:	6900      	ldr	r0, [r0, #16]
 800b08a:	f000 ff3d 	bl	800bf08 <HAL_GPIO_ReadPin>
}
 800b08e:	bd08      	pop	{r3, pc}
 800b090:	20001108 	.word	0x20001108

0800b094 <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 800b094:	4a2e      	ldr	r2, [pc, #184]	@ (800b150 <SystemInit+0xbc>)
 800b096:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 800b09a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800b09e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800b0a2:	4a2c      	ldr	r2, [pc, #176]	@ (800b154 <SystemInit+0xc0>)
 800b0a4:	6813      	ldr	r3, [r2, #0]
 800b0a6:	f003 030f 	and.w	r3, r3, #15
 800b0aa:	2b06      	cmp	r3, #6
 800b0ac:	d805      	bhi.n	800b0ba <SystemInit+0x26>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 800b0ae:	6813      	ldr	r3, [r2, #0]
 800b0b0:	f023 030f 	bic.w	r3, r3, #15
 800b0b4:	f043 0307 	orr.w	r3, r3, #7
 800b0b8:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 800b0ba:	4b27      	ldr	r3, [pc, #156]	@ (800b158 <SystemInit+0xc4>)
 800b0bc:	681a      	ldr	r2, [r3, #0]
 800b0be:	f042 0201 	orr.w	r2, r2, #1
 800b0c2:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800b0c4:	2200      	movs	r2, #0
 800b0c6:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 800b0c8:	4a24      	ldr	r2, [pc, #144]	@ (800b15c <SystemInit+0xc8>)
 800b0ca:	6819      	ldr	r1, [r3, #0]
 800b0cc:	400a      	ands	r2, r1

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800b0ce:	4921      	ldr	r1, [pc, #132]	@ (800b154 <SystemInit+0xc0>)
  RCC->CR &= 0xEAF6ED7FU;
 800b0d0:	601a      	str	r2, [r3, #0]
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800b0d2:	680a      	ldr	r2, [r1, #0]
 800b0d4:	0710      	lsls	r0, r2, #28
 800b0d6:	d505      	bpl.n	800b0e4 <SystemInit+0x50>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 800b0d8:	680a      	ldr	r2, [r1, #0]
 800b0da:	f022 020f 	bic.w	r2, r2, #15
 800b0de:	f042 0207 	orr.w	r2, r2, #7
 800b0e2:	600a      	str	r2, [r1, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 800b0e4:	2200      	movs	r2, #0

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
 800b0e6:	491e      	ldr	r1, [pc, #120]	@ (800b160 <SystemInit+0xcc>)
  RCC->D1CFGR = 0x00000000;
 800b0e8:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
 800b0ea:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
 800b0ec:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x02020200;
 800b0ee:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
 800b0f0:	491c      	ldr	r1, [pc, #112]	@ (800b164 <SystemInit+0xd0>)
 800b0f2:	62d9      	str	r1, [r3, #44]	@ 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 800b0f4:	491c      	ldr	r1, [pc, #112]	@ (800b168 <SystemInit+0xd4>)
 800b0f6:	6319      	str	r1, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 800b0f8:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 800b0fa:	6399      	str	r1, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 800b0fc:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 800b0fe:	6419      	str	r1, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 800b100:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800b102:	6819      	ldr	r1, [r3, #0]
 800b104:	f421 2180 	bic.w	r1, r1, #262144	@ 0x40000
 800b108:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800b10a:	661a      	str	r2, [r3, #96]	@ 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 800b10c:	4b17      	ldr	r3, [pc, #92]	@ (800b16c <SystemInit+0xd8>)
 800b10e:	681b      	ldr	r3, [r3, #0]
 800b110:	f36f 030f 	bfc	r3, #0, #16
 800b114:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800b118:	d203      	bcs.n	800b122 <SystemInit+0x8e>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 800b11a:	4b15      	ldr	r3, [pc, #84]	@ (800b170 <SystemInit+0xdc>)
 800b11c:	2201      	movs	r2, #1
 800b11e:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#else
  if(READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN) == 0U)
 800b122:	4b0d      	ldr	r3, [pc, #52]	@ (800b158 <SystemInit+0xc4>)
 800b124:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
 800b128:	04d2      	lsls	r2, r2, #19
 800b12a:	d40f      	bmi.n	800b14c <SystemInit+0xb8>
  {
    /* Enable the FMC interface clock */
    SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 800b12c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
    /*
     * Disable the FMC bank1 (enabled after reset).
     * This, prevents CPU speculation access on this bank which blocks the use of FMC during
     * 24us. During this time the others FMC master (such as LTDC) cannot use it!
     */
    FMC_Bank1_R->BTCR[0] = 0x000030D2;
 800b130:	f243 01d2 	movw	r1, #12498	@ 0x30d2
    SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 800b134:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 800b138:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
    FMC_Bank1_R->BTCR[0] = 0x000030D2;
 800b13c:	4a0d      	ldr	r2, [pc, #52]	@ (800b174 <SystemInit+0xe0>)
 800b13e:	6011      	str	r1, [r2, #0]

    /* Disable the FMC interface clock */
    CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 800b140:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
 800b144:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 800b148:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
 800b14c:	4770      	bx	lr
 800b14e:	bf00      	nop
 800b150:	e000ed00 	.word	0xe000ed00
 800b154:	52002000 	.word	0x52002000
 800b158:	58024400 	.word	0x58024400
 800b15c:	eaf6ed7f 	.word	0xeaf6ed7f
 800b160:	02020200 	.word	0x02020200
 800b164:	01ff0000 	.word	0x01ff0000
 800b168:	01010280 	.word	0x01010280
 800b16c:	5c001000 	.word	0x5c001000
 800b170:	51008000 	.word	0x51008000
 800b174:	52004000 	.word	0x52004000

0800b178 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800b178:	b570      	push	{r4, r5, r6, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 800b17a:	4e0f      	ldr	r6, [pc, #60]	@ (800b1b8 <HAL_InitTick+0x40>)
{
 800b17c:	4605      	mov	r5, r0
  if((uint32_t)uwTickFreq == 0UL)
 800b17e:	7832      	ldrb	r2, [r6, #0]
 800b180:	b90a      	cbnz	r2, 800b186 <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
 800b182:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 800b184:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 800b186:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800b18a:	fbb3 f3f2 	udiv	r3, r3, r2
 800b18e:	4a0b      	ldr	r2, [pc, #44]	@ (800b1bc <HAL_InitTick+0x44>)
 800b190:	6810      	ldr	r0, [r2, #0]
 800b192:	fbb0 f0f3 	udiv	r0, r0, r3
 800b196:	f000 f8d7 	bl	800b348 <HAL_SYSTICK_Config>
 800b19a:	4604      	mov	r4, r0
 800b19c:	2800      	cmp	r0, #0
 800b19e:	d1f0      	bne.n	800b182 <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800b1a0:	2d0f      	cmp	r5, #15
 800b1a2:	d8ee      	bhi.n	800b182 <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800b1a4:	4602      	mov	r2, r0
 800b1a6:	4629      	mov	r1, r5
 800b1a8:	f04f 30ff 	mov.w	r0, #4294967295
 800b1ac:	f000 f87a 	bl	800b2a4 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800b1b0:	4620      	mov	r0, r4
 800b1b2:	6075      	str	r5, [r6, #4]
  return HAL_OK;
 800b1b4:	e7e6      	b.n	800b184 <HAL_InitTick+0xc>
 800b1b6:	bf00      	nop
 800b1b8:	20001124 	.word	0x20001124
 800b1bc:	20001120 	.word	0x20001120

0800b1c0 <HAL_Init>:
{
 800b1c0:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800b1c2:	2003      	movs	r0, #3
 800b1c4:	f000 f85c 	bl	800b280 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800b1c8:	f001 f97e 	bl	800c4c8 <HAL_RCC_GetSysClockFreq>
 800b1cc:	490f      	ldr	r1, [pc, #60]	@ (800b20c <HAL_Init+0x4c>)
 800b1ce:	4a10      	ldr	r2, [pc, #64]	@ (800b210 <HAL_Init+0x50>)
 800b1d0:	698b      	ldr	r3, [r1, #24]
 800b1d2:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800b1d6:	5cd3      	ldrb	r3, [r2, r3]
 800b1d8:	f003 031f 	and.w	r3, r3, #31
 800b1dc:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800b1de:	698b      	ldr	r3, [r1, #24]
 800b1e0:	f003 030f 	and.w	r3, r3, #15
 800b1e4:	5cd3      	ldrb	r3, [r2, r3]
 800b1e6:	4a0b      	ldr	r2, [pc, #44]	@ (800b214 <HAL_Init+0x54>)
 800b1e8:	f003 031f 	and.w	r3, r3, #31
 800b1ec:	fa20 f303 	lsr.w	r3, r0, r3
 800b1f0:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 800b1f2:	4b09      	ldr	r3, [pc, #36]	@ (800b218 <HAL_Init+0x58>)
 800b1f4:	6018      	str	r0, [r3, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800b1f6:	2000      	movs	r0, #0
 800b1f8:	f7ff ffbe 	bl	800b178 <HAL_InitTick>
 800b1fc:	4604      	mov	r4, r0
 800b1fe:	b918      	cbnz	r0, 800b208 <HAL_Init+0x48>
  HAL_MspInit();
 800b200:	f7fd fe66 	bl	8008ed0 <HAL_MspInit>
}
 800b204:	4620      	mov	r0, r4
 800b206:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800b208:	2401      	movs	r4, #1
 800b20a:	e7fb      	b.n	800b204 <HAL_Init+0x44>
 800b20c:	58024400 	.word	0x58024400
 800b210:	0800e516 	.word	0x0800e516
 800b214:	2000111c 	.word	0x2000111c
 800b218:	20001120 	.word	0x20001120

0800b21c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 800b21c:	4a03      	ldr	r2, [pc, #12]	@ (800b22c <HAL_IncTick+0x10>)
 800b21e:	4b04      	ldr	r3, [pc, #16]	@ (800b230 <HAL_IncTick+0x14>)
 800b220:	6811      	ldr	r1, [r2, #0]
 800b222:	781b      	ldrb	r3, [r3, #0]
 800b224:	440b      	add	r3, r1
 800b226:	6013      	str	r3, [r2, #0]
}
 800b228:	4770      	bx	lr
 800b22a:	bf00      	nop
 800b22c:	20001d78 	.word	0x20001d78
 800b230:	20001124 	.word	0x20001124

0800b234 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800b234:	4b01      	ldr	r3, [pc, #4]	@ (800b23c <HAL_GetTick+0x8>)
 800b236:	6818      	ldr	r0, [r3, #0]
}
 800b238:	4770      	bx	lr
 800b23a:	bf00      	nop
 800b23c:	20001d78 	.word	0x20001d78

0800b240 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800b240:	b538      	push	{r3, r4, r5, lr}
 800b242:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800b244:	f7ff fff6 	bl	800b234 <HAL_GetTick>
 800b248:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800b24a:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 800b24c:	bf1e      	ittt	ne
 800b24e:	4b04      	ldrne	r3, [pc, #16]	@ (800b260 <HAL_Delay+0x20>)
 800b250:	781b      	ldrbne	r3, [r3, #0]
 800b252:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800b254:	f7ff ffee 	bl	800b234 <HAL_GetTick>
 800b258:	1b43      	subs	r3, r0, r5
 800b25a:	42a3      	cmp	r3, r4
 800b25c:	d3fa      	bcc.n	800b254 <HAL_Delay+0x14>
  {
  }
}
 800b25e:	bd38      	pop	{r3, r4, r5, pc}
 800b260:	20001124 	.word	0x20001124

0800b264 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 800b264:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 800b268:	6913      	ldr	r3, [r2, #16]
 800b26a:	f023 0302 	bic.w	r3, r3, #2
 800b26e:	6113      	str	r3, [r2, #16]
}
 800b270:	4770      	bx	lr
	...

0800b274 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 800b274:	4b01      	ldr	r3, [pc, #4]	@ (800b27c <HAL_GetREVID+0x8>)
 800b276:	6818      	ldr	r0, [r3, #0]
}
 800b278:	0c00      	lsrs	r0, r0, #16
 800b27a:	4770      	bx	lr
 800b27c:	5c001000 	.word	0x5c001000

0800b280 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800b280:	4907      	ldr	r1, [pc, #28]	@ (800b2a0 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800b282:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800b284:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800b286:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800b28a:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b28e:	0412      	lsls	r2, r2, #16
 800b290:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800b292:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800b294:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800b298:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800b29c:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800b29e:	4770      	bx	lr
 800b2a0:	e000ed00 	.word	0xe000ed00

0800b2a4 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800b2a4:	4b16      	ldr	r3, [pc, #88]	@ (800b300 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800b2a6:	b530      	push	{r4, r5, lr}
 800b2a8:	68dc      	ldr	r4, [r3, #12]
 800b2aa:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800b2ae:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b2b2:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800b2b4:	2b04      	cmp	r3, #4
 800b2b6:	bf28      	it	cs
 800b2b8:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b2ba:	2d06      	cmp	r5, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b2bc:	f04f 35ff 	mov.w	r5, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b2c0:	bf8c      	ite	hi
 800b2c2:	3c03      	subhi	r4, #3
 800b2c4:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b2c6:	fa05 f303 	lsl.w	r3, r5, r3
  if ((int32_t)(IRQn) >= 0)
 800b2ca:	2800      	cmp	r0, #0
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800b2cc:	fa05 f504 	lsl.w	r5, r5, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b2d0:	ea21 0303 	bic.w	r3, r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800b2d4:	ea22 0205 	bic.w	r2, r2, r5
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b2d8:	fa03 f304 	lsl.w	r3, r3, r4
 800b2dc:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b2e0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800b2e4:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 800b2e6:	db06      	blt.n	800b2f6 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b2e8:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 800b2ec:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 800b2f0:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800b2f4:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b2f6:	f000 000f 	and.w	r0, r0, #15
 800b2fa:	4a02      	ldr	r2, [pc, #8]	@ (800b304 <HAL_NVIC_SetPriority+0x60>)
 800b2fc:	5413      	strb	r3, [r2, r0]
 800b2fe:	e7f9      	b.n	800b2f4 <HAL_NVIC_SetPriority+0x50>
 800b300:	e000ed00 	.word	0xe000ed00
 800b304:	e000ed14 	.word	0xe000ed14

0800b308 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800b308:	2800      	cmp	r0, #0
 800b30a:	db07      	blt.n	800b31c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800b30c:	0941      	lsrs	r1, r0, #5
 800b30e:	2301      	movs	r3, #1
 800b310:	f000 001f 	and.w	r0, r0, #31
 800b314:	4a02      	ldr	r2, [pc, #8]	@ (800b320 <HAL_NVIC_EnableIRQ+0x18>)
 800b316:	4083      	lsls	r3, r0
 800b318:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800b31c:	4770      	bx	lr
 800b31e:	bf00      	nop
 800b320:	e000e100 	.word	0xe000e100

0800b324 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 800b324:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800b328:	4905      	ldr	r1, [pc, #20]	@ (800b340 <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800b32a:	4b06      	ldr	r3, [pc, #24]	@ (800b344 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800b32c:	68ca      	ldr	r2, [r1, #12]
 800b32e:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800b332:	4313      	orrs	r3, r2
 800b334:	60cb      	str	r3, [r1, #12]
 800b336:	f3bf 8f4f 	dsb	sy
    __NOP();
 800b33a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 800b33c:	e7fd      	b.n	800b33a <HAL_NVIC_SystemReset+0x16>
 800b33e:	bf00      	nop
 800b340:	e000ed00 	.word	0xe000ed00
 800b344:	05fa0004 	.word	0x05fa0004

0800b348 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800b348:	3801      	subs	r0, #1
 800b34a:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 800b34e:	d20b      	bcs.n	800b368 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800b350:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b354:	4a05      	ldr	r2, [pc, #20]	@ (800b36c <HAL_SYSTICK_Config+0x24>)
 800b356:	21f0      	movs	r1, #240	@ 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800b358:	6158      	str	r0, [r3, #20]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800b35a:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b35c:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b360:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800b362:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b364:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800b366:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800b368:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 800b36a:	4770      	bx	lr
 800b36c:	e000ed00 	.word	0xe000ed00

0800b370 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800b370:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b372:	f022 0603 	bic.w	r6, r2, #3
 800b376:	460b      	mov	r3, r1
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 800b378:	0897      	lsrs	r7, r2, #2
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b37a:	6805      	ldr	r5, [r0, #0]
 800b37c:	440e      	add	r6, r1
  for (i = 0U; i < (BufferLength / 4U); i++)
 800b37e:	42b3      	cmp	r3, r6
 800b380:	d10a      	bne.n	800b398 <CRC_Handle_8+0x28>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 800b382:	f012 0203 	ands.w	r2, r2, #3
 800b386:	d004      	beq.n	800b392 <CRC_Handle_8+0x22>
  {
    if ((BufferLength % 4U) == 1U)
 800b388:	2a01      	cmp	r2, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b38a:	f811 4027 	ldrb.w	r4, [r1, r7, lsl #2]
    if ((BufferLength % 4U) == 1U)
 800b38e:	d114      	bne.n	800b3ba <CRC_Handle_8+0x4a>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 800b390:	702c      	strb	r4, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800b392:	6803      	ldr	r3, [r0, #0]
 800b394:	6818      	ldr	r0, [r3, #0]
}
 800b396:	bdf0      	pop	{r4, r5, r6, r7, pc}
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800b398:	785c      	ldrb	r4, [r3, #1]
 800b39a:	3304      	adds	r3, #4
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b39c:	f813 cc04 	ldrb.w	ip, [r3, #-4]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800b3a0:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800b3a2:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 800b3a6:	f813 cc01 	ldrb.w	ip, [r3, #-1]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800b3aa:	ea44 040c 	orr.w	r4, r4, ip
 800b3ae:	f813 cc02 	ldrb.w	ip, [r3, #-2]
 800b3b2:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b3b6:	602c      	str	r4, [r5, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800b3b8:	e7e1      	b.n	800b37e <CRC_Handle_8+0xe>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800b3ba:	7859      	ldrb	r1, [r3, #1]
    if ((BufferLength % 4U) == 2U)
 800b3bc:	2a02      	cmp	r2, #2
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800b3be:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
      *pReg = data;
 800b3c2:	8029      	strh	r1, [r5, #0]
    if ((BufferLength % 4U) == 2U)
 800b3c4:	d0e5      	beq.n	800b392 <CRC_Handle_8+0x22>
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800b3c6:	789b      	ldrb	r3, [r3, #2]
 800b3c8:	702b      	strb	r3, [r5, #0]
 800b3ca:	e7e2      	b.n	800b392 <CRC_Handle_8+0x22>

0800b3cc <CRC_Handle_16>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 800b3cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b3ce:	6800      	ldr	r0, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b3d0:	0855      	lsrs	r5, r2, #1
 800b3d2:	2300      	movs	r3, #0
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b3d4:	1c8e      	adds	r6, r1, #2
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b3d6:	429d      	cmp	r5, r3
 800b3d8:	d106      	bne.n	800b3e8 <CRC_Handle_16+0x1c>
  }
  if ((BufferLength % 2U) != 0U)
 800b3da:	07d3      	lsls	r3, r2, #31
 800b3dc:	d502      	bpl.n	800b3e4 <CRC_Handle_16+0x18>
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 800b3de:	f831 3025 	ldrh.w	r3, [r1, r5, lsl #2]
 800b3e2:	8003      	strh	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800b3e4:	6800      	ldr	r0, [r0, #0]
}
 800b3e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b3e8:	f831 7023 	ldrh.w	r7, [r1, r3, lsl #2]
 800b3ec:	f836 4023 	ldrh.w	r4, [r6, r3, lsl #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b3f0:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b3f2:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 800b3f6:	6004      	str	r4, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b3f8:	e7ed      	b.n	800b3d6 <CRC_Handle_16+0xa>

0800b3fa <HAL_CRC_MspInit>:
}
 800b3fa:	4770      	bx	lr

0800b3fc <HAL_CRC_Init>:
{
 800b3fc:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 800b3fe:	4604      	mov	r4, r0
 800b400:	b908      	cbnz	r0, 800b406 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 800b402:	2001      	movs	r0, #1
}
 800b404:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 800b406:	7f43      	ldrb	r3, [r0, #29]
 800b408:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 800b40c:	b913      	cbnz	r3, 800b414 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 800b40e:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800b410:	f7ff fff3 	bl	800b3fa <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 800b414:	2302      	movs	r3, #2
 800b416:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800b418:	7923      	ldrb	r3, [r4, #4]
 800b41a:	b9e3      	cbnz	r3, 800b456 <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800b41c:	6823      	ldr	r3, [r4, #0]
 800b41e:	4a13      	ldr	r2, [pc, #76]	@ (800b46c <HAL_CRC_Init+0x70>)
 800b420:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800b422:	689a      	ldr	r2, [r3, #8]
 800b424:	f022 0218 	bic.w	r2, r2, #24
 800b428:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800b42a:	7962      	ldrb	r2, [r4, #5]
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800b42c:	6823      	ldr	r3, [r4, #0]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800b42e:	b9d2      	cbnz	r2, 800b466 <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800b430:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800b434:	611a      	str	r2, [r3, #16]
  return HAL_OK;
 800b436:	2000      	movs	r0, #0
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800b438:	689a      	ldr	r2, [r3, #8]
 800b43a:	6961      	ldr	r1, [r4, #20]
 800b43c:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800b440:	430a      	orrs	r2, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800b442:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800b444:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800b446:	689a      	ldr	r2, [r3, #8]
 800b448:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 800b44c:	430a      	orrs	r2, r1
 800b44e:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800b450:	2301      	movs	r3, #1
 800b452:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 800b454:	e7d6      	b.n	800b404 <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800b456:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 800b45a:	4620      	mov	r0, r4
 800b45c:	f000 f82c 	bl	800b4b8 <HAL_CRCEx_Polynomial_Set>
 800b460:	2800      	cmp	r0, #0
 800b462:	d0e2      	beq.n	800b42a <HAL_CRC_Init+0x2e>
 800b464:	e7cd      	b.n	800b402 <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800b466:	6922      	ldr	r2, [r4, #16]
 800b468:	e7e4      	b.n	800b434 <HAL_CRC_Init+0x38>
 800b46a:	bf00      	nop
 800b46c:	04c11db7 	.word	0x04c11db7

0800b470 <HAL_CRC_Calculate>:
{
 800b470:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 800b472:	2602      	movs	r6, #2
{
 800b474:	4604      	mov	r4, r0
  hcrc->State = HAL_CRC_STATE_BUSY;
 800b476:	7746      	strb	r6, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 800b478:	6806      	ldr	r6, [r0, #0]
 800b47a:	68b7      	ldr	r7, [r6, #8]
 800b47c:	f047 0701 	orr.w	r7, r7, #1
 800b480:	60b7      	str	r7, [r6, #8]
  switch (hcrc->InputDataFormat)
 800b482:	6a07      	ldr	r7, [r0, #32]
 800b484:	2f02      	cmp	r7, #2
 800b486:	d014      	beq.n	800b4b2 <HAL_CRC_Calculate+0x42>
 800b488:	2f03      	cmp	r7, #3
 800b48a:	d005      	beq.n	800b498 <HAL_CRC_Calculate+0x28>
 800b48c:	2f01      	cmp	r7, #1
 800b48e:	d00d      	beq.n	800b4ac <HAL_CRC_Calculate+0x3c>
 800b490:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 800b492:	2301      	movs	r3, #1
 800b494:	7763      	strb	r3, [r4, #29]
}
 800b496:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b498:	eb01 0582 	add.w	r5, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 800b49c:	42a9      	cmp	r1, r5
 800b49e:	d101      	bne.n	800b4a4 <HAL_CRC_Calculate+0x34>
      temp = hcrc->Instance->DR;
 800b4a0:	6830      	ldr	r0, [r6, #0]
      break;
 800b4a2:	e7f6      	b.n	800b492 <HAL_CRC_Calculate+0x22>
        hcrc->Instance->DR = pBuffer[index];
 800b4a4:	f851 3b04 	ldr.w	r3, [r1], #4
 800b4a8:	6033      	str	r3, [r6, #0]
      for (index = 0U; index < BufferLength; index++)
 800b4aa:	e7f7      	b.n	800b49c <HAL_CRC_Calculate+0x2c>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800b4ac:	f7ff ff60 	bl	800b370 <CRC_Handle_8>
      break;
 800b4b0:	e7ef      	b.n	800b492 <HAL_CRC_Calculate+0x22>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 800b4b2:	f7ff ff8b 	bl	800b3cc <CRC_Handle_16>
      break;
 800b4b6:	e7ec      	b.n	800b492 <HAL_CRC_Calculate+0x22>

0800b4b8 <HAL_CRCEx_Polynomial_Set>:

  /* Check the parameters */
  assert_param(IS_CRC_POL_LENGTH(PolyLength));

  /* Ensure that the generating polynomial is odd */
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 800b4b8:	07cb      	lsls	r3, r1, #31
{
 800b4ba:	b510      	push	{r4, lr}
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 800b4bc:	d50d      	bpl.n	800b4da <HAL_CRCEx_Polynomial_Set+0x22>
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 800b4be:	231f      	movs	r3, #31
     * definition. HAL_ERROR is reported if Pol degree is
     * larger than that indicated by PolyLength.
     * Look for MSB position: msb will contain the degree of
     *  the second to the largest polynomial member. E.g., for
     *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
    while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800b4c0:	3b01      	subs	r3, #1
 800b4c2:	d31d      	bcc.n	800b500 <HAL_CRCEx_Polynomial_Set+0x48>
 800b4c4:	fa21 f403 	lsr.w	r4, r1, r3
 800b4c8:	07e4      	lsls	r4, r4, #31
 800b4ca:	d5f9      	bpl.n	800b4c0 <HAL_CRCEx_Polynomial_Set+0x8>
    {
    }

    switch (PolyLength)
 800b4cc:	2a10      	cmp	r2, #16
 800b4ce:	d013      	beq.n	800b4f8 <HAL_CRCEx_Polynomial_Set+0x40>
 800b4d0:	2a10      	cmp	r2, #16
 800b4d2:	d804      	bhi.n	800b4de <HAL_CRCEx_Polynomial_Set+0x26>
 800b4d4:	b13a      	cbz	r2, 800b4e6 <HAL_CRCEx_Polynomial_Set+0x2e>
 800b4d6:	2a08      	cmp	r2, #8
 800b4d8:	d010      	beq.n	800b4fc <HAL_CRCEx_Polynomial_Set+0x44>
    {

      case CRC_POLYLENGTH_7B:
        if (msb >= HAL_CRC_LENGTH_7B)
        {
          status =   HAL_ERROR;
 800b4da:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 800b4dc:	e00b      	b.n	800b4f6 <HAL_CRCEx_Polynomial_Set+0x3e>
    switch (PolyLength)
 800b4de:	2a18      	cmp	r2, #24
 800b4e0:	d1fb      	bne.n	800b4da <HAL_CRCEx_Polynomial_Set+0x22>
        if (msb >= HAL_CRC_LENGTH_7B)
 800b4e2:	2b06      	cmp	r3, #6
        if (msb >= HAL_CRC_LENGTH_16B)
 800b4e4:	d8f9      	bhi.n	800b4da <HAL_CRCEx_Polynomial_Set+0x22>
    WRITE_REG(hcrc->Instance->POL, Pol);
 800b4e6:	6800      	ldr	r0, [r0, #0]
 800b4e8:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800b4ea:	6883      	ldr	r3, [r0, #8]
 800b4ec:	f023 0318 	bic.w	r3, r3, #24
 800b4f0:	4313      	orrs	r3, r2
 800b4f2:	6083      	str	r3, [r0, #8]
 800b4f4:	2000      	movs	r0, #0
}
 800b4f6:	bd10      	pop	{r4, pc}
        if (msb >= HAL_CRC_LENGTH_8B)
 800b4f8:	2b07      	cmp	r3, #7
 800b4fa:	e7f3      	b.n	800b4e4 <HAL_CRCEx_Polynomial_Set+0x2c>
        if (msb >= HAL_CRC_LENGTH_16B)
 800b4fc:	2b0f      	cmp	r3, #15
 800b4fe:	e7f1      	b.n	800b4e4 <HAL_CRCEx_Polynomial_Set+0x2c>
    switch (PolyLength)
 800b500:	2a10      	cmp	r2, #16
 800b502:	d1e5      	bne.n	800b4d0 <HAL_CRCEx_Polynomial_Set+0x18>
 800b504:	e7e9      	b.n	800b4da <HAL_CRCEx_Polynomial_Set+0x22>
	...

0800b508 <HAL_FLASH_Unlock>:
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 800b508:	4b10      	ldr	r3, [pc, #64]	@ (800b54c <HAL_FLASH_Unlock+0x44>)
 800b50a:	68da      	ldr	r2, [r3, #12]
 800b50c:	07d2      	lsls	r2, r2, #31
 800b50e:	d406      	bmi.n	800b51e <HAL_FLASH_Unlock+0x16>
      return HAL_ERROR;
    }
  }

#if defined (DUAL_BANK)
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 800b510:	4b0e      	ldr	r3, [pc, #56]	@ (800b54c <HAL_FLASH_Unlock+0x44>)
 800b512:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800b516:	f010 0001 	ands.w	r0, r0, #1
 800b51a:	d10a      	bne.n	800b532 <HAL_FLASH_Unlock+0x2a>
 800b51c:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 800b51e:	4a0c      	ldr	r2, [pc, #48]	@ (800b550 <HAL_FLASH_Unlock+0x48>)
 800b520:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 800b522:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 800b526:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 800b528:	68db      	ldr	r3, [r3, #12]
 800b52a:	07db      	lsls	r3, r3, #31
 800b52c:	d5f0      	bpl.n	800b510 <HAL_FLASH_Unlock+0x8>
      return HAL_ERROR;
 800b52e:	2001      	movs	r0, #1
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
}
 800b530:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 800b532:	4a07      	ldr	r2, [pc, #28]	@ (800b550 <HAL_FLASH_Unlock+0x48>)
 800b534:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 800b538:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 800b53c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 800b540:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800b544:	f000 0001 	and.w	r0, r0, #1
 800b548:	4770      	bx	lr
 800b54a:	bf00      	nop
 800b54c:	52002000 	.word	0x52002000
 800b550:	45670123 	.word	0x45670123

0800b554 <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
 800b554:	4b0a      	ldr	r3, [pc, #40]	@ (800b580 <HAL_FLASH_Lock+0x2c>)
 800b556:	68da      	ldr	r2, [r3, #12]
 800b558:	f042 0201 	orr.w	r2, r2, #1
 800b55c:	60da      	str	r2, [r3, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
 800b55e:	68da      	ldr	r2, [r3, #12]
 800b560:	07d2      	lsls	r2, r2, #31
 800b562:	d50b      	bpl.n	800b57c <HAL_FLASH_Lock+0x28>
    return HAL_ERROR;
  }

#if defined (DUAL_BANK)
  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
 800b564:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b568:	f042 0201 	orr.w	r2, r2, #1
 800b56c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c

  /* Verify Flash Bank2 is locked */
  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
 800b570:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800b574:	43c0      	mvns	r0, r0
 800b576:	f000 0001 	and.w	r0, r0, #1
 800b57a:	4770      	bx	lr
    return HAL_ERROR;
 800b57c:	2001      	movs	r0, #1
    return HAL_ERROR;
  }
#endif /* DUAL_BANK */

  return HAL_OK;
}
 800b57e:	4770      	bx	lr
 800b580:	52002000 	.word	0x52002000

0800b584 <HAL_FLASH_OB_Unlock>:
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
 800b584:	4b06      	ldr	r3, [pc, #24]	@ (800b5a0 <HAL_FLASH_OB_Unlock+0x1c>)
 800b586:	6998      	ldr	r0, [r3, #24]
 800b588:	f010 0001 	ands.w	r0, r0, #1
 800b58c:	d007      	beq.n	800b59e <HAL_FLASH_OB_Unlock+0x1a>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
 800b58e:	4a05      	ldr	r2, [pc, #20]	@ (800b5a4 <HAL_FLASH_OB_Unlock+0x20>)
 800b590:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
 800b592:	f102 3244 	add.w	r2, r2, #1145324612	@ 0x44444444
 800b596:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
 800b598:	6998      	ldr	r0, [r3, #24]
 800b59a:	f000 0001 	and.w	r0, r0, #1
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
 800b59e:	4770      	bx	lr
 800b5a0:	52002000 	.word	0x52002000
 800b5a4:	08192a3b 	.word	0x08192a3b

0800b5a8 <HAL_FLASH_OB_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
 800b5a8:	4b04      	ldr	r3, [pc, #16]	@ (800b5bc <HAL_FLASH_OB_Lock+0x14>)
 800b5aa:	699a      	ldr	r2, [r3, #24]
 800b5ac:	f042 0201 	orr.w	r2, r2, #1
 800b5b0:	619a      	str	r2, [r3, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
 800b5b2:	6998      	ldr	r0, [r3, #24]
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 800b5b4:	43c0      	mvns	r0, r0
 800b5b6:	f000 0001 	and.w	r0, r0, #1
 800b5ba:	4770      	bx	lr
 800b5bc:	52002000 	.word	0x52002000

0800b5c0 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
 800b5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b5c4:	460c      	mov	r4, r1
 800b5c6:	4605      	mov	r5, r0
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
  uint32_t errorflag = 0;
  uint32_t tickstart = HAL_GetTick();
 800b5c8:	f7ff fe34 	bl	800b234 <HAL_GetTick>
 800b5cc:	4f27      	ldr	r7, [pc, #156]	@ (800b66c <FLASH_WaitForLastOperation+0xac>)
  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
 800b5ce:	2c02      	cmp	r4, #2
  uint32_t tickstart = HAL_GetTick();
 800b5d0:	4606      	mov	r6, r0
    /* Select bsyflag depending on Bank */
    bsyflag = FLASH_FLAG_QW_BANK2;
  }
#endif /* DUAL_BANK */

  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b5d2:	bf0c      	ite	eq
 800b5d4:	f04f 4800 	moveq.w	r8, #2147483648	@ 0x80000000
 800b5d8:	f04f 0800 	movne.w	r8, #0
 800b5dc:	f1b8 0f00 	cmp.w	r8, #0
 800b5e0:	d122      	bne.n	800b628 <FLASH_WaitForLastOperation+0x68>
 800b5e2:	693b      	ldr	r3, [r7, #16]
 800b5e4:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800b5e8:	b99b      	cbnz	r3, 800b612 <FLASH_WaitForLastOperation+0x52>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
 800b5ea:	2c01      	cmp	r4, #1
 800b5ec:	4b1f      	ldr	r3, [pc, #124]	@ (800b66c <FLASH_WaitForLastOperation+0xac>)
 800b5ee:	4a20      	ldr	r2, [pc, #128]	@ (800b670 <FLASH_WaitForLastOperation+0xb0>)
 800b5f0:	d11d      	bne.n	800b62e <FLASH_WaitForLastOperation+0x6e>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 800b5f2:	691b      	ldr	r3, [r3, #16]
 800b5f4:	4013      	ands	r3, r2
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
  }
#endif /* DUAL_BANK */

  /* In case of error reported in Flash SR1 or SR2 register */
  if((errorflag & 0x7FFFFFFFU) != 0U)
 800b5f6:	f033 4000 	bics.w	r0, r3, #2147483648	@ 0x80000000
 800b5fa:	d021      	beq.n	800b640 <FLASH_WaitForLastOperation+0x80>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
 800b5fc:	491d      	ldr	r1, [pc, #116]	@ (800b674 <FLASH_WaitForLastOperation+0xb4>)

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800b5fe:	2b00      	cmp	r3, #0
    pFlash.ErrorCode |= errorflag;
 800b600:	698a      	ldr	r2, [r1, #24]
 800b602:	ea42 0203 	orr.w	r2, r2, r3
 800b606:	618a      	str	r2, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800b608:	4a18      	ldr	r2, [pc, #96]	@ (800b66c <FLASH_WaitForLastOperation+0xac>)
 800b60a:	db16      	blt.n	800b63a <FLASH_WaitForLastOperation+0x7a>
 800b60c:	6153      	str	r3, [r2, #20]

    return HAL_ERROR;
 800b60e:	2001      	movs	r0, #1
 800b610:	e020      	b.n	800b654 <FLASH_WaitForLastOperation+0x94>
    if(Timeout != HAL_MAX_DELAY)
 800b612:	1c68      	adds	r0, r5, #1
 800b614:	d0e2      	beq.n	800b5dc <FLASH_WaitForLastOperation+0x1c>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800b616:	f7ff fe0d 	bl	800b234 <HAL_GetTick>
 800b61a:	1b80      	subs	r0, r0, r6
 800b61c:	42a8      	cmp	r0, r5
 800b61e:	d801      	bhi.n	800b624 <FLASH_WaitForLastOperation+0x64>
 800b620:	2d00      	cmp	r5, #0
 800b622:	d1db      	bne.n	800b5dc <FLASH_WaitForLastOperation+0x1c>
        return HAL_TIMEOUT;
 800b624:	2003      	movs	r0, #3
 800b626:	e015      	b.n	800b654 <FLASH_WaitForLastOperation+0x94>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b628:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800b62c:	e7da      	b.n	800b5e4 <FLASH_WaitForLastOperation+0x24>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 800b62e:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 800b632:	4013      	ands	r3, r2
 800b634:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800b638:	e7dd      	b.n	800b5f6 <FLASH_WaitForLastOperation+0x36>
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800b63a:	f8c2 0114 	str.w	r0, [r2, #276]	@ 0x114
 800b63e:	e7e6      	b.n	800b60e <FLASH_WaitForLastOperation+0x4e>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
 800b640:	2c01      	cmp	r4, #1
 800b642:	4b0a      	ldr	r3, [pc, #40]	@ (800b66c <FLASH_WaitForLastOperation+0xac>)
 800b644:	d108      	bne.n	800b658 <FLASH_WaitForLastOperation+0x98>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
 800b646:	691a      	ldr	r2, [r3, #16]
 800b648:	03d1      	lsls	r1, r2, #15
 800b64a:	d502      	bpl.n	800b652 <FLASH_WaitForLastOperation+0x92>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
 800b64c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800b650:	615a      	str	r2, [r3, #20]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
 800b652:	2000      	movs	r0, #0
}
 800b654:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
 800b658:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 800b65c:	03d2      	lsls	r2, r2, #15
 800b65e:	d5f8      	bpl.n	800b652 <FLASH_WaitForLastOperation+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
 800b660:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800b664:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
 800b668:	e7f3      	b.n	800b652 <FLASH_WaitForLastOperation+0x92>
 800b66a:	bf00      	nop
 800b66c:	52002000 	.word	0x52002000
 800b670:	17ee0000 	.word	0x17ee0000
 800b674:	20001d7c 	.word	0x20001d7c

0800b678 <HAL_FLASH_Program>:
{
 800b678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 800b67a:	4e28      	ldr	r6, [pc, #160]	@ (800b71c <HAL_FLASH_Program+0xa4>)
{
 800b67c:	460d      	mov	r5, r1
 800b67e:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 800b680:	7d33      	ldrb	r3, [r6, #20]
 800b682:	2b01      	cmp	r3, #1
 800b684:	d048      	beq.n	800b718 <HAL_FLASH_Program+0xa0>
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 800b686:	f101 4378 	add.w	r3, r1, #4160749568	@ 0xf8000000
  __HAL_LOCK(&pFlash);
 800b68a:	2001      	movs	r0, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 800b68c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
  __HAL_LOCK(&pFlash);
 800b690:	7530      	strb	r0, [r6, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 800b692:	d331      	bcc.n	800b6f8 <HAL_FLASH_Program+0x80>
  else if(IS_FLASH_PROGRAM_ADDRESS_BANK2(FlashAddress))
 800b694:	f1a1 6301 	sub.w	r3, r1, #135266304	@ 0x8100000
 800b698:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800b69c:	d22b      	bcs.n	800b6f6 <HAL_FLASH_Program+0x7e>
    bank = FLASH_BANK_2;
 800b69e:	2402      	movs	r4, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b6a0:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 800b6a2:	4621      	mov	r1, r4
 800b6a4:	f24c 3050 	movw	r0, #50000	@ 0xc350
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b6a8:	61b3      	str	r3, [r6, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 800b6aa:	f7ff ff89 	bl	800b5c0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 800b6ae:	bb00      	cbnz	r0, 800b6f2 <HAL_FLASH_Program+0x7a>
    if(bank == FLASH_BANK_1)
 800b6b0:	2c01      	cmp	r4, #1
 800b6b2:	4b1b      	ldr	r3, [pc, #108]	@ (800b720 <HAL_FLASH_Program+0xa8>)
 800b6b4:	d122      	bne.n	800b6fc <HAL_FLASH_Program+0x84>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
 800b6b6:	68da      	ldr	r2, [r3, #12]
 800b6b8:	f042 0202 	orr.w	r2, r2, #2
 800b6bc:	60da      	str	r2, [r3, #12]
  __ASM volatile ("isb 0xF":::"memory");
 800b6be:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 800b6c2:	f3bf 8f4f 	dsb	sy
}
 800b6c6:	2300      	movs	r3, #0
        *dest_addr = *src_addr;
 800b6c8:	58fa      	ldr	r2, [r7, r3]
 800b6ca:	50ea      	str	r2, [r5, r3]
     } while (row_index != 0U);
 800b6cc:	3304      	adds	r3, #4
 800b6ce:	2b20      	cmp	r3, #32
 800b6d0:	d1fa      	bne.n	800b6c8 <HAL_FLASH_Program+0x50>
  __ASM volatile ("isb 0xF":::"memory");
 800b6d2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 800b6d6:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 800b6da:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b6de:	4621      	mov	r1, r4
 800b6e0:	f7ff ff6e 	bl	800b5c0 <FLASH_WaitForLastOperation>
      if(bank == FLASH_BANK_1)
 800b6e4:	2c01      	cmp	r4, #1
 800b6e6:	4b0e      	ldr	r3, [pc, #56]	@ (800b720 <HAL_FLASH_Program+0xa8>)
 800b6e8:	d10f      	bne.n	800b70a <HAL_FLASH_Program+0x92>
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 800b6ea:	68da      	ldr	r2, [r3, #12]
 800b6ec:	f022 0202 	bic.w	r2, r2, #2
 800b6f0:	60da      	str	r2, [r3, #12]
  __HAL_UNLOCK(&pFlash);
 800b6f2:	2300      	movs	r3, #0
 800b6f4:	7533      	strb	r3, [r6, #20]
}
 800b6f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    bank = FLASH_BANK_1;
 800b6f8:	4604      	mov	r4, r0
 800b6fa:	e7d1      	b.n	800b6a0 <HAL_FLASH_Program+0x28>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
 800b6fc:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b700:	f042 0202 	orr.w	r2, r2, #2
 800b704:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 800b708:	e7d9      	b.n	800b6be <HAL_FLASH_Program+0x46>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
 800b70a:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b70e:	f022 0202 	bic.w	r2, r2, #2
 800b712:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 800b716:	e7ec      	b.n	800b6f2 <HAL_FLASH_Program+0x7a>
  __HAL_LOCK(&pFlash);
 800b718:	2002      	movs	r0, #2
 800b71a:	e7ec      	b.n	800b6f6 <HAL_FLASH_Program+0x7e>
 800b71c:	20001d7c 	.word	0x20001d7c
 800b720:	52002000 	.word	0x52002000

0800b724 <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
 800b724:	b570      	push	{r4, r5, r6, lr}
 800b726:	4604      	mov	r4, r0
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
 800b728:	4d10      	ldr	r5, [pc, #64]	@ (800b76c <FLASH_OB_WaitForLastOperation+0x48>)
  uint32_t tickstart = HAL_GetTick();
 800b72a:	f7ff fd83 	bl	800b234 <HAL_GetTick>
 800b72e:	4606      	mov	r6, r0
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
 800b730:	69eb      	ldr	r3, [r5, #28]
 800b732:	07db      	lsls	r3, r3, #31
 800b734:	d40e      	bmi.n	800b754 <FLASH_OB_WaitForLastOperation+0x30>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
 800b736:	69e8      	ldr	r0, [r5, #28]
 800b738:	f010 4080 	ands.w	r0, r0, #1073741824	@ 0x40000000
 800b73c:	d009      	beq.n	800b752 <FLASH_OB_WaitForLastOperation+0x2e>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
 800b73e:	4a0c      	ldr	r2, [pc, #48]	@ (800b770 <FLASH_OB_WaitForLastOperation+0x4c>)

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
 800b740:	2001      	movs	r0, #1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
 800b742:	6993      	ldr	r3, [r2, #24]
 800b744:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800b748:	6193      	str	r3, [r2, #24]
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
 800b74a:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800b74c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800b750:	626b      	str	r3, [r5, #36]	@ 0x24
    return HAL_ERROR;
  }

  /* If there is no error flag set */
  return HAL_OK;
}
 800b752:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
 800b754:	1c62      	adds	r2, r4, #1
 800b756:	d0eb      	beq.n	800b730 <FLASH_OB_WaitForLastOperation+0xc>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800b758:	f7ff fd6c 	bl	800b234 <HAL_GetTick>
 800b75c:	1b80      	subs	r0, r0, r6
 800b75e:	42a0      	cmp	r0, r4
 800b760:	d801      	bhi.n	800b766 <FLASH_OB_WaitForLastOperation+0x42>
 800b762:	2c00      	cmp	r4, #0
 800b764:	d1e4      	bne.n	800b730 <FLASH_OB_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 800b766:	2003      	movs	r0, #3
 800b768:	e7f3      	b.n	800b752 <FLASH_OB_WaitForLastOperation+0x2e>
 800b76a:	bf00      	nop
 800b76c:	52002000 	.word	0x52002000
 800b770:	20001d7c 	.word	0x20001d7c

0800b774 <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
 800b774:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b778:	460d      	mov	r5, r1
 800b77a:	4604      	mov	r4, r0
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
 800b77c:	f7ff fd5a 	bl	800b234 <HAL_GetTick>
 800b780:	4f1e      	ldr	r7, [pc, #120]	@ (800b7fc <FLASH_CRC_WaitForLastOperation+0x88>)
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
 800b782:	2d01      	cmp	r5, #1
  uint32_t tickstart = HAL_GetTick();
 800b784:	4606      	mov	r6, r0
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b786:	bf14      	ite	ne
 800b788:	f04f 4800 	movne.w	r8, #2147483648	@ 0x80000000
 800b78c:	f04f 0800 	moveq.w	r8, #0
 800b790:	f1b8 0f00 	cmp.w	r8, #0
 800b794:	d11f      	bne.n	800b7d6 <FLASH_CRC_WaitForLastOperation+0x62>
 800b796:	693b      	ldr	r3, [r7, #16]
 800b798:	071b      	lsls	r3, r3, #28
 800b79a:	d411      	bmi.n	800b7c0 <FLASH_CRC_WaitForLastOperation+0x4c>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
 800b79c:	2d01      	cmp	r5, #1
 800b79e:	4b17      	ldr	r3, [pc, #92]	@ (800b7fc <FLASH_CRC_WaitForLastOperation+0x88>)
 800b7a0:	d11c      	bne.n	800b7dc <FLASH_CRC_WaitForLastOperation+0x68>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
 800b7a2:	6918      	ldr	r0, [r3, #16]
 800b7a4:	f010 5080 	ands.w	r0, r0, #268435456	@ 0x10000000
 800b7a8:	d008      	beq.n	800b7bc <FLASH_CRC_WaitForLastOperation+0x48>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
 800b7aa:	4915      	ldr	r1, [pc, #84]	@ (800b800 <FLASH_CRC_WaitForLastOperation+0x8c>)
 800b7ac:	698a      	ldr	r2, [r1, #24]
 800b7ae:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 800b7b2:	618a      	str	r2, [r1, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
 800b7b4:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800b7b8:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
 800b7ba:	2001      	movs	r0, #1
  }
#endif /* DUAL_BANK */

  /* If there is no error flag set */
  return HAL_OK;
}
 800b7bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 800b7c0:	1c62      	adds	r2, r4, #1
 800b7c2:	d0e5      	beq.n	800b790 <FLASH_CRC_WaitForLastOperation+0x1c>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800b7c4:	f7ff fd36 	bl	800b234 <HAL_GetTick>
 800b7c8:	1b80      	subs	r0, r0, r6
 800b7ca:	42a0      	cmp	r0, r4
 800b7cc:	d801      	bhi.n	800b7d2 <FLASH_CRC_WaitForLastOperation+0x5e>
 800b7ce:	2c00      	cmp	r4, #0
 800b7d0:	d1de      	bne.n	800b790 <FLASH_CRC_WaitForLastOperation+0x1c>
        return HAL_TIMEOUT;
 800b7d2:	2003      	movs	r0, #3
 800b7d4:	e7f2      	b.n	800b7bc <FLASH_CRC_WaitForLastOperation+0x48>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b7d6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800b7da:	e7dd      	b.n	800b798 <FLASH_CRC_WaitForLastOperation+0x24>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
 800b7dc:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
 800b7e0:	f010 5080 	ands.w	r0, r0, #268435456	@ 0x10000000
 800b7e4:	d0ea      	beq.n	800b7bc <FLASH_CRC_WaitForLastOperation+0x48>
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
 800b7e6:	4906      	ldr	r1, [pc, #24]	@ (800b800 <FLASH_CRC_WaitForLastOperation+0x8c>)
 800b7e8:	698a      	ldr	r2, [r1, #24]
 800b7ea:	f042 4210 	orr.w	r2, r2, #2415919104	@ 0x90000000
 800b7ee:	618a      	str	r2, [r1, #24]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
 800b7f0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800b7f4:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
      return HAL_ERROR;
 800b7f8:	e7df      	b.n	800b7ba <FLASH_CRC_WaitForLastOperation+0x46>
 800b7fa:	bf00      	nop
 800b7fc:	52002000 	.word	0x52002000
 800b800:	20001d7c 	.word	0x20001d7c

0800b804 <HAL_FLASH_OB_Launch>:
{
 800b804:	b508      	push	{r3, lr}
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800b806:	2101      	movs	r1, #1
 800b808:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b80c:	f7ff ffb2 	bl	800b774 <FLASH_CRC_WaitForLastOperation>
 800b810:	b980      	cbnz	r0, 800b834 <HAL_FLASH_OB_Launch+0x30>
  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800b812:	2102      	movs	r1, #2
 800b814:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b818:	f7ff ffac 	bl	800b774 <FLASH_CRC_WaitForLastOperation>
 800b81c:	b950      	cbnz	r0, 800b834 <HAL_FLASH_OB_Launch+0x30>
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
 800b81e:	4a06      	ldr	r2, [pc, #24]	@ (800b838 <HAL_FLASH_OB_Launch+0x34>)
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800b820:	f24c 3050 	movw	r0, #50000	@ 0xc350
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
 800b824:	6993      	ldr	r3, [r2, #24]
 800b826:	f043 0302 	orr.w	r3, r3, #2
 800b82a:	6193      	str	r3, [r2, #24]
}
 800b82c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800b830:	f7ff bf78 	b.w	800b724 <FLASH_OB_WaitForLastOperation>
}
 800b834:	2001      	movs	r0, #1
 800b836:	bd08      	pop	{r3, pc}
 800b838:	52002000 	.word	0x52002000

0800b83c <FLASH_MassErase>:
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));

#if defined (DUAL_BANK)
  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
 800b83c:	f001 0303 	and.w	r3, r1, #3
 800b840:	2b03      	cmp	r3, #3
 800b842:	d117      	bne.n	800b874 <FLASH_MassErase+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
 800b844:	4b1d      	ldr	r3, [pc, #116]	@ (800b8bc <FLASH_MassErase+0x80>)
 800b846:	68da      	ldr	r2, [r3, #12]
 800b848:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b84c:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
 800b84e:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b852:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b856:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c

    /* Set voltage range */
    FLASH->CR1 |= VoltageRange;
 800b85a:	68da      	ldr	r2, [r3, #12]
 800b85c:	4302      	orrs	r2, r0
 800b85e:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
 800b860:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b864:	4302      	orrs	r2, r0
 800b866:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
#endif /* FLASH_CR_PSIZE */

    /* Set Mass Erase Bit */
    FLASH->OPTCR |= FLASH_OPTCR_MER;
 800b86a:	699a      	ldr	r2, [r3, #24]
 800b86c:	f042 0210 	orr.w	r2, r2, #16
 800b870:	619a      	str	r2, [r3, #24]
 800b872:	4770      	bx	lr
  }
  else
#endif /* DUAL_BANK */
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b874:	07ca      	lsls	r2, r1, #31
 800b876:	d50b      	bpl.n	800b890 <FLASH_MassErase+0x54>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
 800b878:	4b10      	ldr	r3, [pc, #64]	@ (800b8bc <FLASH_MassErase+0x80>)
 800b87a:	68da      	ldr	r2, [r3, #12]
 800b87c:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b880:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
 800b882:	68da      	ldr	r2, [r3, #12]
 800b884:	4302      	orrs	r2, r0
 800b886:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
 800b888:	68da      	ldr	r2, [r3, #12]
 800b88a:	f042 0288 	orr.w	r2, r2, #136	@ 0x88
 800b88e:	60da      	str	r2, [r3, #12]
    }

#if defined (DUAL_BANK)
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b890:	078b      	lsls	r3, r1, #30
 800b892:	d511      	bpl.n	800b8b8 <FLASH_MassErase+0x7c>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
 800b894:	4b09      	ldr	r3, [pc, #36]	@ (800b8bc <FLASH_MassErase+0x80>)
 800b896:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b89a:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b89e:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
      FLASH->CR2 |= VoltageRange;
 800b8a2:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b8a6:	4310      	orrs	r0, r2
 800b8a8:	f8c3 010c 	str.w	r0, [r3, #268]	@ 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
 800b8ac:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b8b0:	f042 0288 	orr.w	r2, r2, #136	@ 0x88
 800b8b4:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    }
#endif /* DUAL_BANK */
  }
}
 800b8b8:	4770      	bx	lr
 800b8ba:	bf00      	nop
 800b8bc:	52002000 	.word	0x52002000

0800b8c0 <HAL_FLASHEx_OBProgram>:
{
 800b8c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 800b8c2:	4e8c      	ldr	r6, [pc, #560]	@ (800baf4 <HAL_FLASHEx_OBProgram+0x234>)
{
 800b8c4:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 800b8c6:	7d33      	ldrb	r3, [r6, #20]
 800b8c8:	2b01      	cmp	r3, #1
 800b8ca:	f000 8111 	beq.w	800baf0 <HAL_FLASHEx_OBProgram+0x230>
 800b8ce:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b8d0:	2300      	movs	r3, #0
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800b8d2:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
 800b8d6:	7531      	strb	r1, [r6, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b8d8:	61b3      	str	r3, [r6, #24]
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800b8da:	f7ff fe71 	bl	800b5c0 <FLASH_WaitForLastOperation>
 800b8de:	b118      	cbz	r0, 800b8e8 <HAL_FLASHEx_OBProgram+0x28>
    status = HAL_ERROR;
 800b8e0:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 800b8e2:	2300      	movs	r3, #0
 800b8e4:	7533      	strb	r3, [r6, #20]
}
 800b8e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800b8e8:	2102      	movs	r1, #2
 800b8ea:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b8ee:	f7ff fe67 	bl	800b5c0 <FLASH_WaitForLastOperation>
 800b8f2:	2800      	cmp	r0, #0
 800b8f4:	d1f4      	bne.n	800b8e0 <HAL_FLASHEx_OBProgram+0x20>
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
 800b8f6:	6827      	ldr	r7, [r4, #0]
 800b8f8:	07f9      	lsls	r1, r7, #31
 800b8fa:	d51a      	bpl.n	800b932 <HAL_FLASHEx_OBProgram+0x72>
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
 800b8fc:	6865      	ldr	r5, [r4, #4]
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
 800b8fe:	69e2      	ldr	r2, [r4, #28]
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
 800b900:	2d01      	cmp	r5, #1
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
 800b902:	68a3      	ldr	r3, [r4, #8]
{
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b904:	f002 0101 	and.w	r1, r2, #1
 800b908:	f002 0202 	and.w	r2, r2, #2
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
 800b90c:	f040 80dd 	bne.w	800baca <HAL_FLASHEx_OBProgram+0x20a>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b910:	b131      	cbz	r1, 800b920 <HAL_FLASHEx_OBProgram+0x60>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
 800b912:	4d79      	ldr	r5, [pc, #484]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800b914:	fa5f fc83 	uxtb.w	ip, r3
 800b918:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 800b91a:	ea21 010c 	bic.w	r1, r1, ip
 800b91e:	63e9      	str	r1, [r5, #60]	@ 0x3c
  }

#if defined (DUAL_BANK)
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b920:	b13a      	cbz	r2, 800b932 <HAL_FLASHEx_OBProgram+0x72>
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
 800b922:	4975      	ldr	r1, [pc, #468]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800b924:	b2db      	uxtb	r3, r3
 800b926:	f8d1 213c 	ldr.w	r2, [r1, #316]	@ 0x13c
 800b92a:	ea22 0303 	bic.w	r3, r2, r3
 800b92e:	f8c1 313c 	str.w	r3, [r1, #316]	@ 0x13c
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 800b932:	07ba      	lsls	r2, r7, #30
 800b934:	d506      	bpl.n	800b944 <HAL_FLASHEx_OBProgram+0x84>
{
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
 800b936:	4a70      	ldr	r2, [pc, #448]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800b938:	68e1      	ldr	r1, [r4, #12]
 800b93a:	6a13      	ldr	r3, [r2, #32]
 800b93c:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800b940:	430b      	orrs	r3, r1
 800b942:	6213      	str	r3, [r2, #32]
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 800b944:	077b      	lsls	r3, r7, #29
 800b946:	d554      	bpl.n	800b9f2 <HAL_FLASHEx_OBProgram+0x132>
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
 800b948:	e9d4 5105 	ldrd	r5, r1, [r4, #20]
  uint32_t optr_reg_mask = 0;

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
 800b94c:	f015 0301 	ands.w	r3, r5, #1
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
 800b950:	bf1a      	itte	ne
 800b952:	f001 0310 	andne.w	r3, r1, #16
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
 800b956:	2210      	movne	r2, #16
  uint32_t optr_reg_mask = 0;
 800b958:	461a      	moveq	r2, r3
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
 800b95a:	f015 0f02 	tst.w	r5, #2
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
 800b95e:	bf1e      	ittt	ne
 800b960:	f001 0c40 	andne.w	ip, r1, #64	@ 0x40
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
 800b964:	f042 0240 	orrne.w	r2, r2, #64	@ 0x40
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
 800b968:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
 800b96c:	f015 0f04 	tst.w	r5, #4
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
 800b970:	bf1e      	ittt	ne
 800b972:	f001 0c80 	andne.w	ip, r1, #128	@ 0x80
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
 800b976:	f042 0280 	orrne.w	r2, r2, #128	@ 0x80
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
 800b97a:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
 800b97e:	f015 0f08 	tst.w	r5, #8
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
 800b982:	bf1e      	ittt	ne
 800b984:	f401 3c00 	andne.w	ip, r1, #131072	@ 0x20000
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
 800b988:	f442 3200 	orrne.w	r2, r2, #131072	@ 0x20000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
 800b98c:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
 800b990:	f015 0f10 	tst.w	r5, #16
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
 800b994:	bf1e      	ittt	ne
 800b996:	f401 2c80 	andne.w	ip, r1, #262144	@ 0x40000
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
 800b99a:	f442 2280 	orrne.w	r2, r2, #262144	@ 0x40000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
 800b99e:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
 800b9a2:	f015 0f20 	tst.w	r5, #32
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
 800b9a6:	bf1e      	ittt	ne
 800b9a8:	f401 1cc0 	andne.w	ip, r1, #1572864	@ 0x180000
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
 800b9ac:	f442 12c0 	orrne.w	r2, r2, #1572864	@ 0x180000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
 800b9b0:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_SECURITY) != 0U)
 800b9b4:	f015 0f40 	tst.w	r5, #64	@ 0x40
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
 800b9b8:	bf1e      	ittt	ne
 800b9ba:	f401 1c00 	andne.w	ip, r1, #2097152	@ 0x200000
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
 800b9be:	f442 1200 	orrne.w	r2, r2, #2097152	@ 0x200000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
 800b9c2:	ea43 030c 	orrne.w	r3, r3, ip
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;
  }
#endif /* FLASH_OPTSR_NRST_STOP_D2 */

#if defined (DUAL_BANK)
  if((UserType & OB_USER_SWAP_BANK) != 0U)
 800b9c6:	f415 7f80 	tst.w	r5, #256	@ 0x100
  {
    /* SWAP_BANK_OPT option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));

    /* Set value and mask for SWAP_BANK_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
 800b9ca:	bf1e      	ittt	ne
 800b9cc:	f001 4c00 	andne.w	ip, r1, #2147483648	@ 0x80000000
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
 800b9d0:	f042 4200 	orrne.w	r2, r2, #2147483648	@ 0x80000000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
 800b9d4:	ea43 030c 	orrne.w	r3, r3, ip
  }
#endif /* DUAL_BANK */

  if((UserType & OB_USER_IOHSLV) != 0U)
 800b9d8:	062d      	lsls	r5, r5, #24
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
 800b9da:	4d47      	ldr	r5, [pc, #284]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
 800b9dc:	bf42      	ittt	mi
 800b9de:	f001 5100 	andmi.w	r1, r1, #536870912	@ 0x20000000
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
 800b9e2:	f042 5200 	orrmi.w	r2, r2, #536870912	@ 0x20000000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
 800b9e6:	430b      	orrmi	r3, r1
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
 800b9e8:	6a29      	ldr	r1, [r5, #32]
 800b9ea:	ea21 0202 	bic.w	r2, r1, r2
 800b9ee:	4313      	orrs	r3, r2
 800b9f0:	622b      	str	r3, [r5, #32]
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
 800b9f2:	073b      	lsls	r3, r7, #28
 800b9f4:	d523      	bpl.n	800ba3e <HAL_FLASHEx_OBProgram+0x17e>
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
 800b9f6:	f8d4 e01c 	ldr.w	lr, [r4, #28]
 800b9fa:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b9fc:	f01e 0f01 	tst.w	lr, #1
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
 800ba00:	e9d4 3508 	ldrd	r3, r5, [r4, #32]
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800ba04:	d00c      	beq.n	800ba20 <HAL_FLASHEx_OBProgram+0x160>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800ba06:	0211      	lsls	r1, r2, #8
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
 800ba08:	f105 4c78 	add.w	ip, r5, #4160749568	@ 0xf8000000
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800ba0c:	f36f 010f 	bfc	r1, #0, #16
 800ba10:	ea43 2c1c 	orr.w	ip, r3, ip, lsr #8
 800ba14:	ea41 010c 	orr.w	r1, r1, ip
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
 800ba18:	f8df c0dc 	ldr.w	ip, [pc, #220]	@ 800baf8 <HAL_FLASHEx_OBProgram+0x238>
 800ba1c:	f8cc 102c 	str.w	r1, [ip, #44]	@ 0x2c
                       PCROPConfig;
  }

#if defined (DUAL_BANK)
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800ba20:	f01e 0f02 	tst.w	lr, #2
 800ba24:	d00b      	beq.n	800ba3e <HAL_FLASHEx_OBProgram+0x17e>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800ba26:	f1a2 6201 	sub.w	r2, r2, #135266304	@ 0x8100000
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
 800ba2a:	f1a5 6501 	sub.w	r5, r5, #135266304	@ 0x8100000
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800ba2e:	0a12      	lsrs	r2, r2, #8
 800ba30:	ea43 2315 	orr.w	r3, r3, r5, lsr #8
 800ba34:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
 800ba38:	4a2f      	ldr	r2, [pc, #188]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800ba3a:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
 800ba3e:	06fd      	lsls	r5, r7, #27
 800ba40:	d506      	bpl.n	800ba50 <HAL_FLASHEx_OBProgram+0x190>
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
 800ba42:	4a2d      	ldr	r2, [pc, #180]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800ba44:	6921      	ldr	r1, [r4, #16]
 800ba46:	6a13      	ldr	r3, [r2, #32]
 800ba48:	f023 030c 	bic.w	r3, r3, #12
 800ba4c:	430b      	orrs	r3, r1
 800ba4e:	6213      	str	r3, [r2, #32]
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
 800ba50:	0679      	lsls	r1, r7, #25
 800ba52:	d513      	bpl.n	800ba7c <HAL_FLASHEx_OBProgram+0x1bc>
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
 800ba54:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800ba56:	f8d4 c034 	ldr.w	ip, [r4, #52]	@ 0x34
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
 800ba5a:	07ca      	lsls	r2, r1, #31
 800ba5c:	d506      	bpl.n	800ba6c <HAL_FLASHEx_OBProgram+0x1ac>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
 800ba5e:	4d26      	ldr	r5, [pc, #152]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800ba60:	8e63      	ldrh	r3, [r4, #50]	@ 0x32
 800ba62:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
 800ba64:	f36f 020f 	bfc	r2, #0, #16
 800ba68:	4313      	orrs	r3, r2
 800ba6a:	646b      	str	r3, [r5, #68]	@ 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
 800ba6c:	078b      	lsls	r3, r1, #30
 800ba6e:	d505      	bpl.n	800ba7c <HAL_FLASHEx_OBProgram+0x1bc>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
 800ba70:	4a21      	ldr	r2, [pc, #132]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800ba72:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800ba74:	b29b      	uxth	r3, r3
 800ba76:	ea43 030c 	orr.w	r3, r3, ip
 800ba7a:	6453      	str	r3, [r2, #68]	@ 0x44
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
 800ba7c:	06bd      	lsls	r5, r7, #26
 800ba7e:	f57f af30 	bpl.w	800b8e2 <HAL_FLASHEx_OBProgram+0x22>
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
 800ba82:	69e5      	ldr	r5, [r4, #28]
 800ba84:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 800ba86:	e9d4 370e 	ldrd	r3, r7, [r4, #56]	@ 0x38
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800ba8a:	07ec      	lsls	r4, r5, #31
 800ba8c:	d50b      	bpl.n	800baa6 <HAL_FLASHEx_OBProgram+0x1e6>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
 800ba8e:	f107 4478 	add.w	r4, r7, #4160749568	@ 0xf8000000
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
 800ba92:	f003 4100 	and.w	r1, r3, #2147483648	@ 0x80000000
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
 800ba96:	ea41 2114 	orr.w	r1, r1, r4, lsr #8
 800ba9a:	0214      	lsls	r4, r2, #8
 800ba9c:	f36f 040f 	bfc	r4, #0, #16
 800baa0:	4321      	orrs	r1, r4
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
 800baa2:	4c15      	ldr	r4, [pc, #84]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800baa4:	6361      	str	r1, [r4, #52]	@ 0x34
  }

#if defined (DUAL_BANK)
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800baa6:	07a9      	lsls	r1, r5, #30
 800baa8:	f57f af1b 	bpl.w	800b8e2 <HAL_FLASHEx_OBProgram+0x22>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
 800baac:	f1a7 6101 	sub.w	r1, r7, #135266304	@ 0x8100000
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
 800bab0:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
 800bab4:	f1a2 6201 	sub.w	r2, r2, #135266304	@ 0x8100000
 800bab8:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
 800babc:	0a12      	lsrs	r2, r2, #8
 800babe:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
 800bac2:	4a0d      	ldr	r2, [pc, #52]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800bac4:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
 800bac8:	e70b      	b.n	800b8e2 <HAL_FLASHEx_OBProgram+0x22>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800baca:	b131      	cbz	r1, 800bada <HAL_FLASHEx_OBProgram+0x21a>
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
 800bacc:	4d0a      	ldr	r5, [pc, #40]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800bace:	b2d9      	uxtb	r1, r3
 800bad0:	f8d5 c03c 	ldr.w	ip, [r5, #60]	@ 0x3c
 800bad4:	ea41 010c 	orr.w	r1, r1, ip
 800bad8:	63e9      	str	r1, [r5, #60]	@ 0x3c
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bada:	2a00      	cmp	r2, #0
 800badc:	f43f af29 	beq.w	800b932 <HAL_FLASHEx_OBProgram+0x72>
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
 800bae0:	4a05      	ldr	r2, [pc, #20]	@ (800baf8 <HAL_FLASHEx_OBProgram+0x238>)
 800bae2:	b2db      	uxtb	r3, r3
 800bae4:	f8d2 113c 	ldr.w	r1, [r2, #316]	@ 0x13c
 800bae8:	430b      	orrs	r3, r1
 800baea:	f8c2 313c 	str.w	r3, [r2, #316]	@ 0x13c
 800baee:	e720      	b.n	800b932 <HAL_FLASHEx_OBProgram+0x72>
  __HAL_LOCK(&pFlash);
 800baf0:	2002      	movs	r0, #2
 800baf2:	e6f8      	b.n	800b8e6 <HAL_FLASHEx_OBProgram+0x26>
 800baf4:	20001d7c 	.word	0x20001d7c
 800baf8:	52002000 	.word	0x52002000

0800bafc <HAL_FLASHEx_OBGetConfig>:
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
 800bafc:	2316      	movs	r3, #22
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
 800bafe:	4a31      	ldr	r2, [pc, #196]	@ (800bbc4 <HAL_FLASHEx_OBGetConfig+0xc8>)
{
 800bb00:	b530      	push	{r4, r5, lr}
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
 800bb02:	6003      	str	r3, [r0, #0]
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
 800bb04:	69d3      	ldr	r3, [r2, #28]
 800bb06:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
 800bb0a:	f5b3 4f2a 	cmp.w	r3, #43520	@ 0xaa00
 800bb0e:	d006      	beq.n	800bb1e <HAL_FLASHEx_OBGetConfig+0x22>
 800bb10:	f5b3 4f4c 	cmp.w	r3, #52224	@ 0xcc00
 800bb14:	bf0c      	ite	eq
 800bb16:	f44f 434c 	moveq.w	r3, #52224	@ 0xcc00
 800bb1a:	f44f 43aa 	movne.w	r3, #21760	@ 0x5500
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 800bb1e:	60c3      	str	r3, [r0, #12]
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
 800bb20:	69d3      	ldr	r3, [r2, #28]
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
 800bb22:	69c4      	ldr	r4, [r0, #28]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
 800bb24:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800bb28:	f023 030c 	bic.w	r3, r3, #12
  pOBInit->USERConfig = FLASH_OB_GetUser();
 800bb2c:	6183      	str	r3, [r0, #24]
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
 800bb2e:	69d3      	ldr	r3, [r2, #28]
 800bb30:	f003 030c 	and.w	r3, r3, #12
  pOBInit->BORLevel = FLASH_OB_GetBOR();
 800bb34:	6103      	str	r3, [r0, #16]
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
 800bb36:	1e63      	subs	r3, r4, #1
 800bb38:	2b01      	cmp	r3, #1
 800bb3a:	d82c      	bhi.n	800bb96 <HAL_FLASHEx_OBGetConfig+0x9a>
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
 800bb3c:	233f      	movs	r3, #63	@ 0x3f
  if(Bank == FLASH_BANK_1)
 800bb3e:	2c01      	cmp	r4, #1
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
 800bb40:	6003      	str	r3, [r0, #0]
  if(Bank == FLASH_BANK_1)
 800bb42:	d134      	bne.n	800bbae <HAL_FLASHEx_OBGetConfig+0xb2>
    regvalue = FLASH->WPSN_CUR1;
 800bb44:	6b93      	ldr	r3, [r2, #56]	@ 0x38
  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
 800bb46:	43db      	mvns	r3, r3
 800bb48:	b2db      	uxtb	r3, r3
 800bb4a:	6083      	str	r3, [r0, #8]
  if(*WRPSector == 0U)
 800bb4c:	3b00      	subs	r3, #0
 800bb4e:	bf18      	it	ne
 800bb50:	2301      	movne	r3, #1
  if(Bank == FLASH_BANK_1)
 800bb52:	2c01      	cmp	r4, #1
 800bb54:	6043      	str	r3, [r0, #4]
 800bb56:	4b1b      	ldr	r3, [pc, #108]	@ (800bbc4 <HAL_FLASHEx_OBGetConfig+0xc8>)
 800bb58:	d12c      	bne.n	800bbb4 <HAL_FLASHEx_OBGetConfig+0xb8>
    regvalue = FLASH->PRAR_CUR1;
 800bb5a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
    bankBase = FLASH_BANK1_BASE;
 800bb5c:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
 800bb60:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
{
  uint32_t regvalue = 0;
  uint32_t bankBase = 0;

  /* Check Bank parameter value */
  if(Bank == FLASH_BANK_1)
 800bb64:	2c01      	cmp	r4, #1
  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
 800bb66:	6203      	str	r3, [r0, #32]
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
 800bb68:	4b17      	ldr	r3, [pc, #92]	@ (800bbc8 <HAL_FLASHEx_OBGetConfig+0xcc>)
 800bb6a:	ea03 2502 	and.w	r5, r3, r2, lsl #8
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
 800bb6e:	ea03 2212 	and.w	r2, r3, r2, lsr #8
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
 800bb72:	440d      	add	r5, r1
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
 800bb74:	440a      	add	r2, r1
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
 800bb76:	6245      	str	r5, [r0, #36]	@ 0x24
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
 800bb78:	6282      	str	r2, [r0, #40]	@ 0x28
  if(Bank == FLASH_BANK_1)
 800bb7a:	4a12      	ldr	r2, [pc, #72]	@ (800bbc4 <HAL_FLASHEx_OBGetConfig+0xc8>)
 800bb7c:	d11f      	bne.n	800bbbe <HAL_FLASHEx_OBGetConfig+0xc2>
  {
    regvalue = FLASH->SCAR_CUR1;
 800bb7e:	6b12      	ldr	r2, [r2, #48]	@ 0x30
    bankBase = FLASH_BANK2_BASE;
  }
#endif /* DUAL_BANK */

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
 800bb80:	f002 4400 	and.w	r4, r2, #2147483648	@ 0x80000000
 800bb84:	6384      	str	r4, [r0, #56]	@ 0x38
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
 800bb86:	ea03 2402 	and.w	r4, r3, r2, lsl #8
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
 800bb8a:	ea03 2312 	and.w	r3, r3, r2, lsr #8
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
 800bb8e:	440c      	add	r4, r1
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
 800bb90:	440b      	add	r3, r1
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
 800bb92:	63c4      	str	r4, [r0, #60]	@ 0x3c
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
 800bb94:	6403      	str	r3, [r0, #64]	@ 0x40
  regvalue = FLASH->BOOT_CUR;
 800bb96:	4b0b      	ldr	r3, [pc, #44]	@ (800bbc4 <HAL_FLASHEx_OBGetConfig+0xc8>)
 800bb98:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
 800bb9a:	041a      	lsls	r2, r3, #16
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
 800bb9c:	f36f 030f 	bfc	r3, #0, #16
 800bba0:	6343      	str	r3, [r0, #52]	@ 0x34
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
 800bba2:	6803      	ldr	r3, [r0, #0]
  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
 800bba4:	6302      	str	r2, [r0, #48]	@ 0x30
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
 800bba6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800bbaa:	6003      	str	r3, [r0, #0]
}
 800bbac:	bd30      	pop	{r4, r5, pc}
    regvalue = FLASH->WPSN_CUR2;
 800bbae:	f8d2 3138 	ldr.w	r3, [r2, #312]	@ 0x138
 800bbb2:	e7c8      	b.n	800bb46 <HAL_FLASHEx_OBGetConfig+0x4a>
    regvalue = FLASH->PRAR_CUR2;
 800bbb4:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
    bankBase = FLASH_BANK2_BASE;
 800bbb8:	f04f 6101 	mov.w	r1, #135266304	@ 0x8100000
 800bbbc:	e7d0      	b.n	800bb60 <HAL_FLASHEx_OBGetConfig+0x64>
    regvalue = FLASH->SCAR_CUR2;
 800bbbe:	f8d2 2130 	ldr.w	r2, [r2, #304]	@ 0x130
    bankBase = FLASH_BANK2_BASE;
 800bbc2:	e7dd      	b.n	800bb80 <HAL_FLASHEx_OBGetConfig+0x84>
 800bbc4:	52002000 	.word	0x52002000
 800bbc8:	000fff00 	.word	0x000fff00

0800bbcc <FLASH_Erase_Sector>:
{
 800bbcc:	b510      	push	{r4, lr}
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bbce:	07cc      	lsls	r4, r1, #31
 800bbd0:	d50b      	bpl.n	800bbea <FLASH_Erase_Sector+0x1e>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 800bbd2:	4c0f      	ldr	r4, [pc, #60]	@ (800bc10 <FLASH_Erase_Sector+0x44>)
 800bbd4:	68e3      	ldr	r3, [r4, #12]
 800bbd6:	f423 63e6 	bic.w	r3, r3, #1840	@ 0x730
 800bbda:	60e3      	str	r3, [r4, #12]
    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 800bbdc:	68e3      	ldr	r3, [r4, #12]
 800bbde:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800bbe2:	4313      	orrs	r3, r2
 800bbe4:	f043 0384 	orr.w	r3, r3, #132	@ 0x84
 800bbe8:	60e3      	str	r3, [r4, #12]
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bbea:	078b      	lsls	r3, r1, #30
 800bbec:	d50f      	bpl.n	800bc0e <FLASH_Erase_Sector+0x42>
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 800bbee:	4908      	ldr	r1, [pc, #32]	@ (800bc10 <FLASH_Erase_Sector+0x44>)
 800bbf0:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
 800bbf4:	f423 63e6 	bic.w	r3, r3, #1840	@ 0x730
 800bbf8:	f8c1 310c 	str.w	r3, [r1, #268]	@ 0x10c
    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 800bbfc:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
 800bc00:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 800bc04:	4302      	orrs	r2, r0
 800bc06:	f042 0284 	orr.w	r2, r2, #132	@ 0x84
 800bc0a:	f8c1 210c 	str.w	r2, [r1, #268]	@ 0x10c
}
 800bc0e:	bd10      	pop	{r4, pc}
 800bc10:	52002000 	.word	0x52002000

0800bc14 <HAL_FLASHEx_Erase>:
{
 800bc14:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_LOCK(&pFlash);
 800bc18:	4f44      	ldr	r7, [pc, #272]	@ (800bd2c <HAL_FLASHEx_Erase+0x118>)
{
 800bc1a:	4605      	mov	r5, r0
 800bc1c:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 800bc1e:	7d3b      	ldrb	r3, [r7, #20]
 800bc20:	2b01      	cmp	r3, #1
 800bc22:	f000 8081 	beq.w	800bd28 <HAL_FLASHEx_Erase+0x114>
 800bc26:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800bc28:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
 800bc2a:	7539      	strb	r1, [r7, #20]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bc2c:	6844      	ldr	r4, [r0, #4]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800bc2e:	61bb      	str	r3, [r7, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bc30:	400c      	ands	r4, r1
 800bc32:	d006      	beq.n	800bc42 <HAL_FLASHEx_Erase+0x2e>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bc34:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bc38:	f7ff fcc2 	bl	800b5c0 <FLASH_WaitForLastOperation>
 800bc3c:	1e04      	subs	r4, r0, #0
 800bc3e:	bf18      	it	ne
 800bc40:	2401      	movne	r4, #1
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bc42:	686b      	ldr	r3, [r5, #4]
 800bc44:	0798      	lsls	r0, r3, #30
 800bc46:	d406      	bmi.n	800bc56 <HAL_FLASHEx_Erase+0x42>
  if(status == HAL_OK)
 800bc48:	b16c      	cbz	r4, 800bc66 <HAL_FLASHEx_Erase+0x52>
 800bc4a:	2401      	movs	r4, #1
  __HAL_UNLOCK(&pFlash);
 800bc4c:	2300      	movs	r3, #0
 800bc4e:	753b      	strb	r3, [r7, #20]
}
 800bc50:	4620      	mov	r0, r4
 800bc52:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800bc56:	2102      	movs	r1, #2
 800bc58:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bc5c:	f7ff fcb0 	bl	800b5c0 <FLASH_WaitForLastOperation>
 800bc60:	2800      	cmp	r0, #0
 800bc62:	d0f1      	beq.n	800bc48 <HAL_FLASHEx_Erase+0x34>
 800bc64:	e7f1      	b.n	800bc4a <HAL_FLASHEx_Erase+0x36>
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 800bc66:	682e      	ldr	r6, [r5, #0]
 800bc68:	2e01      	cmp	r6, #1
 800bc6a:	d125      	bne.n	800bcb8 <HAL_FLASHEx_Erase+0xa4>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
 800bc6c:	6869      	ldr	r1, [r5, #4]
 800bc6e:	6928      	ldr	r0, [r5, #16]
 800bc70:	f7ff fde4 	bl	800b83c <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bc74:	07c9      	lsls	r1, r1, #31
 800bc76:	d50c      	bpl.n	800bc92 <HAL_FLASHEx_Erase+0x7e>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bc78:	4631      	mov	r1, r6
 800bc7a:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bc7e:	f7ff fc9f 	bl	800b5c0 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
 800bc82:	4a2b      	ldr	r2, [pc, #172]	@ (800bd30 <HAL_FLASHEx_Erase+0x11c>)
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bc84:	1e04      	subs	r4, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
 800bc86:	68d3      	ldr	r3, [r2, #12]
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bc88:	bf18      	it	ne
 800bc8a:	2401      	movne	r4, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
 800bc8c:	f023 0308 	bic.w	r3, r3, #8
 800bc90:	60d3      	str	r3, [r2, #12]
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bc92:	686b      	ldr	r3, [r5, #4]
 800bc94:	079a      	lsls	r2, r3, #30
 800bc96:	d5d9      	bpl.n	800bc4c <HAL_FLASHEx_Erase+0x38>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800bc98:	2102      	movs	r1, #2
 800bc9a:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bc9e:	f7ff fc8f 	bl	800b5c0 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
 800bca2:	4a23      	ldr	r2, [pc, #140]	@ (800bd30 <HAL_FLASHEx_Erase+0x11c>)
          status = HAL_ERROR;
 800bca4:	2800      	cmp	r0, #0
        FLASH->CR2 &= (~FLASH_CR_BER);
 800bca6:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
          status = HAL_ERROR;
 800bcaa:	bf18      	it	ne
 800bcac:	2401      	movne	r4, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
 800bcae:	f023 0308 	bic.w	r3, r3, #8
 800bcb2:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
 800bcb6:	e7c9      	b.n	800bc4c <HAL_FLASHEx_Erase+0x38>
      *SectorError = 0xFFFFFFFFU;
 800bcb8:	f04f 33ff 	mov.w	r3, #4294967295
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 800bcbc:	f8df 9070 	ldr.w	r9, [pc, #112]	@ 800bd30 <HAL_FLASHEx_Erase+0x11c>
 800bcc0:	f8df a070 	ldr.w	sl, [pc, #112]	@ 800bd34 <HAL_FLASHEx_Erase+0x120>
      *SectorError = 0xFFFFFFFFU;
 800bcc4:	f8c8 3000 	str.w	r3, [r8]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 800bcc8:	68ae      	ldr	r6, [r5, #8]
 800bcca:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 800bcce:	4413      	add	r3, r2
 800bcd0:	42b3      	cmp	r3, r6
 800bcd2:	d9bb      	bls.n	800bc4c <HAL_FLASHEx_Erase+0x38>
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
 800bcd4:	f8d5 b004 	ldr.w	fp, [r5, #4]
 800bcd8:	4630      	mov	r0, r6
 800bcda:	692a      	ldr	r2, [r5, #16]
 800bcdc:	4659      	mov	r1, fp
 800bcde:	f7ff ff75 	bl	800bbcc <FLASH_Erase_Sector>
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bce2:	f01b 0001 	ands.w	r0, fp, #1
 800bce6:	d00a      	beq.n	800bcfe <HAL_FLASHEx_Erase+0xea>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
 800bce8:	2101      	movs	r1, #1
 800bcea:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bcee:	f7ff fc67 	bl	800b5c0 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 800bcf2:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800bcf6:	ea03 030a 	and.w	r3, r3, sl
 800bcfa:	f8c9 300c 	str.w	r3, [r9, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bcfe:	686b      	ldr	r3, [r5, #4]
 800bd00:	079b      	lsls	r3, r3, #30
 800bd02:	d50a      	bpl.n	800bd1a <HAL_FLASHEx_Erase+0x106>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
 800bd04:	2102      	movs	r1, #2
 800bd06:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bd0a:	f7ff fc59 	bl	800b5c0 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 800bd0e:	f8d9 310c 	ldr.w	r3, [r9, #268]	@ 0x10c
 800bd12:	ea03 030a 	and.w	r3, r3, sl
 800bd16:	f8c9 310c 	str.w	r3, [r9, #268]	@ 0x10c
        if(status != HAL_OK)
 800bd1a:	b118      	cbz	r0, 800bd24 <HAL_FLASHEx_Erase+0x110>
          break;
 800bd1c:	4604      	mov	r4, r0
          *SectorError = sector_index;
 800bd1e:	f8c8 6000 	str.w	r6, [r8]
          break;
 800bd22:	e793      	b.n	800bc4c <HAL_FLASHEx_Erase+0x38>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 800bd24:	3601      	adds	r6, #1
 800bd26:	e7d0      	b.n	800bcca <HAL_FLASHEx_Erase+0xb6>
  __HAL_LOCK(&pFlash);
 800bd28:	2402      	movs	r4, #2
 800bd2a:	e791      	b.n	800bc50 <HAL_FLASHEx_Erase+0x3c>
 800bd2c:	20001d7c 	.word	0x20001d7c
 800bd30:	52002000 	.word	0x52002000
 800bd34:	fffff8fb 	.word	0xfffff8fb

0800bd38 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
 800bd38:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00U;
 800bd3c:	2300      	movs	r3, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bd3e:	f8df 91c4 	ldr.w	r9, [pc, #452]	@ 800bf04 <HAL_GPIO_Init+0x1cc>
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800bd42:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800bd46:	680a      	ldr	r2, [r1, #0]
 800bd48:	fa32 f503 	lsrs.w	r5, r2, r3
 800bd4c:	d102      	bne.n	800bd54 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 800bd4e:	b003      	add	sp, #12
 800bd50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 800bd54:	2501      	movs	r5, #1
 800bd56:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00U)
 800bd5a:	ea18 0202 	ands.w	r2, r8, r2
 800bd5e:	f000 80bb 	beq.w	800bed8 <HAL_GPIO_Init+0x1a0>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bd62:	684e      	ldr	r6, [r1, #4]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bd64:	2703      	movs	r7, #3
 800bd66:	ea4f 0e43 	mov.w	lr, r3, lsl #1
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bd6a:	f006 0503 	and.w	r5, r6, #3
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bd6e:	fa07 fc0e 	lsl.w	ip, r7, lr
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bd72:	1e6f      	subs	r7, r5, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bd74:	ea6f 0c0c 	mvn.w	ip, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bd78:	2f01      	cmp	r7, #1
 800bd7a:	d834      	bhi.n	800bde6 <HAL_GPIO_Init+0xae>
        temp = GPIOx->OSPEEDR;
 800bd7c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bd7e:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 800bd82:	68cf      	ldr	r7, [r1, #12]
 800bd84:	fa07 f70e 	lsl.w	r7, r7, lr
 800bd88:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 800bd8c:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 800bd8e:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800bd90:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800bd94:	f3c6 1700 	ubfx	r7, r6, #4, #1
 800bd98:	409f      	lsls	r7, r3
 800bd9a:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 800bd9e:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 800bda0:	68c7      	ldr	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800bda2:	2d02      	cmp	r5, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800bda4:	ea07 080c 	and.w	r8, r7, ip
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800bda8:	688f      	ldr	r7, [r1, #8]
 800bdaa:	fa07 f70e 	lsl.w	r7, r7, lr
 800bdae:	ea47 0708 	orr.w	r7, r7, r8
      GPIOx->PUPDR = temp;
 800bdb2:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800bdb4:	d119      	bne.n	800bdea <HAL_GPIO_Init+0xb2>
        temp = GPIOx->AFR[position >> 3U];
 800bdb6:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800bdba:	f003 0a07 	and.w	sl, r3, #7
 800bdbe:	f04f 0b0f 	mov.w	fp, #15
 800bdc2:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 800bdc6:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3U];
 800bdca:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800bdce:	fa0b fb0a 	lsl.w	fp, fp, sl
 800bdd2:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800bdd6:	690f      	ldr	r7, [r1, #16]
 800bdd8:	fa07 f70a 	lsl.w	r7, r7, sl
 800bddc:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3U] = temp;
 800bde0:	f8c8 7020 	str.w	r7, [r8, #32]
 800bde4:	e001      	b.n	800bdea <HAL_GPIO_Init+0xb2>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800bde6:	2d03      	cmp	r5, #3
 800bde8:	d1da      	bne.n	800bda0 <HAL_GPIO_Init+0x68>
      temp = GPIOx->MODER;
 800bdea:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800bdec:	fa05 f50e 	lsl.w	r5, r5, lr
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800bdf0:	f416 3f40 	tst.w	r6, #196608	@ 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800bdf4:	ea07 070c 	and.w	r7, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800bdf8:	ea45 0507 	orr.w	r5, r5, r7
      GPIOx->MODER = temp;
 800bdfc:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800bdfe:	d06b      	beq.n	800bed8 <HAL_GPIO_Init+0x1a0>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800be00:	f8d9 50f4 	ldr.w	r5, [r9, #244]	@ 0xf4
 800be04:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800be08:	f003 0c03 	and.w	ip, r3, #3
 800be0c:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800be10:	f045 0502 	orr.w	r5, r5, #2
 800be14:	f107 47b0 	add.w	r7, r7, #1476395008	@ 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800be18:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800be1c:	f8c9 50f4 	str.w	r5, [r9, #244]	@ 0xf4
 800be20:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
 800be24:	f8d9 50f4 	ldr.w	r5, [r9, #244]	@ 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800be28:	fa0e fe0c 	lsl.w	lr, lr, ip
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800be2c:	f005 0502 	and.w	r5, r5, #2
 800be30:	9501      	str	r5, [sp, #4]
 800be32:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 800be34:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800be36:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800be3a:	4d31      	ldr	r5, [pc, #196]	@ (800bf00 <HAL_GPIO_Init+0x1c8>)
 800be3c:	42a8      	cmp	r0, r5
 800be3e:	d04d      	beq.n	800bedc <HAL_GPIO_Init+0x1a4>
 800be40:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be44:	42a8      	cmp	r0, r5
 800be46:	d04b      	beq.n	800bee0 <HAL_GPIO_Init+0x1a8>
 800be48:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be4c:	42a8      	cmp	r0, r5
 800be4e:	d049      	beq.n	800bee4 <HAL_GPIO_Init+0x1ac>
 800be50:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be54:	42a8      	cmp	r0, r5
 800be56:	d047      	beq.n	800bee8 <HAL_GPIO_Init+0x1b0>
 800be58:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be5c:	42a8      	cmp	r0, r5
 800be5e:	d045      	beq.n	800beec <HAL_GPIO_Init+0x1b4>
 800be60:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be64:	42a8      	cmp	r0, r5
 800be66:	d043      	beq.n	800bef0 <HAL_GPIO_Init+0x1b8>
 800be68:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be6c:	42a8      	cmp	r0, r5
 800be6e:	d041      	beq.n	800bef4 <HAL_GPIO_Init+0x1bc>
 800be70:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be74:	42a8      	cmp	r0, r5
 800be76:	d03f      	beq.n	800bef8 <HAL_GPIO_Init+0x1c0>
 800be78:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be7c:	42a8      	cmp	r0, r5
 800be7e:	d03d      	beq.n	800befc <HAL_GPIO_Init+0x1c4>
 800be80:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800be84:	42a8      	cmp	r0, r5
 800be86:	bf14      	ite	ne
 800be88:	250a      	movne	r5, #10
 800be8a:	2509      	moveq	r5, #9
 800be8c:	fa05 f50c 	lsl.w	r5, r5, ip
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800be90:	f416 1f80 	tst.w	r6, #1048576	@ 0x100000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800be94:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 800be98:	60bd      	str	r5, [r7, #8]
        temp &= ~(iocurrent);
 800be9a:	ea6f 0702 	mvn.w	r7, r2
        temp = EXTI->RTSR1;
 800be9e:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 800bea0:	bf0c      	ite	eq
 800bea2:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800bea4:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800bea6:	f416 1f00 	tst.w	r6, #2097152	@ 0x200000
        EXTI->RTSR1 = temp;
 800beaa:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 800beac:	6865      	ldr	r5, [r4, #4]
        temp &= ~(iocurrent);
 800beae:	bf0c      	ite	eq
 800beb0:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800beb2:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800beb4:	f416 3f00 	tst.w	r6, #131072	@ 0x20000
        EXTI->FTSR1 = temp;
 800beb8:	6065      	str	r5, [r4, #4]
        temp = EXTI_CurrentCPU->EMR1;
 800beba:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
        temp &= ~(iocurrent);
 800bebe:	bf0c      	ite	eq
 800bec0:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800bec2:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800bec4:	03f6      	lsls	r6, r6, #15
        EXTI_CurrentCPU->EMR1 = temp;
 800bec6:	f8c4 5084 	str.w	r5, [r4, #132]	@ 0x84
        temp = EXTI_CurrentCPU->IMR1;
 800beca:	f8d4 5080 	ldr.w	r5, [r4, #128]	@ 0x80
        temp &= ~(iocurrent);
 800bece:	bf54      	ite	pl
 800bed0:	403d      	andpl	r5, r7
          temp |= iocurrent;
 800bed2:	4315      	orrmi	r5, r2
        EXTI_CurrentCPU->IMR1 = temp;
 800bed4:	f8c4 5080 	str.w	r5, [r4, #128]	@ 0x80
    position++;
 800bed8:	3301      	adds	r3, #1
 800beda:	e734      	b.n	800bd46 <HAL_GPIO_Init+0xe>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800bedc:	2500      	movs	r5, #0
 800bede:	e7d5      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bee0:	2501      	movs	r5, #1
 800bee2:	e7d3      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bee4:	2502      	movs	r5, #2
 800bee6:	e7d1      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bee8:	2503      	movs	r5, #3
 800beea:	e7cf      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800beec:	2504      	movs	r5, #4
 800beee:	e7cd      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bef0:	2505      	movs	r5, #5
 800bef2:	e7cb      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bef4:	2506      	movs	r5, #6
 800bef6:	e7c9      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bef8:	2507      	movs	r5, #7
 800befa:	e7c7      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800befc:	2508      	movs	r5, #8
 800befe:	e7c5      	b.n	800be8c <HAL_GPIO_Init+0x154>
 800bf00:	58020000 	.word	0x58020000
 800bf04:	58024400 	.word	0x58024400

0800bf08 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 800bf08:	6903      	ldr	r3, [r0, #16]
 800bf0a:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 800bf0c:	bf14      	ite	ne
 800bf0e:	2001      	movne	r0, #1
 800bf10:	2000      	moveq	r0, #0
 800bf12:	4770      	bx	lr

0800bf14 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800bf14:	b10a      	cbz	r2, 800bf1a <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800bf16:	6181      	str	r1, [r0, #24]
  }
}
 800bf18:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800bf1a:	0409      	lsls	r1, r1, #16
 800bf1c:	e7fb      	b.n	800bf16 <HAL_GPIO_WritePin+0x2>

0800bf1e <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800bf1e:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800bf20:	ea01 0203 	and.w	r2, r1, r3
 800bf24:	ea21 0103 	bic.w	r1, r1, r3
 800bf28:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 800bf2c:	6181      	str	r1, [r0, #24]
}
 800bf2e:	4770      	bx	lr

0800bf30 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 800bf30:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 800bf32:	4c10      	ldr	r4, [pc, #64]	@ (800bf74 <HAL_PWREx_ConfigSupply+0x44>)
 800bf34:	68e3      	ldr	r3, [r4, #12]
 800bf36:	f013 0f04 	tst.w	r3, #4
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800bf3a:	68e3      	ldr	r3, [r4, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 800bf3c:	d105      	bne.n	800bf4a <HAL_PWREx_ConfigSupply+0x1a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800bf3e:	f003 0307 	and.w	r3, r3, #7
 800bf42:	1a18      	subs	r0, r3, r0
 800bf44:	bf18      	it	ne
 800bf46:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 800bf48:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 800bf4a:	f023 0307 	bic.w	r3, r3, #7
 800bf4e:	4318      	orrs	r0, r3
 800bf50:	60e0      	str	r0, [r4, #12]
  tickstart = HAL_GetTick ();
 800bf52:	f7ff f96f 	bl	800b234 <HAL_GetTick>
 800bf56:	4605      	mov	r5, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 800bf58:	6863      	ldr	r3, [r4, #4]
 800bf5a:	049b      	lsls	r3, r3, #18
 800bf5c:	d501      	bpl.n	800bf62 <HAL_PWREx_ConfigSupply+0x32>
      return HAL_OK;
 800bf5e:	2000      	movs	r0, #0
 800bf60:	e7f2      	b.n	800bf48 <HAL_PWREx_ConfigSupply+0x18>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 800bf62:	f7ff f967 	bl	800b234 <HAL_GetTick>
 800bf66:	1b40      	subs	r0, r0, r5
 800bf68:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 800bf6c:	d9f4      	bls.n	800bf58 <HAL_PWREx_ConfigSupply+0x28>
      return HAL_ERROR;
 800bf6e:	2001      	movs	r0, #1
 800bf70:	e7ea      	b.n	800bf48 <HAL_PWREx_ConfigSupply+0x18>
 800bf72:	bf00      	nop
 800bf74:	58024800 	.word	0x58024800

0800bf78 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800bf78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800bf7a:	4604      	mov	r4, r0
 800bf7c:	2800      	cmp	r0, #0
 800bf7e:	d074      	beq.n	800c06a <HAL_RCC_OscConfig+0xf2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800bf80:	6803      	ldr	r3, [r0, #0]
 800bf82:	07d8      	lsls	r0, r3, #31
 800bf84:	d45e      	bmi.n	800c044 <HAL_RCC_OscConfig+0xcc>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800bf86:	6823      	ldr	r3, [r4, #0]
 800bf88:	0799      	lsls	r1, r3, #30
 800bf8a:	f100 80ad 	bmi.w	800c0e8 <HAL_RCC_OscConfig+0x170>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800bf8e:	6823      	ldr	r3, [r4, #0]
 800bf90:	06da      	lsls	r2, r3, #27
 800bf92:	d527      	bpl.n	800bfe4 <HAL_RCC_OscConfig+0x6c>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800bf94:	4a9c      	ldr	r2, [pc, #624]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800bf96:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800bf98:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800bf9a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 800bf9e:	2b08      	cmp	r3, #8
 800bfa0:	d007      	beq.n	800bfb2 <HAL_RCC_OscConfig+0x3a>
 800bfa2:	2b18      	cmp	r3, #24
 800bfa4:	f040 8103 	bne.w	800c1ae <HAL_RCC_OscConfig+0x236>
 800bfa8:	f001 0303 	and.w	r3, r1, #3
 800bfac:	2b01      	cmp	r3, #1
 800bfae:	f040 80fe 	bne.w	800c1ae <HAL_RCC_OscConfig+0x236>
    {
      /* When CSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800bfb2:	6813      	ldr	r3, [r2, #0]
 800bfb4:	05db      	lsls	r3, r3, #23
 800bfb6:	d502      	bpl.n	800bfbe <HAL_RCC_OscConfig+0x46>
 800bfb8:	69e3      	ldr	r3, [r4, #28]
 800bfba:	2b80      	cmp	r3, #128	@ 0x80
 800bfbc:	d155      	bne.n	800c06a <HAL_RCC_OscConfig+0xf2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800bfbe:	f7ff f959 	bl	800b274 <HAL_GetREVID>
 800bfc2:	f241 0303 	movw	r3, #4099	@ 0x1003
 800bfc6:	6a21      	ldr	r1, [r4, #32]
 800bfc8:	4298      	cmp	r0, r3
 800bfca:	4b8f      	ldr	r3, [pc, #572]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800bfcc:	f200 80e8 	bhi.w	800c1a0 <HAL_RCC_OscConfig+0x228>
 800bfd0:	685a      	ldr	r2, [r3, #4]
 800bfd2:	2920      	cmp	r1, #32
 800bfd4:	f022 42f8 	bic.w	r2, r2, #2080374784	@ 0x7c000000
 800bfd8:	bf0c      	ite	eq
 800bfda:	f042 4280 	orreq.w	r2, r2, #1073741824	@ 0x40000000
 800bfde:	ea42 6281 	orrne.w	r2, r2, r1, lsl #26
 800bfe2:	605a      	str	r2, [r3, #4]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800bfe4:	6823      	ldr	r3, [r4, #0]
 800bfe6:	0719      	lsls	r1, r3, #28
 800bfe8:	f100 8123 	bmi.w	800c232 <HAL_RCC_OscConfig+0x2ba>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800bfec:	6823      	ldr	r3, [r4, #0]
 800bfee:	069a      	lsls	r2, r3, #26
 800bff0:	f100 8144 	bmi.w	800c27c <HAL_RCC_OscConfig+0x304>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800bff4:	6823      	ldr	r3, [r4, #0]
 800bff6:	075d      	lsls	r5, r3, #29
 800bff8:	d51e      	bpl.n	800c038 <HAL_RCC_OscConfig+0xc0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800bffa:	4d84      	ldr	r5, [pc, #528]	@ (800c20c <HAL_RCC_OscConfig+0x294>)
 800bffc:	682b      	ldr	r3, [r5, #0]
 800bffe:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800c002:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800c004:	f7ff f916 	bl	800b234 <HAL_GetTick>
 800c008:	4606      	mov	r6, r0

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800c00a:	682b      	ldr	r3, [r5, #0]
 800c00c:	05da      	lsls	r2, r3, #23
 800c00e:	f140 815a 	bpl.w	800c2c6 <HAL_RCC_OscConfig+0x34e>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c012:	68a3      	ldr	r3, [r4, #8]
 800c014:	4d7c      	ldr	r5, [pc, #496]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800c016:	2b01      	cmp	r3, #1
 800c018:	f040 815c 	bne.w	800c2d4 <HAL_RCC_OscConfig+0x35c>
 800c01c:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c01e:	f043 0301 	orr.w	r3, r3, #1
 800c022:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c024:	f241 3788 	movw	r7, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 800c028:	f7ff f904 	bl	800b234 <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800c02c:	4e76      	ldr	r6, [pc, #472]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
      tickstart = HAL_GetTick();
 800c02e:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800c030:	6f33      	ldr	r3, [r6, #112]	@ 0x70
 800c032:	079b      	lsls	r3, r3, #30
 800c034:	f140 8174 	bpl.w	800c320 <HAL_RCC_OscConfig+0x3a8>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800c038:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800c03a:	2900      	cmp	r1, #0
 800c03c:	f040 8177 	bne.w	800c32e <HAL_RCC_OscConfig+0x3b6>
          __HAL_RCC_PLLFRACN_ENABLE();
        }
      }
    }
  }
  return HAL_OK;
 800c040:	2000      	movs	r0, #0
 800c042:	e02b      	b.n	800c09c <HAL_RCC_OscConfig+0x124>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c044:	4a70      	ldr	r2, [pc, #448]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800c046:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800c048:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c04a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 800c04e:	2b10      	cmp	r3, #16
 800c050:	d005      	beq.n	800c05e <HAL_RCC_OscConfig+0xe6>
 800c052:	2b18      	cmp	r3, #24
 800c054:	d10b      	bne.n	800c06e <HAL_RCC_OscConfig+0xf6>
 800c056:	f001 0303 	and.w	r3, r1, #3
 800c05a:	2b02      	cmp	r3, #2
 800c05c:	d107      	bne.n	800c06e <HAL_RCC_OscConfig+0xf6>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800c05e:	6813      	ldr	r3, [r2, #0]
 800c060:	039a      	lsls	r2, r3, #14
 800c062:	d590      	bpl.n	800bf86 <HAL_RCC_OscConfig+0xe>
 800c064:	6863      	ldr	r3, [r4, #4]
 800c066:	2b00      	cmp	r3, #0
 800c068:	d18d      	bne.n	800bf86 <HAL_RCC_OscConfig+0xe>
    return HAL_ERROR;
 800c06a:	2001      	movs	r0, #1
 800c06c:	e016      	b.n	800c09c <HAL_RCC_OscConfig+0x124>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800c06e:	6863      	ldr	r3, [r4, #4]
 800c070:	4d65      	ldr	r5, [pc, #404]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800c072:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c076:	d112      	bne.n	800c09e <HAL_RCC_OscConfig+0x126>
 800c078:	682b      	ldr	r3, [r5, #0]
 800c07a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800c07e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c080:	f7ff f8d8 	bl	800b234 <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800c084:	4e60      	ldr	r6, [pc, #384]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
        tickstart = HAL_GetTick();
 800c086:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800c088:	6833      	ldr	r3, [r6, #0]
 800c08a:	039b      	lsls	r3, r3, #14
 800c08c:	f53f af7b 	bmi.w	800bf86 <HAL_RCC_OscConfig+0xe>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800c090:	f7ff f8d0 	bl	800b234 <HAL_GetTick>
 800c094:	1b40      	subs	r0, r0, r5
 800c096:	2864      	cmp	r0, #100	@ 0x64
 800c098:	d9f6      	bls.n	800c088 <HAL_RCC_OscConfig+0x110>
            return HAL_TIMEOUT;
 800c09a:	2003      	movs	r0, #3
}
 800c09c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800c09e:	b9a3      	cbnz	r3, 800c0ca <HAL_RCC_OscConfig+0x152>
 800c0a0:	682b      	ldr	r3, [r5, #0]
 800c0a2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800c0a6:	602b      	str	r3, [r5, #0]
 800c0a8:	682b      	ldr	r3, [r5, #0]
 800c0aa:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800c0ae:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c0b0:	f7ff f8c0 	bl	800b234 <HAL_GetTick>
 800c0b4:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800c0b6:	682b      	ldr	r3, [r5, #0]
 800c0b8:	039f      	lsls	r7, r3, #14
 800c0ba:	f57f af64 	bpl.w	800bf86 <HAL_RCC_OscConfig+0xe>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800c0be:	f7ff f8b9 	bl	800b234 <HAL_GetTick>
 800c0c2:	1b80      	subs	r0, r0, r6
 800c0c4:	2864      	cmp	r0, #100	@ 0x64
 800c0c6:	d9f6      	bls.n	800c0b6 <HAL_RCC_OscConfig+0x13e>
 800c0c8:	e7e7      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800c0ca:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800c0ce:	682b      	ldr	r3, [r5, #0]
 800c0d0:	d103      	bne.n	800c0da <HAL_RCC_OscConfig+0x162>
 800c0d2:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800c0d6:	602b      	str	r3, [r5, #0]
 800c0d8:	e7ce      	b.n	800c078 <HAL_RCC_OscConfig+0x100>
 800c0da:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800c0de:	602b      	str	r3, [r5, #0]
 800c0e0:	682b      	ldr	r3, [r5, #0]
 800c0e2:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800c0e6:	e7ca      	b.n	800c07e <HAL_RCC_OscConfig+0x106>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c0e8:	4947      	ldr	r1, [pc, #284]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800c0ea:	68e2      	ldr	r2, [r4, #12]
 800c0ec:	690b      	ldr	r3, [r1, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800c0ee:	6a88      	ldr	r0, [r1, #40]	@ 0x28
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800c0f0:	f013 0338 	ands.w	r3, r3, #56	@ 0x38
 800c0f4:	d003      	beq.n	800c0fe <HAL_RCC_OscConfig+0x186>
 800c0f6:	2b18      	cmp	r3, #24
 800c0f8:	d12a      	bne.n	800c150 <HAL_RCC_OscConfig+0x1d8>
 800c0fa:	0780      	lsls	r0, r0, #30
 800c0fc:	d128      	bne.n	800c150 <HAL_RCC_OscConfig+0x1d8>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800c0fe:	680b      	ldr	r3, [r1, #0]
 800c100:	075b      	lsls	r3, r3, #29
 800c102:	d501      	bpl.n	800c108 <HAL_RCC_OscConfig+0x190>
 800c104:	2a00      	cmp	r2, #0
 800c106:	d0b0      	beq.n	800c06a <HAL_RCC_OscConfig+0xf2>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800c108:	4d3f      	ldr	r5, [pc, #252]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800c10a:	682b      	ldr	r3, [r5, #0]
 800c10c:	f023 0319 	bic.w	r3, r3, #25
 800c110:	4313      	orrs	r3, r2
 800c112:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c114:	f7ff f88e 	bl	800b234 <HAL_GetTick>
 800c118:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c11a:	682b      	ldr	r3, [r5, #0]
 800c11c:	075f      	lsls	r7, r3, #29
 800c11e:	d511      	bpl.n	800c144 <HAL_RCC_OscConfig+0x1cc>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800c120:	f7ff f8a8 	bl	800b274 <HAL_GetREVID>
 800c124:	f241 0303 	movw	r3, #4099	@ 0x1003
 800c128:	6922      	ldr	r2, [r4, #16]
 800c12a:	4298      	cmp	r0, r3
 800c12c:	686b      	ldr	r3, [r5, #4]
 800c12e:	d822      	bhi.n	800c176 <HAL_RCC_OscConfig+0x1fe>
 800c130:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 800c134:	2a40      	cmp	r2, #64	@ 0x40
 800c136:	bf0c      	ite	eq
 800c138:	f443 3300 	orreq.w	r3, r3, #131072	@ 0x20000
 800c13c:	ea43 3302 	orrne.w	r3, r3, r2, lsl #12
 800c140:	606b      	str	r3, [r5, #4]
 800c142:	e724      	b.n	800bf8e <HAL_RCC_OscConfig+0x16>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c144:	f7ff f876 	bl	800b234 <HAL_GetTick>
 800c148:	1b80      	subs	r0, r0, r6
 800c14a:	2802      	cmp	r0, #2
 800c14c:	d9e5      	bls.n	800c11a <HAL_RCC_OscConfig+0x1a2>
 800c14e:	e7a4      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800c150:	4d2d      	ldr	r5, [pc, #180]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800c152:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800c154:	b1a2      	cbz	r2, 800c180 <HAL_RCC_OscConfig+0x208>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800c156:	f023 0319 	bic.w	r3, r3, #25
 800c15a:	4313      	orrs	r3, r2
 800c15c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c15e:	f7ff f869 	bl	800b234 <HAL_GetTick>
 800c162:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c164:	682b      	ldr	r3, [r5, #0]
 800c166:	0758      	lsls	r0, r3, #29
 800c168:	d4da      	bmi.n	800c120 <HAL_RCC_OscConfig+0x1a8>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c16a:	f7ff f863 	bl	800b234 <HAL_GetTick>
 800c16e:	1b80      	subs	r0, r0, r6
 800c170:	2802      	cmp	r0, #2
 800c172:	d9f7      	bls.n	800c164 <HAL_RCC_OscConfig+0x1ec>
 800c174:	e791      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800c176:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 800c17a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c17e:	e7df      	b.n	800c140 <HAL_RCC_OscConfig+0x1c8>
        __HAL_RCC_HSI_DISABLE();
 800c180:	f023 0301 	bic.w	r3, r3, #1
 800c184:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c186:	f7ff f855 	bl	800b234 <HAL_GetTick>
 800c18a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800c18c:	682b      	ldr	r3, [r5, #0]
 800c18e:	0759      	lsls	r1, r3, #29
 800c190:	f57f aefd 	bpl.w	800bf8e <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c194:	f7ff f84e 	bl	800b234 <HAL_GetTick>
 800c198:	1b80      	subs	r0, r0, r6
 800c19a:	2802      	cmp	r0, #2
 800c19c:	d9f6      	bls.n	800c18c <HAL_RCC_OscConfig+0x214>
 800c19e:	e77c      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800c1a0:	68da      	ldr	r2, [r3, #12]
 800c1a2:	f022 527c 	bic.w	r2, r2, #1056964608	@ 0x3f000000
 800c1a6:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800c1aa:	60da      	str	r2, [r3, #12]
 800c1ac:	e71a      	b.n	800bfe4 <HAL_RCC_OscConfig+0x6c>
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
 800c1ae:	69e3      	ldr	r3, [r4, #28]
 800c1b0:	4d15      	ldr	r5, [pc, #84]	@ (800c208 <HAL_RCC_OscConfig+0x290>)
 800c1b2:	b36b      	cbz	r3, 800c210 <HAL_RCC_OscConfig+0x298>
        __HAL_RCC_CSI_ENABLE();
 800c1b4:	682b      	ldr	r3, [r5, #0]
 800c1b6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800c1ba:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c1bc:	f7ff f83a 	bl	800b234 <HAL_GetTick>
 800c1c0:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800c1c2:	682b      	ldr	r3, [r5, #0]
 800c1c4:	05df      	lsls	r7, r3, #23
 800c1c6:	d511      	bpl.n	800c1ec <HAL_RCC_OscConfig+0x274>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800c1c8:	f7ff f854 	bl	800b274 <HAL_GetREVID>
 800c1cc:	f241 0303 	movw	r3, #4099	@ 0x1003
 800c1d0:	6a22      	ldr	r2, [r4, #32]
 800c1d2:	4298      	cmp	r0, r3
 800c1d4:	d810      	bhi.n	800c1f8 <HAL_RCC_OscConfig+0x280>
 800c1d6:	686b      	ldr	r3, [r5, #4]
 800c1d8:	2a20      	cmp	r2, #32
 800c1da:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 800c1de:	bf0c      	ite	eq
 800c1e0:	f043 4380 	orreq.w	r3, r3, #1073741824	@ 0x40000000
 800c1e4:	ea43 6382 	orrne.w	r3, r3, r2, lsl #26
 800c1e8:	606b      	str	r3, [r5, #4]
 800c1ea:	e6fb      	b.n	800bfe4 <HAL_RCC_OscConfig+0x6c>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 800c1ec:	f7ff f822 	bl	800b234 <HAL_GetTick>
 800c1f0:	1b80      	subs	r0, r0, r6
 800c1f2:	2802      	cmp	r0, #2
 800c1f4:	d9e5      	bls.n	800c1c2 <HAL_RCC_OscConfig+0x24a>
 800c1f6:	e750      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800c1f8:	68eb      	ldr	r3, [r5, #12]
 800c1fa:	f023 537c 	bic.w	r3, r3, #1056964608	@ 0x3f000000
 800c1fe:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c202:	60eb      	str	r3, [r5, #12]
 800c204:	e6ee      	b.n	800bfe4 <HAL_RCC_OscConfig+0x6c>
 800c206:	bf00      	nop
 800c208:	58024400 	.word	0x58024400
 800c20c:	58024800 	.word	0x58024800
        __HAL_RCC_CSI_DISABLE();
 800c210:	682b      	ldr	r3, [r5, #0]
 800c212:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800c216:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c218:	f7ff f80c 	bl	800b234 <HAL_GetTick>
 800c21c:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800c21e:	682b      	ldr	r3, [r5, #0]
 800c220:	05d8      	lsls	r0, r3, #23
 800c222:	f57f aedf 	bpl.w	800bfe4 <HAL_RCC_OscConfig+0x6c>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 800c226:	f7ff f805 	bl	800b234 <HAL_GetTick>
 800c22a:	1b80      	subs	r0, r0, r6
 800c22c:	2802      	cmp	r0, #2
 800c22e:	d9f6      	bls.n	800c21e <HAL_RCC_OscConfig+0x2a6>
 800c230:	e733      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800c232:	6963      	ldr	r3, [r4, #20]
 800c234:	4da3      	ldr	r5, [pc, #652]	@ (800c4c4 <HAL_RCC_OscConfig+0x54c>)
 800c236:	b183      	cbz	r3, 800c25a <HAL_RCC_OscConfig+0x2e2>
      __HAL_RCC_LSI_ENABLE();
 800c238:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c23a:	f043 0301 	orr.w	r3, r3, #1
 800c23e:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 800c240:	f7fe fff8 	bl	800b234 <HAL_GetTick>
 800c244:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800c246:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c248:	079b      	lsls	r3, r3, #30
 800c24a:	f53f aecf 	bmi.w	800bfec <HAL_RCC_OscConfig+0x74>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800c24e:	f7fe fff1 	bl	800b234 <HAL_GetTick>
 800c252:	1b80      	subs	r0, r0, r6
 800c254:	2802      	cmp	r0, #2
 800c256:	d9f6      	bls.n	800c246 <HAL_RCC_OscConfig+0x2ce>
 800c258:	e71f      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_LSI_DISABLE();
 800c25a:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c25c:	f023 0301 	bic.w	r3, r3, #1
 800c260:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 800c262:	f7fe ffe7 	bl	800b234 <HAL_GetTick>
 800c266:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800c268:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c26a:	079f      	lsls	r7, r3, #30
 800c26c:	f57f aebe 	bpl.w	800bfec <HAL_RCC_OscConfig+0x74>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800c270:	f7fe ffe0 	bl	800b234 <HAL_GetTick>
 800c274:	1b80      	subs	r0, r0, r6
 800c276:	2802      	cmp	r0, #2
 800c278:	d9f6      	bls.n	800c268 <HAL_RCC_OscConfig+0x2f0>
 800c27a:	e70e      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)
 800c27c:	69a3      	ldr	r3, [r4, #24]
 800c27e:	4d91      	ldr	r5, [pc, #580]	@ (800c4c4 <HAL_RCC_OscConfig+0x54c>)
 800c280:	b183      	cbz	r3, 800c2a4 <HAL_RCC_OscConfig+0x32c>
      __HAL_RCC_HSI48_ENABLE();
 800c282:	682b      	ldr	r3, [r5, #0]
 800c284:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800c288:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800c28a:	f7fe ffd3 	bl	800b234 <HAL_GetTick>
 800c28e:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800c290:	682b      	ldr	r3, [r5, #0]
 800c292:	0498      	lsls	r0, r3, #18
 800c294:	f53f aeae 	bmi.w	800bff4 <HAL_RCC_OscConfig+0x7c>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800c298:	f7fe ffcc 	bl	800b234 <HAL_GetTick>
 800c29c:	1b80      	subs	r0, r0, r6
 800c29e:	2802      	cmp	r0, #2
 800c2a0:	d9f6      	bls.n	800c290 <HAL_RCC_OscConfig+0x318>
 800c2a2:	e6fa      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_HSI48_DISABLE();
 800c2a4:	682b      	ldr	r3, [r5, #0]
 800c2a6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800c2aa:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800c2ac:	f7fe ffc2 	bl	800b234 <HAL_GetTick>
 800c2b0:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800c2b2:	682b      	ldr	r3, [r5, #0]
 800c2b4:	0499      	lsls	r1, r3, #18
 800c2b6:	f57f ae9d 	bpl.w	800bff4 <HAL_RCC_OscConfig+0x7c>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800c2ba:	f7fe ffbb 	bl	800b234 <HAL_GetTick>
 800c2be:	1b80      	subs	r0, r0, r6
 800c2c0:	2802      	cmp	r0, #2
 800c2c2:	d9f6      	bls.n	800c2b2 <HAL_RCC_OscConfig+0x33a>
 800c2c4:	e6e9      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c2c6:	f7fe ffb5 	bl	800b234 <HAL_GetTick>
 800c2ca:	1b80      	subs	r0, r0, r6
 800c2cc:	2864      	cmp	r0, #100	@ 0x64
 800c2ce:	f67f ae9c 	bls.w	800c00a <HAL_RCC_OscConfig+0x92>
 800c2d2:	e6e2      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c2d4:	b9b3      	cbnz	r3, 800c304 <HAL_RCC_OscConfig+0x38c>
 800c2d6:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c2d8:	f241 3788 	movw	r7, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c2dc:	f023 0301 	bic.w	r3, r3, #1
 800c2e0:	672b      	str	r3, [r5, #112]	@ 0x70
 800c2e2:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c2e4:	f023 0304 	bic.w	r3, r3, #4
 800c2e8:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();
 800c2ea:	f7fe ffa3 	bl	800b234 <HAL_GetTick>
 800c2ee:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800c2f0:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c2f2:	0798      	lsls	r0, r3, #30
 800c2f4:	f57f aea0 	bpl.w	800c038 <HAL_RCC_OscConfig+0xc0>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c2f8:	f7fe ff9c 	bl	800b234 <HAL_GetTick>
 800c2fc:	1b80      	subs	r0, r0, r6
 800c2fe:	42b8      	cmp	r0, r7
 800c300:	d9f6      	bls.n	800c2f0 <HAL_RCC_OscConfig+0x378>
 800c302:	e6ca      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c304:	2b05      	cmp	r3, #5
 800c306:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c308:	d103      	bne.n	800c312 <HAL_RCC_OscConfig+0x39a>
 800c30a:	f043 0304 	orr.w	r3, r3, #4
 800c30e:	672b      	str	r3, [r5, #112]	@ 0x70
 800c310:	e684      	b.n	800c01c <HAL_RCC_OscConfig+0xa4>
 800c312:	f023 0301 	bic.w	r3, r3, #1
 800c316:	672b      	str	r3, [r5, #112]	@ 0x70
 800c318:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c31a:	f023 0304 	bic.w	r3, r3, #4
 800c31e:	e680      	b.n	800c022 <HAL_RCC_OscConfig+0xaa>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c320:	f7fe ff88 	bl	800b234 <HAL_GetTick>
 800c324:	1b40      	subs	r0, r0, r5
 800c326:	42b8      	cmp	r0, r7
 800c328:	f67f ae82 	bls.w	800c030 <HAL_RCC_OscConfig+0xb8>
 800c32c:	e6b5      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 800c32e:	4d65      	ldr	r5, [pc, #404]	@ (800c4c4 <HAL_RCC_OscConfig+0x54c>)
 800c330:	692b      	ldr	r3, [r5, #16]
 800c332:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800c336:	2b18      	cmp	r3, #24
 800c338:	d078      	beq.n	800c42c <HAL_RCC_OscConfig+0x4b4>
        __HAL_RCC_PLL_DISABLE();
 800c33a:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800c33c:	2902      	cmp	r1, #2
        __HAL_RCC_PLL_DISABLE();
 800c33e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 800c342:	602b      	str	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800c344:	d165      	bne.n	800c412 <HAL_RCC_OscConfig+0x49a>
        tickstart = HAL_GetTick();
 800c346:	f7fe ff75 	bl	800b234 <HAL_GetTick>
 800c34a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800c34c:	682b      	ldr	r3, [r5, #0]
 800c34e:	0199      	lsls	r1, r3, #6
 800c350:	d459      	bmi.n	800c406 <HAL_RCC_OscConfig+0x48e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800c352:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 800c354:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 800c356:	f423 737c 	bic.w	r3, r3, #1008	@ 0x3f0
 800c35a:	f023 0303 	bic.w	r3, r3, #3
 800c35e:	4313      	orrs	r3, r2
 800c360:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 800c362:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800c366:	62ab      	str	r3, [r5, #40]	@ 0x28
 800c368:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800c36a:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800c36c:	3b01      	subs	r3, #1
 800c36e:	3a01      	subs	r2, #1
 800c370:	025b      	lsls	r3, r3, #9
 800c372:	0412      	lsls	r2, r2, #16
 800c374:	b29b      	uxth	r3, r3
 800c376:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 800c37a:	4313      	orrs	r3, r2
 800c37c:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800c37e:	3a01      	subs	r2, #1
 800c380:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800c384:	4313      	orrs	r3, r2
 800c386:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 800c388:	3a01      	subs	r2, #1
 800c38a:	0612      	lsls	r2, r2, #24
 800c38c:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 800c390:	4313      	orrs	r3, r2
 800c392:	632b      	str	r3, [r5, #48]	@ 0x30
        __HAL_RCC_PLLFRACN_DISABLE();
 800c394:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c396:	f023 0301 	bic.w	r3, r3, #1
 800c39a:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800c39c:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
 800c39e:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800c3a0:	f36f 03cf 	bfc	r3, #3, #13
 800c3a4:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800c3a8:	636b      	str	r3, [r5, #52]	@ 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 800c3aa:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3ac:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 800c3ae:	f023 030c 	bic.w	r3, r3, #12
 800c3b2:	4313      	orrs	r3, r2
 800c3b4:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 800c3b6:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3b8:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 800c3ba:	f023 0302 	bic.w	r3, r3, #2
 800c3be:	4313      	orrs	r3, r2
 800c3c0:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800c3c2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3c4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800c3c8:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800c3ca:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3cc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800c3d0:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 800c3d2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3d4:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800c3d8:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLFRACN_ENABLE();
 800c3da:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3dc:	f043 0301 	orr.w	r3, r3, #1
 800c3e0:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLL_ENABLE();
 800c3e2:	682b      	ldr	r3, [r5, #0]
 800c3e4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800c3e8:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c3ea:	f7fe ff23 	bl	800b234 <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800c3ee:	4d35      	ldr	r5, [pc, #212]	@ (800c4c4 <HAL_RCC_OscConfig+0x54c>)
        tickstart = HAL_GetTick();
 800c3f0:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800c3f2:	682b      	ldr	r3, [r5, #0]
 800c3f4:	019a      	lsls	r2, r3, #6
 800c3f6:	f53f ae23 	bmi.w	800c040 <HAL_RCC_OscConfig+0xc8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c3fa:	f7fe ff1b 	bl	800b234 <HAL_GetTick>
 800c3fe:	1b00      	subs	r0, r0, r4
 800c400:	2802      	cmp	r0, #2
 800c402:	d9f6      	bls.n	800c3f2 <HAL_RCC_OscConfig+0x47a>
 800c404:	e649      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c406:	f7fe ff15 	bl	800b234 <HAL_GetTick>
 800c40a:	1b80      	subs	r0, r0, r6
 800c40c:	2802      	cmp	r0, #2
 800c40e:	d99d      	bls.n	800c34c <HAL_RCC_OscConfig+0x3d4>
 800c410:	e643      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
        tickstart = HAL_GetTick();
 800c412:	f7fe ff0f 	bl	800b234 <HAL_GetTick>
 800c416:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800c418:	682b      	ldr	r3, [r5, #0]
 800c41a:	019b      	lsls	r3, r3, #6
 800c41c:	f57f ae10 	bpl.w	800c040 <HAL_RCC_OscConfig+0xc8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c420:	f7fe ff08 	bl	800b234 <HAL_GetTick>
 800c424:	1b00      	subs	r0, r0, r4
 800c426:	2802      	cmp	r0, #2
 800c428:	d9f6      	bls.n	800c418 <HAL_RCC_OscConfig+0x4a0>
 800c42a:	e636      	b.n	800c09a <HAL_RCC_OscConfig+0x122>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800c42c:	2901      	cmp	r1, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
 800c42e:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 800c430:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800c432:	f43f ae1a 	beq.w	800c06a <HAL_RCC_OscConfig+0xf2>
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800c436:	f002 0103 	and.w	r1, r2, #3
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800c43a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 800c43c:	4281      	cmp	r1, r0
 800c43e:	f47f ae14 	bne.w	800c06a <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800c442:	f3c2 1205 	ubfx	r2, r2, #4, #6
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800c446:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800c448:	428a      	cmp	r2, r1
 800c44a:	f47f ae0e 	bne.w	800c06a <HAL_RCC_OscConfig+0xf2>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800c44e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800c450:	f3c3 0108 	ubfx	r1, r3, #0, #9
 800c454:	3a01      	subs	r2, #1
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800c456:	4291      	cmp	r1, r2
 800c458:	f47f ae07 	bne.w	800c06a <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800c45c:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 800c45e:	f3c3 2146 	ubfx	r1, r3, #9, #7
 800c462:	3a01      	subs	r2, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800c464:	4291      	cmp	r1, r2
 800c466:	f47f ae00 	bne.w	800c06a <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800c46a:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800c46c:	f3c3 4106 	ubfx	r1, r3, #16, #7
 800c470:	3a01      	subs	r2, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800c472:	4291      	cmp	r1, r2
 800c474:	f47f adf9 	bne.w	800c06a <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800c478:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 800c47a:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800c47e:	3a01      	subs	r2, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800c480:	4293      	cmp	r3, r2
 800c482:	f47f adf2 	bne.w	800c06a <HAL_RCC_OscConfig+0xf2>
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 800c486:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 800c488:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 800c48a:	f3c3 03cc 	ubfx	r3, r3, #3, #13
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 800c48e:	429a      	cmp	r2, r3
 800c490:	f43f add6 	beq.w	800c040 <HAL_RCC_OscConfig+0xc8>
          __HAL_RCC_PLLFRACN_DISABLE();
 800c494:	4d0b      	ldr	r5, [pc, #44]	@ (800c4c4 <HAL_RCC_OscConfig+0x54c>)
 800c496:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c498:	f023 0301 	bic.w	r3, r3, #1
 800c49c:	62eb      	str	r3, [r5, #44]	@ 0x2c
          tickstart = HAL_GetTick();
 800c49e:	f7fe fec9 	bl	800b234 <HAL_GetTick>
 800c4a2:	4606      	mov	r6, r0
          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)
 800c4a4:	f7fe fec6 	bl	800b234 <HAL_GetTick>
 800c4a8:	42b0      	cmp	r0, r6
 800c4aa:	d0fb      	beq.n	800c4a4 <HAL_RCC_OscConfig+0x52c>
          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800c4ac:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
 800c4ae:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800c4b0:	f36f 03cf 	bfc	r3, #3, #13
 800c4b4:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800c4b8:	636b      	str	r3, [r5, #52]	@ 0x34
          __HAL_RCC_PLLFRACN_ENABLE();
 800c4ba:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c4bc:	f043 0301 	orr.w	r3, r3, #1
 800c4c0:	62eb      	str	r3, [r5, #44]	@ 0x2c
 800c4c2:	e5bd      	b.n	800c040 <HAL_RCC_OscConfig+0xc8>
 800c4c4:	58024400 	.word	0x58024400

0800c4c8 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 800c4c8:	4b49      	ldr	r3, [pc, #292]	@ (800c5f0 <HAL_RCC_GetSysClockFreq+0x128>)
 800c4ca:	691a      	ldr	r2, [r3, #16]
 800c4cc:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 800c4d0:	2a10      	cmp	r2, #16
{
 800c4d2:	b530      	push	{r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800c4d4:	f000 8088 	beq.w	800c5e8 <HAL_RCC_GetSysClockFreq+0x120>
 800c4d8:	2a18      	cmp	r2, #24
 800c4da:	d00c      	beq.n	800c4f6 <HAL_RCC_GetSysClockFreq+0x2e>
 800c4dc:	2a00      	cmp	r2, #0
 800c4de:	f040 8085 	bne.w	800c5ec <HAL_RCC_GetSysClockFreq+0x124>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c4e2:	681a      	ldr	r2, [r3, #0]
 800c4e4:	4843      	ldr	r0, [pc, #268]	@ (800c5f4 <HAL_RCC_GetSysClockFreq+0x12c>)
 800c4e6:	f012 0f20 	tst.w	r2, #32
 800c4ea:	d003      	beq.n	800c4f4 <HAL_RCC_GetSysClockFreq+0x2c>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c4ec:	681b      	ldr	r3, [r3, #0]
 800c4ee:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800c4f2:	40d8      	lsrs	r0, r3
      sysclockfreq = CSI_VALUE;
      break;
  }

  return sysclockfreq;
}
 800c4f4:	bd30      	pop	{r4, r5, pc}
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c4f6:	6a99      	ldr	r1, [r3, #40]	@ 0x28
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 800c4f8:	6a9d      	ldr	r5, [r3, #40]	@ 0x28
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 800c4fa:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
      if (pllm != 0U)
 800c4fc:	f415 7f7c 	tst.w	r5, #1008	@ 0x3f0
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 800c500:	f3c5 1005 	ubfx	r0, r5, #4, #6
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800c504:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
      if (pllm != 0U)
 800c506:	d0f5      	beq.n	800c4f4 <HAL_RCC_GetSysClockFreq+0x2c>
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800c508:	f3c2 02cc 	ubfx	r2, r2, #3, #13
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 800c50c:	f004 0401 	and.w	r4, r4, #1
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c510:	f001 0103 	and.w	r1, r1, #3
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c514:	ee07 0a90 	vmov	s15, r0
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800c518:	4362      	muls	r2, r4
 800c51a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
        switch (pllsource)
 800c51e:	2901      	cmp	r1, #1
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c520:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800c524:	ee06 2a90 	vmov	s13, r2
 800c528:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
        switch (pllsource)
 800c52c:	d04e      	beq.n	800c5cc <HAL_RCC_GetSysClockFreq+0x104>
 800c52e:	2902      	cmp	r1, #2
 800c530:	d03e      	beq.n	800c5b0 <HAL_RCC_GetSysClockFreq+0xe8>
 800c532:	2900      	cmp	r1, #0
 800c534:	d14a      	bne.n	800c5cc <HAL_RCC_GetSysClockFreq+0x104>
            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c536:	681a      	ldr	r2, [r3, #0]
 800c538:	0692      	lsls	r2, r2, #26
 800c53a:	d527      	bpl.n	800c58c <HAL_RCC_GetSysClockFreq+0xc4>
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c53c:	6819      	ldr	r1, [r3, #0]
 800c53e:	4a2d      	ldr	r2, [pc, #180]	@ (800c5f4 <HAL_RCC_GetSysClockFreq+0x12c>)
 800c540:	f3c1 01c1 	ubfx	r1, r1, #3, #2
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c544:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c546:	40ca      	lsrs	r2, r1
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c548:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c54c:	ee07 2a90 	vmov	s15, r2
 800c550:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 800c554:	eec5 7a87 	vdiv.f32	s15, s11, s14
 800c558:	ee07 3a10 	vmov	s14, r3
 800c55c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c560:	ee37 7a26 	vadd.f32	s14, s14, s13
 800c564:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c568:	ee67 7a87 	vmul.f32	s15, s15, s14
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 800c56c:	4b20      	ldr	r3, [pc, #128]	@ (800c5f0 <HAL_RCC_GetSysClockFreq+0x128>)
 800c56e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c570:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800c574:	3301      	adds	r3, #1
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 800c576:	ee07 3a10 	vmov	s14, r3
 800c57a:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 800c57e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800c582:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800c586:	ee17 0a90 	vmov	r0, s15
 800c58a:	e7b3      	b.n	800c4f4 <HAL_RCC_GetSysClockFreq+0x2c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c58c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c58e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c592:	ee07 3a90 	vmov	s15, r3
 800c596:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c59a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c59e:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c5a2:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 800c5f8 <HAL_RCC_GetSysClockFreq+0x130>
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c5a6:	eec6 6a07 	vdiv.f32	s13, s12, s14
 800c5aa:	ee67 7aa6 	vmul.f32	s15, s15, s13
            break;
 800c5ae:	e7dd      	b.n	800c56c <HAL_RCC_GetSysClockFreq+0xa4>
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c5b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c5b2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c5b6:	ee07 3a90 	vmov	s15, r3
 800c5ba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c5be:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c5c2:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c5c6:	ed9f 6a0d 	vldr	s12, [pc, #52]	@ 800c5fc <HAL_RCC_GetSysClockFreq+0x134>
 800c5ca:	e7ec      	b.n	800c5a6 <HAL_RCC_GetSysClockFreq+0xde>
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c5cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c5ce:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c5d2:	ee07 3a90 	vmov	s15, r3
 800c5d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c5da:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c5de:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c5e2:	ed9f 6a07 	vldr	s12, [pc, #28]	@ 800c600 <HAL_RCC_GetSysClockFreq+0x138>
 800c5e6:	e7de      	b.n	800c5a6 <HAL_RCC_GetSysClockFreq+0xde>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800c5e8:	4806      	ldr	r0, [pc, #24]	@ (800c604 <HAL_RCC_GetSysClockFreq+0x13c>)
 800c5ea:	e783      	b.n	800c4f4 <HAL_RCC_GetSysClockFreq+0x2c>
      sysclockfreq = CSI_VALUE;
 800c5ec:	4806      	ldr	r0, [pc, #24]	@ (800c608 <HAL_RCC_GetSysClockFreq+0x140>)
 800c5ee:	e781      	b.n	800c4f4 <HAL_RCC_GetSysClockFreq+0x2c>
 800c5f0:	58024400 	.word	0x58024400
 800c5f4:	03d09000 	.word	0x03d09000
 800c5f8:	4c742400 	.word	0x4c742400
 800c5fc:	4af42400 	.word	0x4af42400
 800c600:	4a742400 	.word	0x4a742400
 800c604:	007a1200 	.word	0x007a1200
 800c608:	003d0900 	.word	0x003d0900

0800c60c <HAL_RCC_ClockConfig>:
{
 800c60c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c610:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 800c612:	4604      	mov	r4, r0
 800c614:	b910      	cbnz	r0, 800c61c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 800c616:	2001      	movs	r0, #1
}
 800c618:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800c61c:	4a88      	ldr	r2, [pc, #544]	@ (800c840 <HAL_RCC_ClockConfig+0x234>)
 800c61e:	6813      	ldr	r3, [r2, #0]
 800c620:	f003 030f 	and.w	r3, r3, #15
 800c624:	428b      	cmp	r3, r1
 800c626:	f0c0 8093 	bcc.w	800c750 <HAL_RCC_ClockConfig+0x144>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800c62a:	6823      	ldr	r3, [r4, #0]
 800c62c:	075f      	lsls	r7, r3, #29
 800c62e:	f100 809b 	bmi.w	800c768 <HAL_RCC_ClockConfig+0x15c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800c632:	071e      	lsls	r6, r3, #28
 800c634:	d50b      	bpl.n	800c64e <HAL_RCC_ClockConfig+0x42>
    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800c636:	4983      	ldr	r1, [pc, #524]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c638:	6960      	ldr	r0, [r4, #20]
 800c63a:	69ca      	ldr	r2, [r1, #28]
 800c63c:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c640:	4290      	cmp	r0, r2
 800c642:	d904      	bls.n	800c64e <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800c644:	69ca      	ldr	r2, [r1, #28]
 800c646:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c64a:	4302      	orrs	r2, r0
 800c64c:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800c64e:	06d8      	lsls	r0, r3, #27
 800c650:	d50b      	bpl.n	800c66a <HAL_RCC_ClockConfig+0x5e>
    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800c652:	497c      	ldr	r1, [pc, #496]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c654:	69a0      	ldr	r0, [r4, #24]
 800c656:	69ca      	ldr	r2, [r1, #28]
 800c658:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 800c65c:	4290      	cmp	r0, r2
 800c65e:	d904      	bls.n	800c66a <HAL_RCC_ClockConfig+0x5e>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800c660:	69ca      	ldr	r2, [r1, #28]
 800c662:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c666:	4302      	orrs	r2, r0
 800c668:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800c66a:	0699      	lsls	r1, r3, #26
 800c66c:	d50b      	bpl.n	800c686 <HAL_RCC_ClockConfig+0x7a>
    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800c66e:	4975      	ldr	r1, [pc, #468]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c670:	69e0      	ldr	r0, [r4, #28]
 800c672:	6a0a      	ldr	r2, [r1, #32]
 800c674:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c678:	4290      	cmp	r0, r2
 800c67a:	d904      	bls.n	800c686 <HAL_RCC_ClockConfig+0x7a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 800c67c:	6a0a      	ldr	r2, [r1, #32]
 800c67e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c682:	4302      	orrs	r2, r0
 800c684:	620a      	str	r2, [r1, #32]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800c686:	079a      	lsls	r2, r3, #30
 800c688:	d50b      	bpl.n	800c6a2 <HAL_RCC_ClockConfig+0x96>
    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800c68a:	496e      	ldr	r1, [pc, #440]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c68c:	68e0      	ldr	r0, [r4, #12]
 800c68e:	698a      	ldr	r2, [r1, #24]
 800c690:	f002 020f 	and.w	r2, r2, #15
 800c694:	4290      	cmp	r0, r2
 800c696:	d904      	bls.n	800c6a2 <HAL_RCC_ClockConfig+0x96>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800c698:	698a      	ldr	r2, [r1, #24]
 800c69a:	f022 020f 	bic.w	r2, r2, #15
 800c69e:	4302      	orrs	r2, r0
 800c6a0:	618a      	str	r2, [r1, #24]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800c6a2:	07df      	lsls	r7, r3, #31
 800c6a4:	d46e      	bmi.n	800c784 <HAL_RCC_ClockConfig+0x178>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800c6a6:	6823      	ldr	r3, [r4, #0]
 800c6a8:	079e      	lsls	r6, r3, #30
 800c6aa:	f100 80a1 	bmi.w	800c7f0 <HAL_RCC_ClockConfig+0x1e4>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800c6ae:	4964      	ldr	r1, [pc, #400]	@ (800c840 <HAL_RCC_ClockConfig+0x234>)
 800c6b0:	680a      	ldr	r2, [r1, #0]
 800c6b2:	f002 020f 	and.w	r2, r2, #15
 800c6b6:	42aa      	cmp	r2, r5
 800c6b8:	f200 80a8 	bhi.w	800c80c <HAL_RCC_ClockConfig+0x200>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800c6bc:	0758      	lsls	r0, r3, #29
 800c6be:	f100 80b1 	bmi.w	800c824 <HAL_RCC_ClockConfig+0x218>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800c6c2:	0719      	lsls	r1, r3, #28
 800c6c4:	d50b      	bpl.n	800c6de <HAL_RCC_ClockConfig+0xd2>
    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800c6c6:	495f      	ldr	r1, [pc, #380]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c6c8:	6960      	ldr	r0, [r4, #20]
 800c6ca:	69ca      	ldr	r2, [r1, #28]
 800c6cc:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c6d0:	4290      	cmp	r0, r2
 800c6d2:	d204      	bcs.n	800c6de <HAL_RCC_ClockConfig+0xd2>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800c6d4:	69ca      	ldr	r2, [r1, #28]
 800c6d6:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c6da:	4302      	orrs	r2, r0
 800c6dc:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800c6de:	06da      	lsls	r2, r3, #27
 800c6e0:	d50b      	bpl.n	800c6fa <HAL_RCC_ClockConfig+0xee>
    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800c6e2:	4958      	ldr	r1, [pc, #352]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c6e4:	69a0      	ldr	r0, [r4, #24]
 800c6e6:	69ca      	ldr	r2, [r1, #28]
 800c6e8:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 800c6ec:	4290      	cmp	r0, r2
 800c6ee:	d204      	bcs.n	800c6fa <HAL_RCC_ClockConfig+0xee>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800c6f0:	69ca      	ldr	r2, [r1, #28]
 800c6f2:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c6f6:	4302      	orrs	r2, r0
 800c6f8:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800c6fa:	069b      	lsls	r3, r3, #26
 800c6fc:	d50b      	bpl.n	800c716 <HAL_RCC_ClockConfig+0x10a>
    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800c6fe:	4a51      	ldr	r2, [pc, #324]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c700:	69e1      	ldr	r1, [r4, #28]
 800c702:	6a13      	ldr	r3, [r2, #32]
 800c704:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800c708:	4299      	cmp	r1, r3
 800c70a:	d204      	bcs.n	800c716 <HAL_RCC_ClockConfig+0x10a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 800c70c:	6a13      	ldr	r3, [r2, #32]
 800c70e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800c712:	430b      	orrs	r3, r1
 800c714:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800c716:	f7ff fed7 	bl	800c4c8 <HAL_RCC_GetSysClockFreq>
 800c71a:	494a      	ldr	r1, [pc, #296]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c71c:	4a4a      	ldr	r2, [pc, #296]	@ (800c848 <HAL_RCC_ClockConfig+0x23c>)
 800c71e:	698b      	ldr	r3, [r1, #24]
 800c720:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800c724:	5cd3      	ldrb	r3, [r2, r3]
 800c726:	f003 031f 	and.w	r3, r3, #31
 800c72a:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c72c:	698b      	ldr	r3, [r1, #24]
 800c72e:	f003 030f 	and.w	r3, r3, #15
 800c732:	5cd3      	ldrb	r3, [r2, r3]
 800c734:	4a45      	ldr	r2, [pc, #276]	@ (800c84c <HAL_RCC_ClockConfig+0x240>)
 800c736:	f003 031f 	and.w	r3, r3, #31
 800c73a:	fa20 f303 	lsr.w	r3, r0, r3
 800c73e:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 800c740:	4b43      	ldr	r3, [pc, #268]	@ (800c850 <HAL_RCC_ClockConfig+0x244>)
 800c742:	6018      	str	r0, [r3, #0]
  halstatus = HAL_InitTick(uwTickPrio);
 800c744:	4b43      	ldr	r3, [pc, #268]	@ (800c854 <HAL_RCC_ClockConfig+0x248>)
}
 800c746:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick(uwTickPrio);
 800c74a:	6818      	ldr	r0, [r3, #0]
 800c74c:	f7fe bd14 	b.w	800b178 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800c750:	6813      	ldr	r3, [r2, #0]
 800c752:	f023 030f 	bic.w	r3, r3, #15
 800c756:	430b      	orrs	r3, r1
 800c758:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800c75a:	6813      	ldr	r3, [r2, #0]
 800c75c:	f003 030f 	and.w	r3, r3, #15
 800c760:	428b      	cmp	r3, r1
 800c762:	f47f af58 	bne.w	800c616 <HAL_RCC_ClockConfig+0xa>
 800c766:	e760      	b.n	800c62a <HAL_RCC_ClockConfig+0x1e>
    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800c768:	4936      	ldr	r1, [pc, #216]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c76a:	6920      	ldr	r0, [r4, #16]
 800c76c:	698a      	ldr	r2, [r1, #24]
 800c76e:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c772:	4290      	cmp	r0, r2
 800c774:	f67f af5d 	bls.w	800c632 <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800c778:	698a      	ldr	r2, [r1, #24]
 800c77a:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c77e:	4302      	orrs	r2, r0
 800c780:	618a      	str	r2, [r1, #24]
 800c782:	e756      	b.n	800c632 <HAL_RCC_ClockConfig+0x26>
    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 800c784:	4b2f      	ldr	r3, [pc, #188]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c786:	68a1      	ldr	r1, [r4, #8]
 800c788:	699a      	ldr	r2, [r3, #24]
 800c78a:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00
 800c78e:	430a      	orrs	r2, r1
 800c790:	619a      	str	r2, [r3, #24]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c792:	6861      	ldr	r1, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800c794:	681a      	ldr	r2, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c796:	2902      	cmp	r1, #2
 800c798:	d11d      	bne.n	800c7d6 <HAL_RCC_ClockConfig+0x1ca>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800c79a:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c79e:	f43f af3a 	beq.w	800c616 <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800c7a2:	691a      	ldr	r2, [r3, #16]
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800c7a4:	f241 3888 	movw	r8, #5000	@ 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800c7a8:	4f26      	ldr	r7, [pc, #152]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800c7aa:	f022 0207 	bic.w	r2, r2, #7
 800c7ae:	430a      	orrs	r2, r1
 800c7b0:	611a      	str	r2, [r3, #16]
    tickstart = HAL_GetTick();
 800c7b2:	f7fe fd3f 	bl	800b234 <HAL_GetTick>
 800c7b6:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800c7b8:	693b      	ldr	r3, [r7, #16]
 800c7ba:	6862      	ldr	r2, [r4, #4]
 800c7bc:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800c7c0:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 800c7c4:	f43f af6f 	beq.w	800c6a6 <HAL_RCC_ClockConfig+0x9a>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800c7c8:	f7fe fd34 	bl	800b234 <HAL_GetTick>
 800c7cc:	1b80      	subs	r0, r0, r6
 800c7ce:	4540      	cmp	r0, r8
 800c7d0:	d9f2      	bls.n	800c7b8 <HAL_RCC_ClockConfig+0x1ac>
        return HAL_TIMEOUT;
 800c7d2:	2003      	movs	r0, #3
 800c7d4:	e720      	b.n	800c618 <HAL_RCC_ClockConfig+0xc>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800c7d6:	2903      	cmp	r1, #3
 800c7d8:	d102      	bne.n	800c7e0 <HAL_RCC_ClockConfig+0x1d4>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800c7da:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
 800c7de:	e7de      	b.n	800c79e <HAL_RCC_ClockConfig+0x192>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 800c7e0:	2901      	cmp	r1, #1
 800c7e2:	d102      	bne.n	800c7ea <HAL_RCC_ClockConfig+0x1de>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800c7e4:	f412 7f80 	tst.w	r2, #256	@ 0x100
 800c7e8:	e7d9      	b.n	800c79e <HAL_RCC_ClockConfig+0x192>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c7ea:	f012 0f04 	tst.w	r2, #4
 800c7ee:	e7d6      	b.n	800c79e <HAL_RCC_ClockConfig+0x192>
    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800c7f0:	4914      	ldr	r1, [pc, #80]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c7f2:	68e0      	ldr	r0, [r4, #12]
 800c7f4:	698a      	ldr	r2, [r1, #24]
 800c7f6:	f002 020f 	and.w	r2, r2, #15
 800c7fa:	4290      	cmp	r0, r2
 800c7fc:	f4bf af57 	bcs.w	800c6ae <HAL_RCC_ClockConfig+0xa2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800c800:	698a      	ldr	r2, [r1, #24]
 800c802:	f022 020f 	bic.w	r2, r2, #15
 800c806:	4302      	orrs	r2, r0
 800c808:	618a      	str	r2, [r1, #24]
 800c80a:	e750      	b.n	800c6ae <HAL_RCC_ClockConfig+0xa2>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800c80c:	680a      	ldr	r2, [r1, #0]
 800c80e:	f022 020f 	bic.w	r2, r2, #15
 800c812:	432a      	orrs	r2, r5
 800c814:	600a      	str	r2, [r1, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800c816:	680a      	ldr	r2, [r1, #0]
 800c818:	f002 020f 	and.w	r2, r2, #15
 800c81c:	42aa      	cmp	r2, r5
 800c81e:	f47f aefa 	bne.w	800c616 <HAL_RCC_ClockConfig+0xa>
 800c822:	e74b      	b.n	800c6bc <HAL_RCC_ClockConfig+0xb0>
    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800c824:	4907      	ldr	r1, [pc, #28]	@ (800c844 <HAL_RCC_ClockConfig+0x238>)
 800c826:	6920      	ldr	r0, [r4, #16]
 800c828:	698a      	ldr	r2, [r1, #24]
 800c82a:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c82e:	4290      	cmp	r0, r2
 800c830:	f4bf af47 	bcs.w	800c6c2 <HAL_RCC_ClockConfig+0xb6>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800c834:	698a      	ldr	r2, [r1, #24]
 800c836:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c83a:	4302      	orrs	r2, r0
 800c83c:	618a      	str	r2, [r1, #24]
 800c83e:	e740      	b.n	800c6c2 <HAL_RCC_ClockConfig+0xb6>
 800c840:	52002000 	.word	0x52002000
 800c844:	58024400 	.word	0x58024400
 800c848:	0800e516 	.word	0x0800e516
 800c84c:	2000111c 	.word	0x2000111c
 800c850:	20001120 	.word	0x20001120
 800c854:	20001128 	.word	0x20001128

0800c858 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800c858:	b508      	push	{r3, lr}
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800c85a:	f7ff fe35 	bl	800c4c8 <HAL_RCC_GetSysClockFreq>
 800c85e:	4a0b      	ldr	r2, [pc, #44]	@ (800c88c <HAL_RCC_GetHCLKFreq+0x34>)
 800c860:	490b      	ldr	r1, [pc, #44]	@ (800c890 <HAL_RCC_GetHCLKFreq+0x38>)
 800c862:	6993      	ldr	r3, [r2, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c864:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800c866:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c86a:	f002 020f 	and.w	r2, r2, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800c86e:	5ccb      	ldrb	r3, [r1, r3]
 800c870:	f003 031f 	and.w	r3, r3, #31
 800c874:	fa20 f303 	lsr.w	r3, r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c878:	5c88      	ldrb	r0, [r1, r2]
 800c87a:	4a06      	ldr	r2, [pc, #24]	@ (800c894 <HAL_RCC_GetHCLKFreq+0x3c>)
 800c87c:	f000 001f 	and.w	r0, r0, #31
 800c880:	fa23 f000 	lsr.w	r0, r3, r0
 800c884:	6010      	str	r0, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800c886:	4a04      	ldr	r2, [pc, #16]	@ (800c898 <HAL_RCC_GetHCLKFreq+0x40>)
 800c888:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 800c88a:	bd08      	pop	{r3, pc}
 800c88c:	58024400 	.word	0x58024400
 800c890:	0800e516 	.word	0x0800e516
 800c894:	2000111c 	.word	0x2000111c
 800c898:	20001120 	.word	0x20001120

0800c89c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800c89c:	b508      	push	{r3, lr}
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 800c89e:	f7ff ffdb 	bl	800c858 <HAL_RCC_GetHCLKFreq>
 800c8a2:	4b05      	ldr	r3, [pc, #20]	@ (800c8b8 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800c8a4:	4a05      	ldr	r2, [pc, #20]	@ (800c8bc <HAL_RCC_GetPCLK1Freq+0x20>)
 800c8a6:	69db      	ldr	r3, [r3, #28]
 800c8a8:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800c8ac:	5cd3      	ldrb	r3, [r2, r3]
 800c8ae:	f003 031f 	and.w	r3, r3, #31
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 800c8b2:	40d8      	lsrs	r0, r3
 800c8b4:	bd08      	pop	{r3, pc}
 800c8b6:	bf00      	nop
 800c8b8:	58024400 	.word	0x58024400
 800c8bc:	0800e516 	.word	0x0800e516

0800c8c0 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800c8c0:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 800c8c2:	f7ff ffc9 	bl	800c858 <HAL_RCC_GetHCLKFreq>
 800c8c6:	4b05      	ldr	r3, [pc, #20]	@ (800c8dc <HAL_RCC_GetPCLK2Freq+0x1c>)
 800c8c8:	4a05      	ldr	r2, [pc, #20]	@ (800c8e0 <HAL_RCC_GetPCLK2Freq+0x20>)
 800c8ca:	69db      	ldr	r3, [r3, #28]
 800c8cc:	f3c3 2302 	ubfx	r3, r3, #8, #3
 800c8d0:	5cd3      	ldrb	r3, [r2, r3]
 800c8d2:	f003 031f 	and.w	r3, r3, #31
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 800c8d6:	40d8      	lsrs	r0, r3
 800c8d8:	bd08      	pop	{r3, pc}
 800c8da:	bf00      	nop
 800c8dc:	58024400 	.word	0x58024400
 800c8e0:	0800e516 	.word	0x0800e516

0800c8e4 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 800c8e4:	b508      	push	{r3, lr}
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 800c8e6:	f7ff ffb7 	bl	800c858 <HAL_RCC_GetHCLKFreq>
 800c8ea:	4b05      	ldr	r3, [pc, #20]	@ (800c900 <HAL_RCCEx_GetD3PCLK1Freq+0x1c>)
 800c8ec:	4a05      	ldr	r2, [pc, #20]	@ (800c904 <HAL_RCCEx_GetD3PCLK1Freq+0x20>)
 800c8ee:	6a1b      	ldr	r3, [r3, #32]
 800c8f0:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800c8f4:	5cd3      	ldrb	r3, [r2, r3]
 800c8f6:	f003 031f 	and.w	r3, r3, #31
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 800c8fa:	40d8      	lsrs	r0, r3
 800c8fc:	bd08      	pop	{r3, pc}
 800c8fe:	bf00      	nop
 800c900:	58024400 	.word	0x58024400
 800c904:	0800e516 	.word	0x0800e516

0800c908 <HAL_RCCEx_GetPLL2ClockFreq>:
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c908:	494f      	ldr	r1, [pc, #316]	@ (800ca48 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
{
 800c90a:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c90c:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 800c90e:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800c910:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));

  if (pll2m != 0U)
 800c912:	f416 3f7c 	tst.w	r6, #258048	@ 0x3f000
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 800c916:	f3c6 3305 	ubfx	r3, r6, #12, #6
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c91a:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
  if (pll2m != 0U)
 800c91c:	f000 8090 	beq.w	800ca40 <HAL_RCCEx_GetPLL2ClockFreq+0x138>
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c920:	ee07 3a90 	vmov	s15, r3
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c924:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800c928:	f3c5 1200 	ubfx	r2, r5, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c92c:	f004 0403 	and.w	r4, r4, #3
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c930:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c934:	4353      	muls	r3, r2
    switch (pllsource)
 800c936:	2c01      	cmp	r4, #1
 800c938:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c93c:	ee06 3a90 	vmov	s13, r3
 800c940:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
 800c944:	d06e      	beq.n	800ca24 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>
 800c946:	2c02      	cmp	r4, #2
 800c948:	d05e      	beq.n	800ca08 <HAL_RCCEx_GetPLL2ClockFreq+0x100>
 800c94a:	2c00      	cmp	r4, #0
 800c94c:	d16a      	bne.n	800ca24 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c94e:	680b      	ldr	r3, [r1, #0]
 800c950:	069b      	lsls	r3, r3, #26
 800c952:	d547      	bpl.n	800c9e4 <HAL_RCCEx_GetPLL2ClockFreq+0xdc>
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c954:	680a      	ldr	r2, [r1, #0]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c956:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c958:	f3c2 01c1 	ubfx	r1, r2, #3, #2
 800c95c:	4a3b      	ldr	r2, [pc, #236]	@ (800ca4c <HAL_RCCEx_GetPLL2ClockFreq+0x144>)
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c95e:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c962:	40ca      	lsrs	r2, r1
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c964:	ee07 2a90 	vmov	s15, r2
 800c968:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 800c96c:	eec5 7a87 	vdiv.f32	s15, s11, s14
 800c970:	ee07 3a10 	vmov	s14, r3
 800c974:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c978:	ee37 7a26 	vadd.f32	s14, s14, s13
 800c97c:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c980:	ee67 7a87 	vmul.f32	s15, s15, s14

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        break;
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 800c984:	4a30      	ldr	r2, [pc, #192]	@ (800ca48 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
 800c986:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800c988:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800c98c:	ee07 3a10 	vmov	s14, r3
 800c990:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c994:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c998:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800c99c:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800c9a0:	edc0 6a00 	vstr	s13, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 800c9a4:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800c9a6:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800c9aa:	ee07 3a10 	vmov	s14, r3
 800c9ae:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c9b2:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c9b6:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800c9ba:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800c9be:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 800c9c2:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800c9c4:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800c9c8:	ee06 3a90 	vmov	s13, r3
 800c9cc:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800c9d0:	ee76 6a86 	vadd.f32	s13, s13, s12
 800c9d4:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800c9d8:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800c9dc:	ee17 3a90 	vmov	r3, s15
 800c9e0:	6083      	str	r3, [r0, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 800c9e2:	bd70      	pop	{r4, r5, r6, pc}
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c9e4:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 800c9e6:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 800ca50 <HAL_RCCEx_GetPLL2ClockFreq+0x148>
 800c9ea:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c9ee:	ee07 3a90 	vmov	s15, r3
 800c9f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c9f6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c9fa:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c9fe:	eec5 6a87 	vdiv.f32	s13, s11, s14
 800ca02:	ee67 7aa6 	vmul.f32	s15, s15, s13
        break;
 800ca06:	e7bd      	b.n	800c984 <HAL_RCCEx_GetPLL2ClockFreq+0x7c>
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800ca08:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 800ca0a:	eddf 5a12 	vldr	s11, [pc, #72]	@ 800ca54 <HAL_RCCEx_GetPLL2ClockFreq+0x14c>
 800ca0e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ca12:	ee07 3a90 	vmov	s15, r3
 800ca16:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ca1a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800ca1e:	ee77 7a86 	vadd.f32	s15, s15, s12
 800ca22:	e7ec      	b.n	800c9fe <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800ca24:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 800ca26:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 800ca58 <HAL_RCCEx_GetPLL2ClockFreq+0x150>
 800ca2a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ca2e:	ee07 3a90 	vmov	s15, r3
 800ca32:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ca36:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800ca3a:	ee77 7a86 	vadd.f32	s15, s15, s12
 800ca3e:	e7de      	b.n	800c9fe <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800ca40:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 800ca44:	e7cc      	b.n	800c9e0 <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
 800ca46:	bf00      	nop
 800ca48:	58024400 	.word	0x58024400
 800ca4c:	03d09000 	.word	0x03d09000
 800ca50:	4c742400 	.word	0x4c742400
 800ca54:	4af42400 	.word	0x4af42400
 800ca58:	4a742400 	.word	0x4a742400

0800ca5c <HAL_RCCEx_GetPLL3ClockFreq>:
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800ca5c:	494f      	ldr	r1, [pc, #316]	@ (800cb9c <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
{
 800ca5e:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800ca60:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 800ca62:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800ca64:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));

  if (pll3m != 0U)
 800ca66:	f016 7f7c 	tst.w	r6, #66060288	@ 0x3f00000
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 800ca6a:	f3c6 5305 	ubfx	r3, r6, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800ca6e:	6c4a      	ldr	r2, [r1, #68]	@ 0x44
  if (pll3m != 0U)
 800ca70:	f000 8090 	beq.w	800cb94 <HAL_RCCEx_GetPLL3ClockFreq+0x138>
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca74:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800ca78:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800ca7c:	f3c5 2200 	ubfx	r2, r5, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800ca80:	f004 0403 	and.w	r4, r4, #3
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca84:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800ca88:	4353      	muls	r3, r2
    switch (pllsource)
 800ca8a:	2c01      	cmp	r4, #1
 800ca8c:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca90:	ee06 3a90 	vmov	s13, r3
 800ca94:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
 800ca98:	d06e      	beq.n	800cb78 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>
 800ca9a:	2c02      	cmp	r4, #2
 800ca9c:	d05e      	beq.n	800cb5c <HAL_RCCEx_GetPLL3ClockFreq+0x100>
 800ca9e:	2c00      	cmp	r4, #0
 800caa0:	d16a      	bne.n	800cb78 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800caa2:	680b      	ldr	r3, [r1, #0]
 800caa4:	069b      	lsls	r3, r3, #26
 800caa6:	d547      	bpl.n	800cb38 <HAL_RCCEx_GetPLL3ClockFreq+0xdc>
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800caa8:	680a      	ldr	r2, [r1, #0]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800caaa:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800caac:	f3c2 01c1 	ubfx	r1, r2, #3, #2
 800cab0:	4a3b      	ldr	r2, [pc, #236]	@ (800cba0 <HAL_RCCEx_GetPLL3ClockFreq+0x144>)
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800cab2:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800cab6:	40ca      	lsrs	r2, r1
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800cab8:	ee07 2a90 	vmov	s15, r2
 800cabc:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 800cac0:	eec5 7a87 	vdiv.f32	s15, s11, s14
 800cac4:	ee07 3a10 	vmov	s14, r3
 800cac8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800cacc:	ee37 7a26 	vadd.f32	s14, s14, s13
 800cad0:	ee37 7a06 	vadd.f32	s14, s14, s12
 800cad4:	ee67 7a87 	vmul.f32	s15, s15, s14

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        break;
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 800cad8:	4a30      	ldr	r2, [pc, #192]	@ (800cb9c <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
 800cada:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800cadc:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800cae0:	ee07 3a10 	vmov	s14, r3
 800cae4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800cae8:	ee37 7a06 	vadd.f32	s14, s14, s12
 800caec:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800caf0:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800caf4:	edc0 6a00 	vstr	s13, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 800caf8:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800cafa:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800cafe:	ee07 3a10 	vmov	s14, r3
 800cb02:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800cb06:	ee37 7a06 	vadd.f32	s14, s14, s12
 800cb0a:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800cb0e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800cb12:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 800cb16:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800cb18:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800cb1c:	ee06 3a90 	vmov	s13, r3
 800cb20:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800cb24:	ee76 6a86 	vadd.f32	s13, s13, s12
 800cb28:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800cb2c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800cb30:	ee17 3a90 	vmov	r3, s15
 800cb34:	6083      	str	r3, [r0, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 800cb36:	bd70      	pop	{r4, r5, r6, pc}
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800cb38:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800cb3a:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 800cba4 <HAL_RCCEx_GetPLL3ClockFreq+0x148>
 800cb3e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cb42:	ee07 3a90 	vmov	s15, r3
 800cb46:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800cb4a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cb4e:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800cb52:	eec5 6a87 	vdiv.f32	s13, s11, s14
 800cb56:	ee67 7aa6 	vmul.f32	s15, s15, s13
        break;
 800cb5a:	e7bd      	b.n	800cad8 <HAL_RCCEx_GetPLL3ClockFreq+0x7c>
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800cb5c:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800cb5e:	eddf 5a12 	vldr	s11, [pc, #72]	@ 800cba8 <HAL_RCCEx_GetPLL3ClockFreq+0x14c>
 800cb62:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cb66:	ee07 3a90 	vmov	s15, r3
 800cb6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800cb6e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cb72:	ee77 7a86 	vadd.f32	s15, s15, s12
 800cb76:	e7ec      	b.n	800cb52 <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800cb78:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800cb7a:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 800cbac <HAL_RCCEx_GetPLL3ClockFreq+0x150>
 800cb7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cb82:	ee07 3a90 	vmov	s15, r3
 800cb86:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800cb8a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cb8e:	ee77 7a86 	vadd.f32	s15, s15, s12
 800cb92:	e7de      	b.n	800cb52 <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800cb94:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800cb98:	e7cc      	b.n	800cb34 <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
 800cb9a:	bf00      	nop
 800cb9c:	58024400 	.word	0x58024400
 800cba0:	03d09000 	.word	0x03d09000
 800cba4:	4c742400 	.word	0x4c742400
 800cba8:	4af42400 	.word	0x4af42400
 800cbac:	4a742400 	.word	0x4a742400

0800cbb0 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800cbb0:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800cbb2:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800cbb4:	e852 3f00 	ldrex	r3, [r2]
 800cbb8:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800cbbc:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 800cbc0:	6802      	ldr	r2, [r0, #0]
 800cbc2:	2900      	cmp	r1, #0
 800cbc4:	d1f5      	bne.n	800cbb2 <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800cbc6:	4c0f      	ldr	r4, [pc, #60]	@ (800cc04 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800cbc8:	f102 0308 	add.w	r3, r2, #8
 800cbcc:	e853 3f00 	ldrex	r3, [r3]
 800cbd0:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800cbd2:	f102 0c08 	add.w	ip, r2, #8
 800cbd6:	e84c 3100 	strex	r1, r3, [ip]
 800cbda:	2900      	cmp	r1, #0
 800cbdc:	d1f4      	bne.n	800cbc8 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800cbde:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 800cbe0:	2b01      	cmp	r3, #1
 800cbe2:	d107      	bne.n	800cbf4 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800cbe4:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800cbe8:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800cbec:	e842 3100 	strex	r1, r3, [r2]
 800cbf0:	2900      	cmp	r1, #0
 800cbf2:	d1f7      	bne.n	800cbe4 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800cbf4:	2320      	movs	r3, #32
 800cbf6:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800cbfa:	2300      	movs	r3, #0
 800cbfc:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800cbfe:	6743      	str	r3, [r0, #116]	@ 0x74
}
 800cc00:	bd10      	pop	{r4, pc}
 800cc02:	bf00      	nop
 800cc04:	effffffe 	.word	0xeffffffe

0800cc08 <UART_SetConfig>:
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cc08:	6802      	ldr	r2, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cc0a:	69c3      	ldr	r3, [r0, #28]
 800cc0c:	6881      	ldr	r1, [r0, #8]
{
 800cc0e:	b530      	push	{r4, r5, lr}
 800cc10:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cc12:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cc14:	6815      	ldr	r5, [r2, #0]
{
 800cc16:	b087      	sub	sp, #28
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cc18:	4301      	orrs	r1, r0
 800cc1a:	6960      	ldr	r0, [r4, #20]
 800cc1c:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cc1e:	48a5      	ldr	r0, [pc, #660]	@ (800ceb4 <UART_SetConfig+0x2ac>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cc20:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cc22:	4028      	ands	r0, r5
 800cc24:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cc26:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cc28:	6011      	str	r1, [r2, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cc2a:	6851      	ldr	r1, [r2, #4]
 800cc2c:	f421 5140 	bic.w	r1, r1, #12288	@ 0x3000
 800cc30:	4301      	orrs	r1, r0
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800cc32:	69a0      	ldr	r0, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cc34:	6051      	str	r1, [r2, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800cc36:	49a0      	ldr	r1, [pc, #640]	@ (800ceb8 <UART_SetConfig+0x2b0>)
 800cc38:	428a      	cmp	r2, r1
    tmpreg |= huart->Init.OneBitSampling;
 800cc3a:	bf1c      	itt	ne
 800cc3c:	6a21      	ldrne	r1, [r4, #32]
 800cc3e:	4308      	orrne	r0, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800cc40:	6891      	ldr	r1, [r2, #8]
 800cc42:	f021 416e 	bic.w	r1, r1, #3992977408	@ 0xee000000
 800cc46:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 800cc4a:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800cc4c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800cc4e:	6091      	str	r1, [r2, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800cc50:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
 800cc52:	f021 010f 	bic.w	r1, r1, #15
 800cc56:	4301      	orrs	r1, r0
 800cc58:	62d1      	str	r1, [r2, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 800cc5a:	4998      	ldr	r1, [pc, #608]	@ (800cebc <UART_SetConfig+0x2b4>)
 800cc5c:	428a      	cmp	r2, r1
 800cc5e:	d112      	bne.n	800cc86 <UART_SetConfig+0x7e>
 800cc60:	4a97      	ldr	r2, [pc, #604]	@ (800cec0 <UART_SetConfig+0x2b8>)
 800cc62:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 800cc64:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 800cc68:	2a18      	cmp	r2, #24
 800cc6a:	f000 8101 	beq.w	800ce70 <UART_SetConfig+0x268>
 800cc6e:	d83b      	bhi.n	800cce8 <UART_SetConfig+0xe0>
 800cc70:	2a08      	cmp	r2, #8
 800cc72:	f000 80f5 	beq.w	800ce60 <UART_SetConfig+0x258>
 800cc76:	2a10      	cmp	r2, #16
 800cc78:	f000 813a 	beq.w	800cef0 <UART_SetConfig+0x2e8>
 800cc7c:	2a00      	cmp	r2, #0
 800cc7e:	f000 80e9 	beq.w	800ce54 <UART_SetConfig+0x24c>
        ret = HAL_ERROR;
 800cc82:	2001      	movs	r0, #1
 800cc84:	e06a      	b.n	800cd5c <UART_SetConfig+0x154>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800cc86:	498f      	ldr	r1, [pc, #572]	@ (800cec4 <UART_SetConfig+0x2bc>)
 800cc88:	428a      	cmp	r2, r1
 800cc8a:	d10d      	bne.n	800cca8 <UART_SetConfig+0xa0>
 800cc8c:	4a8c      	ldr	r2, [pc, #560]	@ (800cec0 <UART_SetConfig+0x2b8>)
 800cc8e:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 800cc90:	f002 0207 	and.w	r2, r2, #7
 800cc94:	2a05      	cmp	r2, #5
 800cc96:	d8f4      	bhi.n	800cc82 <UART_SetConfig+0x7a>
 800cc98:	e8df f012 	tbh	[pc, r2, lsl #1]
 800cc9c:	00e2007e 	.word	0x00e2007e
 800cca0:	00ea012a 	.word	0x00ea012a
 800cca4:	002b0107 	.word	0x002b0107
 800cca8:	4987      	ldr	r1, [pc, #540]	@ (800cec8 <UART_SetConfig+0x2c0>)
 800ccaa:	428a      	cmp	r2, r1
 800ccac:	d0ee      	beq.n	800cc8c <UART_SetConfig+0x84>
 800ccae:	4987      	ldr	r1, [pc, #540]	@ (800cecc <UART_SetConfig+0x2c4>)
 800ccb0:	428a      	cmp	r2, r1
 800ccb2:	d0eb      	beq.n	800cc8c <UART_SetConfig+0x84>
 800ccb4:	4986      	ldr	r1, [pc, #536]	@ (800ced0 <UART_SetConfig+0x2c8>)
 800ccb6:	428a      	cmp	r2, r1
 800ccb8:	d0e8      	beq.n	800cc8c <UART_SetConfig+0x84>
 800ccba:	4986      	ldr	r1, [pc, #536]	@ (800ced4 <UART_SetConfig+0x2cc>)
 800ccbc:	428a      	cmp	r2, r1
 800ccbe:	d0cf      	beq.n	800cc60 <UART_SetConfig+0x58>
 800ccc0:	4985      	ldr	r1, [pc, #532]	@ (800ced8 <UART_SetConfig+0x2d0>)
 800ccc2:	428a      	cmp	r2, r1
 800ccc4:	d0e2      	beq.n	800cc8c <UART_SetConfig+0x84>
 800ccc6:	4985      	ldr	r1, [pc, #532]	@ (800cedc <UART_SetConfig+0x2d4>)
 800ccc8:	428a      	cmp	r2, r1
 800ccca:	d0df      	beq.n	800cc8c <UART_SetConfig+0x84>
 800cccc:	4b7a      	ldr	r3, [pc, #488]	@ (800ceb8 <UART_SetConfig+0x2b0>)
 800ccce:	429a      	cmp	r2, r3
 800ccd0:	d1d7      	bne.n	800cc82 <UART_SetConfig+0x7a>
 800ccd2:	4a7b      	ldr	r2, [pc, #492]	@ (800cec0 <UART_SetConfig+0x2b8>)
 800ccd4:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 800ccd6:	f003 0307 	and.w	r3, r3, #7
 800ccda:	2b05      	cmp	r3, #5
 800ccdc:	d8d1      	bhi.n	800cc82 <UART_SetConfig+0x7a>
 800ccde:	e8df f003 	tbb	[pc, r3]
 800cce2:	4538      	.short	0x4538
 800cce4:	0f594f4a 	.word	0x0f594f4a
 800cce8:	2a20      	cmp	r2, #32
 800ccea:	f000 80de 	beq.w	800ceaa <UART_SetConfig+0x2a2>
 800ccee:	2a28      	cmp	r2, #40	@ 0x28
 800ccf0:	d1c7      	bne.n	800cc82 <UART_SetConfig+0x7a>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ccf2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ccf6:	f000 808a 	beq.w	800ce0e <UART_SetConfig+0x206>
 800ccfa:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 800ccfe:	e0c4      	b.n	800ce8a <UART_SetConfig+0x282>
        pclk = (uint32_t) LSE_VALUE;
 800cd00:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800cd04:	4b76      	ldr	r3, [pc, #472]	@ (800cee0 <UART_SetConfig+0x2d8>)
 800cd06:	6a62      	ldr	r2, [r4, #36]	@ 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800cd08:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800cd0a:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800cd0e:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800cd12:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800cd16:	4299      	cmp	r1, r3
 800cd18:	d8b3      	bhi.n	800cc82 <UART_SetConfig+0x7a>
 800cd1a:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 800cd1e:	d8b0      	bhi.n	800cc82 <UART_SetConfig+0x7a>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800cd20:	2300      	movs	r3, #0
 800cd22:	4619      	mov	r1, r3
 800cd24:	f7fb fee4 	bl	8008af0 <__aeabi_uldivmod>
 800cd28:	462a      	mov	r2, r5
 800cd2a:	0209      	lsls	r1, r1, #8
 800cd2c:	086b      	lsrs	r3, r5, #1
 800cd2e:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 800cd32:	0200      	lsls	r0, r0, #8
 800cd34:	18c0      	adds	r0, r0, r3
 800cd36:	f04f 0300 	mov.w	r3, #0
 800cd3a:	f141 0100 	adc.w	r1, r1, #0
 800cd3e:	f7fb fed7 	bl	8008af0 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800cd42:	4b68      	ldr	r3, [pc, #416]	@ (800cee4 <UART_SetConfig+0x2dc>)
 800cd44:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800cd48:	429a      	cmp	r2, r3
 800cd4a:	d89a      	bhi.n	800cc82 <UART_SetConfig+0x7a>
        huart->Instance->BRR = (uint16_t)usartdiv;
 800cd4c:	6823      	ldr	r3, [r4, #0]
 800cd4e:	60d8      	str	r0, [r3, #12]
 800cd50:	e003      	b.n	800cd5a <UART_SetConfig+0x152>
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 800cd52:	f7ff fdc7 	bl	800c8e4 <HAL_RCCEx_GetD3PCLK1Freq>
    if (pclk != 0U)
 800cd56:	2800      	cmp	r0, #0
 800cd58:	d1d4      	bne.n	800cd04 <UART_SetConfig+0xfc>
          pclk = (uint32_t) HSI_VALUE;
 800cd5a:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 800cd5c:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
 800cd60:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 800cd62:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 800cd64:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
 800cd68:	b007      	add	sp, #28
 800cd6a:	bd30      	pop	{r4, r5, pc}
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800cd6c:	4668      	mov	r0, sp
 800cd6e:	f7ff fdcb 	bl	800c908 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800cd72:	9801      	ldr	r0, [sp, #4]
        break;
 800cd74:	e7ef      	b.n	800cd56 <UART_SetConfig+0x14e>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800cd76:	a803      	add	r0, sp, #12
 800cd78:	f7ff fe70 	bl	800ca5c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800cd7c:	9804      	ldr	r0, [sp, #16]
        break;
 800cd7e:	e7ea      	b.n	800cd56 <UART_SetConfig+0x14e>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cd80:	6813      	ldr	r3, [r2, #0]
 800cd82:	4859      	ldr	r0, [pc, #356]	@ (800cee8 <UART_SetConfig+0x2e0>)
 800cd84:	f013 0f20 	tst.w	r3, #32
 800cd88:	d0bc      	beq.n	800cd04 <UART_SetConfig+0xfc>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800cd8a:	6813      	ldr	r3, [r2, #0]
 800cd8c:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800cd90:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 800cd92:	e7b7      	b.n	800cd04 <UART_SetConfig+0xfc>
        pclk = (uint32_t) CSI_VALUE;
 800cd94:	4855      	ldr	r0, [pc, #340]	@ (800ceec <UART_SetConfig+0x2e4>)
 800cd96:	e7b5      	b.n	800cd04 <UART_SetConfig+0xfc>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cd98:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cd9c:	d155      	bne.n	800ce4a <UART_SetConfig+0x242>
 800cd9e:	2300      	movs	r3, #0
    switch (clocksource)
 800cda0:	2b08      	cmp	r3, #8
 800cda2:	f63f af6e 	bhi.w	800cc82 <UART_SetConfig+0x7a>
 800cda6:	a201      	add	r2, pc, #4	@ (adr r2, 800cdac <UART_SetConfig+0x1a4>)
 800cda8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800cdac:	0800cdd9 	.word	0x0800cdd9
 800cdb0:	0800cde5 	.word	0x0800cde5
 800cdb4:	0800cc83 	.word	0x0800cc83
 800cdb8:	0800cc83 	.word	0x0800cc83
 800cdbc:	0800cdeb 	.word	0x0800cdeb
 800cdc0:	0800cc83 	.word	0x0800cc83
 800cdc4:	0800cc83 	.word	0x0800cc83
 800cdc8:	0800cc83 	.word	0x0800cc83
 800cdcc:	0800cdf5 	.word	0x0800cdf5
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cdd0:	2304      	movs	r3, #4
 800cdd2:	e7e5      	b.n	800cda0 <UART_SetConfig+0x198>
 800cdd4:	2308      	movs	r3, #8
 800cdd6:	e7e3      	b.n	800cda0 <UART_SetConfig+0x198>
        pclk = HAL_RCC_GetPCLK1Freq();
 800cdd8:	f7ff fd60 	bl	800c89c <HAL_RCC_GetPCLK1Freq>
        pclk = HAL_RCC_GetPCLK2Freq();
 800cddc:	4603      	mov	r3, r0
    if (pclk != 0U)
 800cdde:	2b00      	cmp	r3, #0
 800cde0:	d0bb      	beq.n	800cd5a <UART_SetConfig+0x152>
 800cde2:	e014      	b.n	800ce0e <UART_SetConfig+0x206>
        pclk = HAL_RCC_GetPCLK2Freq();
 800cde4:	f7ff fd6c 	bl	800c8c0 <HAL_RCC_GetPCLK2Freq>
 800cde8:	e7f8      	b.n	800cddc <UART_SetConfig+0x1d4>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800cdea:	4668      	mov	r0, sp
 800cdec:	f7ff fd8c 	bl	800c908 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800cdf0:	9b01      	ldr	r3, [sp, #4]
        break;
 800cdf2:	e7f4      	b.n	800cdde <UART_SetConfig+0x1d6>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800cdf4:	a803      	add	r0, sp, #12
 800cdf6:	f7ff fe31 	bl	800ca5c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800cdfa:	9b04      	ldr	r3, [sp, #16]
        break;
 800cdfc:	e7ef      	b.n	800cdde <UART_SetConfig+0x1d6>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cdfe:	f013 0f20 	tst.w	r3, #32
 800ce02:	4b39      	ldr	r3, [pc, #228]	@ (800cee8 <UART_SetConfig+0x2e0>)
 800ce04:	d003      	beq.n	800ce0e <UART_SetConfig+0x206>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800ce06:	6812      	ldr	r2, [r2, #0]
 800ce08:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 800ce0c:	40d3      	lsrs	r3, r2
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800ce0e:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 800ce10:	4a33      	ldr	r2, [pc, #204]	@ (800cee0 <UART_SetConfig+0x2d8>)
 800ce12:	6861      	ldr	r1, [r4, #4]
 800ce14:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 800ce18:	fbb3 f3f2 	udiv	r3, r3, r2
 800ce1c:	084a      	lsrs	r2, r1, #1
 800ce1e:	eb02 0343 	add.w	r3, r2, r3, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800ce22:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800ce26:	fbb3 f3f1 	udiv	r3, r3, r1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800ce2a:	f1a3 0110 	sub.w	r1, r3, #16
 800ce2e:	4291      	cmp	r1, r2
 800ce30:	f63f af27 	bhi.w	800cc82 <UART_SetConfig+0x7a>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800ce34:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800ce38:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 800ce3c:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800ce3e:	b292      	uxth	r2, r2
        huart->Instance->BRR = brrtemp;
 800ce40:	4313      	orrs	r3, r2
 800ce42:	60cb      	str	r3, [r1, #12]
 800ce44:	e789      	b.n	800cd5a <UART_SetConfig+0x152>
        pclk = (uint32_t) CSI_VALUE;
 800ce46:	4b29      	ldr	r3, [pc, #164]	@ (800ceec <UART_SetConfig+0x2e4>)
 800ce48:	e7e1      	b.n	800ce0e <UART_SetConfig+0x206>
        pclk = HAL_RCC_GetPCLK1Freq();
 800ce4a:	f7ff fd27 	bl	800c89c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800ce4e:	2800      	cmp	r0, #0
 800ce50:	d083      	beq.n	800cd5a <UART_SetConfig+0x152>
 800ce52:	e01a      	b.n	800ce8a <UART_SetConfig+0x282>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ce54:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ce58:	d0c4      	beq.n	800cde4 <UART_SetConfig+0x1dc>
        pclk = HAL_RCC_GetPCLK2Freq();
 800ce5a:	f7ff fd31 	bl	800c8c0 <HAL_RCC_GetPCLK2Freq>
        break;
 800ce5e:	e7f6      	b.n	800ce4e <UART_SetConfig+0x246>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ce60:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ce64:	d0b4      	beq.n	800cdd0 <UART_SetConfig+0x1c8>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800ce66:	4668      	mov	r0, sp
 800ce68:	f7ff fd4e 	bl	800c908 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800ce6c:	9801      	ldr	r0, [sp, #4]
        break;
 800ce6e:	e7ee      	b.n	800ce4e <UART_SetConfig+0x246>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ce70:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ce74:	4a12      	ldr	r2, [pc, #72]	@ (800cec0 <UART_SetConfig+0x2b8>)
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800ce76:	6813      	ldr	r3, [r2, #0]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ce78:	d0c1      	beq.n	800cdfe <UART_SetConfig+0x1f6>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800ce7a:	f013 0f20 	tst.w	r3, #32
 800ce7e:	481a      	ldr	r0, [pc, #104]	@ (800cee8 <UART_SetConfig+0x2e0>)
 800ce80:	d003      	beq.n	800ce8a <UART_SetConfig+0x282>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800ce82:	6813      	ldr	r3, [r2, #0]
 800ce84:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800ce88:	40d8      	lsrs	r0, r3
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800ce8a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800ce8c:	4a14      	ldr	r2, [pc, #80]	@ (800cee0 <UART_SetConfig+0x2d8>)
 800ce8e:	6863      	ldr	r3, [r4, #4]
 800ce90:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 800ce94:	fbb0 f0f2 	udiv	r0, r0, r2
 800ce98:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800ce9c:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800cea0:	f64f 73ef 	movw	r3, #65519	@ 0xffef
 800cea4:	f1a0 0210 	sub.w	r2, r0, #16
 800cea8:	e74e      	b.n	800cd48 <UART_SetConfig+0x140>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ceaa:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ceae:	d0ca      	beq.n	800ce46 <UART_SetConfig+0x23e>
        pclk = (uint32_t) CSI_VALUE;
 800ceb0:	480e      	ldr	r0, [pc, #56]	@ (800ceec <UART_SetConfig+0x2e4>)
 800ceb2:	e7ea      	b.n	800ce8a <UART_SetConfig+0x282>
 800ceb4:	cfff69f3 	.word	0xcfff69f3
 800ceb8:	58000c00 	.word	0x58000c00
 800cebc:	40011000 	.word	0x40011000
 800cec0:	58024400 	.word	0x58024400
 800cec4:	40004400 	.word	0x40004400
 800cec8:	40004800 	.word	0x40004800
 800cecc:	40004c00 	.word	0x40004c00
 800ced0:	40005000 	.word	0x40005000
 800ced4:	40011400 	.word	0x40011400
 800ced8:	40007800 	.word	0x40007800
 800cedc:	40007c00 	.word	0x40007c00
 800cee0:	0800e526 	.word	0x0800e526
 800cee4:	000ffcff 	.word	0x000ffcff
 800cee8:	03d09000 	.word	0x03d09000
 800ceec:	003d0900 	.word	0x003d0900
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cef0:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cef4:	f43f af6e 	beq.w	800cdd4 <UART_SetConfig+0x1cc>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800cef8:	a803      	add	r0, sp, #12
 800cefa:	f7ff fdaf 	bl	800ca5c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800cefe:	9804      	ldr	r0, [sp, #16]
        break;
 800cf00:	e7a5      	b.n	800ce4e <UART_SetConfig+0x246>
 800cf02:	bf00      	nop

0800cf04 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800cf04:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800cf06:	071a      	lsls	r2, r3, #28
{
 800cf08:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800cf0a:	d506      	bpl.n	800cf1a <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800cf0c:	6801      	ldr	r1, [r0, #0]
 800cf0e:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 800cf10:	684a      	ldr	r2, [r1, #4]
 800cf12:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800cf16:	4322      	orrs	r2, r4
 800cf18:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800cf1a:	07dc      	lsls	r4, r3, #31
 800cf1c:	d506      	bpl.n	800cf2c <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800cf1e:	6801      	ldr	r1, [r0, #0]
 800cf20:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 800cf22:	684a      	ldr	r2, [r1, #4]
 800cf24:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 800cf28:	4322      	orrs	r2, r4
 800cf2a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800cf2c:	0799      	lsls	r1, r3, #30
 800cf2e:	d506      	bpl.n	800cf3e <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800cf30:	6801      	ldr	r1, [r0, #0]
 800cf32:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 800cf34:	684a      	ldr	r2, [r1, #4]
 800cf36:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 800cf3a:	4322      	orrs	r2, r4
 800cf3c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800cf3e:	075a      	lsls	r2, r3, #29
 800cf40:	d506      	bpl.n	800cf50 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800cf42:	6801      	ldr	r1, [r0, #0]
 800cf44:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 800cf46:	684a      	ldr	r2, [r1, #4]
 800cf48:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800cf4c:	4322      	orrs	r2, r4
 800cf4e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800cf50:	06dc      	lsls	r4, r3, #27
 800cf52:	d506      	bpl.n	800cf62 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800cf54:	6801      	ldr	r1, [r0, #0]
 800cf56:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 800cf58:	688a      	ldr	r2, [r1, #8]
 800cf5a:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 800cf5e:	4322      	orrs	r2, r4
 800cf60:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800cf62:	0699      	lsls	r1, r3, #26
 800cf64:	d506      	bpl.n	800cf74 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800cf66:	6801      	ldr	r1, [r0, #0]
 800cf68:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 800cf6a:	688a      	ldr	r2, [r1, #8]
 800cf6c:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 800cf70:	4322      	orrs	r2, r4
 800cf72:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800cf74:	065a      	lsls	r2, r3, #25
 800cf76:	d510      	bpl.n	800cf9a <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800cf78:	6801      	ldr	r1, [r0, #0]
 800cf7a:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 800cf7c:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800cf7e:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800cf82:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 800cf86:	ea42 0204 	orr.w	r2, r2, r4
 800cf8a:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800cf8c:	d105      	bne.n	800cf9a <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800cf8e:	684a      	ldr	r2, [r1, #4]
 800cf90:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 800cf92:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 800cf96:	4322      	orrs	r2, r4
 800cf98:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800cf9a:	061b      	lsls	r3, r3, #24
 800cf9c:	d506      	bpl.n	800cfac <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800cf9e:	6802      	ldr	r2, [r0, #0]
 800cfa0:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 800cfa2:	6853      	ldr	r3, [r2, #4]
 800cfa4:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 800cfa8:	430b      	orrs	r3, r1
 800cfaa:	6053      	str	r3, [r2, #4]
}
 800cfac:	bd10      	pop	{r4, pc}

0800cfae <UART_WaitOnFlagUntilTimeout>:
{
 800cfae:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cfb2:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800cfb6:	4604      	mov	r4, r0
 800cfb8:	460d      	mov	r5, r1
 800cfba:	4617      	mov	r7, r2
 800cfbc:	4698      	mov	r8, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800cfbe:	6822      	ldr	r2, [r4, #0]
 800cfc0:	69d3      	ldr	r3, [r2, #28]
 800cfc2:	ea35 0303 	bics.w	r3, r5, r3
 800cfc6:	bf0c      	ite	eq
 800cfc8:	2301      	moveq	r3, #1
 800cfca:	2300      	movne	r3, #0
 800cfcc:	42bb      	cmp	r3, r7
 800cfce:	d001      	beq.n	800cfd4 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 800cfd0:	2000      	movs	r0, #0
 800cfd2:	e022      	b.n	800d01a <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
 800cfd4:	f1b9 3fff 	cmp.w	r9, #4294967295
 800cfd8:	d0f2      	beq.n	800cfc0 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800cfda:	f7fe f92b 	bl	800b234 <HAL_GetTick>
 800cfde:	eba0 0008 	sub.w	r0, r0, r8
 800cfe2:	4548      	cmp	r0, r9
 800cfe4:	d829      	bhi.n	800d03a <UART_WaitOnFlagUntilTimeout+0x8c>
 800cfe6:	f1b9 0f00 	cmp.w	r9, #0
 800cfea:	d026      	beq.n	800d03a <UART_WaitOnFlagUntilTimeout+0x8c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 800cfec:	6821      	ldr	r1, [r4, #0]
 800cfee:	680b      	ldr	r3, [r1, #0]
 800cff0:	075a      	lsls	r2, r3, #29
 800cff2:	d5e4      	bpl.n	800cfbe <UART_WaitOnFlagUntilTimeout+0x10>
 800cff4:	2d80      	cmp	r5, #128	@ 0x80
 800cff6:	d0e2      	beq.n	800cfbe <UART_WaitOnFlagUntilTimeout+0x10>
 800cff8:	2d40      	cmp	r5, #64	@ 0x40
 800cffa:	d0e0      	beq.n	800cfbe <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 800cffc:	69ce      	ldr	r6, [r1, #28]
 800cffe:	f016 0608 	ands.w	r6, r6, #8
 800d002:	d00c      	beq.n	800d01e <UART_WaitOnFlagUntilTimeout+0x70>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800d004:	2508      	movs	r5, #8
          UART_EndRxTransfer(huart);
 800d006:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800d008:	620d      	str	r5, [r1, #32]
          UART_EndRxTransfer(huart);
 800d00a:	f7ff fdd1 	bl	800cbb0 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
 800d00e:	2300      	movs	r3, #0
          return HAL_ERROR;
 800d010:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 800d012:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
 800d016:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 800d01a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800d01e:	69cb      	ldr	r3, [r1, #28]
 800d020:	051b      	lsls	r3, r3, #20
 800d022:	d5cc      	bpl.n	800cfbe <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800d024:	f44f 6300 	mov.w	r3, #2048	@ 0x800
          UART_EndRxTransfer(huart);
 800d028:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800d02a:	620b      	str	r3, [r1, #32]
          UART_EndRxTransfer(huart);
 800d02c:	f7ff fdc0 	bl	800cbb0 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800d030:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
 800d032:	f884 6084 	strb.w	r6, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800d036:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
 800d03a:	2003      	movs	r0, #3
 800d03c:	e7ed      	b.n	800d01a <UART_WaitOnFlagUntilTimeout+0x6c>

0800d03e <HAL_UART_Transmit>:
{
 800d03e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800d042:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 800d044:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 800d048:	4604      	mov	r4, r0
 800d04a:	460e      	mov	r6, r1
  if (huart->gState == HAL_UART_STATE_READY)
 800d04c:	2b20      	cmp	r3, #32
{
 800d04e:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 800d050:	d146      	bne.n	800d0e0 <HAL_UART_Transmit+0xa2>
    if ((pData == NULL) || (Size == 0U))
 800d052:	2900      	cmp	r1, #0
 800d054:	d046      	beq.n	800d0e4 <HAL_UART_Transmit+0xa6>
 800d056:	2a00      	cmp	r2, #0
 800d058:	d044      	beq.n	800d0e4 <HAL_UART_Transmit+0xa6>
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800d05a:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d05c:	2500      	movs	r5, #0
 800d05e:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800d062:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
 800d066:	f7fe f8e5 	bl	800b234 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d06a:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 800d06c:	4681      	mov	r9, r0
    huart->TxXferSize  = Size;
 800d06e:	f8a4 7054 	strh.w	r7, [r4, #84]	@ 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d072:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
 800d076:	f8a4 7056 	strh.w	r7, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d07a:	d103      	bne.n	800d084 <HAL_UART_Transmit+0x46>
 800d07c:	6923      	ldr	r3, [r4, #16]
 800d07e:	b90b      	cbnz	r3, 800d084 <HAL_UART_Transmit+0x46>
      pdata16bits = (const uint16_t *) pData;
 800d080:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 800d082:	461e      	mov	r6, r3
    while (huart->TxXferCount > 0U)
 800d084:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800d088:	464b      	mov	r3, r9
 800d08a:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 800d08e:	b292      	uxth	r2, r2
 800d090:	b942      	cbnz	r2, 800d0a4 <HAL_UART_Transmit+0x66>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800d092:	2140      	movs	r1, #64	@ 0x40
 800d094:	4620      	mov	r0, r4
 800d096:	f7ff ff8a 	bl	800cfae <UART_WaitOnFlagUntilTimeout>
 800d09a:	2320      	movs	r3, #32
 800d09c:	b948      	cbnz	r0, 800d0b2 <HAL_UART_Transmit+0x74>
    huart->gState = HAL_UART_STATE_READY;
 800d09e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
 800d0a2:	e009      	b.n	800d0b8 <HAL_UART_Transmit+0x7a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800d0a4:	2200      	movs	r2, #0
 800d0a6:	2180      	movs	r1, #128	@ 0x80
 800d0a8:	4620      	mov	r0, r4
 800d0aa:	f7ff ff80 	bl	800cfae <UART_WaitOnFlagUntilTimeout>
 800d0ae:	b130      	cbz	r0, 800d0be <HAL_UART_Transmit+0x80>
        huart->gState = HAL_UART_STATE_READY;
 800d0b0:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 800d0b2:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 800d0b4:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
 800d0b8:	b003      	add	sp, #12
 800d0ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800d0be:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 800d0c0:	b95e      	cbnz	r6, 800d0da <HAL_UART_Transmit+0x9c>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800d0c2:	f835 3b02 	ldrh.w	r3, [r5], #2
 800d0c6:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800d0ca:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 800d0cc:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
 800d0d0:	3a01      	subs	r2, #1
 800d0d2:	b292      	uxth	r2, r2
 800d0d4:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
 800d0d8:	e7d4      	b.n	800d084 <HAL_UART_Transmit+0x46>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800d0da:	f816 3b01 	ldrb.w	r3, [r6], #1
 800d0de:	e7f4      	b.n	800d0ca <HAL_UART_Transmit+0x8c>
    return HAL_BUSY;
 800d0e0:	2002      	movs	r0, #2
 800d0e2:	e7e9      	b.n	800d0b8 <HAL_UART_Transmit+0x7a>
      return  HAL_ERROR;
 800d0e4:	2001      	movs	r0, #1
 800d0e6:	e7e7      	b.n	800d0b8 <HAL_UART_Transmit+0x7a>

0800d0e8 <HAL_UART_Receive>:
{
 800d0e8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800d0ec:	4698      	mov	r8, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 800d0ee:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
 800d0f2:	4604      	mov	r4, r0
 800d0f4:	460f      	mov	r7, r1
  if (huart->RxState == HAL_UART_STATE_READY)
 800d0f6:	2b20      	cmp	r3, #32
{
 800d0f8:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 800d0fa:	d15c      	bne.n	800d1b6 <HAL_UART_Receive+0xce>
    if ((pData == NULL) || (Size == 0U))
 800d0fc:	2900      	cmp	r1, #0
 800d0fe:	d05c      	beq.n	800d1ba <HAL_UART_Receive+0xd2>
 800d100:	2a00      	cmp	r2, #0
 800d102:	d05a      	beq.n	800d1ba <HAL_UART_Receive+0xd2>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800d104:	2322      	movs	r3, #34	@ 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d106:	2500      	movs	r5, #0
 800d108:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800d10c:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d110:	66c5      	str	r5, [r0, #108]	@ 0x6c
    tickstart = HAL_GetTick();
 800d112:	f7fe f88f 	bl	800b234 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 800d116:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 800d118:	4681      	mov	r9, r0
    huart->RxXferSize  = Size;
 800d11a:	f8a4 605c 	strh.w	r6, [r4, #92]	@ 0x5c
    UART_MASK_COMPUTATION(huart);
 800d11e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->RxXferCount = Size;
 800d122:	f8a4 605e 	strh.w	r6, [r4, #94]	@ 0x5e
    UART_MASK_COMPUTATION(huart);
 800d126:	d10d      	bne.n	800d144 <HAL_UART_Receive+0x5c>
 800d128:	6923      	ldr	r3, [r4, #16]
 800d12a:	b1db      	cbz	r3, 800d164 <HAL_UART_Receive+0x7c>
 800d12c:	22ff      	movs	r2, #255	@ 0xff
    uhMask = huart->Mask;
 800d12e:	4616      	mov	r6, r2
    UART_MASK_COMPUTATION(huart);
 800d130:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
    while (huart->RxXferCount > 0U)
 800d134:	f8b4 005e 	ldrh.w	r0, [r4, #94]	@ 0x5e
 800d138:	b280      	uxth	r0, r0
 800d13a:	b9e0      	cbnz	r0, 800d176 <HAL_UART_Receive+0x8e>
    huart->RxState = HAL_UART_STATE_READY;
 800d13c:	2320      	movs	r3, #32
 800d13e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    return HAL_OK;
 800d142:	e025      	b.n	800d190 <HAL_UART_Receive+0xa8>
    UART_MASK_COMPUTATION(huart);
 800d144:	b933      	cbnz	r3, 800d154 <HAL_UART_Receive+0x6c>
 800d146:	6925      	ldr	r5, [r4, #16]
 800d148:	2d00      	cmp	r5, #0
 800d14a:	d0ef      	beq.n	800d12c <HAL_UART_Receive+0x44>
 800d14c:	227f      	movs	r2, #127	@ 0x7f
      pdata16bits = NULL;
 800d14e:	461d      	mov	r5, r3
    uhMask = huart->Mask;
 800d150:	4616      	mov	r6, r2
 800d152:	e7ed      	b.n	800d130 <HAL_UART_Receive+0x48>
    UART_MASK_COMPUTATION(huart);
 800d154:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800d158:	d10a      	bne.n	800d170 <HAL_UART_Receive+0x88>
 800d15a:	6923      	ldr	r3, [r4, #16]
 800d15c:	2b00      	cmp	r3, #0
 800d15e:	d0f5      	beq.n	800d14c <HAL_UART_Receive+0x64>
 800d160:	223f      	movs	r2, #63	@ 0x3f
 800d162:	e7e4      	b.n	800d12e <HAL_UART_Receive+0x46>
 800d164:	f240 12ff 	movw	r2, #511	@ 0x1ff
      pdata16bits = (uint16_t *) pData;
 800d168:	463d      	mov	r5, r7
      pdata8bits  = NULL;
 800d16a:	461f      	mov	r7, r3
    uhMask = huart->Mask;
 800d16c:	4616      	mov	r6, r2
 800d16e:	e7df      	b.n	800d130 <HAL_UART_Receive+0x48>
 800d170:	462a      	mov	r2, r5
 800d172:	462e      	mov	r6, r5
 800d174:	e7dc      	b.n	800d130 <HAL_UART_Receive+0x48>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 800d176:	464b      	mov	r3, r9
 800d178:	2200      	movs	r2, #0
 800d17a:	2120      	movs	r1, #32
 800d17c:	4620      	mov	r0, r4
 800d17e:	f8cd 8000 	str.w	r8, [sp]
 800d182:	f7ff ff14 	bl	800cfae <UART_WaitOnFlagUntilTimeout>
 800d186:	b130      	cbz	r0, 800d196 <HAL_UART_Receive+0xae>
        huart->RxState = HAL_UART_STATE_READY;
 800d188:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 800d18a:	2003      	movs	r0, #3
        huart->RxState = HAL_UART_STATE_READY;
 800d18c:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
 800d190:	b003      	add	sp, #12
 800d192:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800d196:	6823      	ldr	r3, [r4, #0]
 800d198:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d19a:	4033      	ands	r3, r6
      if (pdata8bits == NULL)
 800d19c:	b947      	cbnz	r7, 800d1b0 <HAL_UART_Receive+0xc8>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800d19e:	f825 3b02 	strh.w	r3, [r5], #2
      huart->RxXferCount--;
 800d1a2:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 800d1a6:	3b01      	subs	r3, #1
 800d1a8:	b29b      	uxth	r3, r3
 800d1aa:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
 800d1ae:	e7c1      	b.n	800d134 <HAL_UART_Receive+0x4c>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 800d1b0:	f807 3b01 	strb.w	r3, [r7], #1
        pdata8bits++;
 800d1b4:	e7f5      	b.n	800d1a2 <HAL_UART_Receive+0xba>
    return HAL_BUSY;
 800d1b6:	2002      	movs	r0, #2
 800d1b8:	e7ea      	b.n	800d190 <HAL_UART_Receive+0xa8>
      return  HAL_ERROR;
 800d1ba:	2001      	movs	r0, #1
 800d1bc:	e7e8      	b.n	800d190 <HAL_UART_Receive+0xa8>

0800d1be <UART_CheckIdleState>:
{
 800d1be:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d1c0:	2600      	movs	r6, #0
{
 800d1c2:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d1c4:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
 800d1c8:	f7fe f834 	bl	800b234 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d1cc:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800d1ce:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d1d0:	681b      	ldr	r3, [r3, #0]
 800d1d2:	071a      	lsls	r2, r3, #28
 800d1d4:	d51c      	bpl.n	800d210 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d1d6:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800d1da:	4632      	mov	r2, r6
 800d1dc:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 800d1e0:	9300      	str	r3, [sp, #0]
 800d1e2:	4603      	mov	r3, r0
 800d1e4:	4620      	mov	r0, r4
 800d1e6:	f7ff fee2 	bl	800cfae <UART_WaitOnFlagUntilTimeout>
 800d1ea:	b188      	cbz	r0, 800d210 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 800d1ec:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800d1ee:	e852 3f00 	ldrex	r3, [r2]
 800d1f2:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800d1f6:	e842 3100 	strex	r1, r3, [r2]
 800d1fa:	2900      	cmp	r1, #0
 800d1fc:	d1f6      	bne.n	800d1ec <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
 800d1fe:	2320      	movs	r3, #32
 800d200:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 800d204:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
 800d206:	2300      	movs	r3, #0
 800d208:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 800d20c:	b002      	add	sp, #8
 800d20e:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800d210:	6823      	ldr	r3, [r4, #0]
 800d212:	681b      	ldr	r3, [r3, #0]
 800d214:	075b      	lsls	r3, r3, #29
 800d216:	d524      	bpl.n	800d262 <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d218:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800d21c:	2200      	movs	r2, #0
 800d21e:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 800d222:	4620      	mov	r0, r4
 800d224:	9300      	str	r3, [sp, #0]
 800d226:	462b      	mov	r3, r5
 800d228:	f7ff fec1 	bl	800cfae <UART_WaitOnFlagUntilTimeout>
 800d22c:	b1c8      	cbz	r0, 800d262 <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800d22e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800d230:	e852 3f00 	ldrex	r3, [r2]
 800d234:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800d238:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 800d23c:	6822      	ldr	r2, [r4, #0]
 800d23e:	2900      	cmp	r1, #0
 800d240:	d1f5      	bne.n	800d22e <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800d242:	f102 0308 	add.w	r3, r2, #8
 800d246:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d24a:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800d24e:	f102 0008 	add.w	r0, r2, #8
 800d252:	e840 3100 	strex	r1, r3, [r0]
 800d256:	2900      	cmp	r1, #0
 800d258:	d1f3      	bne.n	800d242 <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
 800d25a:	2320      	movs	r3, #32
 800d25c:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
 800d260:	e7d0      	b.n	800d204 <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
 800d262:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d264:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 800d266:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 800d26a:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d26e:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 800d270:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
 800d272:	e7c8      	b.n	800d206 <UART_CheckIdleState+0x48>

0800d274 <HAL_UART_Init>:
{
 800d274:	b510      	push	{r4, lr}
  if (huart == NULL)
 800d276:	4604      	mov	r4, r0
 800d278:	b350      	cbz	r0, 800d2d0 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 800d27a:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 800d27e:	b91b      	cbnz	r3, 800d288 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 800d280:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 800d284:	f7fb fe58 	bl	8008f38 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 800d288:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 800d28a:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800d28c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 800d290:	6813      	ldr	r3, [r2, #0]
 800d292:	f023 0301 	bic.w	r3, r3, #1
 800d296:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800d298:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800d29a:	b113      	cbz	r3, 800d2a2 <HAL_UART_Init+0x2e>
    UART_AdvFeatureConfig(huart);
 800d29c:	4620      	mov	r0, r4
 800d29e:	f7ff fe31 	bl	800cf04 <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
 800d2a2:	4620      	mov	r0, r4
 800d2a4:	f7ff fcb0 	bl	800cc08 <UART_SetConfig>
 800d2a8:	2801      	cmp	r0, #1
 800d2aa:	d011      	beq.n	800d2d0 <HAL_UART_Init+0x5c>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800d2ac:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 800d2ae:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800d2b0:	685a      	ldr	r2, [r3, #4]
 800d2b2:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 800d2b6:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800d2b8:	689a      	ldr	r2, [r3, #8]
 800d2ba:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 800d2be:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800d2c0:	681a      	ldr	r2, [r3, #0]
 800d2c2:	f042 0201 	orr.w	r2, r2, #1
}
 800d2c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
 800d2ca:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 800d2cc:	f7ff bf77 	b.w	800d1be <UART_CheckIdleState>
}
 800d2d0:	2001      	movs	r0, #1
 800d2d2:	bd10      	pop	{r4, pc}

0800d2d4 <std>:
 800d2d4:	2300      	movs	r3, #0
 800d2d6:	b510      	push	{r4, lr}
 800d2d8:	4604      	mov	r4, r0
 800d2da:	e9c0 3300 	strd	r3, r3, [r0]
 800d2de:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800d2e2:	6083      	str	r3, [r0, #8]
 800d2e4:	8181      	strh	r1, [r0, #12]
 800d2e6:	6643      	str	r3, [r0, #100]	@ 0x64
 800d2e8:	81c2      	strh	r2, [r0, #14]
 800d2ea:	6183      	str	r3, [r0, #24]
 800d2ec:	4619      	mov	r1, r3
 800d2ee:	2208      	movs	r2, #8
 800d2f0:	305c      	adds	r0, #92	@ 0x5c
 800d2f2:	f000 fabd 	bl	800d870 <memset>
 800d2f6:	4b0d      	ldr	r3, [pc, #52]	@ (800d32c <std+0x58>)
 800d2f8:	6263      	str	r3, [r4, #36]	@ 0x24
 800d2fa:	4b0d      	ldr	r3, [pc, #52]	@ (800d330 <std+0x5c>)
 800d2fc:	62a3      	str	r3, [r4, #40]	@ 0x28
 800d2fe:	4b0d      	ldr	r3, [pc, #52]	@ (800d334 <std+0x60>)
 800d300:	62e3      	str	r3, [r4, #44]	@ 0x2c
 800d302:	4b0d      	ldr	r3, [pc, #52]	@ (800d338 <std+0x64>)
 800d304:	6323      	str	r3, [r4, #48]	@ 0x30
 800d306:	4b0d      	ldr	r3, [pc, #52]	@ (800d33c <std+0x68>)
 800d308:	6224      	str	r4, [r4, #32]
 800d30a:	429c      	cmp	r4, r3
 800d30c:	d006      	beq.n	800d31c <std+0x48>
 800d30e:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 800d312:	4294      	cmp	r4, r2
 800d314:	d002      	beq.n	800d31c <std+0x48>
 800d316:	33d0      	adds	r3, #208	@ 0xd0
 800d318:	429c      	cmp	r4, r3
 800d31a:	d105      	bne.n	800d328 <std+0x54>
 800d31c:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 800d320:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d324:	f000 bb1c 	b.w	800d960 <__retarget_lock_init_recursive>
 800d328:	bd10      	pop	{r4, pc}
 800d32a:	bf00      	nop
 800d32c:	0800d6a1 	.word	0x0800d6a1
 800d330:	0800d6c3 	.word	0x0800d6c3
 800d334:	0800d6fb 	.word	0x0800d6fb
 800d338:	0800d71f 	.word	0x0800d71f
 800d33c:	20001d9c 	.word	0x20001d9c

0800d340 <stdio_exit_handler>:
 800d340:	4a02      	ldr	r2, [pc, #8]	@ (800d34c <stdio_exit_handler+0xc>)
 800d342:	4903      	ldr	r1, [pc, #12]	@ (800d350 <stdio_exit_handler+0x10>)
 800d344:	4803      	ldr	r0, [pc, #12]	@ (800d354 <stdio_exit_handler+0x14>)
 800d346:	f000 b869 	b.w	800d41c <_fwalk_sglue>
 800d34a:	bf00      	nop
 800d34c:	2000112c 	.word	0x2000112c
 800d350:	0800e229 	.word	0x0800e229
 800d354:	2000113c 	.word	0x2000113c

0800d358 <cleanup_stdio>:
 800d358:	6841      	ldr	r1, [r0, #4]
 800d35a:	4b0c      	ldr	r3, [pc, #48]	@ (800d38c <cleanup_stdio+0x34>)
 800d35c:	4299      	cmp	r1, r3
 800d35e:	b510      	push	{r4, lr}
 800d360:	4604      	mov	r4, r0
 800d362:	d001      	beq.n	800d368 <cleanup_stdio+0x10>
 800d364:	f000 ff60 	bl	800e228 <_fflush_r>
 800d368:	68a1      	ldr	r1, [r4, #8]
 800d36a:	4b09      	ldr	r3, [pc, #36]	@ (800d390 <cleanup_stdio+0x38>)
 800d36c:	4299      	cmp	r1, r3
 800d36e:	d002      	beq.n	800d376 <cleanup_stdio+0x1e>
 800d370:	4620      	mov	r0, r4
 800d372:	f000 ff59 	bl	800e228 <_fflush_r>
 800d376:	68e1      	ldr	r1, [r4, #12]
 800d378:	4b06      	ldr	r3, [pc, #24]	@ (800d394 <cleanup_stdio+0x3c>)
 800d37a:	4299      	cmp	r1, r3
 800d37c:	d004      	beq.n	800d388 <cleanup_stdio+0x30>
 800d37e:	4620      	mov	r0, r4
 800d380:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d384:	f000 bf50 	b.w	800e228 <_fflush_r>
 800d388:	bd10      	pop	{r4, pc}
 800d38a:	bf00      	nop
 800d38c:	20001d9c 	.word	0x20001d9c
 800d390:	20001e04 	.word	0x20001e04
 800d394:	20001e6c 	.word	0x20001e6c

0800d398 <global_stdio_init.part.0>:
 800d398:	b510      	push	{r4, lr}
 800d39a:	4b0b      	ldr	r3, [pc, #44]	@ (800d3c8 <global_stdio_init.part.0+0x30>)
 800d39c:	4c0b      	ldr	r4, [pc, #44]	@ (800d3cc <global_stdio_init.part.0+0x34>)
 800d39e:	4a0c      	ldr	r2, [pc, #48]	@ (800d3d0 <global_stdio_init.part.0+0x38>)
 800d3a0:	601a      	str	r2, [r3, #0]
 800d3a2:	4620      	mov	r0, r4
 800d3a4:	2200      	movs	r2, #0
 800d3a6:	2104      	movs	r1, #4
 800d3a8:	f7ff ff94 	bl	800d2d4 <std>
 800d3ac:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 800d3b0:	2201      	movs	r2, #1
 800d3b2:	2109      	movs	r1, #9
 800d3b4:	f7ff ff8e 	bl	800d2d4 <std>
 800d3b8:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 800d3bc:	2202      	movs	r2, #2
 800d3be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3c2:	2112      	movs	r1, #18
 800d3c4:	f7ff bf86 	b.w	800d2d4 <std>
 800d3c8:	20001ed4 	.word	0x20001ed4
 800d3cc:	20001d9c 	.word	0x20001d9c
 800d3d0:	0800d341 	.word	0x0800d341

0800d3d4 <__sfp_lock_acquire>:
 800d3d4:	4801      	ldr	r0, [pc, #4]	@ (800d3dc <__sfp_lock_acquire+0x8>)
 800d3d6:	f000 bac4 	b.w	800d962 <__retarget_lock_acquire_recursive>
 800d3da:	bf00      	nop
 800d3dc:	20001edd 	.word	0x20001edd

0800d3e0 <__sfp_lock_release>:
 800d3e0:	4801      	ldr	r0, [pc, #4]	@ (800d3e8 <__sfp_lock_release+0x8>)
 800d3e2:	f000 babf 	b.w	800d964 <__retarget_lock_release_recursive>
 800d3e6:	bf00      	nop
 800d3e8:	20001edd 	.word	0x20001edd

0800d3ec <__sinit>:
 800d3ec:	b510      	push	{r4, lr}
 800d3ee:	4604      	mov	r4, r0
 800d3f0:	f7ff fff0 	bl	800d3d4 <__sfp_lock_acquire>
 800d3f4:	6a23      	ldr	r3, [r4, #32]
 800d3f6:	b11b      	cbz	r3, 800d400 <__sinit+0x14>
 800d3f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3fc:	f7ff bff0 	b.w	800d3e0 <__sfp_lock_release>
 800d400:	4b04      	ldr	r3, [pc, #16]	@ (800d414 <__sinit+0x28>)
 800d402:	6223      	str	r3, [r4, #32]
 800d404:	4b04      	ldr	r3, [pc, #16]	@ (800d418 <__sinit+0x2c>)
 800d406:	681b      	ldr	r3, [r3, #0]
 800d408:	2b00      	cmp	r3, #0
 800d40a:	d1f5      	bne.n	800d3f8 <__sinit+0xc>
 800d40c:	f7ff ffc4 	bl	800d398 <global_stdio_init.part.0>
 800d410:	e7f2      	b.n	800d3f8 <__sinit+0xc>
 800d412:	bf00      	nop
 800d414:	0800d359 	.word	0x0800d359
 800d418:	20001ed4 	.word	0x20001ed4

0800d41c <_fwalk_sglue>:
 800d41c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d420:	4607      	mov	r7, r0
 800d422:	4688      	mov	r8, r1
 800d424:	4614      	mov	r4, r2
 800d426:	2600      	movs	r6, #0
 800d428:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 800d42c:	f1b9 0901 	subs.w	r9, r9, #1
 800d430:	d505      	bpl.n	800d43e <_fwalk_sglue+0x22>
 800d432:	6824      	ldr	r4, [r4, #0]
 800d434:	2c00      	cmp	r4, #0
 800d436:	d1f7      	bne.n	800d428 <_fwalk_sglue+0xc>
 800d438:	4630      	mov	r0, r6
 800d43a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d43e:	89ab      	ldrh	r3, [r5, #12]
 800d440:	2b01      	cmp	r3, #1
 800d442:	d907      	bls.n	800d454 <_fwalk_sglue+0x38>
 800d444:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800d448:	3301      	adds	r3, #1
 800d44a:	d003      	beq.n	800d454 <_fwalk_sglue+0x38>
 800d44c:	4629      	mov	r1, r5
 800d44e:	4638      	mov	r0, r7
 800d450:	47c0      	blx	r8
 800d452:	4306      	orrs	r6, r0
 800d454:	3568      	adds	r5, #104	@ 0x68
 800d456:	e7e9      	b.n	800d42c <_fwalk_sglue+0x10>

0800d458 <iprintf>:
 800d458:	b40f      	push	{r0, r1, r2, r3}
 800d45a:	b507      	push	{r0, r1, r2, lr}
 800d45c:	4906      	ldr	r1, [pc, #24]	@ (800d478 <iprintf+0x20>)
 800d45e:	ab04      	add	r3, sp, #16
 800d460:	6808      	ldr	r0, [r1, #0]
 800d462:	f853 2b04 	ldr.w	r2, [r3], #4
 800d466:	6881      	ldr	r1, [r0, #8]
 800d468:	9301      	str	r3, [sp, #4]
 800d46a:	f000 fbb5 	bl	800dbd8 <_vfiprintf_r>
 800d46e:	b003      	add	sp, #12
 800d470:	f85d eb04 	ldr.w	lr, [sp], #4
 800d474:	b004      	add	sp, #16
 800d476:	4770      	bx	lr
 800d478:	20001138 	.word	0x20001138

0800d47c <_puts_r>:
 800d47c:	6a03      	ldr	r3, [r0, #32]
 800d47e:	b570      	push	{r4, r5, r6, lr}
 800d480:	6884      	ldr	r4, [r0, #8]
 800d482:	4605      	mov	r5, r0
 800d484:	460e      	mov	r6, r1
 800d486:	b90b      	cbnz	r3, 800d48c <_puts_r+0x10>
 800d488:	f7ff ffb0 	bl	800d3ec <__sinit>
 800d48c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d48e:	07db      	lsls	r3, r3, #31
 800d490:	d405      	bmi.n	800d49e <_puts_r+0x22>
 800d492:	89a3      	ldrh	r3, [r4, #12]
 800d494:	0598      	lsls	r0, r3, #22
 800d496:	d402      	bmi.n	800d49e <_puts_r+0x22>
 800d498:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d49a:	f000 fa62 	bl	800d962 <__retarget_lock_acquire_recursive>
 800d49e:	89a3      	ldrh	r3, [r4, #12]
 800d4a0:	0719      	lsls	r1, r3, #28
 800d4a2:	d502      	bpl.n	800d4aa <_puts_r+0x2e>
 800d4a4:	6923      	ldr	r3, [r4, #16]
 800d4a6:	2b00      	cmp	r3, #0
 800d4a8:	d135      	bne.n	800d516 <_puts_r+0x9a>
 800d4aa:	4621      	mov	r1, r4
 800d4ac:	4628      	mov	r0, r5
 800d4ae:	f000 f979 	bl	800d7a4 <__swsetup_r>
 800d4b2:	b380      	cbz	r0, 800d516 <_puts_r+0x9a>
 800d4b4:	f04f 35ff 	mov.w	r5, #4294967295
 800d4b8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d4ba:	07da      	lsls	r2, r3, #31
 800d4bc:	d405      	bmi.n	800d4ca <_puts_r+0x4e>
 800d4be:	89a3      	ldrh	r3, [r4, #12]
 800d4c0:	059b      	lsls	r3, r3, #22
 800d4c2:	d402      	bmi.n	800d4ca <_puts_r+0x4e>
 800d4c4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d4c6:	f000 fa4d 	bl	800d964 <__retarget_lock_release_recursive>
 800d4ca:	4628      	mov	r0, r5
 800d4cc:	bd70      	pop	{r4, r5, r6, pc}
 800d4ce:	2b00      	cmp	r3, #0
 800d4d0:	da04      	bge.n	800d4dc <_puts_r+0x60>
 800d4d2:	69a2      	ldr	r2, [r4, #24]
 800d4d4:	429a      	cmp	r2, r3
 800d4d6:	dc17      	bgt.n	800d508 <_puts_r+0x8c>
 800d4d8:	290a      	cmp	r1, #10
 800d4da:	d015      	beq.n	800d508 <_puts_r+0x8c>
 800d4dc:	6823      	ldr	r3, [r4, #0]
 800d4de:	1c5a      	adds	r2, r3, #1
 800d4e0:	6022      	str	r2, [r4, #0]
 800d4e2:	7019      	strb	r1, [r3, #0]
 800d4e4:	68a3      	ldr	r3, [r4, #8]
 800d4e6:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800d4ea:	3b01      	subs	r3, #1
 800d4ec:	60a3      	str	r3, [r4, #8]
 800d4ee:	2900      	cmp	r1, #0
 800d4f0:	d1ed      	bne.n	800d4ce <_puts_r+0x52>
 800d4f2:	2b00      	cmp	r3, #0
 800d4f4:	da11      	bge.n	800d51a <_puts_r+0x9e>
 800d4f6:	4622      	mov	r2, r4
 800d4f8:	210a      	movs	r1, #10
 800d4fa:	4628      	mov	r0, r5
 800d4fc:	f000 f913 	bl	800d726 <__swbuf_r>
 800d500:	3001      	adds	r0, #1
 800d502:	d0d7      	beq.n	800d4b4 <_puts_r+0x38>
 800d504:	250a      	movs	r5, #10
 800d506:	e7d7      	b.n	800d4b8 <_puts_r+0x3c>
 800d508:	4622      	mov	r2, r4
 800d50a:	4628      	mov	r0, r5
 800d50c:	f000 f90b 	bl	800d726 <__swbuf_r>
 800d510:	3001      	adds	r0, #1
 800d512:	d1e7      	bne.n	800d4e4 <_puts_r+0x68>
 800d514:	e7ce      	b.n	800d4b4 <_puts_r+0x38>
 800d516:	3e01      	subs	r6, #1
 800d518:	e7e4      	b.n	800d4e4 <_puts_r+0x68>
 800d51a:	6823      	ldr	r3, [r4, #0]
 800d51c:	1c5a      	adds	r2, r3, #1
 800d51e:	6022      	str	r2, [r4, #0]
 800d520:	220a      	movs	r2, #10
 800d522:	701a      	strb	r2, [r3, #0]
 800d524:	e7ee      	b.n	800d504 <_puts_r+0x88>
	...

0800d528 <puts>:
 800d528:	4b02      	ldr	r3, [pc, #8]	@ (800d534 <puts+0xc>)
 800d52a:	4601      	mov	r1, r0
 800d52c:	6818      	ldr	r0, [r3, #0]
 800d52e:	f7ff bfa5 	b.w	800d47c <_puts_r>
 800d532:	bf00      	nop
 800d534:	20001138 	.word	0x20001138

0800d538 <setvbuf>:
 800d538:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800d53c:	461d      	mov	r5, r3
 800d53e:	4b57      	ldr	r3, [pc, #348]	@ (800d69c <setvbuf+0x164>)
 800d540:	681f      	ldr	r7, [r3, #0]
 800d542:	4604      	mov	r4, r0
 800d544:	460e      	mov	r6, r1
 800d546:	4690      	mov	r8, r2
 800d548:	b127      	cbz	r7, 800d554 <setvbuf+0x1c>
 800d54a:	6a3b      	ldr	r3, [r7, #32]
 800d54c:	b913      	cbnz	r3, 800d554 <setvbuf+0x1c>
 800d54e:	4638      	mov	r0, r7
 800d550:	f7ff ff4c 	bl	800d3ec <__sinit>
 800d554:	f1b8 0f02 	cmp.w	r8, #2
 800d558:	d006      	beq.n	800d568 <setvbuf+0x30>
 800d55a:	f1b8 0f01 	cmp.w	r8, #1
 800d55e:	f200 809a 	bhi.w	800d696 <setvbuf+0x15e>
 800d562:	2d00      	cmp	r5, #0
 800d564:	f2c0 8097 	blt.w	800d696 <setvbuf+0x15e>
 800d568:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d56a:	07d9      	lsls	r1, r3, #31
 800d56c:	d405      	bmi.n	800d57a <setvbuf+0x42>
 800d56e:	89a3      	ldrh	r3, [r4, #12]
 800d570:	059a      	lsls	r2, r3, #22
 800d572:	d402      	bmi.n	800d57a <setvbuf+0x42>
 800d574:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d576:	f000 f9f4 	bl	800d962 <__retarget_lock_acquire_recursive>
 800d57a:	4621      	mov	r1, r4
 800d57c:	4638      	mov	r0, r7
 800d57e:	f000 fe53 	bl	800e228 <_fflush_r>
 800d582:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800d584:	b141      	cbz	r1, 800d598 <setvbuf+0x60>
 800d586:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800d58a:	4299      	cmp	r1, r3
 800d58c:	d002      	beq.n	800d594 <setvbuf+0x5c>
 800d58e:	4638      	mov	r0, r7
 800d590:	f000 f9f8 	bl	800d984 <_free_r>
 800d594:	2300      	movs	r3, #0
 800d596:	6363      	str	r3, [r4, #52]	@ 0x34
 800d598:	2300      	movs	r3, #0
 800d59a:	61a3      	str	r3, [r4, #24]
 800d59c:	6063      	str	r3, [r4, #4]
 800d59e:	89a3      	ldrh	r3, [r4, #12]
 800d5a0:	061b      	lsls	r3, r3, #24
 800d5a2:	d503      	bpl.n	800d5ac <setvbuf+0x74>
 800d5a4:	6921      	ldr	r1, [r4, #16]
 800d5a6:	4638      	mov	r0, r7
 800d5a8:	f000 f9ec 	bl	800d984 <_free_r>
 800d5ac:	89a3      	ldrh	r3, [r4, #12]
 800d5ae:	f423 634a 	bic.w	r3, r3, #3232	@ 0xca0
 800d5b2:	f023 0303 	bic.w	r3, r3, #3
 800d5b6:	f1b8 0f02 	cmp.w	r8, #2
 800d5ba:	81a3      	strh	r3, [r4, #12]
 800d5bc:	d061      	beq.n	800d682 <setvbuf+0x14a>
 800d5be:	ab01      	add	r3, sp, #4
 800d5c0:	466a      	mov	r2, sp
 800d5c2:	4621      	mov	r1, r4
 800d5c4:	4638      	mov	r0, r7
 800d5c6:	f000 fe57 	bl	800e278 <__swhatbuf_r>
 800d5ca:	89a3      	ldrh	r3, [r4, #12]
 800d5cc:	4318      	orrs	r0, r3
 800d5ce:	81a0      	strh	r0, [r4, #12]
 800d5d0:	bb2d      	cbnz	r5, 800d61e <setvbuf+0xe6>
 800d5d2:	9d00      	ldr	r5, [sp, #0]
 800d5d4:	4628      	mov	r0, r5
 800d5d6:	f000 fa1f 	bl	800da18 <malloc>
 800d5da:	4606      	mov	r6, r0
 800d5dc:	2800      	cmp	r0, #0
 800d5de:	d152      	bne.n	800d686 <setvbuf+0x14e>
 800d5e0:	f8dd 9000 	ldr.w	r9, [sp]
 800d5e4:	45a9      	cmp	r9, r5
 800d5e6:	d140      	bne.n	800d66a <setvbuf+0x132>
 800d5e8:	f04f 35ff 	mov.w	r5, #4294967295
 800d5ec:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d5f0:	f043 0202 	orr.w	r2, r3, #2
 800d5f4:	81a2      	strh	r2, [r4, #12]
 800d5f6:	2200      	movs	r2, #0
 800d5f8:	60a2      	str	r2, [r4, #8]
 800d5fa:	f104 0247 	add.w	r2, r4, #71	@ 0x47
 800d5fe:	6022      	str	r2, [r4, #0]
 800d600:	6122      	str	r2, [r4, #16]
 800d602:	2201      	movs	r2, #1
 800d604:	6162      	str	r2, [r4, #20]
 800d606:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800d608:	07d6      	lsls	r6, r2, #31
 800d60a:	d404      	bmi.n	800d616 <setvbuf+0xde>
 800d60c:	0598      	lsls	r0, r3, #22
 800d60e:	d402      	bmi.n	800d616 <setvbuf+0xde>
 800d610:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d612:	f000 f9a7 	bl	800d964 <__retarget_lock_release_recursive>
 800d616:	4628      	mov	r0, r5
 800d618:	b003      	add	sp, #12
 800d61a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d61e:	2e00      	cmp	r6, #0
 800d620:	d0d8      	beq.n	800d5d4 <setvbuf+0x9c>
 800d622:	6a3b      	ldr	r3, [r7, #32]
 800d624:	b913      	cbnz	r3, 800d62c <setvbuf+0xf4>
 800d626:	4638      	mov	r0, r7
 800d628:	f7ff fee0 	bl	800d3ec <__sinit>
 800d62c:	f1b8 0f01 	cmp.w	r8, #1
 800d630:	bf08      	it	eq
 800d632:	89a3      	ldrheq	r3, [r4, #12]
 800d634:	6026      	str	r6, [r4, #0]
 800d636:	bf04      	itt	eq
 800d638:	f043 0301 	orreq.w	r3, r3, #1
 800d63c:	81a3      	strheq	r3, [r4, #12]
 800d63e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d642:	f013 0208 	ands.w	r2, r3, #8
 800d646:	e9c4 6504 	strd	r6, r5, [r4, #16]
 800d64a:	d01e      	beq.n	800d68a <setvbuf+0x152>
 800d64c:	07d9      	lsls	r1, r3, #31
 800d64e:	bf41      	itttt	mi
 800d650:	2200      	movmi	r2, #0
 800d652:	426d      	negmi	r5, r5
 800d654:	60a2      	strmi	r2, [r4, #8]
 800d656:	61a5      	strmi	r5, [r4, #24]
 800d658:	bf58      	it	pl
 800d65a:	60a5      	strpl	r5, [r4, #8]
 800d65c:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800d65e:	07d2      	lsls	r2, r2, #31
 800d660:	d401      	bmi.n	800d666 <setvbuf+0x12e>
 800d662:	059b      	lsls	r3, r3, #22
 800d664:	d513      	bpl.n	800d68e <setvbuf+0x156>
 800d666:	2500      	movs	r5, #0
 800d668:	e7d5      	b.n	800d616 <setvbuf+0xde>
 800d66a:	4648      	mov	r0, r9
 800d66c:	f000 f9d4 	bl	800da18 <malloc>
 800d670:	4606      	mov	r6, r0
 800d672:	2800      	cmp	r0, #0
 800d674:	d0b8      	beq.n	800d5e8 <setvbuf+0xb0>
 800d676:	89a3      	ldrh	r3, [r4, #12]
 800d678:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800d67c:	81a3      	strh	r3, [r4, #12]
 800d67e:	464d      	mov	r5, r9
 800d680:	e7cf      	b.n	800d622 <setvbuf+0xea>
 800d682:	2500      	movs	r5, #0
 800d684:	e7b2      	b.n	800d5ec <setvbuf+0xb4>
 800d686:	46a9      	mov	r9, r5
 800d688:	e7f5      	b.n	800d676 <setvbuf+0x13e>
 800d68a:	60a2      	str	r2, [r4, #8]
 800d68c:	e7e6      	b.n	800d65c <setvbuf+0x124>
 800d68e:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d690:	f000 f968 	bl	800d964 <__retarget_lock_release_recursive>
 800d694:	e7e7      	b.n	800d666 <setvbuf+0x12e>
 800d696:	f04f 35ff 	mov.w	r5, #4294967295
 800d69a:	e7bc      	b.n	800d616 <setvbuf+0xde>
 800d69c:	20001138 	.word	0x20001138

0800d6a0 <__sread>:
 800d6a0:	b510      	push	{r4, lr}
 800d6a2:	460c      	mov	r4, r1
 800d6a4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d6a8:	f000 f90c 	bl	800d8c4 <_read_r>
 800d6ac:	2800      	cmp	r0, #0
 800d6ae:	bfab      	itete	ge
 800d6b0:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 800d6b2:	89a3      	ldrhlt	r3, [r4, #12]
 800d6b4:	181b      	addge	r3, r3, r0
 800d6b6:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 800d6ba:	bfac      	ite	ge
 800d6bc:	6563      	strge	r3, [r4, #84]	@ 0x54
 800d6be:	81a3      	strhlt	r3, [r4, #12]
 800d6c0:	bd10      	pop	{r4, pc}

0800d6c2 <__swrite>:
 800d6c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d6c6:	461f      	mov	r7, r3
 800d6c8:	898b      	ldrh	r3, [r1, #12]
 800d6ca:	05db      	lsls	r3, r3, #23
 800d6cc:	4605      	mov	r5, r0
 800d6ce:	460c      	mov	r4, r1
 800d6d0:	4616      	mov	r6, r2
 800d6d2:	d505      	bpl.n	800d6e0 <__swrite+0x1e>
 800d6d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d6d8:	2302      	movs	r3, #2
 800d6da:	2200      	movs	r2, #0
 800d6dc:	f000 f8e0 	bl	800d8a0 <_lseek_r>
 800d6e0:	89a3      	ldrh	r3, [r4, #12]
 800d6e2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800d6e6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800d6ea:	81a3      	strh	r3, [r4, #12]
 800d6ec:	4632      	mov	r2, r6
 800d6ee:	463b      	mov	r3, r7
 800d6f0:	4628      	mov	r0, r5
 800d6f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800d6f6:	f000 b8f7 	b.w	800d8e8 <_write_r>

0800d6fa <__sseek>:
 800d6fa:	b510      	push	{r4, lr}
 800d6fc:	460c      	mov	r4, r1
 800d6fe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d702:	f000 f8cd 	bl	800d8a0 <_lseek_r>
 800d706:	1c43      	adds	r3, r0, #1
 800d708:	89a3      	ldrh	r3, [r4, #12]
 800d70a:	bf15      	itete	ne
 800d70c:	6560      	strne	r0, [r4, #84]	@ 0x54
 800d70e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 800d712:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 800d716:	81a3      	strheq	r3, [r4, #12]
 800d718:	bf18      	it	ne
 800d71a:	81a3      	strhne	r3, [r4, #12]
 800d71c:	bd10      	pop	{r4, pc}

0800d71e <__sclose>:
 800d71e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d722:	f000 b8ad 	b.w	800d880 <_close_r>

0800d726 <__swbuf_r>:
 800d726:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d728:	460e      	mov	r6, r1
 800d72a:	4614      	mov	r4, r2
 800d72c:	4605      	mov	r5, r0
 800d72e:	b118      	cbz	r0, 800d738 <__swbuf_r+0x12>
 800d730:	6a03      	ldr	r3, [r0, #32]
 800d732:	b90b      	cbnz	r3, 800d738 <__swbuf_r+0x12>
 800d734:	f7ff fe5a 	bl	800d3ec <__sinit>
 800d738:	69a3      	ldr	r3, [r4, #24]
 800d73a:	60a3      	str	r3, [r4, #8]
 800d73c:	89a3      	ldrh	r3, [r4, #12]
 800d73e:	071a      	lsls	r2, r3, #28
 800d740:	d501      	bpl.n	800d746 <__swbuf_r+0x20>
 800d742:	6923      	ldr	r3, [r4, #16]
 800d744:	b943      	cbnz	r3, 800d758 <__swbuf_r+0x32>
 800d746:	4621      	mov	r1, r4
 800d748:	4628      	mov	r0, r5
 800d74a:	f000 f82b 	bl	800d7a4 <__swsetup_r>
 800d74e:	b118      	cbz	r0, 800d758 <__swbuf_r+0x32>
 800d750:	f04f 37ff 	mov.w	r7, #4294967295
 800d754:	4638      	mov	r0, r7
 800d756:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d758:	6823      	ldr	r3, [r4, #0]
 800d75a:	6922      	ldr	r2, [r4, #16]
 800d75c:	1a98      	subs	r0, r3, r2
 800d75e:	6963      	ldr	r3, [r4, #20]
 800d760:	b2f6      	uxtb	r6, r6
 800d762:	4283      	cmp	r3, r0
 800d764:	4637      	mov	r7, r6
 800d766:	dc05      	bgt.n	800d774 <__swbuf_r+0x4e>
 800d768:	4621      	mov	r1, r4
 800d76a:	4628      	mov	r0, r5
 800d76c:	f000 fd5c 	bl	800e228 <_fflush_r>
 800d770:	2800      	cmp	r0, #0
 800d772:	d1ed      	bne.n	800d750 <__swbuf_r+0x2a>
 800d774:	68a3      	ldr	r3, [r4, #8]
 800d776:	3b01      	subs	r3, #1
 800d778:	60a3      	str	r3, [r4, #8]
 800d77a:	6823      	ldr	r3, [r4, #0]
 800d77c:	1c5a      	adds	r2, r3, #1
 800d77e:	6022      	str	r2, [r4, #0]
 800d780:	701e      	strb	r6, [r3, #0]
 800d782:	6962      	ldr	r2, [r4, #20]
 800d784:	1c43      	adds	r3, r0, #1
 800d786:	429a      	cmp	r2, r3
 800d788:	d004      	beq.n	800d794 <__swbuf_r+0x6e>
 800d78a:	89a3      	ldrh	r3, [r4, #12]
 800d78c:	07db      	lsls	r3, r3, #31
 800d78e:	d5e1      	bpl.n	800d754 <__swbuf_r+0x2e>
 800d790:	2e0a      	cmp	r6, #10
 800d792:	d1df      	bne.n	800d754 <__swbuf_r+0x2e>
 800d794:	4621      	mov	r1, r4
 800d796:	4628      	mov	r0, r5
 800d798:	f000 fd46 	bl	800e228 <_fflush_r>
 800d79c:	2800      	cmp	r0, #0
 800d79e:	d0d9      	beq.n	800d754 <__swbuf_r+0x2e>
 800d7a0:	e7d6      	b.n	800d750 <__swbuf_r+0x2a>
	...

0800d7a4 <__swsetup_r>:
 800d7a4:	b538      	push	{r3, r4, r5, lr}
 800d7a6:	4b29      	ldr	r3, [pc, #164]	@ (800d84c <__swsetup_r+0xa8>)
 800d7a8:	4605      	mov	r5, r0
 800d7aa:	6818      	ldr	r0, [r3, #0]
 800d7ac:	460c      	mov	r4, r1
 800d7ae:	b118      	cbz	r0, 800d7b8 <__swsetup_r+0x14>
 800d7b0:	6a03      	ldr	r3, [r0, #32]
 800d7b2:	b90b      	cbnz	r3, 800d7b8 <__swsetup_r+0x14>
 800d7b4:	f7ff fe1a 	bl	800d3ec <__sinit>
 800d7b8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d7bc:	0719      	lsls	r1, r3, #28
 800d7be:	d422      	bmi.n	800d806 <__swsetup_r+0x62>
 800d7c0:	06da      	lsls	r2, r3, #27
 800d7c2:	d407      	bmi.n	800d7d4 <__swsetup_r+0x30>
 800d7c4:	2209      	movs	r2, #9
 800d7c6:	602a      	str	r2, [r5, #0]
 800d7c8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800d7cc:	81a3      	strh	r3, [r4, #12]
 800d7ce:	f04f 30ff 	mov.w	r0, #4294967295
 800d7d2:	e033      	b.n	800d83c <__swsetup_r+0x98>
 800d7d4:	0758      	lsls	r0, r3, #29
 800d7d6:	d512      	bpl.n	800d7fe <__swsetup_r+0x5a>
 800d7d8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800d7da:	b141      	cbz	r1, 800d7ee <__swsetup_r+0x4a>
 800d7dc:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800d7e0:	4299      	cmp	r1, r3
 800d7e2:	d002      	beq.n	800d7ea <__swsetup_r+0x46>
 800d7e4:	4628      	mov	r0, r5
 800d7e6:	f000 f8cd 	bl	800d984 <_free_r>
 800d7ea:	2300      	movs	r3, #0
 800d7ec:	6363      	str	r3, [r4, #52]	@ 0x34
 800d7ee:	89a3      	ldrh	r3, [r4, #12]
 800d7f0:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 800d7f4:	81a3      	strh	r3, [r4, #12]
 800d7f6:	2300      	movs	r3, #0
 800d7f8:	6063      	str	r3, [r4, #4]
 800d7fa:	6923      	ldr	r3, [r4, #16]
 800d7fc:	6023      	str	r3, [r4, #0]
 800d7fe:	89a3      	ldrh	r3, [r4, #12]
 800d800:	f043 0308 	orr.w	r3, r3, #8
 800d804:	81a3      	strh	r3, [r4, #12]
 800d806:	6923      	ldr	r3, [r4, #16]
 800d808:	b94b      	cbnz	r3, 800d81e <__swsetup_r+0x7a>
 800d80a:	89a3      	ldrh	r3, [r4, #12]
 800d80c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 800d810:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d814:	d003      	beq.n	800d81e <__swsetup_r+0x7a>
 800d816:	4621      	mov	r1, r4
 800d818:	4628      	mov	r0, r5
 800d81a:	f000 fd53 	bl	800e2c4 <__smakebuf_r>
 800d81e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d822:	f013 0201 	ands.w	r2, r3, #1
 800d826:	d00a      	beq.n	800d83e <__swsetup_r+0x9a>
 800d828:	2200      	movs	r2, #0
 800d82a:	60a2      	str	r2, [r4, #8]
 800d82c:	6962      	ldr	r2, [r4, #20]
 800d82e:	4252      	negs	r2, r2
 800d830:	61a2      	str	r2, [r4, #24]
 800d832:	6922      	ldr	r2, [r4, #16]
 800d834:	b942      	cbnz	r2, 800d848 <__swsetup_r+0xa4>
 800d836:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 800d83a:	d1c5      	bne.n	800d7c8 <__swsetup_r+0x24>
 800d83c:	bd38      	pop	{r3, r4, r5, pc}
 800d83e:	0799      	lsls	r1, r3, #30
 800d840:	bf58      	it	pl
 800d842:	6962      	ldrpl	r2, [r4, #20]
 800d844:	60a2      	str	r2, [r4, #8]
 800d846:	e7f4      	b.n	800d832 <__swsetup_r+0x8e>
 800d848:	2000      	movs	r0, #0
 800d84a:	e7f7      	b.n	800d83c <__swsetup_r+0x98>
 800d84c:	20001138 	.word	0x20001138

0800d850 <memcmp>:
 800d850:	b510      	push	{r4, lr}
 800d852:	3901      	subs	r1, #1
 800d854:	4402      	add	r2, r0
 800d856:	4290      	cmp	r0, r2
 800d858:	d101      	bne.n	800d85e <memcmp+0xe>
 800d85a:	2000      	movs	r0, #0
 800d85c:	e005      	b.n	800d86a <memcmp+0x1a>
 800d85e:	7803      	ldrb	r3, [r0, #0]
 800d860:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800d864:	42a3      	cmp	r3, r4
 800d866:	d001      	beq.n	800d86c <memcmp+0x1c>
 800d868:	1b18      	subs	r0, r3, r4
 800d86a:	bd10      	pop	{r4, pc}
 800d86c:	3001      	adds	r0, #1
 800d86e:	e7f2      	b.n	800d856 <memcmp+0x6>

0800d870 <memset>:
 800d870:	4402      	add	r2, r0
 800d872:	4603      	mov	r3, r0
 800d874:	4293      	cmp	r3, r2
 800d876:	d100      	bne.n	800d87a <memset+0xa>
 800d878:	4770      	bx	lr
 800d87a:	f803 1b01 	strb.w	r1, [r3], #1
 800d87e:	e7f9      	b.n	800d874 <memset+0x4>

0800d880 <_close_r>:
 800d880:	b538      	push	{r3, r4, r5, lr}
 800d882:	4d06      	ldr	r5, [pc, #24]	@ (800d89c <_close_r+0x1c>)
 800d884:	2300      	movs	r3, #0
 800d886:	4604      	mov	r4, r0
 800d888:	4608      	mov	r0, r1
 800d88a:	602b      	str	r3, [r5, #0]
 800d88c:	f7fb fb92 	bl	8008fb4 <_close>
 800d890:	1c43      	adds	r3, r0, #1
 800d892:	d102      	bne.n	800d89a <_close_r+0x1a>
 800d894:	682b      	ldr	r3, [r5, #0]
 800d896:	b103      	cbz	r3, 800d89a <_close_r+0x1a>
 800d898:	6023      	str	r3, [r4, #0]
 800d89a:	bd38      	pop	{r3, r4, r5, pc}
 800d89c:	20001ed8 	.word	0x20001ed8

0800d8a0 <_lseek_r>:
 800d8a0:	b538      	push	{r3, r4, r5, lr}
 800d8a2:	4d07      	ldr	r5, [pc, #28]	@ (800d8c0 <_lseek_r+0x20>)
 800d8a4:	4604      	mov	r4, r0
 800d8a6:	4608      	mov	r0, r1
 800d8a8:	4611      	mov	r1, r2
 800d8aa:	2200      	movs	r2, #0
 800d8ac:	602a      	str	r2, [r5, #0]
 800d8ae:	461a      	mov	r2, r3
 800d8b0:	f7fb fb8a 	bl	8008fc8 <_lseek>
 800d8b4:	1c43      	adds	r3, r0, #1
 800d8b6:	d102      	bne.n	800d8be <_lseek_r+0x1e>
 800d8b8:	682b      	ldr	r3, [r5, #0]
 800d8ba:	b103      	cbz	r3, 800d8be <_lseek_r+0x1e>
 800d8bc:	6023      	str	r3, [r4, #0]
 800d8be:	bd38      	pop	{r3, r4, r5, pc}
 800d8c0:	20001ed8 	.word	0x20001ed8

0800d8c4 <_read_r>:
 800d8c4:	b538      	push	{r3, r4, r5, lr}
 800d8c6:	4d07      	ldr	r5, [pc, #28]	@ (800d8e4 <_read_r+0x20>)
 800d8c8:	4604      	mov	r4, r0
 800d8ca:	4608      	mov	r0, r1
 800d8cc:	4611      	mov	r1, r2
 800d8ce:	2200      	movs	r2, #0
 800d8d0:	602a      	str	r2, [r5, #0]
 800d8d2:	461a      	mov	r2, r3
 800d8d4:	f7fb fb37 	bl	8008f46 <_read>
 800d8d8:	1c43      	adds	r3, r0, #1
 800d8da:	d102      	bne.n	800d8e2 <_read_r+0x1e>
 800d8dc:	682b      	ldr	r3, [r5, #0]
 800d8de:	b103      	cbz	r3, 800d8e2 <_read_r+0x1e>
 800d8e0:	6023      	str	r3, [r4, #0]
 800d8e2:	bd38      	pop	{r3, r4, r5, pc}
 800d8e4:	20001ed8 	.word	0x20001ed8

0800d8e8 <_write_r>:
 800d8e8:	b538      	push	{r3, r4, r5, lr}
 800d8ea:	4d07      	ldr	r5, [pc, #28]	@ (800d908 <_write_r+0x20>)
 800d8ec:	4604      	mov	r4, r0
 800d8ee:	4608      	mov	r0, r1
 800d8f0:	4611      	mov	r1, r2
 800d8f2:	2200      	movs	r2, #0
 800d8f4:	602a      	str	r2, [r5, #0]
 800d8f6:	461a      	mov	r2, r3
 800d8f8:	f7fb fb33 	bl	8008f62 <_write>
 800d8fc:	1c43      	adds	r3, r0, #1
 800d8fe:	d102      	bne.n	800d906 <_write_r+0x1e>
 800d900:	682b      	ldr	r3, [r5, #0]
 800d902:	b103      	cbz	r3, 800d906 <_write_r+0x1e>
 800d904:	6023      	str	r3, [r4, #0]
 800d906:	bd38      	pop	{r3, r4, r5, pc}
 800d908:	20001ed8 	.word	0x20001ed8

0800d90c <__errno>:
 800d90c:	4b01      	ldr	r3, [pc, #4]	@ (800d914 <__errno+0x8>)
 800d90e:	6818      	ldr	r0, [r3, #0]
 800d910:	4770      	bx	lr
 800d912:	bf00      	nop
 800d914:	20001138 	.word	0x20001138

0800d918 <__libc_init_array>:
 800d918:	b570      	push	{r4, r5, r6, lr}
 800d91a:	4d0d      	ldr	r5, [pc, #52]	@ (800d950 <__libc_init_array+0x38>)
 800d91c:	4c0d      	ldr	r4, [pc, #52]	@ (800d954 <__libc_init_array+0x3c>)
 800d91e:	1b64      	subs	r4, r4, r5
 800d920:	10a4      	asrs	r4, r4, #2
 800d922:	2600      	movs	r6, #0
 800d924:	42a6      	cmp	r6, r4
 800d926:	d109      	bne.n	800d93c <__libc_init_array+0x24>
 800d928:	4d0b      	ldr	r5, [pc, #44]	@ (800d958 <__libc_init_array+0x40>)
 800d92a:	4c0c      	ldr	r4, [pc, #48]	@ (800d95c <__libc_init_array+0x44>)
 800d92c:	f000 fd38 	bl	800e3a0 <_init>
 800d930:	1b64      	subs	r4, r4, r5
 800d932:	10a4      	asrs	r4, r4, #2
 800d934:	2600      	movs	r6, #0
 800d936:	42a6      	cmp	r6, r4
 800d938:	d105      	bne.n	800d946 <__libc_init_array+0x2e>
 800d93a:	bd70      	pop	{r4, r5, r6, pc}
 800d93c:	f855 3b04 	ldr.w	r3, [r5], #4
 800d940:	4798      	blx	r3
 800d942:	3601      	adds	r6, #1
 800d944:	e7ee      	b.n	800d924 <__libc_init_array+0xc>
 800d946:	f855 3b04 	ldr.w	r3, [r5], #4
 800d94a:	4798      	blx	r3
 800d94c:	3601      	adds	r6, #1
 800d94e:	e7f2      	b.n	800d936 <__libc_init_array+0x1e>
 800d950:	0800ee60 	.word	0x0800ee60
 800d954:	0800ee60 	.word	0x0800ee60
 800d958:	0800ee60 	.word	0x0800ee60
 800d95c:	0800ee64 	.word	0x0800ee64

0800d960 <__retarget_lock_init_recursive>:
 800d960:	4770      	bx	lr

0800d962 <__retarget_lock_acquire_recursive>:
 800d962:	4770      	bx	lr

0800d964 <__retarget_lock_release_recursive>:
 800d964:	4770      	bx	lr

0800d966 <memcpy>:
 800d966:	440a      	add	r2, r1
 800d968:	4291      	cmp	r1, r2
 800d96a:	f100 33ff 	add.w	r3, r0, #4294967295
 800d96e:	d100      	bne.n	800d972 <memcpy+0xc>
 800d970:	4770      	bx	lr
 800d972:	b510      	push	{r4, lr}
 800d974:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d978:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d97c:	4291      	cmp	r1, r2
 800d97e:	d1f9      	bne.n	800d974 <memcpy+0xe>
 800d980:	bd10      	pop	{r4, pc}
	...

0800d984 <_free_r>:
 800d984:	b538      	push	{r3, r4, r5, lr}
 800d986:	4605      	mov	r5, r0
 800d988:	2900      	cmp	r1, #0
 800d98a:	d041      	beq.n	800da10 <_free_r+0x8c>
 800d98c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800d990:	1f0c      	subs	r4, r1, #4
 800d992:	2b00      	cmp	r3, #0
 800d994:	bfb8      	it	lt
 800d996:	18e4      	addlt	r4, r4, r3
 800d998:	f000 f8e8 	bl	800db6c <__malloc_lock>
 800d99c:	4a1d      	ldr	r2, [pc, #116]	@ (800da14 <_free_r+0x90>)
 800d99e:	6813      	ldr	r3, [r2, #0]
 800d9a0:	b933      	cbnz	r3, 800d9b0 <_free_r+0x2c>
 800d9a2:	6063      	str	r3, [r4, #4]
 800d9a4:	6014      	str	r4, [r2, #0]
 800d9a6:	4628      	mov	r0, r5
 800d9a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800d9ac:	f000 b8e4 	b.w	800db78 <__malloc_unlock>
 800d9b0:	42a3      	cmp	r3, r4
 800d9b2:	d908      	bls.n	800d9c6 <_free_r+0x42>
 800d9b4:	6820      	ldr	r0, [r4, #0]
 800d9b6:	1821      	adds	r1, r4, r0
 800d9b8:	428b      	cmp	r3, r1
 800d9ba:	bf01      	itttt	eq
 800d9bc:	6819      	ldreq	r1, [r3, #0]
 800d9be:	685b      	ldreq	r3, [r3, #4]
 800d9c0:	1809      	addeq	r1, r1, r0
 800d9c2:	6021      	streq	r1, [r4, #0]
 800d9c4:	e7ed      	b.n	800d9a2 <_free_r+0x1e>
 800d9c6:	461a      	mov	r2, r3
 800d9c8:	685b      	ldr	r3, [r3, #4]
 800d9ca:	b10b      	cbz	r3, 800d9d0 <_free_r+0x4c>
 800d9cc:	42a3      	cmp	r3, r4
 800d9ce:	d9fa      	bls.n	800d9c6 <_free_r+0x42>
 800d9d0:	6811      	ldr	r1, [r2, #0]
 800d9d2:	1850      	adds	r0, r2, r1
 800d9d4:	42a0      	cmp	r0, r4
 800d9d6:	d10b      	bne.n	800d9f0 <_free_r+0x6c>
 800d9d8:	6820      	ldr	r0, [r4, #0]
 800d9da:	4401      	add	r1, r0
 800d9dc:	1850      	adds	r0, r2, r1
 800d9de:	4283      	cmp	r3, r0
 800d9e0:	6011      	str	r1, [r2, #0]
 800d9e2:	d1e0      	bne.n	800d9a6 <_free_r+0x22>
 800d9e4:	6818      	ldr	r0, [r3, #0]
 800d9e6:	685b      	ldr	r3, [r3, #4]
 800d9e8:	6053      	str	r3, [r2, #4]
 800d9ea:	4408      	add	r0, r1
 800d9ec:	6010      	str	r0, [r2, #0]
 800d9ee:	e7da      	b.n	800d9a6 <_free_r+0x22>
 800d9f0:	d902      	bls.n	800d9f8 <_free_r+0x74>
 800d9f2:	230c      	movs	r3, #12
 800d9f4:	602b      	str	r3, [r5, #0]
 800d9f6:	e7d6      	b.n	800d9a6 <_free_r+0x22>
 800d9f8:	6820      	ldr	r0, [r4, #0]
 800d9fa:	1821      	adds	r1, r4, r0
 800d9fc:	428b      	cmp	r3, r1
 800d9fe:	bf04      	itt	eq
 800da00:	6819      	ldreq	r1, [r3, #0]
 800da02:	685b      	ldreq	r3, [r3, #4]
 800da04:	6063      	str	r3, [r4, #4]
 800da06:	bf04      	itt	eq
 800da08:	1809      	addeq	r1, r1, r0
 800da0a:	6021      	streq	r1, [r4, #0]
 800da0c:	6054      	str	r4, [r2, #4]
 800da0e:	e7ca      	b.n	800d9a6 <_free_r+0x22>
 800da10:	bd38      	pop	{r3, r4, r5, pc}
 800da12:	bf00      	nop
 800da14:	20001ee4 	.word	0x20001ee4

0800da18 <malloc>:
 800da18:	4b02      	ldr	r3, [pc, #8]	@ (800da24 <malloc+0xc>)
 800da1a:	4601      	mov	r1, r0
 800da1c:	6818      	ldr	r0, [r3, #0]
 800da1e:	f000 b825 	b.w	800da6c <_malloc_r>
 800da22:	bf00      	nop
 800da24:	20001138 	.word	0x20001138

0800da28 <sbrk_aligned>:
 800da28:	b570      	push	{r4, r5, r6, lr}
 800da2a:	4e0f      	ldr	r6, [pc, #60]	@ (800da68 <sbrk_aligned+0x40>)
 800da2c:	460c      	mov	r4, r1
 800da2e:	6831      	ldr	r1, [r6, #0]
 800da30:	4605      	mov	r5, r0
 800da32:	b911      	cbnz	r1, 800da3a <sbrk_aligned+0x12>
 800da34:	f000 fca4 	bl	800e380 <_sbrk_r>
 800da38:	6030      	str	r0, [r6, #0]
 800da3a:	4621      	mov	r1, r4
 800da3c:	4628      	mov	r0, r5
 800da3e:	f000 fc9f 	bl	800e380 <_sbrk_r>
 800da42:	1c43      	adds	r3, r0, #1
 800da44:	d103      	bne.n	800da4e <sbrk_aligned+0x26>
 800da46:	f04f 34ff 	mov.w	r4, #4294967295
 800da4a:	4620      	mov	r0, r4
 800da4c:	bd70      	pop	{r4, r5, r6, pc}
 800da4e:	1cc4      	adds	r4, r0, #3
 800da50:	f024 0403 	bic.w	r4, r4, #3
 800da54:	42a0      	cmp	r0, r4
 800da56:	d0f8      	beq.n	800da4a <sbrk_aligned+0x22>
 800da58:	1a21      	subs	r1, r4, r0
 800da5a:	4628      	mov	r0, r5
 800da5c:	f000 fc90 	bl	800e380 <_sbrk_r>
 800da60:	3001      	adds	r0, #1
 800da62:	d1f2      	bne.n	800da4a <sbrk_aligned+0x22>
 800da64:	e7ef      	b.n	800da46 <sbrk_aligned+0x1e>
 800da66:	bf00      	nop
 800da68:	20001ee0 	.word	0x20001ee0

0800da6c <_malloc_r>:
 800da6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800da70:	1ccd      	adds	r5, r1, #3
 800da72:	f025 0503 	bic.w	r5, r5, #3
 800da76:	3508      	adds	r5, #8
 800da78:	2d0c      	cmp	r5, #12
 800da7a:	bf38      	it	cc
 800da7c:	250c      	movcc	r5, #12
 800da7e:	2d00      	cmp	r5, #0
 800da80:	4606      	mov	r6, r0
 800da82:	db01      	blt.n	800da88 <_malloc_r+0x1c>
 800da84:	42a9      	cmp	r1, r5
 800da86:	d904      	bls.n	800da92 <_malloc_r+0x26>
 800da88:	230c      	movs	r3, #12
 800da8a:	6033      	str	r3, [r6, #0]
 800da8c:	2000      	movs	r0, #0
 800da8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800da92:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 800db68 <_malloc_r+0xfc>
 800da96:	f000 f869 	bl	800db6c <__malloc_lock>
 800da9a:	f8d8 3000 	ldr.w	r3, [r8]
 800da9e:	461c      	mov	r4, r3
 800daa0:	bb44      	cbnz	r4, 800daf4 <_malloc_r+0x88>
 800daa2:	4629      	mov	r1, r5
 800daa4:	4630      	mov	r0, r6
 800daa6:	f7ff ffbf 	bl	800da28 <sbrk_aligned>
 800daaa:	1c43      	adds	r3, r0, #1
 800daac:	4604      	mov	r4, r0
 800daae:	d158      	bne.n	800db62 <_malloc_r+0xf6>
 800dab0:	f8d8 4000 	ldr.w	r4, [r8]
 800dab4:	4627      	mov	r7, r4
 800dab6:	2f00      	cmp	r7, #0
 800dab8:	d143      	bne.n	800db42 <_malloc_r+0xd6>
 800daba:	2c00      	cmp	r4, #0
 800dabc:	d04b      	beq.n	800db56 <_malloc_r+0xea>
 800dabe:	6823      	ldr	r3, [r4, #0]
 800dac0:	4639      	mov	r1, r7
 800dac2:	4630      	mov	r0, r6
 800dac4:	eb04 0903 	add.w	r9, r4, r3
 800dac8:	f000 fc5a 	bl	800e380 <_sbrk_r>
 800dacc:	4581      	cmp	r9, r0
 800dace:	d142      	bne.n	800db56 <_malloc_r+0xea>
 800dad0:	6821      	ldr	r1, [r4, #0]
 800dad2:	1a6d      	subs	r5, r5, r1
 800dad4:	4629      	mov	r1, r5
 800dad6:	4630      	mov	r0, r6
 800dad8:	f7ff ffa6 	bl	800da28 <sbrk_aligned>
 800dadc:	3001      	adds	r0, #1
 800dade:	d03a      	beq.n	800db56 <_malloc_r+0xea>
 800dae0:	6823      	ldr	r3, [r4, #0]
 800dae2:	442b      	add	r3, r5
 800dae4:	6023      	str	r3, [r4, #0]
 800dae6:	f8d8 3000 	ldr.w	r3, [r8]
 800daea:	685a      	ldr	r2, [r3, #4]
 800daec:	bb62      	cbnz	r2, 800db48 <_malloc_r+0xdc>
 800daee:	f8c8 7000 	str.w	r7, [r8]
 800daf2:	e00f      	b.n	800db14 <_malloc_r+0xa8>
 800daf4:	6822      	ldr	r2, [r4, #0]
 800daf6:	1b52      	subs	r2, r2, r5
 800daf8:	d420      	bmi.n	800db3c <_malloc_r+0xd0>
 800dafa:	2a0b      	cmp	r2, #11
 800dafc:	d917      	bls.n	800db2e <_malloc_r+0xc2>
 800dafe:	1961      	adds	r1, r4, r5
 800db00:	42a3      	cmp	r3, r4
 800db02:	6025      	str	r5, [r4, #0]
 800db04:	bf18      	it	ne
 800db06:	6059      	strne	r1, [r3, #4]
 800db08:	6863      	ldr	r3, [r4, #4]
 800db0a:	bf08      	it	eq
 800db0c:	f8c8 1000 	streq.w	r1, [r8]
 800db10:	5162      	str	r2, [r4, r5]
 800db12:	604b      	str	r3, [r1, #4]
 800db14:	4630      	mov	r0, r6
 800db16:	f000 f82f 	bl	800db78 <__malloc_unlock>
 800db1a:	f104 000b 	add.w	r0, r4, #11
 800db1e:	1d23      	adds	r3, r4, #4
 800db20:	f020 0007 	bic.w	r0, r0, #7
 800db24:	1ac2      	subs	r2, r0, r3
 800db26:	bf1c      	itt	ne
 800db28:	1a1b      	subne	r3, r3, r0
 800db2a:	50a3      	strne	r3, [r4, r2]
 800db2c:	e7af      	b.n	800da8e <_malloc_r+0x22>
 800db2e:	6862      	ldr	r2, [r4, #4]
 800db30:	42a3      	cmp	r3, r4
 800db32:	bf0c      	ite	eq
 800db34:	f8c8 2000 	streq.w	r2, [r8]
 800db38:	605a      	strne	r2, [r3, #4]
 800db3a:	e7eb      	b.n	800db14 <_malloc_r+0xa8>
 800db3c:	4623      	mov	r3, r4
 800db3e:	6864      	ldr	r4, [r4, #4]
 800db40:	e7ae      	b.n	800daa0 <_malloc_r+0x34>
 800db42:	463c      	mov	r4, r7
 800db44:	687f      	ldr	r7, [r7, #4]
 800db46:	e7b6      	b.n	800dab6 <_malloc_r+0x4a>
 800db48:	461a      	mov	r2, r3
 800db4a:	685b      	ldr	r3, [r3, #4]
 800db4c:	42a3      	cmp	r3, r4
 800db4e:	d1fb      	bne.n	800db48 <_malloc_r+0xdc>
 800db50:	2300      	movs	r3, #0
 800db52:	6053      	str	r3, [r2, #4]
 800db54:	e7de      	b.n	800db14 <_malloc_r+0xa8>
 800db56:	230c      	movs	r3, #12
 800db58:	6033      	str	r3, [r6, #0]
 800db5a:	4630      	mov	r0, r6
 800db5c:	f000 f80c 	bl	800db78 <__malloc_unlock>
 800db60:	e794      	b.n	800da8c <_malloc_r+0x20>
 800db62:	6005      	str	r5, [r0, #0]
 800db64:	e7d6      	b.n	800db14 <_malloc_r+0xa8>
 800db66:	bf00      	nop
 800db68:	20001ee4 	.word	0x20001ee4

0800db6c <__malloc_lock>:
 800db6c:	4801      	ldr	r0, [pc, #4]	@ (800db74 <__malloc_lock+0x8>)
 800db6e:	f7ff bef8 	b.w	800d962 <__retarget_lock_acquire_recursive>
 800db72:	bf00      	nop
 800db74:	20001edc 	.word	0x20001edc

0800db78 <__malloc_unlock>:
 800db78:	4801      	ldr	r0, [pc, #4]	@ (800db80 <__malloc_unlock+0x8>)
 800db7a:	f7ff bef3 	b.w	800d964 <__retarget_lock_release_recursive>
 800db7e:	bf00      	nop
 800db80:	20001edc 	.word	0x20001edc

0800db84 <__sfputc_r>:
 800db84:	6893      	ldr	r3, [r2, #8]
 800db86:	3b01      	subs	r3, #1
 800db88:	2b00      	cmp	r3, #0
 800db8a:	b410      	push	{r4}
 800db8c:	6093      	str	r3, [r2, #8]
 800db8e:	da08      	bge.n	800dba2 <__sfputc_r+0x1e>
 800db90:	6994      	ldr	r4, [r2, #24]
 800db92:	42a3      	cmp	r3, r4
 800db94:	db01      	blt.n	800db9a <__sfputc_r+0x16>
 800db96:	290a      	cmp	r1, #10
 800db98:	d103      	bne.n	800dba2 <__sfputc_r+0x1e>
 800db9a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800db9e:	f7ff bdc2 	b.w	800d726 <__swbuf_r>
 800dba2:	6813      	ldr	r3, [r2, #0]
 800dba4:	1c58      	adds	r0, r3, #1
 800dba6:	6010      	str	r0, [r2, #0]
 800dba8:	7019      	strb	r1, [r3, #0]
 800dbaa:	4608      	mov	r0, r1
 800dbac:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dbb0:	4770      	bx	lr

0800dbb2 <__sfputs_r>:
 800dbb2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dbb4:	4606      	mov	r6, r0
 800dbb6:	460f      	mov	r7, r1
 800dbb8:	4614      	mov	r4, r2
 800dbba:	18d5      	adds	r5, r2, r3
 800dbbc:	42ac      	cmp	r4, r5
 800dbbe:	d101      	bne.n	800dbc4 <__sfputs_r+0x12>
 800dbc0:	2000      	movs	r0, #0
 800dbc2:	e007      	b.n	800dbd4 <__sfputs_r+0x22>
 800dbc4:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dbc8:	463a      	mov	r2, r7
 800dbca:	4630      	mov	r0, r6
 800dbcc:	f7ff ffda 	bl	800db84 <__sfputc_r>
 800dbd0:	1c43      	adds	r3, r0, #1
 800dbd2:	d1f3      	bne.n	800dbbc <__sfputs_r+0xa>
 800dbd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800dbd8 <_vfiprintf_r>:
 800dbd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dbdc:	460d      	mov	r5, r1
 800dbde:	b09d      	sub	sp, #116	@ 0x74
 800dbe0:	4614      	mov	r4, r2
 800dbe2:	4698      	mov	r8, r3
 800dbe4:	4606      	mov	r6, r0
 800dbe6:	b118      	cbz	r0, 800dbf0 <_vfiprintf_r+0x18>
 800dbe8:	6a03      	ldr	r3, [r0, #32]
 800dbea:	b90b      	cbnz	r3, 800dbf0 <_vfiprintf_r+0x18>
 800dbec:	f7ff fbfe 	bl	800d3ec <__sinit>
 800dbf0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800dbf2:	07d9      	lsls	r1, r3, #31
 800dbf4:	d405      	bmi.n	800dc02 <_vfiprintf_r+0x2a>
 800dbf6:	89ab      	ldrh	r3, [r5, #12]
 800dbf8:	059a      	lsls	r2, r3, #22
 800dbfa:	d402      	bmi.n	800dc02 <_vfiprintf_r+0x2a>
 800dbfc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800dbfe:	f7ff feb0 	bl	800d962 <__retarget_lock_acquire_recursive>
 800dc02:	89ab      	ldrh	r3, [r5, #12]
 800dc04:	071b      	lsls	r3, r3, #28
 800dc06:	d501      	bpl.n	800dc0c <_vfiprintf_r+0x34>
 800dc08:	692b      	ldr	r3, [r5, #16]
 800dc0a:	b99b      	cbnz	r3, 800dc34 <_vfiprintf_r+0x5c>
 800dc0c:	4629      	mov	r1, r5
 800dc0e:	4630      	mov	r0, r6
 800dc10:	f7ff fdc8 	bl	800d7a4 <__swsetup_r>
 800dc14:	b170      	cbz	r0, 800dc34 <_vfiprintf_r+0x5c>
 800dc16:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800dc18:	07dc      	lsls	r4, r3, #31
 800dc1a:	d504      	bpl.n	800dc26 <_vfiprintf_r+0x4e>
 800dc1c:	f04f 30ff 	mov.w	r0, #4294967295
 800dc20:	b01d      	add	sp, #116	@ 0x74
 800dc22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800dc26:	89ab      	ldrh	r3, [r5, #12]
 800dc28:	0598      	lsls	r0, r3, #22
 800dc2a:	d4f7      	bmi.n	800dc1c <_vfiprintf_r+0x44>
 800dc2c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800dc2e:	f7ff fe99 	bl	800d964 <__retarget_lock_release_recursive>
 800dc32:	e7f3      	b.n	800dc1c <_vfiprintf_r+0x44>
 800dc34:	2300      	movs	r3, #0
 800dc36:	9309      	str	r3, [sp, #36]	@ 0x24
 800dc38:	2320      	movs	r3, #32
 800dc3a:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 800dc3e:	f8cd 800c 	str.w	r8, [sp, #12]
 800dc42:	2330      	movs	r3, #48	@ 0x30
 800dc44:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 800ddf4 <_vfiprintf_r+0x21c>
 800dc48:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 800dc4c:	f04f 0901 	mov.w	r9, #1
 800dc50:	4623      	mov	r3, r4
 800dc52:	469a      	mov	sl, r3
 800dc54:	f813 2b01 	ldrb.w	r2, [r3], #1
 800dc58:	b10a      	cbz	r2, 800dc5e <_vfiprintf_r+0x86>
 800dc5a:	2a25      	cmp	r2, #37	@ 0x25
 800dc5c:	d1f9      	bne.n	800dc52 <_vfiprintf_r+0x7a>
 800dc5e:	ebba 0b04 	subs.w	fp, sl, r4
 800dc62:	d00b      	beq.n	800dc7c <_vfiprintf_r+0xa4>
 800dc64:	465b      	mov	r3, fp
 800dc66:	4622      	mov	r2, r4
 800dc68:	4629      	mov	r1, r5
 800dc6a:	4630      	mov	r0, r6
 800dc6c:	f7ff ffa1 	bl	800dbb2 <__sfputs_r>
 800dc70:	3001      	adds	r0, #1
 800dc72:	f000 80a7 	beq.w	800ddc4 <_vfiprintf_r+0x1ec>
 800dc76:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800dc78:	445a      	add	r2, fp
 800dc7a:	9209      	str	r2, [sp, #36]	@ 0x24
 800dc7c:	f89a 3000 	ldrb.w	r3, [sl]
 800dc80:	2b00      	cmp	r3, #0
 800dc82:	f000 809f 	beq.w	800ddc4 <_vfiprintf_r+0x1ec>
 800dc86:	2300      	movs	r3, #0
 800dc88:	f04f 32ff 	mov.w	r2, #4294967295
 800dc8c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800dc90:	f10a 0a01 	add.w	sl, sl, #1
 800dc94:	9304      	str	r3, [sp, #16]
 800dc96:	9307      	str	r3, [sp, #28]
 800dc98:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 800dc9c:	931a      	str	r3, [sp, #104]	@ 0x68
 800dc9e:	4654      	mov	r4, sl
 800dca0:	2205      	movs	r2, #5
 800dca2:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dca6:	4853      	ldr	r0, [pc, #332]	@ (800ddf4 <_vfiprintf_r+0x21c>)
 800dca8:	f7fa fed2 	bl	8008a50 <memchr>
 800dcac:	9a04      	ldr	r2, [sp, #16]
 800dcae:	b9d8      	cbnz	r0, 800dce8 <_vfiprintf_r+0x110>
 800dcb0:	06d1      	lsls	r1, r2, #27
 800dcb2:	bf44      	itt	mi
 800dcb4:	2320      	movmi	r3, #32
 800dcb6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800dcba:	0713      	lsls	r3, r2, #28
 800dcbc:	bf44      	itt	mi
 800dcbe:	232b      	movmi	r3, #43	@ 0x2b
 800dcc0:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800dcc4:	f89a 3000 	ldrb.w	r3, [sl]
 800dcc8:	2b2a      	cmp	r3, #42	@ 0x2a
 800dcca:	d015      	beq.n	800dcf8 <_vfiprintf_r+0x120>
 800dccc:	9a07      	ldr	r2, [sp, #28]
 800dcce:	4654      	mov	r4, sl
 800dcd0:	2000      	movs	r0, #0
 800dcd2:	f04f 0c0a 	mov.w	ip, #10
 800dcd6:	4621      	mov	r1, r4
 800dcd8:	f811 3b01 	ldrb.w	r3, [r1], #1
 800dcdc:	3b30      	subs	r3, #48	@ 0x30
 800dcde:	2b09      	cmp	r3, #9
 800dce0:	d94b      	bls.n	800dd7a <_vfiprintf_r+0x1a2>
 800dce2:	b1b0      	cbz	r0, 800dd12 <_vfiprintf_r+0x13a>
 800dce4:	9207      	str	r2, [sp, #28]
 800dce6:	e014      	b.n	800dd12 <_vfiprintf_r+0x13a>
 800dce8:	eba0 0308 	sub.w	r3, r0, r8
 800dcec:	fa09 f303 	lsl.w	r3, r9, r3
 800dcf0:	4313      	orrs	r3, r2
 800dcf2:	9304      	str	r3, [sp, #16]
 800dcf4:	46a2      	mov	sl, r4
 800dcf6:	e7d2      	b.n	800dc9e <_vfiprintf_r+0xc6>
 800dcf8:	9b03      	ldr	r3, [sp, #12]
 800dcfa:	1d19      	adds	r1, r3, #4
 800dcfc:	681b      	ldr	r3, [r3, #0]
 800dcfe:	9103      	str	r1, [sp, #12]
 800dd00:	2b00      	cmp	r3, #0
 800dd02:	bfbb      	ittet	lt
 800dd04:	425b      	neglt	r3, r3
 800dd06:	f042 0202 	orrlt.w	r2, r2, #2
 800dd0a:	9307      	strge	r3, [sp, #28]
 800dd0c:	9307      	strlt	r3, [sp, #28]
 800dd0e:	bfb8      	it	lt
 800dd10:	9204      	strlt	r2, [sp, #16]
 800dd12:	7823      	ldrb	r3, [r4, #0]
 800dd14:	2b2e      	cmp	r3, #46	@ 0x2e
 800dd16:	d10a      	bne.n	800dd2e <_vfiprintf_r+0x156>
 800dd18:	7863      	ldrb	r3, [r4, #1]
 800dd1a:	2b2a      	cmp	r3, #42	@ 0x2a
 800dd1c:	d132      	bne.n	800dd84 <_vfiprintf_r+0x1ac>
 800dd1e:	9b03      	ldr	r3, [sp, #12]
 800dd20:	1d1a      	adds	r2, r3, #4
 800dd22:	681b      	ldr	r3, [r3, #0]
 800dd24:	9203      	str	r2, [sp, #12]
 800dd26:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 800dd2a:	3402      	adds	r4, #2
 800dd2c:	9305      	str	r3, [sp, #20]
 800dd2e:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 800de04 <_vfiprintf_r+0x22c>
 800dd32:	7821      	ldrb	r1, [r4, #0]
 800dd34:	2203      	movs	r2, #3
 800dd36:	4650      	mov	r0, sl
 800dd38:	f7fa fe8a 	bl	8008a50 <memchr>
 800dd3c:	b138      	cbz	r0, 800dd4e <_vfiprintf_r+0x176>
 800dd3e:	9b04      	ldr	r3, [sp, #16]
 800dd40:	eba0 000a 	sub.w	r0, r0, sl
 800dd44:	2240      	movs	r2, #64	@ 0x40
 800dd46:	4082      	lsls	r2, r0
 800dd48:	4313      	orrs	r3, r2
 800dd4a:	3401      	adds	r4, #1
 800dd4c:	9304      	str	r3, [sp, #16]
 800dd4e:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dd52:	4829      	ldr	r0, [pc, #164]	@ (800ddf8 <_vfiprintf_r+0x220>)
 800dd54:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 800dd58:	2206      	movs	r2, #6
 800dd5a:	f7fa fe79 	bl	8008a50 <memchr>
 800dd5e:	2800      	cmp	r0, #0
 800dd60:	d03f      	beq.n	800dde2 <_vfiprintf_r+0x20a>
 800dd62:	4b26      	ldr	r3, [pc, #152]	@ (800ddfc <_vfiprintf_r+0x224>)
 800dd64:	bb1b      	cbnz	r3, 800ddae <_vfiprintf_r+0x1d6>
 800dd66:	9b03      	ldr	r3, [sp, #12]
 800dd68:	3307      	adds	r3, #7
 800dd6a:	f023 0307 	bic.w	r3, r3, #7
 800dd6e:	3308      	adds	r3, #8
 800dd70:	9303      	str	r3, [sp, #12]
 800dd72:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800dd74:	443b      	add	r3, r7
 800dd76:	9309      	str	r3, [sp, #36]	@ 0x24
 800dd78:	e76a      	b.n	800dc50 <_vfiprintf_r+0x78>
 800dd7a:	fb0c 3202 	mla	r2, ip, r2, r3
 800dd7e:	460c      	mov	r4, r1
 800dd80:	2001      	movs	r0, #1
 800dd82:	e7a8      	b.n	800dcd6 <_vfiprintf_r+0xfe>
 800dd84:	2300      	movs	r3, #0
 800dd86:	3401      	adds	r4, #1
 800dd88:	9305      	str	r3, [sp, #20]
 800dd8a:	4619      	mov	r1, r3
 800dd8c:	f04f 0c0a 	mov.w	ip, #10
 800dd90:	4620      	mov	r0, r4
 800dd92:	f810 2b01 	ldrb.w	r2, [r0], #1
 800dd96:	3a30      	subs	r2, #48	@ 0x30
 800dd98:	2a09      	cmp	r2, #9
 800dd9a:	d903      	bls.n	800dda4 <_vfiprintf_r+0x1cc>
 800dd9c:	2b00      	cmp	r3, #0
 800dd9e:	d0c6      	beq.n	800dd2e <_vfiprintf_r+0x156>
 800dda0:	9105      	str	r1, [sp, #20]
 800dda2:	e7c4      	b.n	800dd2e <_vfiprintf_r+0x156>
 800dda4:	fb0c 2101 	mla	r1, ip, r1, r2
 800dda8:	4604      	mov	r4, r0
 800ddaa:	2301      	movs	r3, #1
 800ddac:	e7f0      	b.n	800dd90 <_vfiprintf_r+0x1b8>
 800ddae:	ab03      	add	r3, sp, #12
 800ddb0:	9300      	str	r3, [sp, #0]
 800ddb2:	462a      	mov	r2, r5
 800ddb4:	4b12      	ldr	r3, [pc, #72]	@ (800de00 <_vfiprintf_r+0x228>)
 800ddb6:	a904      	add	r1, sp, #16
 800ddb8:	4630      	mov	r0, r6
 800ddba:	f3af 8000 	nop.w
 800ddbe:	4607      	mov	r7, r0
 800ddc0:	1c78      	adds	r0, r7, #1
 800ddc2:	d1d6      	bne.n	800dd72 <_vfiprintf_r+0x19a>
 800ddc4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800ddc6:	07d9      	lsls	r1, r3, #31
 800ddc8:	d405      	bmi.n	800ddd6 <_vfiprintf_r+0x1fe>
 800ddca:	89ab      	ldrh	r3, [r5, #12]
 800ddcc:	059a      	lsls	r2, r3, #22
 800ddce:	d402      	bmi.n	800ddd6 <_vfiprintf_r+0x1fe>
 800ddd0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800ddd2:	f7ff fdc7 	bl	800d964 <__retarget_lock_release_recursive>
 800ddd6:	89ab      	ldrh	r3, [r5, #12]
 800ddd8:	065b      	lsls	r3, r3, #25
 800ddda:	f53f af1f 	bmi.w	800dc1c <_vfiprintf_r+0x44>
 800ddde:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800dde0:	e71e      	b.n	800dc20 <_vfiprintf_r+0x48>
 800dde2:	ab03      	add	r3, sp, #12
 800dde4:	9300      	str	r3, [sp, #0]
 800dde6:	462a      	mov	r2, r5
 800dde8:	4b05      	ldr	r3, [pc, #20]	@ (800de00 <_vfiprintf_r+0x228>)
 800ddea:	a904      	add	r1, sp, #16
 800ddec:	4630      	mov	r0, r6
 800ddee:	f000 f879 	bl	800dee4 <_printf_i>
 800ddf2:	e7e4      	b.n	800ddbe <_vfiprintf_r+0x1e6>
 800ddf4:	0800ee20 	.word	0x0800ee20
 800ddf8:	0800ee2a 	.word	0x0800ee2a
 800ddfc:	00000000 	.word	0x00000000
 800de00:	0800dbb3 	.word	0x0800dbb3
 800de04:	0800ee26 	.word	0x0800ee26

0800de08 <_printf_common>:
 800de08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800de0c:	4616      	mov	r6, r2
 800de0e:	4698      	mov	r8, r3
 800de10:	688a      	ldr	r2, [r1, #8]
 800de12:	690b      	ldr	r3, [r1, #16]
 800de14:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800de18:	4293      	cmp	r3, r2
 800de1a:	bfb8      	it	lt
 800de1c:	4613      	movlt	r3, r2
 800de1e:	6033      	str	r3, [r6, #0]
 800de20:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 800de24:	4607      	mov	r7, r0
 800de26:	460c      	mov	r4, r1
 800de28:	b10a      	cbz	r2, 800de2e <_printf_common+0x26>
 800de2a:	3301      	adds	r3, #1
 800de2c:	6033      	str	r3, [r6, #0]
 800de2e:	6823      	ldr	r3, [r4, #0]
 800de30:	0699      	lsls	r1, r3, #26
 800de32:	bf42      	ittt	mi
 800de34:	6833      	ldrmi	r3, [r6, #0]
 800de36:	3302      	addmi	r3, #2
 800de38:	6033      	strmi	r3, [r6, #0]
 800de3a:	6825      	ldr	r5, [r4, #0]
 800de3c:	f015 0506 	ands.w	r5, r5, #6
 800de40:	d106      	bne.n	800de50 <_printf_common+0x48>
 800de42:	f104 0a19 	add.w	sl, r4, #25
 800de46:	68e3      	ldr	r3, [r4, #12]
 800de48:	6832      	ldr	r2, [r6, #0]
 800de4a:	1a9b      	subs	r3, r3, r2
 800de4c:	42ab      	cmp	r3, r5
 800de4e:	dc26      	bgt.n	800de9e <_printf_common+0x96>
 800de50:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 800de54:	6822      	ldr	r2, [r4, #0]
 800de56:	3b00      	subs	r3, #0
 800de58:	bf18      	it	ne
 800de5a:	2301      	movne	r3, #1
 800de5c:	0692      	lsls	r2, r2, #26
 800de5e:	d42b      	bmi.n	800deb8 <_printf_common+0xb0>
 800de60:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 800de64:	4641      	mov	r1, r8
 800de66:	4638      	mov	r0, r7
 800de68:	47c8      	blx	r9
 800de6a:	3001      	adds	r0, #1
 800de6c:	d01e      	beq.n	800deac <_printf_common+0xa4>
 800de6e:	6823      	ldr	r3, [r4, #0]
 800de70:	6922      	ldr	r2, [r4, #16]
 800de72:	f003 0306 	and.w	r3, r3, #6
 800de76:	2b04      	cmp	r3, #4
 800de78:	bf02      	ittt	eq
 800de7a:	68e5      	ldreq	r5, [r4, #12]
 800de7c:	6833      	ldreq	r3, [r6, #0]
 800de7e:	1aed      	subeq	r5, r5, r3
 800de80:	68a3      	ldr	r3, [r4, #8]
 800de82:	bf0c      	ite	eq
 800de84:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800de88:	2500      	movne	r5, #0
 800de8a:	4293      	cmp	r3, r2
 800de8c:	bfc4      	itt	gt
 800de8e:	1a9b      	subgt	r3, r3, r2
 800de90:	18ed      	addgt	r5, r5, r3
 800de92:	2600      	movs	r6, #0
 800de94:	341a      	adds	r4, #26
 800de96:	42b5      	cmp	r5, r6
 800de98:	d11a      	bne.n	800ded0 <_printf_common+0xc8>
 800de9a:	2000      	movs	r0, #0
 800de9c:	e008      	b.n	800deb0 <_printf_common+0xa8>
 800de9e:	2301      	movs	r3, #1
 800dea0:	4652      	mov	r2, sl
 800dea2:	4641      	mov	r1, r8
 800dea4:	4638      	mov	r0, r7
 800dea6:	47c8      	blx	r9
 800dea8:	3001      	adds	r0, #1
 800deaa:	d103      	bne.n	800deb4 <_printf_common+0xac>
 800deac:	f04f 30ff 	mov.w	r0, #4294967295
 800deb0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800deb4:	3501      	adds	r5, #1
 800deb6:	e7c6      	b.n	800de46 <_printf_common+0x3e>
 800deb8:	18e1      	adds	r1, r4, r3
 800deba:	1c5a      	adds	r2, r3, #1
 800debc:	2030      	movs	r0, #48	@ 0x30
 800debe:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 800dec2:	4422      	add	r2, r4
 800dec4:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 800dec8:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 800decc:	3302      	adds	r3, #2
 800dece:	e7c7      	b.n	800de60 <_printf_common+0x58>
 800ded0:	2301      	movs	r3, #1
 800ded2:	4622      	mov	r2, r4
 800ded4:	4641      	mov	r1, r8
 800ded6:	4638      	mov	r0, r7
 800ded8:	47c8      	blx	r9
 800deda:	3001      	adds	r0, #1
 800dedc:	d0e6      	beq.n	800deac <_printf_common+0xa4>
 800dede:	3601      	adds	r6, #1
 800dee0:	e7d9      	b.n	800de96 <_printf_common+0x8e>
	...

0800dee4 <_printf_i>:
 800dee4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800dee8:	7e0f      	ldrb	r7, [r1, #24]
 800deea:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 800deec:	2f78      	cmp	r7, #120	@ 0x78
 800deee:	4691      	mov	r9, r2
 800def0:	4680      	mov	r8, r0
 800def2:	460c      	mov	r4, r1
 800def4:	469a      	mov	sl, r3
 800def6:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 800defa:	d807      	bhi.n	800df0c <_printf_i+0x28>
 800defc:	2f62      	cmp	r7, #98	@ 0x62
 800defe:	d80a      	bhi.n	800df16 <_printf_i+0x32>
 800df00:	2f00      	cmp	r7, #0
 800df02:	f000 80d1 	beq.w	800e0a8 <_printf_i+0x1c4>
 800df06:	2f58      	cmp	r7, #88	@ 0x58
 800df08:	f000 80b8 	beq.w	800e07c <_printf_i+0x198>
 800df0c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800df10:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 800df14:	e03a      	b.n	800df8c <_printf_i+0xa8>
 800df16:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 800df1a:	2b15      	cmp	r3, #21
 800df1c:	d8f6      	bhi.n	800df0c <_printf_i+0x28>
 800df1e:	a101      	add	r1, pc, #4	@ (adr r1, 800df24 <_printf_i+0x40>)
 800df20:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800df24:	0800df7d 	.word	0x0800df7d
 800df28:	0800df91 	.word	0x0800df91
 800df2c:	0800df0d 	.word	0x0800df0d
 800df30:	0800df0d 	.word	0x0800df0d
 800df34:	0800df0d 	.word	0x0800df0d
 800df38:	0800df0d 	.word	0x0800df0d
 800df3c:	0800df91 	.word	0x0800df91
 800df40:	0800df0d 	.word	0x0800df0d
 800df44:	0800df0d 	.word	0x0800df0d
 800df48:	0800df0d 	.word	0x0800df0d
 800df4c:	0800df0d 	.word	0x0800df0d
 800df50:	0800e08f 	.word	0x0800e08f
 800df54:	0800dfbb 	.word	0x0800dfbb
 800df58:	0800e049 	.word	0x0800e049
 800df5c:	0800df0d 	.word	0x0800df0d
 800df60:	0800df0d 	.word	0x0800df0d
 800df64:	0800e0b1 	.word	0x0800e0b1
 800df68:	0800df0d 	.word	0x0800df0d
 800df6c:	0800dfbb 	.word	0x0800dfbb
 800df70:	0800df0d 	.word	0x0800df0d
 800df74:	0800df0d 	.word	0x0800df0d
 800df78:	0800e051 	.word	0x0800e051
 800df7c:	6833      	ldr	r3, [r6, #0]
 800df7e:	1d1a      	adds	r2, r3, #4
 800df80:	681b      	ldr	r3, [r3, #0]
 800df82:	6032      	str	r2, [r6, #0]
 800df84:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800df88:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 800df8c:	2301      	movs	r3, #1
 800df8e:	e09c      	b.n	800e0ca <_printf_i+0x1e6>
 800df90:	6833      	ldr	r3, [r6, #0]
 800df92:	6820      	ldr	r0, [r4, #0]
 800df94:	1d19      	adds	r1, r3, #4
 800df96:	6031      	str	r1, [r6, #0]
 800df98:	0606      	lsls	r6, r0, #24
 800df9a:	d501      	bpl.n	800dfa0 <_printf_i+0xbc>
 800df9c:	681d      	ldr	r5, [r3, #0]
 800df9e:	e003      	b.n	800dfa8 <_printf_i+0xc4>
 800dfa0:	0645      	lsls	r5, r0, #25
 800dfa2:	d5fb      	bpl.n	800df9c <_printf_i+0xb8>
 800dfa4:	f9b3 5000 	ldrsh.w	r5, [r3]
 800dfa8:	2d00      	cmp	r5, #0
 800dfaa:	da03      	bge.n	800dfb4 <_printf_i+0xd0>
 800dfac:	232d      	movs	r3, #45	@ 0x2d
 800dfae:	426d      	negs	r5, r5
 800dfb0:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800dfb4:	4858      	ldr	r0, [pc, #352]	@ (800e118 <_printf_i+0x234>)
 800dfb6:	230a      	movs	r3, #10
 800dfb8:	e011      	b.n	800dfde <_printf_i+0xfa>
 800dfba:	6821      	ldr	r1, [r4, #0]
 800dfbc:	6833      	ldr	r3, [r6, #0]
 800dfbe:	0608      	lsls	r0, r1, #24
 800dfc0:	f853 5b04 	ldr.w	r5, [r3], #4
 800dfc4:	d402      	bmi.n	800dfcc <_printf_i+0xe8>
 800dfc6:	0649      	lsls	r1, r1, #25
 800dfc8:	bf48      	it	mi
 800dfca:	b2ad      	uxthmi	r5, r5
 800dfcc:	2f6f      	cmp	r7, #111	@ 0x6f
 800dfce:	4852      	ldr	r0, [pc, #328]	@ (800e118 <_printf_i+0x234>)
 800dfd0:	6033      	str	r3, [r6, #0]
 800dfd2:	bf14      	ite	ne
 800dfd4:	230a      	movne	r3, #10
 800dfd6:	2308      	moveq	r3, #8
 800dfd8:	2100      	movs	r1, #0
 800dfda:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 800dfde:	6866      	ldr	r6, [r4, #4]
 800dfe0:	60a6      	str	r6, [r4, #8]
 800dfe2:	2e00      	cmp	r6, #0
 800dfe4:	db05      	blt.n	800dff2 <_printf_i+0x10e>
 800dfe6:	6821      	ldr	r1, [r4, #0]
 800dfe8:	432e      	orrs	r6, r5
 800dfea:	f021 0104 	bic.w	r1, r1, #4
 800dfee:	6021      	str	r1, [r4, #0]
 800dff0:	d04b      	beq.n	800e08a <_printf_i+0x1a6>
 800dff2:	4616      	mov	r6, r2
 800dff4:	fbb5 f1f3 	udiv	r1, r5, r3
 800dff8:	fb03 5711 	mls	r7, r3, r1, r5
 800dffc:	5dc7      	ldrb	r7, [r0, r7]
 800dffe:	f806 7d01 	strb.w	r7, [r6, #-1]!
 800e002:	462f      	mov	r7, r5
 800e004:	42bb      	cmp	r3, r7
 800e006:	460d      	mov	r5, r1
 800e008:	d9f4      	bls.n	800dff4 <_printf_i+0x110>
 800e00a:	2b08      	cmp	r3, #8
 800e00c:	d10b      	bne.n	800e026 <_printf_i+0x142>
 800e00e:	6823      	ldr	r3, [r4, #0]
 800e010:	07df      	lsls	r7, r3, #31
 800e012:	d508      	bpl.n	800e026 <_printf_i+0x142>
 800e014:	6923      	ldr	r3, [r4, #16]
 800e016:	6861      	ldr	r1, [r4, #4]
 800e018:	4299      	cmp	r1, r3
 800e01a:	bfde      	ittt	le
 800e01c:	2330      	movle	r3, #48	@ 0x30
 800e01e:	f806 3c01 	strble.w	r3, [r6, #-1]
 800e022:	f106 36ff 	addle.w	r6, r6, #4294967295
 800e026:	1b92      	subs	r2, r2, r6
 800e028:	6122      	str	r2, [r4, #16]
 800e02a:	f8cd a000 	str.w	sl, [sp]
 800e02e:	464b      	mov	r3, r9
 800e030:	aa03      	add	r2, sp, #12
 800e032:	4621      	mov	r1, r4
 800e034:	4640      	mov	r0, r8
 800e036:	f7ff fee7 	bl	800de08 <_printf_common>
 800e03a:	3001      	adds	r0, #1
 800e03c:	d14a      	bne.n	800e0d4 <_printf_i+0x1f0>
 800e03e:	f04f 30ff 	mov.w	r0, #4294967295
 800e042:	b004      	add	sp, #16
 800e044:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e048:	6823      	ldr	r3, [r4, #0]
 800e04a:	f043 0320 	orr.w	r3, r3, #32
 800e04e:	6023      	str	r3, [r4, #0]
 800e050:	4832      	ldr	r0, [pc, #200]	@ (800e11c <_printf_i+0x238>)
 800e052:	2778      	movs	r7, #120	@ 0x78
 800e054:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 800e058:	6823      	ldr	r3, [r4, #0]
 800e05a:	6831      	ldr	r1, [r6, #0]
 800e05c:	061f      	lsls	r7, r3, #24
 800e05e:	f851 5b04 	ldr.w	r5, [r1], #4
 800e062:	d402      	bmi.n	800e06a <_printf_i+0x186>
 800e064:	065f      	lsls	r7, r3, #25
 800e066:	bf48      	it	mi
 800e068:	b2ad      	uxthmi	r5, r5
 800e06a:	6031      	str	r1, [r6, #0]
 800e06c:	07d9      	lsls	r1, r3, #31
 800e06e:	bf44      	itt	mi
 800e070:	f043 0320 	orrmi.w	r3, r3, #32
 800e074:	6023      	strmi	r3, [r4, #0]
 800e076:	b11d      	cbz	r5, 800e080 <_printf_i+0x19c>
 800e078:	2310      	movs	r3, #16
 800e07a:	e7ad      	b.n	800dfd8 <_printf_i+0xf4>
 800e07c:	4826      	ldr	r0, [pc, #152]	@ (800e118 <_printf_i+0x234>)
 800e07e:	e7e9      	b.n	800e054 <_printf_i+0x170>
 800e080:	6823      	ldr	r3, [r4, #0]
 800e082:	f023 0320 	bic.w	r3, r3, #32
 800e086:	6023      	str	r3, [r4, #0]
 800e088:	e7f6      	b.n	800e078 <_printf_i+0x194>
 800e08a:	4616      	mov	r6, r2
 800e08c:	e7bd      	b.n	800e00a <_printf_i+0x126>
 800e08e:	6833      	ldr	r3, [r6, #0]
 800e090:	6825      	ldr	r5, [r4, #0]
 800e092:	6961      	ldr	r1, [r4, #20]
 800e094:	1d18      	adds	r0, r3, #4
 800e096:	6030      	str	r0, [r6, #0]
 800e098:	062e      	lsls	r6, r5, #24
 800e09a:	681b      	ldr	r3, [r3, #0]
 800e09c:	d501      	bpl.n	800e0a2 <_printf_i+0x1be>
 800e09e:	6019      	str	r1, [r3, #0]
 800e0a0:	e002      	b.n	800e0a8 <_printf_i+0x1c4>
 800e0a2:	0668      	lsls	r0, r5, #25
 800e0a4:	d5fb      	bpl.n	800e09e <_printf_i+0x1ba>
 800e0a6:	8019      	strh	r1, [r3, #0]
 800e0a8:	2300      	movs	r3, #0
 800e0aa:	6123      	str	r3, [r4, #16]
 800e0ac:	4616      	mov	r6, r2
 800e0ae:	e7bc      	b.n	800e02a <_printf_i+0x146>
 800e0b0:	6833      	ldr	r3, [r6, #0]
 800e0b2:	1d1a      	adds	r2, r3, #4
 800e0b4:	6032      	str	r2, [r6, #0]
 800e0b6:	681e      	ldr	r6, [r3, #0]
 800e0b8:	6862      	ldr	r2, [r4, #4]
 800e0ba:	2100      	movs	r1, #0
 800e0bc:	4630      	mov	r0, r6
 800e0be:	f7fa fcc7 	bl	8008a50 <memchr>
 800e0c2:	b108      	cbz	r0, 800e0c8 <_printf_i+0x1e4>
 800e0c4:	1b80      	subs	r0, r0, r6
 800e0c6:	6060      	str	r0, [r4, #4]
 800e0c8:	6863      	ldr	r3, [r4, #4]
 800e0ca:	6123      	str	r3, [r4, #16]
 800e0cc:	2300      	movs	r3, #0
 800e0ce:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800e0d2:	e7aa      	b.n	800e02a <_printf_i+0x146>
 800e0d4:	6923      	ldr	r3, [r4, #16]
 800e0d6:	4632      	mov	r2, r6
 800e0d8:	4649      	mov	r1, r9
 800e0da:	4640      	mov	r0, r8
 800e0dc:	47d0      	blx	sl
 800e0de:	3001      	adds	r0, #1
 800e0e0:	d0ad      	beq.n	800e03e <_printf_i+0x15a>
 800e0e2:	6823      	ldr	r3, [r4, #0]
 800e0e4:	079b      	lsls	r3, r3, #30
 800e0e6:	d413      	bmi.n	800e110 <_printf_i+0x22c>
 800e0e8:	68e0      	ldr	r0, [r4, #12]
 800e0ea:	9b03      	ldr	r3, [sp, #12]
 800e0ec:	4298      	cmp	r0, r3
 800e0ee:	bfb8      	it	lt
 800e0f0:	4618      	movlt	r0, r3
 800e0f2:	e7a6      	b.n	800e042 <_printf_i+0x15e>
 800e0f4:	2301      	movs	r3, #1
 800e0f6:	4632      	mov	r2, r6
 800e0f8:	4649      	mov	r1, r9
 800e0fa:	4640      	mov	r0, r8
 800e0fc:	47d0      	blx	sl
 800e0fe:	3001      	adds	r0, #1
 800e100:	d09d      	beq.n	800e03e <_printf_i+0x15a>
 800e102:	3501      	adds	r5, #1
 800e104:	68e3      	ldr	r3, [r4, #12]
 800e106:	9903      	ldr	r1, [sp, #12]
 800e108:	1a5b      	subs	r3, r3, r1
 800e10a:	42ab      	cmp	r3, r5
 800e10c:	dcf2      	bgt.n	800e0f4 <_printf_i+0x210>
 800e10e:	e7eb      	b.n	800e0e8 <_printf_i+0x204>
 800e110:	2500      	movs	r5, #0
 800e112:	f104 0619 	add.w	r6, r4, #25
 800e116:	e7f5      	b.n	800e104 <_printf_i+0x220>
 800e118:	0800ee31 	.word	0x0800ee31
 800e11c:	0800ee42 	.word	0x0800ee42

0800e120 <__sflush_r>:
 800e120:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 800e124:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e128:	0716      	lsls	r6, r2, #28
 800e12a:	4605      	mov	r5, r0
 800e12c:	460c      	mov	r4, r1
 800e12e:	d454      	bmi.n	800e1da <__sflush_r+0xba>
 800e130:	684b      	ldr	r3, [r1, #4]
 800e132:	2b00      	cmp	r3, #0
 800e134:	dc02      	bgt.n	800e13c <__sflush_r+0x1c>
 800e136:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800e138:	2b00      	cmp	r3, #0
 800e13a:	dd48      	ble.n	800e1ce <__sflush_r+0xae>
 800e13c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 800e13e:	2e00      	cmp	r6, #0
 800e140:	d045      	beq.n	800e1ce <__sflush_r+0xae>
 800e142:	2300      	movs	r3, #0
 800e144:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 800e148:	682f      	ldr	r7, [r5, #0]
 800e14a:	6a21      	ldr	r1, [r4, #32]
 800e14c:	602b      	str	r3, [r5, #0]
 800e14e:	d030      	beq.n	800e1b2 <__sflush_r+0x92>
 800e150:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800e152:	89a3      	ldrh	r3, [r4, #12]
 800e154:	0759      	lsls	r1, r3, #29
 800e156:	d505      	bpl.n	800e164 <__sflush_r+0x44>
 800e158:	6863      	ldr	r3, [r4, #4]
 800e15a:	1ad2      	subs	r2, r2, r3
 800e15c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800e15e:	b10b      	cbz	r3, 800e164 <__sflush_r+0x44>
 800e160:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 800e162:	1ad2      	subs	r2, r2, r3
 800e164:	2300      	movs	r3, #0
 800e166:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 800e168:	6a21      	ldr	r1, [r4, #32]
 800e16a:	4628      	mov	r0, r5
 800e16c:	47b0      	blx	r6
 800e16e:	1c43      	adds	r3, r0, #1
 800e170:	89a3      	ldrh	r3, [r4, #12]
 800e172:	d106      	bne.n	800e182 <__sflush_r+0x62>
 800e174:	6829      	ldr	r1, [r5, #0]
 800e176:	291d      	cmp	r1, #29
 800e178:	d82b      	bhi.n	800e1d2 <__sflush_r+0xb2>
 800e17a:	4a2a      	ldr	r2, [pc, #168]	@ (800e224 <__sflush_r+0x104>)
 800e17c:	40ca      	lsrs	r2, r1
 800e17e:	07d6      	lsls	r6, r2, #31
 800e180:	d527      	bpl.n	800e1d2 <__sflush_r+0xb2>
 800e182:	2200      	movs	r2, #0
 800e184:	6062      	str	r2, [r4, #4]
 800e186:	04d9      	lsls	r1, r3, #19
 800e188:	6922      	ldr	r2, [r4, #16]
 800e18a:	6022      	str	r2, [r4, #0]
 800e18c:	d504      	bpl.n	800e198 <__sflush_r+0x78>
 800e18e:	1c42      	adds	r2, r0, #1
 800e190:	d101      	bne.n	800e196 <__sflush_r+0x76>
 800e192:	682b      	ldr	r3, [r5, #0]
 800e194:	b903      	cbnz	r3, 800e198 <__sflush_r+0x78>
 800e196:	6560      	str	r0, [r4, #84]	@ 0x54
 800e198:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800e19a:	602f      	str	r7, [r5, #0]
 800e19c:	b1b9      	cbz	r1, 800e1ce <__sflush_r+0xae>
 800e19e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800e1a2:	4299      	cmp	r1, r3
 800e1a4:	d002      	beq.n	800e1ac <__sflush_r+0x8c>
 800e1a6:	4628      	mov	r0, r5
 800e1a8:	f7ff fbec 	bl	800d984 <_free_r>
 800e1ac:	2300      	movs	r3, #0
 800e1ae:	6363      	str	r3, [r4, #52]	@ 0x34
 800e1b0:	e00d      	b.n	800e1ce <__sflush_r+0xae>
 800e1b2:	2301      	movs	r3, #1
 800e1b4:	4628      	mov	r0, r5
 800e1b6:	47b0      	blx	r6
 800e1b8:	4602      	mov	r2, r0
 800e1ba:	1c50      	adds	r0, r2, #1
 800e1bc:	d1c9      	bne.n	800e152 <__sflush_r+0x32>
 800e1be:	682b      	ldr	r3, [r5, #0]
 800e1c0:	2b00      	cmp	r3, #0
 800e1c2:	d0c6      	beq.n	800e152 <__sflush_r+0x32>
 800e1c4:	2b1d      	cmp	r3, #29
 800e1c6:	d001      	beq.n	800e1cc <__sflush_r+0xac>
 800e1c8:	2b16      	cmp	r3, #22
 800e1ca:	d11e      	bne.n	800e20a <__sflush_r+0xea>
 800e1cc:	602f      	str	r7, [r5, #0]
 800e1ce:	2000      	movs	r0, #0
 800e1d0:	e022      	b.n	800e218 <__sflush_r+0xf8>
 800e1d2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800e1d6:	b21b      	sxth	r3, r3
 800e1d8:	e01b      	b.n	800e212 <__sflush_r+0xf2>
 800e1da:	690f      	ldr	r7, [r1, #16]
 800e1dc:	2f00      	cmp	r7, #0
 800e1de:	d0f6      	beq.n	800e1ce <__sflush_r+0xae>
 800e1e0:	0793      	lsls	r3, r2, #30
 800e1e2:	680e      	ldr	r6, [r1, #0]
 800e1e4:	bf08      	it	eq
 800e1e6:	694b      	ldreq	r3, [r1, #20]
 800e1e8:	600f      	str	r7, [r1, #0]
 800e1ea:	bf18      	it	ne
 800e1ec:	2300      	movne	r3, #0
 800e1ee:	eba6 0807 	sub.w	r8, r6, r7
 800e1f2:	608b      	str	r3, [r1, #8]
 800e1f4:	f1b8 0f00 	cmp.w	r8, #0
 800e1f8:	dde9      	ble.n	800e1ce <__sflush_r+0xae>
 800e1fa:	6a21      	ldr	r1, [r4, #32]
 800e1fc:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 800e1fe:	4643      	mov	r3, r8
 800e200:	463a      	mov	r2, r7
 800e202:	4628      	mov	r0, r5
 800e204:	47b0      	blx	r6
 800e206:	2800      	cmp	r0, #0
 800e208:	dc08      	bgt.n	800e21c <__sflush_r+0xfc>
 800e20a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e20e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800e212:	81a3      	strh	r3, [r4, #12]
 800e214:	f04f 30ff 	mov.w	r0, #4294967295
 800e218:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e21c:	4407      	add	r7, r0
 800e21e:	eba8 0800 	sub.w	r8, r8, r0
 800e222:	e7e7      	b.n	800e1f4 <__sflush_r+0xd4>
 800e224:	20400001 	.word	0x20400001

0800e228 <_fflush_r>:
 800e228:	b538      	push	{r3, r4, r5, lr}
 800e22a:	690b      	ldr	r3, [r1, #16]
 800e22c:	4605      	mov	r5, r0
 800e22e:	460c      	mov	r4, r1
 800e230:	b913      	cbnz	r3, 800e238 <_fflush_r+0x10>
 800e232:	2500      	movs	r5, #0
 800e234:	4628      	mov	r0, r5
 800e236:	bd38      	pop	{r3, r4, r5, pc}
 800e238:	b118      	cbz	r0, 800e242 <_fflush_r+0x1a>
 800e23a:	6a03      	ldr	r3, [r0, #32]
 800e23c:	b90b      	cbnz	r3, 800e242 <_fflush_r+0x1a>
 800e23e:	f7ff f8d5 	bl	800d3ec <__sinit>
 800e242:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e246:	2b00      	cmp	r3, #0
 800e248:	d0f3      	beq.n	800e232 <_fflush_r+0xa>
 800e24a:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800e24c:	07d0      	lsls	r0, r2, #31
 800e24e:	d404      	bmi.n	800e25a <_fflush_r+0x32>
 800e250:	0599      	lsls	r1, r3, #22
 800e252:	d402      	bmi.n	800e25a <_fflush_r+0x32>
 800e254:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800e256:	f7ff fb84 	bl	800d962 <__retarget_lock_acquire_recursive>
 800e25a:	4628      	mov	r0, r5
 800e25c:	4621      	mov	r1, r4
 800e25e:	f7ff ff5f 	bl	800e120 <__sflush_r>
 800e262:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800e264:	07da      	lsls	r2, r3, #31
 800e266:	4605      	mov	r5, r0
 800e268:	d4e4      	bmi.n	800e234 <_fflush_r+0xc>
 800e26a:	89a3      	ldrh	r3, [r4, #12]
 800e26c:	059b      	lsls	r3, r3, #22
 800e26e:	d4e1      	bmi.n	800e234 <_fflush_r+0xc>
 800e270:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800e272:	f7ff fb77 	bl	800d964 <__retarget_lock_release_recursive>
 800e276:	e7dd      	b.n	800e234 <_fflush_r+0xc>

0800e278 <__swhatbuf_r>:
 800e278:	b570      	push	{r4, r5, r6, lr}
 800e27a:	460c      	mov	r4, r1
 800e27c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800e280:	2900      	cmp	r1, #0
 800e282:	b096      	sub	sp, #88	@ 0x58
 800e284:	4615      	mov	r5, r2
 800e286:	461e      	mov	r6, r3
 800e288:	da0d      	bge.n	800e2a6 <__swhatbuf_r+0x2e>
 800e28a:	89a3      	ldrh	r3, [r4, #12]
 800e28c:	f013 0f80 	tst.w	r3, #128	@ 0x80
 800e290:	f04f 0100 	mov.w	r1, #0
 800e294:	bf14      	ite	ne
 800e296:	2340      	movne	r3, #64	@ 0x40
 800e298:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 800e29c:	2000      	movs	r0, #0
 800e29e:	6031      	str	r1, [r6, #0]
 800e2a0:	602b      	str	r3, [r5, #0]
 800e2a2:	b016      	add	sp, #88	@ 0x58
 800e2a4:	bd70      	pop	{r4, r5, r6, pc}
 800e2a6:	466a      	mov	r2, sp
 800e2a8:	f000 f848 	bl	800e33c <_fstat_r>
 800e2ac:	2800      	cmp	r0, #0
 800e2ae:	dbec      	blt.n	800e28a <__swhatbuf_r+0x12>
 800e2b0:	9901      	ldr	r1, [sp, #4]
 800e2b2:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 800e2b6:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 800e2ba:	4259      	negs	r1, r3
 800e2bc:	4159      	adcs	r1, r3
 800e2be:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800e2c2:	e7eb      	b.n	800e29c <__swhatbuf_r+0x24>

0800e2c4 <__smakebuf_r>:
 800e2c4:	898b      	ldrh	r3, [r1, #12]
 800e2c6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e2c8:	079d      	lsls	r5, r3, #30
 800e2ca:	4606      	mov	r6, r0
 800e2cc:	460c      	mov	r4, r1
 800e2ce:	d507      	bpl.n	800e2e0 <__smakebuf_r+0x1c>
 800e2d0:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 800e2d4:	6023      	str	r3, [r4, #0]
 800e2d6:	6123      	str	r3, [r4, #16]
 800e2d8:	2301      	movs	r3, #1
 800e2da:	6163      	str	r3, [r4, #20]
 800e2dc:	b003      	add	sp, #12
 800e2de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e2e0:	ab01      	add	r3, sp, #4
 800e2e2:	466a      	mov	r2, sp
 800e2e4:	f7ff ffc8 	bl	800e278 <__swhatbuf_r>
 800e2e8:	9f00      	ldr	r7, [sp, #0]
 800e2ea:	4605      	mov	r5, r0
 800e2ec:	4639      	mov	r1, r7
 800e2ee:	4630      	mov	r0, r6
 800e2f0:	f7ff fbbc 	bl	800da6c <_malloc_r>
 800e2f4:	b948      	cbnz	r0, 800e30a <__smakebuf_r+0x46>
 800e2f6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e2fa:	059a      	lsls	r2, r3, #22
 800e2fc:	d4ee      	bmi.n	800e2dc <__smakebuf_r+0x18>
 800e2fe:	f023 0303 	bic.w	r3, r3, #3
 800e302:	f043 0302 	orr.w	r3, r3, #2
 800e306:	81a3      	strh	r3, [r4, #12]
 800e308:	e7e2      	b.n	800e2d0 <__smakebuf_r+0xc>
 800e30a:	89a3      	ldrh	r3, [r4, #12]
 800e30c:	6020      	str	r0, [r4, #0]
 800e30e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800e312:	81a3      	strh	r3, [r4, #12]
 800e314:	9b01      	ldr	r3, [sp, #4]
 800e316:	e9c4 0704 	strd	r0, r7, [r4, #16]
 800e31a:	b15b      	cbz	r3, 800e334 <__smakebuf_r+0x70>
 800e31c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800e320:	4630      	mov	r0, r6
 800e322:	f000 f81d 	bl	800e360 <_isatty_r>
 800e326:	b128      	cbz	r0, 800e334 <__smakebuf_r+0x70>
 800e328:	89a3      	ldrh	r3, [r4, #12]
 800e32a:	f023 0303 	bic.w	r3, r3, #3
 800e32e:	f043 0301 	orr.w	r3, r3, #1
 800e332:	81a3      	strh	r3, [r4, #12]
 800e334:	89a3      	ldrh	r3, [r4, #12]
 800e336:	431d      	orrs	r5, r3
 800e338:	81a5      	strh	r5, [r4, #12]
 800e33a:	e7cf      	b.n	800e2dc <__smakebuf_r+0x18>

0800e33c <_fstat_r>:
 800e33c:	b538      	push	{r3, r4, r5, lr}
 800e33e:	4d07      	ldr	r5, [pc, #28]	@ (800e35c <_fstat_r+0x20>)
 800e340:	2300      	movs	r3, #0
 800e342:	4604      	mov	r4, r0
 800e344:	4608      	mov	r0, r1
 800e346:	4611      	mov	r1, r2
 800e348:	602b      	str	r3, [r5, #0]
 800e34a:	f7fa fe36 	bl	8008fba <_fstat>
 800e34e:	1c43      	adds	r3, r0, #1
 800e350:	d102      	bne.n	800e358 <_fstat_r+0x1c>
 800e352:	682b      	ldr	r3, [r5, #0]
 800e354:	b103      	cbz	r3, 800e358 <_fstat_r+0x1c>
 800e356:	6023      	str	r3, [r4, #0]
 800e358:	bd38      	pop	{r3, r4, r5, pc}
 800e35a:	bf00      	nop
 800e35c:	20001ed8 	.word	0x20001ed8

0800e360 <_isatty_r>:
 800e360:	b538      	push	{r3, r4, r5, lr}
 800e362:	4d06      	ldr	r5, [pc, #24]	@ (800e37c <_isatty_r+0x1c>)
 800e364:	2300      	movs	r3, #0
 800e366:	4604      	mov	r4, r0
 800e368:	4608      	mov	r0, r1
 800e36a:	602b      	str	r3, [r5, #0]
 800e36c:	f7fa fe2a 	bl	8008fc4 <_isatty>
 800e370:	1c43      	adds	r3, r0, #1
 800e372:	d102      	bne.n	800e37a <_isatty_r+0x1a>
 800e374:	682b      	ldr	r3, [r5, #0]
 800e376:	b103      	cbz	r3, 800e37a <_isatty_r+0x1a>
 800e378:	6023      	str	r3, [r4, #0]
 800e37a:	bd38      	pop	{r3, r4, r5, pc}
 800e37c:	20001ed8 	.word	0x20001ed8

0800e380 <_sbrk_r>:
 800e380:	b538      	push	{r3, r4, r5, lr}
 800e382:	4d06      	ldr	r5, [pc, #24]	@ (800e39c <_sbrk_r+0x1c>)
 800e384:	2300      	movs	r3, #0
 800e386:	4604      	mov	r4, r0
 800e388:	4608      	mov	r0, r1
 800e38a:	602b      	str	r3, [r5, #0]
 800e38c:	f7fa fdf8 	bl	8008f80 <_sbrk>
 800e390:	1c43      	adds	r3, r0, #1
 800e392:	d102      	bne.n	800e39a <_sbrk_r+0x1a>
 800e394:	682b      	ldr	r3, [r5, #0]
 800e396:	b103      	cbz	r3, 800e39a <_sbrk_r+0x1a>
 800e398:	6023      	str	r3, [r4, #0]
 800e39a:	bd38      	pop	{r3, r4, r5, pc}
 800e39c:	20001ed8 	.word	0x20001ed8

0800e3a0 <_init>:
 800e3a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e3a2:	bf00      	nop
 800e3a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e3a6:	bc08      	pop	{r3}
 800e3a8:	469e      	mov	lr, r3
 800e3aa:	4770      	bx	lr

0800e3ac <_fini>:
 800e3ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e3ae:	bf00      	nop
 800e3b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e3b2:	bc08      	pop	{r3}
 800e3b4:	469e      	mov	lr, r3
 800e3b6:	4770      	bx	lr

0800e3b8 <__SFU_LL_SECU_ActivateSecUser_veneer>:
 800e3b8:	f85f f000 	ldr.w	pc, [pc]	@ 800e3bc <__SFU_LL_SECU_ActivateSecUser_veneer+0x4>
 800e3bc:	20001001 	.word	0x20001001

Disassembly of section .RamFunc:

20001000 <SFU_LL_SECU_ActivateSecUser>:
#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LOADER) || defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION) */
#endif /* SFU_MPU_PROTECT_ENABLE */

#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    /* Reset FPU context */
    SCB->CPACR &= ~((3UL << 10*2)|(3UL << 11*2));  /* reset CP10 and CP11 Full Access */
20001000:	4c14      	ldr	r4, [pc, #80]	@ (20001054 <SFU_LL_SECU_ActivateSecUser+0x54>)
{
20001002:	4605      	mov	r5, r0
20001004:	b508      	push	{r3, lr}
  (void) HAL_FLASH_Unlock();
20001006:	f000 f847 	bl	20001098 <__HAL_FLASH_Unlock_veneer>
    SCB->CPACR &= ~((3UL << 10*2)|(3UL << 11*2));  /* reset CP10 and CP11 Full Access */
2000100a:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
2000100e:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
20001012:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk; /* Disable automatic lazy state preservation for floating-point context */
20001016:	4b10      	ldr	r3, [pc, #64]	@ (20001058 <SFU_LL_SECU_ActivateSecUser+0x58>)
20001018:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
2000101a:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
2000101e:	635a      	str	r2, [r3, #52]	@ 0x34
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk; /* Clear the lazy state preservation for floating-point context */
20001020:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
20001022:	f022 0201 	bic.w	r2, r2, #1
20001026:	635a      	str	r2, [r3, #52]	@ 0x34
  __ASM volatile ("MRS %0, control" : "=r" (result) );
20001028:	f3ef 8314 	mrs	r3, CONTROL
#endif /* (__FPU_PRESENT == 1) && (__FPU_USED == 1) */

    /* clear process stack & unprivileged bit */
    __set_CONTROL(__get_CONTROL() & ~0x3U);
2000102c:	f023 0303 	bic.w	r3, r3, #3
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
20001030:	f383 8814 	msr	CONTROL, r3

    /* returns from interrupt into application */
    launch_application(Address, (uint32_t)jump_to_function);
20001034:	4909      	ldr	r1, [pc, #36]	@ (2000105c <SFU_LL_SECU_ActivateSecUser+0x5c>)
20001036:	4628      	mov	r0, r5
20001038:	f000 f818 	bl	2000106c <launch_application>
  __ASM volatile ("dsb 0xF":::"memory");
2000103c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20001040:	68e2      	ldr	r2, [r4, #12]
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20001042:	4b07      	ldr	r3, [pc, #28]	@ (20001060 <SFU_LL_SECU_ActivateSecUser+0x60>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20001044:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20001048:	4313      	orrs	r3, r2
2000104a:	60e3      	str	r3, [r4, #12]
2000104c:	f3bf 8f4f 	dsb	sy
    __NOP();
20001050:	bf00      	nop
  for(;;)                                                           /* wait until reset */
20001052:	e7fd      	b.n	20001050 <SFU_LL_SECU_ActivateSecUser+0x50>
20001054:	e000ed00 	.word	0xe000ed00
20001058:	e000ef00 	.word	0xe000ef00
2000105c:	20001064 	.word	0x20001064
20001060:	05fa0004 	.word	0x05fa0004

20001064 <jump_to_function>:

        .section  .RamFunc,"ax",%progbits
        .global jump_to_function
jump_to_function:
        LDR SP, [R0]
20001064:	f8d0 d000 	ldr.w	sp, [r0]
        LDR PC, [R0,#4]
20001068:	f8d0 f004 	ldr.w	pc, [r0, #4]

2000106c <launch_application>:
* return from exception to application launch function
* R0: application vector address
* R1: exit function address
* push interrupt context R0 R1 R2 R3 R12 LR PC xPSR
*******************************************************/
        MOV R2, #0x01000000 /* xPSR activate Thumb bit */
2000106c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
        PUSH {R2}
20001070:	b404      	push	{r2}
        MOV R2, #1
20001072:	f04f 0201 	mov.w	r2, #1
        BIC R1, R1, R2      /* clear least significant bit of exit function */
20001076:	ea21 0102 	bic.w	r1, r1, r2
        PUSH {R1}           /* return address = application entry point */
2000107a:	b402      	push	{r1}
        MOV R1, #0          /* clear other context registers */
2000107c:	f04f 0100 	mov.w	r1, #0
        PUSH {R1}
20001080:	b402      	push	{r1}
        PUSH {R1}
20001082:	b402      	push	{r1}
        PUSH {R1}
20001084:	b402      	push	{r1}
        PUSH {R1}
20001086:	b402      	push	{r1}
        PUSH {R1}
20001088:	b402      	push	{r1}
        PUSH {R0}           /* R0 = application entry point */
2000108a:	b401      	push	{r0}
        MOV LR, #0xFFFFFFF9 /* set LR to return to thread mode with main stack */
2000108c:	f06f 0e06 	mvn.w	lr, #6
        BX LR               /* return from interrupt */
20001090:	4770      	bx	lr
20001092:	0000      	movs	r0, r0
20001094:	0000      	movs	r0, r0
	...

20001098 <__HAL_FLASH_Unlock_veneer>:
20001098:	f85f f000 	ldr.w	pc, [pc]	@ 2000109c <__HAL_FLASH_Unlock_veneer+0x4>
2000109c:	0800b509 	.word	0x0800b509
