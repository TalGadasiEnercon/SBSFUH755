
SBSFU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000002a0  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text.SE_CORE_Bin 00004978  08000400  08000400  00001400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .SE_IF_Code   0000075c  08008000  08008000  00006000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000058d8  08008a00  08008a00  00007a00  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000a90  0800e2d8  0800e2d8  0000d2d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.extab    00000000  0800ed68  0800ed68  0000e188  2**0
                  CONTENTS, READONLY
  6 .ARM          00000008  0800ed68  0800ed68  0000dd68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .preinit_array 00000000  0800ed70  0800ed70  0000e188  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .init_array   00000008  0800ed70  0800ed70  0000dd70  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .fini_array   00000008  0800ed78  0800ed78  0000dd78  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .data         00000088  20001100  0800ed80  0000e100  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .RamFunc      000000a0  20001000  08008900  00007000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          00000d40  20001188  0800ee08  0000e188  2**3
                  ALLOC
 13 ._user_heap_stack 00002000  20001ec8  0800ee08  0000eec8  2**0
                  ALLOC
 14 .ARM.attributes 0000002e  00000000  00000000  0000e188  2**0
                  CONTENTS, READONLY
 15 .debug_info   00022189  00000000  00000000  0000e1b6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00005bd9  00000000  00000000  0003033f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 0000a5c4  00000000  00000000  00035f18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000011a0  00000000  00000000  000404e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000011e5  00000000  00000000  00041680  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00040237  00000000  00000000  00042865  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   00026f46  00000000  00000000  00082a9c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    0018975b  00000000  00000000  000a99e2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  0023313d  2**0
                  CONTENTS, READONLY
 24 .debug_frame  000033ec  00000000  00000000  00233180  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 000000dc  00000000  00000000  0023656c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .SE_IF_Code:

08008000 <SE_APP_GetActiveFwInfo>:
  * @param pFwInfo Active Firmware Info structure that will be filled.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
__root SE_ErrorStatus SE_APP_GetActiveFwInfo(SE_StatusTypeDef *peSE_Status, uint32_t SlotNumber,
                                             SE_APP_ActiveFwInfo_t *pFwInfo)
{
 8008000:	b570      	push	{r4, r5, r6, lr}
 8008002:	b086      	sub	sp, #24
 8008004:	4604      	mov	r4, r0
 8008006:	460d      	mov	r5, r1
 8008008:	4616      	mov	r6, r2
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800800a:	f000 fb28 	bl	800865e <SE_IsUnprivileged>
 800800e:	b150      	cbz	r0, 8008026 <SE_APP_GetActiveFwInfo+0x26>
  {
    uint32_t params[2] = {SlotNumber, (uint32_t)pFwInfo};
    SE_SysCall(&e_ret_status, SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, &params);
 8008010:	ab04      	add	r3, sp, #16
 8008012:	4622      	mov	r2, r4
 8008014:	2120      	movs	r1, #32
 8008016:	a803      	add	r0, sp, #12
    uint32_t params[2] = {SlotNumber, (uint32_t)pFwInfo};
 8008018:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, &params);
 800801c:	f000 fb29 	bl	8008672 <SE_SysCall>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 8008020:	9803      	ldr	r0, [sp, #12]
 8008022:	b006      	add	sp, #24
 8008024:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 8008026:	a804      	add	r0, sp, #16
 8008028:	f000 fb10 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, primask_bit, SlotNumber, pFwInfo);
 800802c:	4621      	mov	r1, r4
 800802e:	462b      	mov	r3, r5
 8008030:	9a04      	ldr	r2, [sp, #16]
 8008032:	4c04      	ldr	r4, [pc, #16]	@ (8008044 <SE_APP_GetActiveFwInfo+0x44>)
 8008034:	2020      	movs	r0, #32
 8008036:	9600      	str	r6, [sp, #0]
 8008038:	47a0      	blx	r4
 800803a:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 800803c:	9804      	ldr	r0, [sp, #16]
 800803e:	f000 fb0a 	bl	8008656 <SE_ExitSecureMode>
 8008042:	e7ed      	b.n	8008020 <SE_APP_GetActiveFwInfo+0x20>
 8008044:	08000405 	.word	0x08000405

08008048 <SE_APP_SVC_Handler>:


#ifdef SFU_ISOLATE_SE_WITH_MPU
__root void SE_APP_SVC_Handler(uint32_t *args)
{
  SE_SVC_Handler(args);
 8008048:	f000 bb16 	b.w	8008678 <SE_SVC_Handler>

0800804c <SE_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param uSystemCoreClock System clock value.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Init(SE_StatusTypeDef *peSE_Status, uint32_t uSystemCoreClock)
{
 800804c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800804e:	4604      	mov	r4, r0
 8008050:	460d      	mov	r5, r1
}
#elif defined(__GNUC__)
static inline uint32_t get_LR(void)
{
  register uint32_t result;
  __asm volatile("MOV %0, LR\n" : "=r"(result));
 8008052:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008054:	4b0c      	ldr	r3, [pc, #48]	@ (8008088 <SE_Init+0x3c>)
 8008056:	429a      	cmp	r2, r3
 8008058:	d314      	bcc.n	8008084 <SE_Init+0x38>
 800805a:	4672      	mov	r2, lr
 800805c:	4b0b      	ldr	r3, [pc, #44]	@ (800808c <SE_Init+0x40>)
 800805e:	429a      	cmp	r2, r3
 8008060:	d810      	bhi.n	8008084 <SE_Init+0x38>

  /* Check the pointers allocation */
  if (peSE_Status == NULL)
 8008062:	b178      	cbz	r0, 8008084 <SE_Init+0x38>

  /* Set the CallGate function pointer */
  SET_CALLGATE();

  /* Enter Secure Mode */
  SE_EnterSecureMode(&primask_bit);
 8008064:	a801      	add	r0, sp, #4
 8008066:	f000 faf1 	bl	800864c <SE_EnterSecureMode>

  /* Secure Engine Call */
  e_ret_status = (*SE_CallGatePtr)(SE_INIT_ID, peSE_Status, primask_bit, uSystemCoreClock);
 800806a:	4621      	mov	r1, r4
 800806c:	462b      	mov	r3, r5
 800806e:	4c08      	ldr	r4, [pc, #32]	@ (8008090 <SE_Init+0x44>)
 8008070:	9a01      	ldr	r2, [sp, #4]
 8008072:	2000      	movs	r0, #0
 8008074:	47a0      	blx	r4
 8008076:	4604      	mov	r4, r0

  /* Exit Secure Mode */
  SE_ExitSecureMode(primask_bit);
 8008078:	9801      	ldr	r0, [sp, #4]
 800807a:	f000 faec 	bl	8008656 <SE_ExitSecureMode>


  return e_ret_status;
}
 800807e:	4620      	mov	r0, r4
 8008080:	b003      	add	sp, #12
 8008082:	bd30      	pop	{r4, r5, pc}
  __IS_SFU_RESERVED();
 8008084:	4c03      	ldr	r4, [pc, #12]	@ (8008094 <SE_Init+0x48>)
 8008086:	e7fa      	b.n	800807e <SE_Init+0x32>
 8008088:	08008a00 	.word	0x08008a00
 800808c:	0801ffff 	.word	0x0801ffff
 8008090:	08000405 	.word	0x08000405
 8008094:	00018799 	.word	0x00018799

08008098 <SE_Startup>:
  *        This function must be called only one time so an internal check is executed.
  * @param None.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Startup(void)
{
 8008098:	b538      	push	{r3, r4, r5, lr}
 800809a:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  static uint8_t b_startup_already_done = 0U;
  static SE_ErrorStatus(*SE_StartupPtr)(void);            /*!< Secure Engine STARTUP  pointer function*/

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 800809c:	4b0a      	ldr	r3, [pc, #40]	@ (80080c8 <SE_Startup+0x30>)
 800809e:	429a      	cmp	r2, r3
 80080a0:	d30e      	bcc.n	80080c0 <SE_Startup+0x28>
 80080a2:	4672      	mov	r2, lr
 80080a4:	4b09      	ldr	r3, [pc, #36]	@ (80080cc <SE_Startup+0x34>)
 80080a6:	429a      	cmp	r2, r3
 80080a8:	d80a      	bhi.n	80080c0 <SE_Startup+0x28>

  /* Need to be sure to execute this initialization only one time! */
  if (b_startup_already_done == 0U)
 80080aa:	4d09      	ldr	r5, [pc, #36]	@ (80080d0 <SE_Startup+0x38>)
 80080ac:	4c09      	ldr	r4, [pc, #36]	@ (80080d4 <SE_Startup+0x3c>)
 80080ae:	782b      	ldrb	r3, [r5, #0]
 80080b0:	b943      	cbnz	r3, 80080c4 <SE_Startup+0x2c>
  {
    /* Secure Core Initialization */
    SE_StartupPtr = (SE_ErrorStatus(*)(void))((uint32_t) SE_STARTUP_REGION_ROM_START + 1U);
 80080b2:	4b09      	ldr	r3, [pc, #36]	@ (80080d8 <SE_Startup+0x40>)
    e_ret_status = (*SE_StartupPtr)();
 80080b4:	4798      	blx	r3
    if (e_ret_status == SE_SUCCESS)
 80080b6:	42a0      	cmp	r0, r4
 80080b8:	d101      	bne.n	80080be <SE_Startup+0x26>
    {
      b_startup_already_done = 1U;
 80080ba:	2301      	movs	r3, #1
 80080bc:	702b      	strb	r3, [r5, #0]
    /* This function has been already successfully called */
    e_ret_status = SE_SUCCESS;
  }

  return e_ret_status;
}
 80080be:	bd38      	pop	{r3, r4, r5, pc}
  __IS_SFU_RESERVED();
 80080c0:	4806      	ldr	r0, [pc, #24]	@ (80080dc <SE_Startup+0x44>)
 80080c2:	e7fc      	b.n	80080be <SE_Startup+0x26>
    e_ret_status = SE_SUCCESS;
 80080c4:	4620      	mov	r0, r4
 80080c6:	e7fa      	b.n	80080be <SE_Startup+0x26>
 80080c8:	08008a00 	.word	0x08008a00
 80080cc:	0801ffff 	.word	0x0801ffff
 80080d0:	20001d78 	.word	0x20001d78
 80080d4:	0012310f 	.word	0x0012310f
 80080d8:	08000901 	.word	0x08000901
 80080dc:	00018799 	.word	0x00018799

080080e0 <SE_LockRestrictServices>:
  * @brief call by SFU to lock part of Secure Engine services
  * @param  pSE_Status Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_LockRestrictServices(SE_StatusTypeDef *pSE_Status)
{
 80080e0:	b513      	push	{r0, r1, r4, lr}
 80080e2:	4604      	mov	r4, r0
 80080e4:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80080e6:	4b12      	ldr	r3, [pc, #72]	@ (8008130 <SE_LockRestrictServices+0x50>)
 80080e8:	429a      	cmp	r2, r3
 80080ea:	d31e      	bcc.n	800812a <SE_LockRestrictServices+0x4a>
 80080ec:	4672      	mov	r2, lr
 80080ee:	4b11      	ldr	r3, [pc, #68]	@ (8008134 <SE_LockRestrictServices+0x54>)
 80080f0:	429a      	cmp	r2, r3
 80080f2:	d81a      	bhi.n	800812a <SE_LockRestrictServices+0x4a>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80080f4:	f000 fab3 	bl	800865e <SE_IsUnprivileged>
 80080f8:	b148      	cbz	r0, 800810e <SE_LockRestrictServices+0x2e>
  {
    SE_SysCall(&e_ret_status, SE_LOCK_RESTRICT_SERVICES, pSE_Status, NULL);
 80080fa:	2300      	movs	r3, #0
 80080fc:	4622      	mov	r2, r4
 80080fe:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8008102:	4668      	mov	r0, sp
 8008104:	f000 fab5 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_LOCK_RESTRICT_SERVICES, pSE_Status, primask_bit);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008108:	9800      	ldr	r0, [sp, #0]
}
 800810a:	b002      	add	sp, #8
 800810c:	bd10      	pop	{r4, pc}
    SE_EnterSecureMode(&primask_bit);
 800810e:	a801      	add	r0, sp, #4
 8008110:	f000 fa9c 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_LOCK_RESTRICT_SERVICES, pSE_Status, primask_bit);
 8008114:	9a01      	ldr	r2, [sp, #4]
 8008116:	4621      	mov	r1, r4
 8008118:	4b07      	ldr	r3, [pc, #28]	@ (8008138 <SE_LockRestrictServices+0x58>)
 800811a:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800811e:	4798      	blx	r3
 8008120:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 8008122:	9801      	ldr	r0, [sp, #4]
 8008124:	f000 fa97 	bl	8008656 <SE_ExitSecureMode>
 8008128:	e7ee      	b.n	8008108 <SE_LockRestrictServices+0x28>
  __IS_SFU_RESERVED();
 800812a:	4804      	ldr	r0, [pc, #16]	@ (800813c <SE_LockRestrictServices+0x5c>)
 800812c:	e7ed      	b.n	800810a <SE_LockRestrictServices+0x2a>
 800812e:	bf00      	nop
 8008130:	08008a00 	.word	0x08008a00
 8008134:	0801ffff 	.word	0x0801ffff
 8008138:	08000405 	.word	0x08000405
 800813c:	00018799 	.word	0x00018799

08008140 <SE_CM0_Update>:
  * @brief call by SFU to trigg FUS or wireless stack update process managed by CM0
  * @param  pSE_Status Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CM0_Update(SE_StatusTypeDef *pSE_Status)
{
 8008140:	b513      	push	{r0, r1, r4, lr}
 8008142:	4604      	mov	r4, r0
 8008144:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008146:	4b12      	ldr	r3, [pc, #72]	@ (8008190 <SE_CM0_Update+0x50>)
 8008148:	429a      	cmp	r2, r3
 800814a:	d31e      	bcc.n	800818a <SE_CM0_Update+0x4a>
 800814c:	4672      	mov	r2, lr
 800814e:	4b11      	ldr	r3, [pc, #68]	@ (8008194 <SE_CM0_Update+0x54>)
 8008150:	429a      	cmp	r2, r3
 8008152:	d81a      	bhi.n	800818a <SE_CM0_Update+0x4a>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008154:	f000 fa83 	bl	800865e <SE_IsUnprivileged>
 8008158:	b148      	cbz	r0, 800816e <SE_CM0_Update+0x2e>
  {
    SE_SysCall(&e_ret_status, SE_CM0_UPDATE, pSE_Status, NULL);
 800815a:	2300      	movs	r3, #0
 800815c:	4622      	mov	r2, r4
 800815e:	f44f 7190 	mov.w	r1, #288	@ 0x120
 8008162:	4668      	mov	r0, sp
 8008164:	f000 fa85 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_CM0_UPDATE, pSE_Status, primask_bit);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008168:	9800      	ldr	r0, [sp, #0]
}
 800816a:	b002      	add	sp, #8
 800816c:	bd10      	pop	{r4, pc}
    SE_EnterSecureMode(&primask_bit);
 800816e:	a801      	add	r0, sp, #4
 8008170:	f000 fa6c 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CM0_UPDATE, pSE_Status, primask_bit);
 8008174:	9a01      	ldr	r2, [sp, #4]
 8008176:	4621      	mov	r1, r4
 8008178:	4b07      	ldr	r3, [pc, #28]	@ (8008198 <SE_CM0_Update+0x58>)
 800817a:	f44f 7090 	mov.w	r0, #288	@ 0x120
 800817e:	4798      	blx	r3
 8008180:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 8008182:	9801      	ldr	r0, [sp, #4]
 8008184:	f000 fa67 	bl	8008656 <SE_ExitSecureMode>
 8008188:	e7ee      	b.n	8008168 <SE_CM0_Update+0x28>
  __IS_SFU_RESERVED();
 800818a:	4804      	ldr	r0, [pc, #16]	@ (800819c <SE_CM0_Update+0x5c>)
 800818c:	e7ed      	b.n	800816a <SE_CM0_Update+0x2a>
 800818e:	bf00      	nop
 8008190:	08008a00 	.word	0x08008a00
 8008194:	0801ffff 	.word	0x0801ffff
 8008198:	08000405 	.word	0x08000405
 800819c:	00018799 	.word	0x00018799

080081a0 <SE_ExtFlash_Decrypt_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxSE_Metadata Metadata that will be used to fill the Crypto Init structure.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_ExtFlash_Decrypt_Init(SE_StatusTypeDef *pSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata)
{
 80081a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80081a2:	4604      	mov	r4, r0
 80081a4:	460d      	mov	r5, r1
 80081a6:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80081a8:	4b12      	ldr	r3, [pc, #72]	@ (80081f4 <SE_ExtFlash_Decrypt_Init+0x54>)
 80081aa:	429a      	cmp	r2, r3
 80081ac:	d320      	bcc.n	80081f0 <SE_ExtFlash_Decrypt_Init+0x50>
 80081ae:	4672      	mov	r2, lr
 80081b0:	4b11      	ldr	r3, [pc, #68]	@ (80081f8 <SE_ExtFlash_Decrypt_Init+0x58>)
 80081b2:	429a      	cmp	r2, r3
 80081b4:	d81c      	bhi.n	80081f0 <SE_ExtFlash_Decrypt_Init+0x50>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80081b6:	f000 fa52 	bl	800865e <SE_IsUnprivileged>
 80081ba:	b150      	cbz	r0, 80081d2 <SE_ExtFlash_Decrypt_Init+0x32>
  {
    uint32_t params[1] = {(uint32_t)pxSE_Metadata};
    SE_SysCall(&e_ret_status, SE_EXTFLASH_DECRYPT_INIT, pSE_Status, &params);
 80081bc:	ab01      	add	r3, sp, #4
 80081be:	4622      	mov	r2, r4
 80081c0:	f44f 7188 	mov.w	r1, #272	@ 0x110
 80081c4:	4668      	mov	r0, sp
    uint32_t params[1] = {(uint32_t)pxSE_Metadata};
 80081c6:	9501      	str	r5, [sp, #4]
    SE_SysCall(&e_ret_status, SE_EXTFLASH_DECRYPT_INIT, pSE_Status, &params);
 80081c8:	f000 fa53 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_EXTFLASH_DECRYPT_INIT, pSE_Status, primask_bit, pxSE_Metadata);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 80081cc:	9800      	ldr	r0, [sp, #0]
}
 80081ce:	b003      	add	sp, #12
 80081d0:	bd30      	pop	{r4, r5, pc}
    SE_EnterSecureMode(&primask_bit);
 80081d2:	a801      	add	r0, sp, #4
 80081d4:	f000 fa3a 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_EXTFLASH_DECRYPT_INIT, pSE_Status, primask_bit, pxSE_Metadata);
 80081d8:	4621      	mov	r1, r4
 80081da:	462b      	mov	r3, r5
 80081dc:	9a01      	ldr	r2, [sp, #4]
 80081de:	4c07      	ldr	r4, [pc, #28]	@ (80081fc <SE_ExtFlash_Decrypt_Init+0x5c>)
 80081e0:	f44f 7088 	mov.w	r0, #272	@ 0x110
 80081e4:	47a0      	blx	r4
 80081e6:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 80081e8:	9801      	ldr	r0, [sp, #4]
 80081ea:	f000 fa34 	bl	8008656 <SE_ExitSecureMode>
 80081ee:	e7ed      	b.n	80081cc <SE_ExtFlash_Decrypt_Init+0x2c>
  __IS_SFU_RESERVED();
 80081f0:	4803      	ldr	r0, [pc, #12]	@ (8008200 <SE_ExtFlash_Decrypt_Init+0x60>)
 80081f2:	e7ec      	b.n	80081ce <SE_ExtFlash_Decrypt_Init+0x2e>
 80081f4:	08008a00 	.word	0x08008a00
 80081f8:	0801ffff 	.word	0x0801ffff
 80081fc:	08000405 	.word	0x08000405
 8008200:	00018799 	.word	0x00018799

08008204 <SE_SFU_IMG_Read>:
  * @param  Length: number of bytes to read from flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Read(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, const uint8_t *pSource,
                               uint32_t Length)
{
 8008204:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008206:	4604      	mov	r4, r0
 8008208:	b087      	sub	sp, #28
 800820a:	460d      	mov	r5, r1
 800820c:	4616      	mov	r6, r2
 800820e:	461f      	mov	r7, r3
 8008210:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008212:	4b14      	ldr	r3, [pc, #80]	@ (8008264 <SE_SFU_IMG_Read+0x60>)
 8008214:	429a      	cmp	r2, r3
 8008216:	d322      	bcc.n	800825e <SE_SFU_IMG_Read+0x5a>
 8008218:	4672      	mov	r2, lr
 800821a:	4b13      	ldr	r3, [pc, #76]	@ (8008268 <SE_SFU_IMG_Read+0x64>)
 800821c:	429a      	cmp	r2, r3
 800821e:	d81e      	bhi.n	800825e <SE_SFU_IMG_Read+0x5a>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008220:	f000 fa1d 	bl	800865e <SE_IsUnprivileged>
 8008224:	b158      	cbz	r0, 800823e <SE_SFU_IMG_Read+0x3a>
  {

    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
    SE_SysCall(&e_ret_status, SE_IMG_READ, pSE_Status, &params);
 8008226:	ab03      	add	r3, sp, #12
 8008228:	4622      	mov	r2, r4
 800822a:	2192      	movs	r1, #146	@ 0x92
 800822c:	a802      	add	r0, sp, #8
    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
 800822e:	9705      	str	r7, [sp, #20]
 8008230:	e9cd 5603 	strd	r5, r6, [sp, #12]
    SE_SysCall(&e_ret_status, SE_IMG_READ, pSE_Status, &params);
 8008234:	f000 fa1d 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008238:	9802      	ldr	r0, [sp, #8]
}
 800823a:	b007      	add	sp, #28
 800823c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SE_EnterSecureMode(&primask_bit);
 800823e:	a803      	add	r0, sp, #12
 8008240:	f000 fa04 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_READ, pSE_Status, primask_bit, pDestination, pSource, Length);;
 8008244:	4621      	mov	r1, r4
 8008246:	462b      	mov	r3, r5
 8008248:	9a03      	ldr	r2, [sp, #12]
 800824a:	4c08      	ldr	r4, [pc, #32]	@ (800826c <SE_SFU_IMG_Read+0x68>)
 800824c:	2092      	movs	r0, #146	@ 0x92
 800824e:	e9cd 6700 	strd	r6, r7, [sp]
 8008252:	47a0      	blx	r4
 8008254:	9002      	str	r0, [sp, #8]
    SE_ExitSecureMode(primask_bit);
 8008256:	9803      	ldr	r0, [sp, #12]
 8008258:	f000 f9fd 	bl	8008656 <SE_ExitSecureMode>
 800825c:	e7ec      	b.n	8008238 <SE_SFU_IMG_Read+0x34>
  __IS_SFU_RESERVED();
 800825e:	4804      	ldr	r0, [pc, #16]	@ (8008270 <SE_SFU_IMG_Read+0x6c>)
 8008260:	e7eb      	b.n	800823a <SE_SFU_IMG_Read+0x36>
 8008262:	bf00      	nop
 8008264:	08008a00 	.word	0x08008a00
 8008268:	0801ffff 	.word	0x0801ffff
 800826c:	08000405 	.word	0x08000405
 8008270:	00018799 	.word	0x00018799

08008274 <SE_SFU_IMG_Write>:
  * @param  Length: number of bytes to write to flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Write(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, const uint8_t *pSource,
                                uint32_t Length)
{
 8008274:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008276:	4604      	mov	r4, r0
 8008278:	b087      	sub	sp, #28
 800827a:	460d      	mov	r5, r1
 800827c:	4616      	mov	r6, r2
 800827e:	461f      	mov	r7, r3
 8008280:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008282:	4b14      	ldr	r3, [pc, #80]	@ (80082d4 <SE_SFU_IMG_Write+0x60>)
 8008284:	429a      	cmp	r2, r3
 8008286:	d322      	bcc.n	80082ce <SE_SFU_IMG_Write+0x5a>
 8008288:	4672      	mov	r2, lr
 800828a:	4b13      	ldr	r3, [pc, #76]	@ (80082d8 <SE_SFU_IMG_Write+0x64>)
 800828c:	429a      	cmp	r2, r3
 800828e:	d81e      	bhi.n	80082ce <SE_SFU_IMG_Write+0x5a>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008290:	f000 f9e5 	bl	800865e <SE_IsUnprivileged>
 8008294:	b158      	cbz	r0, 80082ae <SE_SFU_IMG_Write+0x3a>
  {
    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
    SE_SysCall(&e_ret_status, SE_IMG_WRITE, pSE_Status, &params);
 8008296:	ab03      	add	r3, sp, #12
 8008298:	4622      	mov	r2, r4
 800829a:	2193      	movs	r1, #147	@ 0x93
 800829c:	a802      	add	r0, sp, #8
    uint32_t params[3] = {(uint32_t)pDestination, (uint32_t)pSource, (uint32_t)Length};
 800829e:	9705      	str	r7, [sp, #20]
 80082a0:	e9cd 5603 	strd	r5, r6, [sp, #12]
    SE_SysCall(&e_ret_status, SE_IMG_WRITE, pSE_Status, &params);
 80082a4:	f000 f9e5 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_WRITE, pSE_Status, primask_bit, pDestination, pSource, Length);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 80082a8:	9802      	ldr	r0, [sp, #8]
}
 80082aa:	b007      	add	sp, #28
 80082ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SE_EnterSecureMode(&primask_bit);
 80082ae:	a803      	add	r0, sp, #12
 80082b0:	f000 f9cc 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_WRITE, pSE_Status, primask_bit, pDestination, pSource, Length);
 80082b4:	4621      	mov	r1, r4
 80082b6:	462b      	mov	r3, r5
 80082b8:	9a03      	ldr	r2, [sp, #12]
 80082ba:	4c08      	ldr	r4, [pc, #32]	@ (80082dc <SE_SFU_IMG_Write+0x68>)
 80082bc:	2093      	movs	r0, #147	@ 0x93
 80082be:	e9cd 6700 	strd	r6, r7, [sp]
 80082c2:	47a0      	blx	r4
 80082c4:	9002      	str	r0, [sp, #8]
    SE_ExitSecureMode(primask_bit);
 80082c6:	9803      	ldr	r0, [sp, #12]
 80082c8:	f000 f9c5 	bl	8008656 <SE_ExitSecureMode>
 80082cc:	e7ec      	b.n	80082a8 <SE_SFU_IMG_Write+0x34>
  __IS_SFU_RESERVED();
 80082ce:	4804      	ldr	r0, [pc, #16]	@ (80082e0 <SE_SFU_IMG_Write+0x6c>)
 80082d0:	e7eb      	b.n	80082aa <SE_SFU_IMG_Write+0x36>
 80082d2:	bf00      	nop
 80082d4:	08008a00 	.word	0x08008a00
 80082d8:	0801ffff 	.word	0x0801ffff
 80082dc:	08000405 	.word	0x08000405
 80082e0:	00018799 	.word	0x00018799

080082e4 <SE_SFU_IMG_Erase>:
  * @param  pDestination: pointer to flash area to erase.
  * @param  Length: number of bytes to erase in flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Erase(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, uint32_t Length)
{
 80082e4:	b570      	push	{r4, r5, r6, lr}
 80082e6:	4604      	mov	r4, r0
 80082e8:	b086      	sub	sp, #24
 80082ea:	460d      	mov	r5, r1
 80082ec:	4616      	mov	r6, r2
 80082ee:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80082f0:	4b12      	ldr	r3, [pc, #72]	@ (800833c <SE_SFU_IMG_Erase+0x58>)
 80082f2:	429a      	cmp	r2, r3
 80082f4:	d320      	bcc.n	8008338 <SE_SFU_IMG_Erase+0x54>
 80082f6:	4672      	mov	r2, lr
 80082f8:	4b11      	ldr	r3, [pc, #68]	@ (8008340 <SE_SFU_IMG_Erase+0x5c>)
 80082fa:	429a      	cmp	r2, r3
 80082fc:	d81c      	bhi.n	8008338 <SE_SFU_IMG_Erase+0x54>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80082fe:	f000 f9ae 	bl	800865e <SE_IsUnprivileged>
 8008302:	b150      	cbz	r0, 800831a <SE_SFU_IMG_Erase+0x36>
  {
    uint32_t params[2] = {(uint32_t)pDestination, (uint32_t)Length};
    SE_SysCall(&e_ret_status, SE_IMG_ERASE, pSE_Status, &params);
 8008304:	ab04      	add	r3, sp, #16
 8008306:	4622      	mov	r2, r4
 8008308:	2194      	movs	r1, #148	@ 0x94
 800830a:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pDestination, (uint32_t)Length};
 800830c:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_IMG_ERASE, pSE_Status, &params);
 8008310:	f000 f9af 	bl	8008672 <SE_SysCall>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_ERASE, pSE_Status, primask_bit, pDestination, Length);
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008314:	9803      	ldr	r0, [sp, #12]
}
 8008316:	b006      	add	sp, #24
 8008318:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 800831a:	a804      	add	r0, sp, #16
 800831c:	f000 f996 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_ERASE, pSE_Status, primask_bit, pDestination, Length);
 8008320:	4621      	mov	r1, r4
 8008322:	462b      	mov	r3, r5
 8008324:	9a04      	ldr	r2, [sp, #16]
 8008326:	4c07      	ldr	r4, [pc, #28]	@ (8008344 <SE_SFU_IMG_Erase+0x60>)
 8008328:	2094      	movs	r0, #148	@ 0x94
 800832a:	9600      	str	r6, [sp, #0]
 800832c:	47a0      	blx	r4
 800832e:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 8008330:	9804      	ldr	r0, [sp, #16]
 8008332:	f000 f990 	bl	8008656 <SE_ExitSecureMode>
 8008336:	e7ed      	b.n	8008314 <SE_SFU_IMG_Erase+0x30>
  __IS_SFU_RESERVED();
 8008338:	4803      	ldr	r0, [pc, #12]	@ (8008348 <SE_SFU_IMG_Erase+0x64>)
 800833a:	e7ec      	b.n	8008316 <SE_SFU_IMG_Erase+0x32>
 800833c:	08008a00 	.word	0x08008a00
 8008340:	0801ffff 	.word	0x0801ffff
 8008344:	08000405 	.word	0x08000405
 8008348:	00018799 	.word	0x00018799

0800834c <SE_Decrypt_Init>:
  * @param SE_FwType Type of Fw Image.
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata, uint32_t SE_FwType)
{
 800834c:	b570      	push	{r4, r5, r6, lr}
 800834e:	4605      	mov	r5, r0
 8008350:	b086      	sub	sp, #24
 8008352:	460e      	mov	r6, r1
 8008354:	4614      	mov	r4, r2
 8008356:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008358:	4b13      	ldr	r3, [pc, #76]	@ (80083a8 <SE_Decrypt_Init+0x5c>)
 800835a:	429a      	cmp	r2, r3
 800835c:	d322      	bcc.n	80083a4 <SE_Decrypt_Init+0x58>
 800835e:	4672      	mov	r2, lr
 8008360:	4b12      	ldr	r3, [pc, #72]	@ (80083ac <SE_Decrypt_Init+0x60>)
 8008362:	429a      	cmp	r2, r3
 8008364:	d81e      	bhi.n	80083a4 <SE_Decrypt_Init+0x58>

  /* Check the parameter */
  if ((SE_FwType != SE_FW_IMAGE_COMPLETE) && (SE_FwType != SE_FW_IMAGE_PARTIAL))
 8008366:	2c01      	cmp	r4, #1
 8008368:	d81c      	bhi.n	80083a4 <SE_Decrypt_Init+0x58>
  {
    return SE_ERROR;
  }

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800836a:	f000 f978 	bl	800865e <SE_IsUnprivileged>
 800836e:	b150      	cbz	r0, 8008386 <SE_Decrypt_Init+0x3a>
  {
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, &params);
 8008370:	ab04      	add	r3, sp, #16
 8008372:	462a      	mov	r2, r5
 8008374:	2104      	movs	r1, #4
 8008376:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
 8008378:	e9cd 6404 	strd	r6, r4, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, &params);
 800837c:	f000 f979 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008380:	9803      	ldr	r0, [sp, #12]
}
 8008382:	b006      	add	sp, #24
 8008384:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 8008386:	a804      	add	r0, sp, #16
 8008388:	f000 f960 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, primask_bit, pxSE_Metadata, SE_FwType);
 800838c:	9400      	str	r4, [sp, #0]
 800838e:	4633      	mov	r3, r6
 8008390:	9a04      	ldr	r2, [sp, #16]
 8008392:	4629      	mov	r1, r5
 8008394:	4c06      	ldr	r4, [pc, #24]	@ (80083b0 <SE_Decrypt_Init+0x64>)
 8008396:	2004      	movs	r0, #4
 8008398:	47a0      	blx	r4
 800839a:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 800839c:	9804      	ldr	r0, [sp, #16]
 800839e:	f000 f95a 	bl	8008656 <SE_ExitSecureMode>
 80083a2:	e7ed      	b.n	8008380 <SE_Decrypt_Init+0x34>
  __IS_SFU_RESERVED();
 80083a4:	4803      	ldr	r0, [pc, #12]	@ (80083b4 <SE_Decrypt_Init+0x68>)
 80083a6:	e7ec      	b.n	8008382 <SE_Decrypt_Init+0x36>
 80083a8:	08008a00 	.word	0x08008a00
 80083ac:	0801ffff 	.word	0x0801ffff
 80083b0:	08000405 	.word	0x08000405
 80083b4:	00018799 	.word	0x00018799

080083b8 <SE_Decrypt_Append>:
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                 uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 80083b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80083bc:	b08a      	sub	sp, #40	@ 0x28
 80083be:	4604      	mov	r4, r0
 80083c0:	460d      	mov	r5, r1
 80083c2:	4616      	mov	r6, r2
 80083c4:	461f      	mov	r7, r3
 80083c6:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 80083ca:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80083cc:	4b15      	ldr	r3, [pc, #84]	@ (8008424 <SE_Decrypt_Append+0x6c>)
 80083ce:	429a      	cmp	r2, r3
 80083d0:	d325      	bcc.n	800841e <SE_Decrypt_Append+0x66>
 80083d2:	4672      	mov	r2, lr
 80083d4:	4b14      	ldr	r3, [pc, #80]	@ (8008428 <SE_Decrypt_Append+0x70>)
 80083d6:	429a      	cmp	r2, r3
 80083d8:	d821      	bhi.n	800841e <SE_Decrypt_Append+0x66>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80083da:	f000 f940 	bl	800865e <SE_IsUnprivileged>
 80083de:	b168      	cbz	r0, 80083fc <SE_Decrypt_Append+0x44>
  {
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, &params);
 80083e0:	ab06      	add	r3, sp, #24
 80083e2:	4622      	mov	r2, r4
 80083e4:	2105      	movs	r1, #5
 80083e6:	a805      	add	r0, sp, #20
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 80083e8:	e9cd 5606 	strd	r5, r6, [sp, #24]
 80083ec:	e9cd 7808 	strd	r7, r8, [sp, #32]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, &params);
 80083f0:	f000 f93f 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 80083f4:	9805      	ldr	r0, [sp, #20]
}
 80083f6:	b00a      	add	sp, #40	@ 0x28
 80083f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SE_EnterSecureMode(&primask_bit);
 80083fc:	a806      	add	r0, sp, #24
 80083fe:	f000 f925 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, primask_bit, pInputBuffer, InputSize,
 8008402:	4621      	mov	r1, r4
 8008404:	462b      	mov	r3, r5
 8008406:	9a06      	ldr	r2, [sp, #24]
 8008408:	4c08      	ldr	r4, [pc, #32]	@ (800842c <SE_Decrypt_Append+0x74>)
 800840a:	2005      	movs	r0, #5
 800840c:	9600      	str	r6, [sp, #0]
 800840e:	e9cd 7801 	strd	r7, r8, [sp, #4]
 8008412:	47a0      	blx	r4
 8008414:	9005      	str	r0, [sp, #20]
    SE_ExitSecureMode(primask_bit);
 8008416:	9806      	ldr	r0, [sp, #24]
 8008418:	f000 f91d 	bl	8008656 <SE_ExitSecureMode>
 800841c:	e7ea      	b.n	80083f4 <SE_Decrypt_Append+0x3c>
  __IS_SFU_RESERVED();
 800841e:	4804      	ldr	r0, [pc, #16]	@ (8008430 <SE_Decrypt_Append+0x78>)
 8008420:	e7e9      	b.n	80083f6 <SE_Decrypt_Append+0x3e>
 8008422:	bf00      	nop
 8008424:	08008a00 	.word	0x08008a00
 8008428:	0801ffff 	.word	0x0801ffff
 800842c:	08000405 	.word	0x08000405
 8008430:	00018799 	.word	0x00018799

08008434 <SE_Decrypt_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008434:	b570      	push	{r4, r5, r6, lr}
 8008436:	4604      	mov	r4, r0
 8008438:	b086      	sub	sp, #24
 800843a:	460d      	mov	r5, r1
 800843c:	4616      	mov	r6, r2
 800843e:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008440:	4b12      	ldr	r3, [pc, #72]	@ (800848c <SE_Decrypt_Finish+0x58>)
 8008442:	429a      	cmp	r2, r3
 8008444:	d320      	bcc.n	8008488 <SE_Decrypt_Finish+0x54>
 8008446:	4672      	mov	r2, lr
 8008448:	4b11      	ldr	r3, [pc, #68]	@ (8008490 <SE_Decrypt_Finish+0x5c>)
 800844a:	429a      	cmp	r2, r3
 800844c:	d81c      	bhi.n	8008488 <SE_Decrypt_Finish+0x54>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800844e:	f000 f906 	bl	800865e <SE_IsUnprivileged>
 8008452:	b150      	cbz	r0, 800846a <SE_Decrypt_Finish+0x36>
  {
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, &params);
 8008454:	ab04      	add	r3, sp, #16
 8008456:	4622      	mov	r2, r4
 8008458:	2106      	movs	r1, #6
 800845a:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 800845c:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, &params);
 8008460:	f000 f907 	bl	8008672 <SE_SysCall>
    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
 8008464:	9803      	ldr	r0, [sp, #12]
}
 8008466:	b006      	add	sp, #24
 8008468:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 800846a:	a804      	add	r0, sp, #16
 800846c:	f000 f8ee 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, primask_bit, pOutputBuffer,
 8008470:	4621      	mov	r1, r4
 8008472:	462b      	mov	r3, r5
 8008474:	9a04      	ldr	r2, [sp, #16]
 8008476:	4c07      	ldr	r4, [pc, #28]	@ (8008494 <SE_Decrypt_Finish+0x60>)
 8008478:	2006      	movs	r0, #6
 800847a:	9600      	str	r6, [sp, #0]
 800847c:	47a0      	blx	r4
 800847e:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 8008480:	9804      	ldr	r0, [sp, #16]
 8008482:	f000 f8e8 	bl	8008656 <SE_ExitSecureMode>
 8008486:	e7ed      	b.n	8008464 <SE_Decrypt_Finish+0x30>
  __IS_SFU_RESERVED();
 8008488:	4803      	ldr	r0, [pc, #12]	@ (8008498 <SE_Decrypt_Finish+0x64>)
 800848a:	e7ec      	b.n	8008466 <SE_Decrypt_Finish+0x32>
 800848c:	08008a00 	.word	0x08008a00
 8008490:	0801ffff 	.word	0x0801ffff
 8008494:	08000405 	.word	0x08000405
 8008498:	00018799 	.word	0x00018799

0800849c <SE_AuthenticateFW_Init>:
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata,
                                      uint32_t SE_FwType)
{
 800849c:	b570      	push	{r4, r5, r6, lr}
 800849e:	4605      	mov	r5, r0
 80084a0:	b086      	sub	sp, #24
 80084a2:	460e      	mov	r6, r1
 80084a4:	4614      	mov	r4, r2
 80084a6:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80084a8:	4b13      	ldr	r3, [pc, #76]	@ (80084f8 <SE_AuthenticateFW_Init+0x5c>)
 80084aa:	429a      	cmp	r2, r3
 80084ac:	d322      	bcc.n	80084f4 <SE_AuthenticateFW_Init+0x58>
 80084ae:	4672      	mov	r2, lr
 80084b0:	4b12      	ldr	r3, [pc, #72]	@ (80084fc <SE_AuthenticateFW_Init+0x60>)
 80084b2:	429a      	cmp	r2, r3
 80084b4:	d81e      	bhi.n	80084f4 <SE_AuthenticateFW_Init+0x58>

  /* Check the parameter */
  if ((SE_FwType != SE_FW_IMAGE_COMPLETE) && (SE_FwType != SE_FW_IMAGE_PARTIAL))
 80084b6:	2c01      	cmp	r4, #1
 80084b8:	d81c      	bhi.n	80084f4 <SE_AuthenticateFW_Init+0x58>
  {
    return SE_ERROR;
  }

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 80084ba:	f000 f8d0 	bl	800865e <SE_IsUnprivileged>
 80084be:	b150      	cbz	r0, 80084d6 <SE_AuthenticateFW_Init+0x3a>
  {
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, &params);
 80084c0:	ab04      	add	r3, sp, #16
 80084c2:	462a      	mov	r2, r5
 80084c4:	2107      	movs	r1, #7
 80084c6:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pxSE_Metadata, (uint32_t)SE_FwType};
 80084c8:	e9cd 6404 	strd	r6, r4, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, &params);
 80084cc:	f000 f8d1 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 80084d0:	9803      	ldr	r0, [sp, #12]
}
 80084d2:	b006      	add	sp, #24
 80084d4:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 80084d6:	a804      	add	r0, sp, #16
 80084d8:	f000 f8b8 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, primask_bit, pxSE_Metadata,
 80084dc:	9400      	str	r4, [sp, #0]
 80084de:	4633      	mov	r3, r6
 80084e0:	9a04      	ldr	r2, [sp, #16]
 80084e2:	4629      	mov	r1, r5
 80084e4:	4c06      	ldr	r4, [pc, #24]	@ (8008500 <SE_AuthenticateFW_Init+0x64>)
 80084e6:	2007      	movs	r0, #7
 80084e8:	47a0      	blx	r4
 80084ea:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 80084ec:	9804      	ldr	r0, [sp, #16]
 80084ee:	f000 f8b2 	bl	8008656 <SE_ExitSecureMode>
 80084f2:	e7ed      	b.n	80084d0 <SE_AuthenticateFW_Init+0x34>
  __IS_SFU_RESERVED();
 80084f4:	4803      	ldr	r0, [pc, #12]	@ (8008504 <SE_AuthenticateFW_Init+0x68>)
 80084f6:	e7ec      	b.n	80084d2 <SE_AuthenticateFW_Init+0x36>
 80084f8:	08008a00 	.word	0x08008a00
 80084fc:	0801ffff 	.word	0x0801ffff
 8008500:	08000405 	.word	0x08000405
 8008504:	00018799 	.word	0x00018799

08008508 <SE_AuthenticateFW_Append>:
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                        uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008508:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800850c:	b08a      	sub	sp, #40	@ 0x28
 800850e:	4604      	mov	r4, r0
 8008510:	460d      	mov	r5, r1
 8008512:	4616      	mov	r6, r2
 8008514:	461f      	mov	r7, r3
 8008516:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 800851a:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 800851c:	4b15      	ldr	r3, [pc, #84]	@ (8008574 <SE_AuthenticateFW_Append+0x6c>)
 800851e:	429a      	cmp	r2, r3
 8008520:	d325      	bcc.n	800856e <SE_AuthenticateFW_Append+0x66>
 8008522:	4672      	mov	r2, lr
 8008524:	4b14      	ldr	r3, [pc, #80]	@ (8008578 <SE_AuthenticateFW_Append+0x70>)
 8008526:	429a      	cmp	r2, r3
 8008528:	d821      	bhi.n	800856e <SE_AuthenticateFW_Append+0x66>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800852a:	f000 f898 	bl	800865e <SE_IsUnprivileged>
 800852e:	b168      	cbz	r0, 800854c <SE_AuthenticateFW_Append+0x44>
  {
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, &params);
 8008530:	ab06      	add	r3, sp, #24
 8008532:	4622      	mov	r2, r4
 8008534:	2108      	movs	r1, #8
 8008536:	a805      	add	r0, sp, #20
    uint32_t params[4] = {(uint32_t)pInputBuffer, (uint32_t)InputSize, (uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 8008538:	e9cd 5606 	strd	r5, r6, [sp, #24]
 800853c:	e9cd 7808 	strd	r7, r8, [sp, #32]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, &params);
 8008540:	f000 f897 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 8008544:	9805      	ldr	r0, [sp, #20]
}
 8008546:	b00a      	add	sp, #40	@ 0x28
 8008548:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SE_EnterSecureMode(&primask_bit);
 800854c:	a806      	add	r0, sp, #24
 800854e:	f000 f87d 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, primask_bit, pInputBuffer,
 8008552:	4621      	mov	r1, r4
 8008554:	462b      	mov	r3, r5
 8008556:	9a06      	ldr	r2, [sp, #24]
 8008558:	4c08      	ldr	r4, [pc, #32]	@ (800857c <SE_AuthenticateFW_Append+0x74>)
 800855a:	2008      	movs	r0, #8
 800855c:	9600      	str	r6, [sp, #0]
 800855e:	e9cd 7801 	strd	r7, r8, [sp, #4]
 8008562:	47a0      	blx	r4
 8008564:	9005      	str	r0, [sp, #20]
    SE_ExitSecureMode(primask_bit);
 8008566:	9806      	ldr	r0, [sp, #24]
 8008568:	f000 f875 	bl	8008656 <SE_ExitSecureMode>
 800856c:	e7ea      	b.n	8008544 <SE_AuthenticateFW_Append+0x3c>
  __IS_SFU_RESERVED();
 800856e:	4804      	ldr	r0, [pc, #16]	@ (8008580 <SE_AuthenticateFW_Append+0x78>)
 8008570:	e7e9      	b.n	8008546 <SE_AuthenticateFW_Append+0x3e>
 8008572:	bf00      	nop
 8008574:	08008a00 	.word	0x08008a00
 8008578:	0801ffff 	.word	0x0801ffff
 800857c:	08000405 	.word	0x08000405
 8008580:	00018799 	.word	0x00018799

08008584 <SE_AuthenticateFW_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008584:	b570      	push	{r4, r5, r6, lr}
 8008586:	4604      	mov	r4, r0
 8008588:	b086      	sub	sp, #24
 800858a:	460d      	mov	r5, r1
 800858c:	4616      	mov	r6, r2
 800858e:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008590:	4b12      	ldr	r3, [pc, #72]	@ (80085dc <SE_AuthenticateFW_Finish+0x58>)
 8008592:	429a      	cmp	r2, r3
 8008594:	d320      	bcc.n	80085d8 <SE_AuthenticateFW_Finish+0x54>
 8008596:	4672      	mov	r2, lr
 8008598:	4b11      	ldr	r3, [pc, #68]	@ (80085e0 <SE_AuthenticateFW_Finish+0x5c>)
 800859a:	429a      	cmp	r2, r3
 800859c:	d81c      	bhi.n	80085d8 <SE_AuthenticateFW_Finish+0x54>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 800859e:	f000 f85e 	bl	800865e <SE_IsUnprivileged>
 80085a2:	b150      	cbz	r0, 80085ba <SE_AuthenticateFW_Finish+0x36>
  {
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, &params);
 80085a4:	ab04      	add	r3, sp, #16
 80085a6:	4622      	mov	r2, r4
 80085a8:	2109      	movs	r1, #9
 80085aa:	a803      	add	r0, sp, #12
    uint32_t params[2] = {(uint32_t)pOutputBuffer, (uint32_t)pOutputSize};
 80085ac:	e9cd 5604 	strd	r5, r6, [sp, #16]
    SE_SysCall(&e_ret_status, SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, &params);
 80085b0:	f000 f85f 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 80085b4:	9803      	ldr	r0, [sp, #12]
}
 80085b6:	b006      	add	sp, #24
 80085b8:	bd70      	pop	{r4, r5, r6, pc}
    SE_EnterSecureMode(&primask_bit);
 80085ba:	a804      	add	r0, sp, #16
 80085bc:	f000 f846 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, primask_bit, pOutputBuffer,
 80085c0:	4621      	mov	r1, r4
 80085c2:	462b      	mov	r3, r5
 80085c4:	9a04      	ldr	r2, [sp, #16]
 80085c6:	4c07      	ldr	r4, [pc, #28]	@ (80085e4 <SE_AuthenticateFW_Finish+0x60>)
 80085c8:	2009      	movs	r0, #9
 80085ca:	9600      	str	r6, [sp, #0]
 80085cc:	47a0      	blx	r4
 80085ce:	9003      	str	r0, [sp, #12]
    SE_ExitSecureMode(primask_bit);
 80085d0:	9804      	ldr	r0, [sp, #16]
 80085d2:	f000 f840 	bl	8008656 <SE_ExitSecureMode>
 80085d6:	e7ed      	b.n	80085b4 <SE_AuthenticateFW_Finish+0x30>
  __IS_SFU_RESERVED();
 80085d8:	4803      	ldr	r0, [pc, #12]	@ (80085e8 <SE_AuthenticateFW_Finish+0x64>)
 80085da:	e7ec      	b.n	80085b6 <SE_AuthenticateFW_Finish+0x32>
 80085dc:	08008a00 	.word	0x08008a00
 80085e0:	0801ffff 	.word	0x0801ffff
 80085e4:	08000405 	.word	0x08000405
 80085e8:	00018799 	.word	0x00018799

080085ec <SE_VerifyHeaderSignature>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxFwRawHeader pointer to RawHeader Buffer.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_VerifyHeaderSignature(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxFwRawHeader)
{
 80085ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80085ee:	4604      	mov	r4, r0
 80085f0:	460d      	mov	r5, r1
 80085f2:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80085f4:	4b11      	ldr	r3, [pc, #68]	@ (800863c <SE_VerifyHeaderSignature+0x50>)
 80085f6:	429a      	cmp	r2, r3
 80085f8:	d31e      	bcc.n	8008638 <SE_VerifyHeaderSignature+0x4c>
 80085fa:	4672      	mov	r2, lr
 80085fc:	4b10      	ldr	r3, [pc, #64]	@ (8008640 <SE_VerifyHeaderSignature+0x54>)
 80085fe:	429a      	cmp	r2, r3
 8008600:	d81a      	bhi.n	8008638 <SE_VerifyHeaderSignature+0x4c>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  if (0U != SE_IsUnprivileged())
 8008602:	f000 f82c 	bl	800865e <SE_IsUnprivileged>
 8008606:	b148      	cbz	r0, 800861c <SE_VerifyHeaderSignature+0x30>
  {
    uint32_t params[1] = {(uint32_t)pxFwRawHeader};
    SE_SysCall(&e_ret_status, SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, &params);
 8008608:	ab01      	add	r3, sp, #4
 800860a:	4622      	mov	r2, r4
 800860c:	2110      	movs	r1, #16
 800860e:	4668      	mov	r0, sp
    uint32_t params[1] = {(uint32_t)pxFwRawHeader};
 8008610:	9501      	str	r5, [sp, #4]
    SE_SysCall(&e_ret_status, SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, &params);
 8008612:	f000 f82e 	bl	8008672 <SE_SysCall>
    SE_ExitSecureMode(primask_bit);
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
 8008616:	9800      	ldr	r0, [sp, #0]

}
 8008618:	b003      	add	sp, #12
 800861a:	bd30      	pop	{r4, r5, pc}
    SE_EnterSecureMode(&primask_bit);
 800861c:	a801      	add	r0, sp, #4
 800861e:	f000 f815 	bl	800864c <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, primask_bit, pxFwRawHeader);
 8008622:	4621      	mov	r1, r4
 8008624:	462b      	mov	r3, r5
 8008626:	9a01      	ldr	r2, [sp, #4]
 8008628:	4c06      	ldr	r4, [pc, #24]	@ (8008644 <SE_VerifyHeaderSignature+0x58>)
 800862a:	2010      	movs	r0, #16
 800862c:	47a0      	blx	r4
 800862e:	9000      	str	r0, [sp, #0]
    SE_ExitSecureMode(primask_bit);
 8008630:	9801      	ldr	r0, [sp, #4]
 8008632:	f000 f810 	bl	8008656 <SE_ExitSecureMode>
 8008636:	e7ee      	b.n	8008616 <SE_VerifyHeaderSignature+0x2a>
  __IS_SFU_RESERVED();
 8008638:	4803      	ldr	r0, [pc, #12]	@ (8008648 <SE_VerifyHeaderSignature+0x5c>)
 800863a:	e7ed      	b.n	8008618 <SE_VerifyHeaderSignature+0x2c>
 800863c:	08008a00 	.word	0x08008a00
 8008640:	0801ffff 	.word	0x0801ffff
 8008644:	08000405 	.word	0x08000405
 8008648:	00018799 	.word	0x00018799

0800864c <SE_EnterSecureMode>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800864c:	f3ef 8310 	mrs	r3, PRIMASK
  */
void SE_EnterSecureMode(uint32_t *pPrimaskBit)
{
#if !defined(CKS_ENABLED)
  /* Disable interrupts */
  *pPrimaskBit = __get_PRIMASK();
 8008650:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8008652:	b672      	cpsid	i
  __disable_irq();
#endif /* !CKS_ENABLED */
}
 8008654:	4770      	bx	lr

08008656 <SE_ExitSecureMode>:
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8008656:	f380 8810 	msr	PRIMASK, r0
  __ASM volatile ("cpsie i" : : : "memory");
 800865a:	b662      	cpsie	i
#if !defined(CKS_ENABLED)
  /* Re-enable the interrupts */
  __set_PRIMASK(PrimaskBit);
  __enable_irq();
#endif /* !CKS_ENABLED */
}
 800865c:	4770      	bx	lr

0800865e <SE_IsUnprivileged>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800865e:	f3ef 8305 	mrs	r3, IPSR
  * @param void
  * @retval 0 if we are in privileged mode, 1 if we are in non-privileged mode
  */
uint32_t SE_IsUnprivileged(void)
{
  return ((__get_IPSR() == 0U) && ((__get_CONTROL() & 1U) == 1U));
 8008662:	b923      	cbnz	r3, 800866e <SE_IsUnprivileged+0x10>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 8008664:	f3ef 8014 	mrs	r0, CONTROL
 8008668:	f000 0001 	and.w	r0, r0, #1
 800866c:	4770      	bx	lr
 800866e:	2000      	movs	r0, #0
}
 8008670:	4770      	bx	lr

08008672 <SE_SysCall>:
  /*
    * You cannot directly change to privileged mode from unprivileged mode without going through an exception,
    * for example an SVC.
    * Handled by @ref MPU_SVC_Handler()  and finally @ref SE_SVC_Handler()
    */
  __ASM __IO("SVC #0");    /* 0 is the hard-coded value to indicate a Secure Engine syscall */
 8008672:	df00      	svc	0
}
 8008674:	4770      	bx	lr
	...

08008678 <SE_SVC_Handler>:
  * @note When this function is entered, privileged mode has already been entered.
  *       When leaving this function, the unprivileged mode is automatically enabled.
  * @note This function is exported to the MPU SVC handler (see @ref MPU_SVC_Handler).
  */
void SE_SVC_Handler(uint32_t *args)
{
 8008678:	b530      	push	{r4, r5, lr}
 800867a:	b087      	sub	sp, #28
 800867c:	4601      	mov	r1, r0
  SE_ErrorStatus ret;
  SE_ErrorStatus *pRet = (SE_ErrorStatus *)(args[0]);
 800867e:	6805      	ldr	r5, [r0, #0]

  /* Set the CallGate function pointer */
  SET_CALLGATE();

  /*Enter Secure Mode*/
  SE_EnterSecureMode(&primask_bit);
 8008680:	a805      	add	r0, sp, #20
  SET_CALLGATE();
 8008682:	4c32      	ldr	r4, [pc, #200]	@ (800874c <SE_SVC_Handler+0xd4>)
  SE_EnterSecureMode(&primask_bit);
 8008684:	f7ff ffe2 	bl	800864c <SE_EnterSecureMode>

  switch (args[1]) /* main case for short operations that can be done under interrupts */
 8008688:	6848      	ldr	r0, [r1, #4]
 800868a:	2893      	cmp	r0, #147	@ 0x93
 800868c:	d81e      	bhi.n	80086cc <SE_SVC_Handler+0x54>
 800868e:	2891      	cmp	r0, #145	@ 0x91
 8008690:	d845      	bhi.n	800871e <SE_SVC_Handler+0xa6>
 8008692:	2820      	cmp	r0, #32
 8008694:	d80e      	bhi.n	80086b4 <SE_SVC_Handler+0x3c>
 8008696:	2803      	cmp	r0, #3
 8008698:	d90a      	bls.n	80086b0 <SE_SVC_Handler+0x38>
 800869a:	1f02      	subs	r2, r0, #4
 800869c:	2301      	movs	r3, #1
 800869e:	4093      	lsls	r3, r2
 80086a0:	4a2b      	ldr	r2, [pc, #172]	@ (8008750 <SE_SVC_Handler+0xd8>)
 80086a2:	4213      	tst	r3, r2
 80086a4:	d10a      	bne.n	80086bc <SE_SVC_Handler+0x44>
 80086a6:	f013 0f12 	tst.w	r3, #18
 80086aa:	d142      	bne.n	8008732 <SE_SVC_Handler+0xba>
 80086ac:	2810      	cmp	r0, #16
 80086ae:	d030      	beq.n	8008712 <SE_SVC_Handler+0x9a>
 80086b0:	4c28      	ldr	r4, [pc, #160]	@ (8008754 <SE_SVC_Handler+0xdc>)
 80086b2:	e018      	b.n	80086e6 <SE_SVC_Handler+0x6e>
 80086b4:	f1a0 0360 	sub.w	r3, r0, #96	@ 0x60
 80086b8:	2b01      	cmp	r3, #1
 80086ba:	d8f9      	bhi.n	80086b0 <SE_SVC_Handler+0x38>
    case SE_SYS_SAVE_DISABLE_IRQ:
    case SE_SYS_RESTORE_ENABLE_IRQ:
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
                              (SE_StatusTypeDef *)args[2],
                              primask_bit,
                              (void *)(((uint32_t *)args[3])[0]),
 80086bc:	68cb      	ldr	r3, [r1, #12]
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 80086be:	685a      	ldr	r2, [r3, #4]
 80086c0:	9200      	str	r2, [sp, #0]
 80086c2:	9a05      	ldr	r2, [sp, #20]
 80086c4:	681b      	ldr	r3, [r3, #0]
 80086c6:	6889      	ldr	r1, [r1, #8]
 80086c8:	47a0      	blx	r4
 80086ca:	e00b      	b.n	80086e4 <SE_SVC_Handler+0x6c>
  switch (args[1]) /* main case for short operations that can be done under interrupts */
 80086cc:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 80086d0:	d005      	beq.n	80086de <SE_SVC_Handler+0x66>
 80086d2:	f5b0 7f88 	cmp.w	r0, #272	@ 0x110
 80086d6:	d01c      	beq.n	8008712 <SE_SVC_Handler+0x9a>
 80086d8:	2894      	cmp	r0, #148	@ 0x94
 80086da:	d1e9      	bne.n	80086b0 <SE_SVC_Handler+0x38>
 80086dc:	e7ee      	b.n	80086bc <SE_SVC_Handler+0x44>
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 80086de:	9a05      	ldr	r2, [sp, #20]
 80086e0:	6889      	ldr	r1, [r1, #8]
 80086e2:	47a0      	blx	r4
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 80086e4:	4604      	mov	r4, r0
      ret = SE_ERROR;
#endif /* KMS_ENABLED */
      break;
  }
  /*  Check return value address  */
  if ((SFU_LL_Buffer_in_ram((void *)pRet, sizeof(*pRet)) == SFU_SUCCESS)
 80086e6:	2104      	movs	r1, #4
 80086e8:	4628      	mov	r0, r5
 80086ea:	f002 f8ab 	bl	800a844 <SFU_LL_Buffer_in_ram>
 80086ee:	4b1a      	ldr	r3, [pc, #104]	@ (8008758 <SE_SVC_Handler+0xe0>)
 80086f0:	4298      	cmp	r0, r3
 80086f2:	d108      	bne.n	8008706 <SE_SVC_Handler+0x8e>
      && (SFU_LL_BufferCheck_in_se_ram((void *)pRet, sizeof(*pRet)) == SFU_ERROR))
 80086f4:	2104      	movs	r1, #4
 80086f6:	4628      	mov	r0, r5
 80086f8:	f002 f88a 	bl	800a810 <SFU_LL_BufferCheck_in_se_ram>
 80086fc:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 8008700:	4298      	cmp	r0, r3
  {
    *pRet = ret;
 8008702:	bf08      	it	eq
 8008704:	602c      	streq	r4, [r5, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8008706:	9b05      	ldr	r3, [sp, #20]
 8008708:	f383 8810 	msr	PRIMASK, r3
  __ASM volatile ("cpsie i" : : : "memory");
 800870c:	b662      	cpsie	i
  SE_ExitSecureMode(primask_bit);

  /*
    * End of the privileged operation execution: switching to unprivileged mode automatically.
    */
}
 800870e:	b007      	add	sp, #28
 8008710:	bd30      	pop	{r4, r5, pc}
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 8008712:	68cb      	ldr	r3, [r1, #12]
 8008714:	9a05      	ldr	r2, [sp, #20]
 8008716:	681b      	ldr	r3, [r3, #0]
 8008718:	6889      	ldr	r1, [r1, #8]
 800871a:	47a0      	blx	r4
 800871c:	e7e2      	b.n	80086e4 <SE_SVC_Handler+0x6c>
                              (void *)(((uint32_t *)args[3])[0]),
 800871e:	68cb      	ldr	r3, [r1, #12]
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 8008720:	689a      	ldr	r2, [r3, #8]
 8008722:	9201      	str	r2, [sp, #4]
 8008724:	685a      	ldr	r2, [r3, #4]
 8008726:	9200      	str	r2, [sp, #0]
 8008728:	9a05      	ldr	r2, [sp, #20]
 800872a:	681b      	ldr	r3, [r3, #0]
 800872c:	6889      	ldr	r1, [r1, #8]
 800872e:	47a0      	blx	r4
 8008730:	e7d8      	b.n	80086e4 <SE_SVC_Handler+0x6c>
                              (void *)(((uint32_t *)args[3])[0]),
 8008732:	68cb      	ldr	r3, [r1, #12]
      ret = (*SE_CallGatePtr)((SE_FunctionIDTypeDef)args[1],
 8008734:	68da      	ldr	r2, [r3, #12]
 8008736:	9202      	str	r2, [sp, #8]
 8008738:	689a      	ldr	r2, [r3, #8]
 800873a:	9201      	str	r2, [sp, #4]
 800873c:	685a      	ldr	r2, [r3, #4]
 800873e:	9200      	str	r2, [sp, #0]
 8008740:	9a05      	ldr	r2, [sp, #20]
 8008742:	681b      	ldr	r3, [r3, #0]
 8008744:	6889      	ldr	r1, [r1, #8]
 8008746:	47a0      	blx	r4
 8008748:	e7cc      	b.n	80086e4 <SE_SVC_Handler+0x6c>
 800874a:	bf00      	nop
 800874c:	08000405 	.word	0x08000405
 8008750:	1000002d 	.word	0x1000002d
 8008754:	00018799 	.word	0x00018799
 8008758:	00122f11 	.word	0x00122f11

Disassembly of section .text:

08008a00 <__do_global_dtors_aux>:
 8008a00:	b510      	push	{r4, lr}
 8008a02:	4c05      	ldr	r4, [pc, #20]	@ (8008a18 <__do_global_dtors_aux+0x18>)
 8008a04:	7823      	ldrb	r3, [r4, #0]
 8008a06:	b933      	cbnz	r3, 8008a16 <__do_global_dtors_aux+0x16>
 8008a08:	4b04      	ldr	r3, [pc, #16]	@ (8008a1c <__do_global_dtors_aux+0x1c>)
 8008a0a:	b113      	cbz	r3, 8008a12 <__do_global_dtors_aux+0x12>
 8008a0c:	4804      	ldr	r0, [pc, #16]	@ (8008a20 <__do_global_dtors_aux+0x20>)
 8008a0e:	f3af 8000 	nop.w
 8008a12:	2301      	movs	r3, #1
 8008a14:	7023      	strb	r3, [r4, #0]
 8008a16:	bd10      	pop	{r4, pc}
 8008a18:	20001188 	.word	0x20001188
 8008a1c:	00000000 	.word	0x00000000
 8008a20:	0800e2b8 	.word	0x0800e2b8

08008a24 <frame_dummy>:
 8008a24:	b508      	push	{r3, lr}
 8008a26:	4b03      	ldr	r3, [pc, #12]	@ (8008a34 <frame_dummy+0x10>)
 8008a28:	b11b      	cbz	r3, 8008a32 <frame_dummy+0xe>
 8008a2a:	4903      	ldr	r1, [pc, #12]	@ (8008a38 <frame_dummy+0x14>)
 8008a2c:	4803      	ldr	r0, [pc, #12]	@ (8008a3c <frame_dummy+0x18>)
 8008a2e:	f3af 8000 	nop.w
 8008a32:	bd08      	pop	{r3, pc}
 8008a34:	00000000 	.word	0x00000000
 8008a38:	2000118c 	.word	0x2000118c
 8008a3c:	0800e2b8 	.word	0x0800e2b8

08008a40 <SVC_Handler>:
        .syntax unified
        .weak  MPU_SVC_Handler
        .global SVC_Handler
        .type  SVC_Handler, %function
SVC_Handler:
        MRS r0, PSP
 8008a40:	f3ef 8009 	mrs	r0, PSP
        B MPU_SVC_Handler
 8008a44:	f001 bda6 	b.w	800a594 <MPU_SVC_Handler>
	...

08008a50 <memchr>:
 8008a50:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8008a54:	2a10      	cmp	r2, #16
 8008a56:	db2b      	blt.n	8008ab0 <memchr+0x60>
 8008a58:	f010 0f07 	tst.w	r0, #7
 8008a5c:	d008      	beq.n	8008a70 <memchr+0x20>
 8008a5e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008a62:	3a01      	subs	r2, #1
 8008a64:	428b      	cmp	r3, r1
 8008a66:	d02d      	beq.n	8008ac4 <memchr+0x74>
 8008a68:	f010 0f07 	tst.w	r0, #7
 8008a6c:	b342      	cbz	r2, 8008ac0 <memchr+0x70>
 8008a6e:	d1f6      	bne.n	8008a5e <memchr+0xe>
 8008a70:	b4f0      	push	{r4, r5, r6, r7}
 8008a72:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8008a76:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 8008a7a:	f022 0407 	bic.w	r4, r2, #7
 8008a7e:	f07f 0700 	mvns.w	r7, #0
 8008a82:	2300      	movs	r3, #0
 8008a84:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8008a88:	3c08      	subs	r4, #8
 8008a8a:	ea85 0501 	eor.w	r5, r5, r1
 8008a8e:	ea86 0601 	eor.w	r6, r6, r1
 8008a92:	fa85 f547 	uadd8	r5, r5, r7
 8008a96:	faa3 f587 	sel	r5, r3, r7
 8008a9a:	fa86 f647 	uadd8	r6, r6, r7
 8008a9e:	faa5 f687 	sel	r6, r5, r7
 8008aa2:	b98e      	cbnz	r6, 8008ac8 <memchr+0x78>
 8008aa4:	d1ee      	bne.n	8008a84 <memchr+0x34>
 8008aa6:	bcf0      	pop	{r4, r5, r6, r7}
 8008aa8:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8008aac:	f002 0207 	and.w	r2, r2, #7
 8008ab0:	b132      	cbz	r2, 8008ac0 <memchr+0x70>
 8008ab2:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008ab6:	3a01      	subs	r2, #1
 8008ab8:	ea83 0301 	eor.w	r3, r3, r1
 8008abc:	b113      	cbz	r3, 8008ac4 <memchr+0x74>
 8008abe:	d1f8      	bne.n	8008ab2 <memchr+0x62>
 8008ac0:	2000      	movs	r0, #0
 8008ac2:	4770      	bx	lr
 8008ac4:	3801      	subs	r0, #1
 8008ac6:	4770      	bx	lr
 8008ac8:	2d00      	cmp	r5, #0
 8008aca:	bf06      	itte	eq
 8008acc:	4635      	moveq	r5, r6
 8008ace:	3803      	subeq	r0, #3
 8008ad0:	3807      	subne	r0, #7
 8008ad2:	f015 0f01 	tst.w	r5, #1
 8008ad6:	d107      	bne.n	8008ae8 <memchr+0x98>
 8008ad8:	3001      	adds	r0, #1
 8008ada:	f415 7f80 	tst.w	r5, #256	@ 0x100
 8008ade:	bf02      	ittt	eq
 8008ae0:	3001      	addeq	r0, #1
 8008ae2:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8008ae6:	3001      	addeq	r0, #1
 8008ae8:	bcf0      	pop	{r4, r5, r6, r7}
 8008aea:	3801      	subs	r0, #1
 8008aec:	4770      	bx	lr
 8008aee:	bf00      	nop

08008af0 <__aeabi_uldivmod>:
 8008af0:	b953      	cbnz	r3, 8008b08 <__aeabi_uldivmod+0x18>
 8008af2:	b94a      	cbnz	r2, 8008b08 <__aeabi_uldivmod+0x18>
 8008af4:	2900      	cmp	r1, #0
 8008af6:	bf08      	it	eq
 8008af8:	2800      	cmpeq	r0, #0
 8008afa:	bf1c      	itt	ne
 8008afc:	f04f 31ff 	movne.w	r1, #4294967295
 8008b00:	f04f 30ff 	movne.w	r0, #4294967295
 8008b04:	f000 b988 	b.w	8008e18 <__aeabi_idiv0>
 8008b08:	f1ad 0c08 	sub.w	ip, sp, #8
 8008b0c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8008b10:	f000 f806 	bl	8008b20 <__udivmoddi4>
 8008b14:	f8dd e004 	ldr.w	lr, [sp, #4]
 8008b18:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008b1c:	b004      	add	sp, #16
 8008b1e:	4770      	bx	lr

08008b20 <__udivmoddi4>:
 8008b20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008b24:	9d08      	ldr	r5, [sp, #32]
 8008b26:	468e      	mov	lr, r1
 8008b28:	4604      	mov	r4, r0
 8008b2a:	4688      	mov	r8, r1
 8008b2c:	2b00      	cmp	r3, #0
 8008b2e:	d14a      	bne.n	8008bc6 <__udivmoddi4+0xa6>
 8008b30:	428a      	cmp	r2, r1
 8008b32:	4617      	mov	r7, r2
 8008b34:	d962      	bls.n	8008bfc <__udivmoddi4+0xdc>
 8008b36:	fab2 f682 	clz	r6, r2
 8008b3a:	b14e      	cbz	r6, 8008b50 <__udivmoddi4+0x30>
 8008b3c:	f1c6 0320 	rsb	r3, r6, #32
 8008b40:	fa01 f806 	lsl.w	r8, r1, r6
 8008b44:	fa20 f303 	lsr.w	r3, r0, r3
 8008b48:	40b7      	lsls	r7, r6
 8008b4a:	ea43 0808 	orr.w	r8, r3, r8
 8008b4e:	40b4      	lsls	r4, r6
 8008b50:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008b54:	fa1f fc87 	uxth.w	ip, r7
 8008b58:	fbb8 f1fe 	udiv	r1, r8, lr
 8008b5c:	0c23      	lsrs	r3, r4, #16
 8008b5e:	fb0e 8811 	mls	r8, lr, r1, r8
 8008b62:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8008b66:	fb01 f20c 	mul.w	r2, r1, ip
 8008b6a:	429a      	cmp	r2, r3
 8008b6c:	d909      	bls.n	8008b82 <__udivmoddi4+0x62>
 8008b6e:	18fb      	adds	r3, r7, r3
 8008b70:	f101 30ff 	add.w	r0, r1, #4294967295
 8008b74:	f080 80ea 	bcs.w	8008d4c <__udivmoddi4+0x22c>
 8008b78:	429a      	cmp	r2, r3
 8008b7a:	f240 80e7 	bls.w	8008d4c <__udivmoddi4+0x22c>
 8008b7e:	3902      	subs	r1, #2
 8008b80:	443b      	add	r3, r7
 8008b82:	1a9a      	subs	r2, r3, r2
 8008b84:	b2a3      	uxth	r3, r4
 8008b86:	fbb2 f0fe 	udiv	r0, r2, lr
 8008b8a:	fb0e 2210 	mls	r2, lr, r0, r2
 8008b8e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008b92:	fb00 fc0c 	mul.w	ip, r0, ip
 8008b96:	459c      	cmp	ip, r3
 8008b98:	d909      	bls.n	8008bae <__udivmoddi4+0x8e>
 8008b9a:	18fb      	adds	r3, r7, r3
 8008b9c:	f100 32ff 	add.w	r2, r0, #4294967295
 8008ba0:	f080 80d6 	bcs.w	8008d50 <__udivmoddi4+0x230>
 8008ba4:	459c      	cmp	ip, r3
 8008ba6:	f240 80d3 	bls.w	8008d50 <__udivmoddi4+0x230>
 8008baa:	443b      	add	r3, r7
 8008bac:	3802      	subs	r0, #2
 8008bae:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8008bb2:	eba3 030c 	sub.w	r3, r3, ip
 8008bb6:	2100      	movs	r1, #0
 8008bb8:	b11d      	cbz	r5, 8008bc2 <__udivmoddi4+0xa2>
 8008bba:	40f3      	lsrs	r3, r6
 8008bbc:	2200      	movs	r2, #0
 8008bbe:	e9c5 3200 	strd	r3, r2, [r5]
 8008bc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008bc6:	428b      	cmp	r3, r1
 8008bc8:	d905      	bls.n	8008bd6 <__udivmoddi4+0xb6>
 8008bca:	b10d      	cbz	r5, 8008bd0 <__udivmoddi4+0xb0>
 8008bcc:	e9c5 0100 	strd	r0, r1, [r5]
 8008bd0:	2100      	movs	r1, #0
 8008bd2:	4608      	mov	r0, r1
 8008bd4:	e7f5      	b.n	8008bc2 <__udivmoddi4+0xa2>
 8008bd6:	fab3 f183 	clz	r1, r3
 8008bda:	2900      	cmp	r1, #0
 8008bdc:	d146      	bne.n	8008c6c <__udivmoddi4+0x14c>
 8008bde:	4573      	cmp	r3, lr
 8008be0:	d302      	bcc.n	8008be8 <__udivmoddi4+0xc8>
 8008be2:	4282      	cmp	r2, r0
 8008be4:	f200 8105 	bhi.w	8008df2 <__udivmoddi4+0x2d2>
 8008be8:	1a84      	subs	r4, r0, r2
 8008bea:	eb6e 0203 	sbc.w	r2, lr, r3
 8008bee:	2001      	movs	r0, #1
 8008bf0:	4690      	mov	r8, r2
 8008bf2:	2d00      	cmp	r5, #0
 8008bf4:	d0e5      	beq.n	8008bc2 <__udivmoddi4+0xa2>
 8008bf6:	e9c5 4800 	strd	r4, r8, [r5]
 8008bfa:	e7e2      	b.n	8008bc2 <__udivmoddi4+0xa2>
 8008bfc:	2a00      	cmp	r2, #0
 8008bfe:	f000 8090 	beq.w	8008d22 <__udivmoddi4+0x202>
 8008c02:	fab2 f682 	clz	r6, r2
 8008c06:	2e00      	cmp	r6, #0
 8008c08:	f040 80a4 	bne.w	8008d54 <__udivmoddi4+0x234>
 8008c0c:	1a8a      	subs	r2, r1, r2
 8008c0e:	0c03      	lsrs	r3, r0, #16
 8008c10:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008c14:	b280      	uxth	r0, r0
 8008c16:	b2bc      	uxth	r4, r7
 8008c18:	2101      	movs	r1, #1
 8008c1a:	fbb2 fcfe 	udiv	ip, r2, lr
 8008c1e:	fb0e 221c 	mls	r2, lr, ip, r2
 8008c22:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008c26:	fb04 f20c 	mul.w	r2, r4, ip
 8008c2a:	429a      	cmp	r2, r3
 8008c2c:	d907      	bls.n	8008c3e <__udivmoddi4+0x11e>
 8008c2e:	18fb      	adds	r3, r7, r3
 8008c30:	f10c 38ff 	add.w	r8, ip, #4294967295
 8008c34:	d202      	bcs.n	8008c3c <__udivmoddi4+0x11c>
 8008c36:	429a      	cmp	r2, r3
 8008c38:	f200 80e0 	bhi.w	8008dfc <__udivmoddi4+0x2dc>
 8008c3c:	46c4      	mov	ip, r8
 8008c3e:	1a9b      	subs	r3, r3, r2
 8008c40:	fbb3 f2fe 	udiv	r2, r3, lr
 8008c44:	fb0e 3312 	mls	r3, lr, r2, r3
 8008c48:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8008c4c:	fb02 f404 	mul.w	r4, r2, r4
 8008c50:	429c      	cmp	r4, r3
 8008c52:	d907      	bls.n	8008c64 <__udivmoddi4+0x144>
 8008c54:	18fb      	adds	r3, r7, r3
 8008c56:	f102 30ff 	add.w	r0, r2, #4294967295
 8008c5a:	d202      	bcs.n	8008c62 <__udivmoddi4+0x142>
 8008c5c:	429c      	cmp	r4, r3
 8008c5e:	f200 80ca 	bhi.w	8008df6 <__udivmoddi4+0x2d6>
 8008c62:	4602      	mov	r2, r0
 8008c64:	1b1b      	subs	r3, r3, r4
 8008c66:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 8008c6a:	e7a5      	b.n	8008bb8 <__udivmoddi4+0x98>
 8008c6c:	f1c1 0620 	rsb	r6, r1, #32
 8008c70:	408b      	lsls	r3, r1
 8008c72:	fa22 f706 	lsr.w	r7, r2, r6
 8008c76:	431f      	orrs	r7, r3
 8008c78:	fa0e f401 	lsl.w	r4, lr, r1
 8008c7c:	fa20 f306 	lsr.w	r3, r0, r6
 8008c80:	fa2e fe06 	lsr.w	lr, lr, r6
 8008c84:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8008c88:	4323      	orrs	r3, r4
 8008c8a:	fa00 f801 	lsl.w	r8, r0, r1
 8008c8e:	fa1f fc87 	uxth.w	ip, r7
 8008c92:	fbbe f0f9 	udiv	r0, lr, r9
 8008c96:	0c1c      	lsrs	r4, r3, #16
 8008c98:	fb09 ee10 	mls	lr, r9, r0, lr
 8008c9c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8008ca0:	fb00 fe0c 	mul.w	lr, r0, ip
 8008ca4:	45a6      	cmp	lr, r4
 8008ca6:	fa02 f201 	lsl.w	r2, r2, r1
 8008caa:	d909      	bls.n	8008cc0 <__udivmoddi4+0x1a0>
 8008cac:	193c      	adds	r4, r7, r4
 8008cae:	f100 3aff 	add.w	sl, r0, #4294967295
 8008cb2:	f080 809c 	bcs.w	8008dee <__udivmoddi4+0x2ce>
 8008cb6:	45a6      	cmp	lr, r4
 8008cb8:	f240 8099 	bls.w	8008dee <__udivmoddi4+0x2ce>
 8008cbc:	3802      	subs	r0, #2
 8008cbe:	443c      	add	r4, r7
 8008cc0:	eba4 040e 	sub.w	r4, r4, lr
 8008cc4:	fa1f fe83 	uxth.w	lr, r3
 8008cc8:	fbb4 f3f9 	udiv	r3, r4, r9
 8008ccc:	fb09 4413 	mls	r4, r9, r3, r4
 8008cd0:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8008cd4:	fb03 fc0c 	mul.w	ip, r3, ip
 8008cd8:	45a4      	cmp	ip, r4
 8008cda:	d908      	bls.n	8008cee <__udivmoddi4+0x1ce>
 8008cdc:	193c      	adds	r4, r7, r4
 8008cde:	f103 3eff 	add.w	lr, r3, #4294967295
 8008ce2:	f080 8082 	bcs.w	8008dea <__udivmoddi4+0x2ca>
 8008ce6:	45a4      	cmp	ip, r4
 8008ce8:	d97f      	bls.n	8008dea <__udivmoddi4+0x2ca>
 8008cea:	3b02      	subs	r3, #2
 8008cec:	443c      	add	r4, r7
 8008cee:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8008cf2:	eba4 040c 	sub.w	r4, r4, ip
 8008cf6:	fba0 ec02 	umull	lr, ip, r0, r2
 8008cfa:	4564      	cmp	r4, ip
 8008cfc:	4673      	mov	r3, lr
 8008cfe:	46e1      	mov	r9, ip
 8008d00:	d362      	bcc.n	8008dc8 <__udivmoddi4+0x2a8>
 8008d02:	d05f      	beq.n	8008dc4 <__udivmoddi4+0x2a4>
 8008d04:	b15d      	cbz	r5, 8008d1e <__udivmoddi4+0x1fe>
 8008d06:	ebb8 0203 	subs.w	r2, r8, r3
 8008d0a:	eb64 0409 	sbc.w	r4, r4, r9
 8008d0e:	fa04 f606 	lsl.w	r6, r4, r6
 8008d12:	fa22 f301 	lsr.w	r3, r2, r1
 8008d16:	431e      	orrs	r6, r3
 8008d18:	40cc      	lsrs	r4, r1
 8008d1a:	e9c5 6400 	strd	r6, r4, [r5]
 8008d1e:	2100      	movs	r1, #0
 8008d20:	e74f      	b.n	8008bc2 <__udivmoddi4+0xa2>
 8008d22:	fbb1 fcf2 	udiv	ip, r1, r2
 8008d26:	0c01      	lsrs	r1, r0, #16
 8008d28:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 8008d2c:	b280      	uxth	r0, r0
 8008d2e:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 8008d32:	463b      	mov	r3, r7
 8008d34:	4638      	mov	r0, r7
 8008d36:	463c      	mov	r4, r7
 8008d38:	46b8      	mov	r8, r7
 8008d3a:	46be      	mov	lr, r7
 8008d3c:	2620      	movs	r6, #32
 8008d3e:	fbb1 f1f7 	udiv	r1, r1, r7
 8008d42:	eba2 0208 	sub.w	r2, r2, r8
 8008d46:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 8008d4a:	e766      	b.n	8008c1a <__udivmoddi4+0xfa>
 8008d4c:	4601      	mov	r1, r0
 8008d4e:	e718      	b.n	8008b82 <__udivmoddi4+0x62>
 8008d50:	4610      	mov	r0, r2
 8008d52:	e72c      	b.n	8008bae <__udivmoddi4+0x8e>
 8008d54:	f1c6 0220 	rsb	r2, r6, #32
 8008d58:	fa2e f302 	lsr.w	r3, lr, r2
 8008d5c:	40b7      	lsls	r7, r6
 8008d5e:	40b1      	lsls	r1, r6
 8008d60:	fa20 f202 	lsr.w	r2, r0, r2
 8008d64:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008d68:	430a      	orrs	r2, r1
 8008d6a:	fbb3 f8fe 	udiv	r8, r3, lr
 8008d6e:	b2bc      	uxth	r4, r7
 8008d70:	fb0e 3318 	mls	r3, lr, r8, r3
 8008d74:	0c11      	lsrs	r1, r2, #16
 8008d76:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8008d7a:	fb08 f904 	mul.w	r9, r8, r4
 8008d7e:	40b0      	lsls	r0, r6
 8008d80:	4589      	cmp	r9, r1
 8008d82:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8008d86:	b280      	uxth	r0, r0
 8008d88:	d93e      	bls.n	8008e08 <__udivmoddi4+0x2e8>
 8008d8a:	1879      	adds	r1, r7, r1
 8008d8c:	f108 3cff 	add.w	ip, r8, #4294967295
 8008d90:	d201      	bcs.n	8008d96 <__udivmoddi4+0x276>
 8008d92:	4589      	cmp	r9, r1
 8008d94:	d81f      	bhi.n	8008dd6 <__udivmoddi4+0x2b6>
 8008d96:	eba1 0109 	sub.w	r1, r1, r9
 8008d9a:	fbb1 f9fe 	udiv	r9, r1, lr
 8008d9e:	fb09 f804 	mul.w	r8, r9, r4
 8008da2:	fb0e 1119 	mls	r1, lr, r9, r1
 8008da6:	b292      	uxth	r2, r2
 8008da8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8008dac:	4542      	cmp	r2, r8
 8008dae:	d229      	bcs.n	8008e04 <__udivmoddi4+0x2e4>
 8008db0:	18ba      	adds	r2, r7, r2
 8008db2:	f109 31ff 	add.w	r1, r9, #4294967295
 8008db6:	d2c4      	bcs.n	8008d42 <__udivmoddi4+0x222>
 8008db8:	4542      	cmp	r2, r8
 8008dba:	d2c2      	bcs.n	8008d42 <__udivmoddi4+0x222>
 8008dbc:	f1a9 0102 	sub.w	r1, r9, #2
 8008dc0:	443a      	add	r2, r7
 8008dc2:	e7be      	b.n	8008d42 <__udivmoddi4+0x222>
 8008dc4:	45f0      	cmp	r8, lr
 8008dc6:	d29d      	bcs.n	8008d04 <__udivmoddi4+0x1e4>
 8008dc8:	ebbe 0302 	subs.w	r3, lr, r2
 8008dcc:	eb6c 0c07 	sbc.w	ip, ip, r7
 8008dd0:	3801      	subs	r0, #1
 8008dd2:	46e1      	mov	r9, ip
 8008dd4:	e796      	b.n	8008d04 <__udivmoddi4+0x1e4>
 8008dd6:	eba7 0909 	sub.w	r9, r7, r9
 8008dda:	4449      	add	r1, r9
 8008ddc:	f1a8 0c02 	sub.w	ip, r8, #2
 8008de0:	fbb1 f9fe 	udiv	r9, r1, lr
 8008de4:	fb09 f804 	mul.w	r8, r9, r4
 8008de8:	e7db      	b.n	8008da2 <__udivmoddi4+0x282>
 8008dea:	4673      	mov	r3, lr
 8008dec:	e77f      	b.n	8008cee <__udivmoddi4+0x1ce>
 8008dee:	4650      	mov	r0, sl
 8008df0:	e766      	b.n	8008cc0 <__udivmoddi4+0x1a0>
 8008df2:	4608      	mov	r0, r1
 8008df4:	e6fd      	b.n	8008bf2 <__udivmoddi4+0xd2>
 8008df6:	443b      	add	r3, r7
 8008df8:	3a02      	subs	r2, #2
 8008dfa:	e733      	b.n	8008c64 <__udivmoddi4+0x144>
 8008dfc:	f1ac 0c02 	sub.w	ip, ip, #2
 8008e00:	443b      	add	r3, r7
 8008e02:	e71c      	b.n	8008c3e <__udivmoddi4+0x11e>
 8008e04:	4649      	mov	r1, r9
 8008e06:	e79c      	b.n	8008d42 <__udivmoddi4+0x222>
 8008e08:	eba1 0109 	sub.w	r1, r1, r9
 8008e0c:	46c4      	mov	ip, r8
 8008e0e:	fbb1 f9fe 	udiv	r9, r1, lr
 8008e12:	fb09 f804 	mul.w	r8, r9, r4
 8008e16:	e7c4      	b.n	8008da2 <__udivmoddi4+0x282>

08008e18 <__aeabi_idiv0>:
 8008e18:	4770      	bx	lr
 8008e1a:	bf00      	nop

08008e1c <main>:
  * @brief  main function
  * @param  None
  * @retval int
  */
int main(void)
{
 8008e1c:	b530      	push	{r4, r5, lr}
 8008e1e:	b09d      	sub	sp, #116	@ 0x74
#endif /* SFU_MPU_PROTECT_ENABLE */

  /* MCU Configuration--------------------------------------------------------*/
  /* This part is NOT secure (security mechanisms NOT enabled yet)            */
  /* Reset of all peripherals, Initializes the Flash interface and the Systick*/
  (void) HAL_Init();
 8008e20:	f002 f95a 	bl	800b0d8 <HAL_Init>
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;
  
  /*!< Supply configuration update enable */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 8008e24:	2002      	movs	r0, #2
 8008e26:	f003 f80f 	bl	800be48 <HAL_PWREx_ConfigSupply>

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8008e2a:	2300      	movs	r3, #0
 8008e2c:	9300      	str	r3, [sp, #0]
 8008e2e:	4b26      	ldr	r3, [pc, #152]	@ (8008ec8 <main+0xac>)
 8008e30:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8008e32:	f022 0201 	bic.w	r2, r2, #1
 8008e36:	62da      	str	r2, [r3, #44]	@ 0x2c
 8008e38:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008e3a:	f003 0301 	and.w	r3, r3, #1
 8008e3e:	9300      	str	r3, [sp, #0]
 8008e40:	4b22      	ldr	r3, [pc, #136]	@ (8008ecc <main+0xb0>)
 8008e42:	699a      	ldr	r2, [r3, #24]
 8008e44:	f442 4240 	orr.w	r2, r2, #49152	@ 0xc000
 8008e48:	619a      	str	r2, [r3, #24]
 8008e4a:	699a      	ldr	r2, [r3, #24]
 8008e4c:	f402 4240 	and.w	r2, r2, #49152	@ 0xc000
 8008e50:	9200      	str	r2, [sp, #0]
 8008e52:	9a00      	ldr	r2, [sp, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8008e54:	699a      	ldr	r2, [r3, #24]
 8008e56:	0490      	lsls	r0, r2, #18
 8008e58:	d5fc      	bpl.n	8008e54 <main+0x38>
  
  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8008e5a:	2101      	movs	r1, #1
 8008e5c:	f44f 23a0 	mov.w	r3, #327680	@ 0x50000
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8008e60:	2202      	movs	r2, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;

  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 400;
 8008e62:	2404      	movs	r4, #4
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLQ = 4;

  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 8008e64:	2508      	movs	r5, #8
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8008e66:	a809      	add	r0, sp, #36	@ 0x24
  RCC_OscInitStruct.PLL.PLLP = 2;
 8008e68:	9216      	str	r2, [sp, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 8008e6a:	9519      	str	r5, [sp, #100]	@ 0x64
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8008e6c:	e9cd 1309 	strd	r1, r3, [sp, #36]	@ 0x24
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 8008e70:	2300      	movs	r3, #0
  RCC_OscInitStruct.PLL.PLLN = 400;
 8008e72:	f44f 71c8 	mov.w	r1, #400	@ 0x190
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 8008e76:	930c      	str	r3, [sp, #48]	@ 0x30
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
 8008e78:	9310      	str	r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8008e7a:	931b      	str	r3, [sp, #108]	@ 0x6c
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 8008e7c:	931a      	str	r3, [sp, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8008e7e:	e9cd 2212 	strd	r2, r2, [sp, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLN = 400;
 8008e82:	e9cd 4114 	strd	r4, r1, [sp, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8008e86:	e9cd 4217 	strd	r4, r2, [sp, #92]	@ 0x5c
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8008e8a:	f003 f801 	bl	800be90 <HAL_RCC_OscConfig>
  if(ret != HAL_OK)
 8008e8e:	b100      	cbz	r0, 8008e92 <main+0x76>
 8008e90:	e7fe      	b.n	8008e90 <main+0x74>
  
/* Select PLL as system clock source and configure  bus clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \
                                 RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1);

  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8008e92:	223f      	movs	r2, #63	@ 0x3f
 8008e94:	2303      	movs	r3, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;  
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2; 
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2; 
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2; 
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8008e96:	4621      	mov	r1, r4
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8008e98:	e9cd 2301 	strd	r2, r3, [sp, #4]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;  
 8008e9c:	2340      	movs	r3, #64	@ 0x40
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2; 
 8008e9e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 8008ea2:	e9cd 0503 	strd	r0, r5, [sp, #12]
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8008ea6:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2; 
 8008ea8:	e9cd 3305 	strd	r3, r3, [sp, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2; 
 8008eac:	e9cd 2307 	strd	r2, r3, [sp, #28]
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8008eb0:	f003 fb38 	bl	800c524 <HAL_RCC_ClockConfig>
  if(ret != HAL_OK)
 8008eb4:	4604      	mov	r4, r0
 8008eb6:	b100      	cbz	r0, 8008eba <main+0x9e>
 8008eb8:	e7fe      	b.n	8008eb8 <main+0x9c>
  (void)SFU_BOOT_RunSecureBootService(); /* no need to take care of the returned value as we reboot in all cases */
 8008eba:	f000 faf7 	bl	80094ac <SFU_BOOT_RunSecureBootService>
  SFU_BOOT_ForceReboot();
 8008ebe:	f000 fa45 	bl	800934c <SFU_BOOT_ForceReboot>
}
 8008ec2:	4620      	mov	r0, r4
 8008ec4:	b01d      	add	sp, #116	@ 0x74
 8008ec6:	bd30      	pop	{r4, r5, pc}
 8008ec8:	58000400 	.word	0x58000400
 8008ecc:	58024800 	.word	0x58024800

08008ed0 <HAL_MspInit>:
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008ed0:	4b18      	ldr	r3, [pc, #96]	@ (8008f34 <HAL_MspInit+0x64>)
{
 8008ed2:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008ed4:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008ed8:	2003      	movs	r0, #3
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008eda:	f042 0202 	orr.w	r2, r2, #2
 8008ede:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
 8008ee2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8008ee6:	f003 0302 	and.w	r3, r3, #2
 8008eea:	9301      	str	r3, [sp, #4]
 8008eec:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008eee:	f002 f953 	bl	800b198 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0U, 0U);
 8008ef2:	2200      	movs	r2, #0
 8008ef4:	f06f 000b 	mvn.w	r0, #11
 8008ef8:	4611      	mov	r1, r2
 8008efa:	f002 f95f 	bl	800b1bc <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0U, 0U);
 8008efe:	2200      	movs	r2, #0
 8008f00:	f06f 000a 	mvn.w	r0, #10
 8008f04:	4611      	mov	r1, r2
 8008f06:	f002 f959 	bl	800b1bc <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0U, 0U);
 8008f0a:	2200      	movs	r2, #0
 8008f0c:	f06f 0009 	mvn.w	r0, #9
 8008f10:	4611      	mov	r1, r2
 8008f12:	f002 f953 	bl	800b1bc <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0U, 0U);
 8008f16:	2200      	movs	r2, #0
 8008f18:	f06f 0003 	mvn.w	r0, #3
 8008f1c:	4611      	mov	r1, r2
 8008f1e:	f002 f94d 	bl	800b1bc <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0U, 0U);
 8008f22:	2200      	movs	r2, #0
 8008f24:	f04f 30ff 	mov.w	r0, #4294967295
 8008f28:	4611      	mov	r1, r2

}
 8008f2a:	b003      	add	sp, #12
 8008f2c:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_SetPriority(SysTick_IRQn, 0U, 0U);
 8008f30:	f002 b944 	b.w	800b1bc <HAL_NVIC_SetPriority>
 8008f34:	58024400 	.word	0x58024400

08008f38 <HAL_UART_MspInit>:
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
  SFU_LL_UART_MspInit(huart);
 8008f38:	f001 bc1c 	b.w	800a774 <SFU_LL_UART_MspInit>

08008f3c <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 8008f3c:	e7fe      	b.n	8008f3c <UsageFault_Handler>

08008f3e <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}
 8008f3e:	4770      	bx	lr

08008f40 <PendSV_Handler>:
/**
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
 8008f40:	4770      	bx	lr

08008f42 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 8008f42:	f002 b8f7 	b.w	800b134 <HAL_IncTick>

08008f46 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

int _read (int file, char *ptr, int len)
{
 8008f46:	b570      	push	{r4, r5, r6, lr}
 8008f48:	460d      	mov	r5, r1
 8008f4a:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f4c:	460e      	mov	r6, r1
 8008f4e:	1b73      	subs	r3, r6, r5
 8008f50:	429c      	cmp	r4, r3
 8008f52:	dc01      	bgt.n	8008f58 <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 8008f54:	4620      	mov	r0, r4
 8008f56:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 8008f58:	f3af 8000 	nop.w
 8008f5c:	f806 0b01 	strb.w	r0, [r6], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f60:	e7f5      	b.n	8008f4e <_read+0x8>

08008f62 <_write>:

int _write(int file, char *ptr, int len)
{
 8008f62:	b570      	push	{r4, r5, r6, lr}
 8008f64:	460d      	mov	r5, r1
 8008f66:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f68:	460e      	mov	r6, r1
 8008f6a:	1b73      	subs	r3, r6, r5
 8008f6c:	429c      	cmp	r4, r3
 8008f6e:	dc01      	bgt.n	8008f74 <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 8008f70:	4620      	mov	r0, r4
 8008f72:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 8008f74:	f816 0b01 	ldrb.w	r0, [r6], #1
 8008f78:	f000 fd01 	bl	800997e <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8008f7c:	e7f5      	b.n	8008f6a <_write+0x8>
	...

08008f80 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8008f80:	4a0a      	ldr	r2, [pc, #40]	@ (8008fac <_sbrk+0x2c>)
 8008f82:	6811      	ldr	r1, [r2, #0]
{
 8008f84:	b508      	push	{r3, lr}
 8008f86:	4603      	mov	r3, r0
	if (heap_end == 0)
 8008f88:	b909      	cbnz	r1, 8008f8e <_sbrk+0xe>
		heap_end = &end;
 8008f8a:	4909      	ldr	r1, [pc, #36]	@ (8008fb0 <_sbrk+0x30>)
 8008f8c:	6011      	str	r1, [r2, #0]

	prev_heap_end = heap_end;
 8008f8e:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 8008f90:	4669      	mov	r1, sp
 8008f92:	4403      	add	r3, r0
 8008f94:	428b      	cmp	r3, r1
 8008f96:	d906      	bls.n	8008fa6 <_sbrk+0x26>
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8008f98:	f004 fc44 	bl	800d824 <__errno>
 8008f9c:	230c      	movs	r3, #12
 8008f9e:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 8008fa0:	f04f 30ff 	mov.w	r0, #4294967295
	}

	heap_end += incr;

	return (caddr_t) prev_heap_end;
}
 8008fa4:	bd08      	pop	{r3, pc}
	heap_end += incr;
 8008fa6:	6013      	str	r3, [r2, #0]
	return (caddr_t) prev_heap_end;
 8008fa8:	e7fc      	b.n	8008fa4 <_sbrk+0x24>
 8008faa:	bf00      	nop
 8008fac:	200011a4 	.word	0x200011a4
 8008fb0:	20001ec8 	.word	0x20001ec8

08008fb4 <_close>:

int _close(int file)
{
	return -1;
}
 8008fb4:	f04f 30ff 	mov.w	r0, #4294967295
 8008fb8:	4770      	bx	lr

08008fba <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8008fba:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
	return 0;
}
 8008fbe:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 8008fc0:	604b      	str	r3, [r1, #4]
}
 8008fc2:	4770      	bx	lr

08008fc4 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8008fc4:	2001      	movs	r0, #1
 8008fc6:	4770      	bx	lr

08008fc8 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8008fc8:	2000      	movs	r0, #0
 8008fca:	4770      	bx	lr

08008fcc <SFU_BOOT_SM_HandleCriticalFailure>:
  * @param  None
  * @note   After a Critical Failure a Reboot will be called.
  * @retval None
  */
static void SFU_BOOT_SM_HandleCriticalFailure(void)
{
 8008fcc:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: HANDLE CRITICAL FAILURE");
 8008fce:	4805      	ldr	r0, [pc, #20]	@ (8008fe4 <SFU_BOOT_SM_HandleCriticalFailure+0x18>)
 8008fd0:	f004 f9ce 	bl	800d370 <iprintf>

  /* It's not possible to continue without compromising the stability or the security of the solution.
     The State Machine needs to be aborted and a Reset must be triggered */
  SFU_SET_SM_IF_CURR_STATE(SFU_ERROR, SFU_STATE_REBOOT_STATE_MACHINE, SFU_STATE_REBOOT_STATE_MACHINE);
 8008fd4:	4b04      	ldr	r3, [pc, #16]	@ (8008fe8 <SFU_BOOT_SM_HandleCriticalFailure+0x1c>)
 8008fd6:	785a      	ldrb	r2, [r3, #1]
 8008fd8:	b2d2      	uxtb	r2, r2
 8008fda:	701a      	strb	r2, [r3, #0]
 8008fdc:	2207      	movs	r2, #7
 8008fde:	705a      	strb	r2, [r3, #1]
}
 8008fe0:	bd08      	pop	{r3, pc}
 8008fe2:	bf00      	nop
 8008fe4:	0800e456 	.word	0x0800e456
 8008fe8:	200011ac 	.word	0x200011ac

08008fec <SFU_BOOT_SM_VerifyUserFwSignature>:
{
 8008fec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8008fee:	4f35      	ldr	r7, [pc, #212]	@ (80090c4 <SFU_BOOT_SM_VerifyUserFwSignature+0xd8>)
  TRACE("\r\n= [SBOOT] STATE: VERIFY USER FW SIGNATURE");
 8008ff0:	4835      	ldr	r0, [pc, #212]	@ (80090c8 <SFU_BOOT_SM_VerifyUserFwSignature+0xdc>)
 8008ff2:	f004 f9bd 	bl	800d370 <iprintf>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8008ff6:	683a      	ldr	r2, [r7, #0]
 8008ff8:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 8008ffc:	429a      	cmp	r2, r3
 8008ffe:	d001      	beq.n	8009004 <SFU_BOOT_SM_VerifyUserFwSignature+0x18>
 8009000:	f000 fcfc 	bl	80099fc <SFU_EXCPT_Security_Error>
  FLOW_CONTROL_INIT(uFlowProtectValue, FLOW_CTRL_INIT_VALUE);
 8009004:	f245 7376 	movw	r3, #22390	@ 0x5776
 8009008:	603b      	str	r3, [r7, #0]
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 800900a:	f001 fe3d 	bl	800ac88 <SFU_LL_SECU_CheckApplyStaticProtections>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 800900e:	683a      	ldr	r2, [r7, #0]
 8009010:	f243 03f1 	movw	r3, #12529	@ 0x30f1
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 8009014:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 8009016:	429a      	cmp	r2, r3
 8009018:	d001      	beq.n	800901e <SFU_BOOT_SM_VerifyUserFwSignature+0x32>
 800901a:	f000 fcef 	bl	80099fc <SFU_EXCPT_Security_Error>
  if (e_ret_status == SFU_SUCCESS)
 800901e:	4b2b      	ldr	r3, [pc, #172]	@ (80090cc <SFU_BOOT_SM_VerifyUserFwSignature+0xe0>)
 8009020:	429c      	cmp	r4, r3
 8009022:	d103      	bne.n	800902c <SFU_BOOT_SM_VerifyUserFwSignature+0x40>
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_THIRD_CONFIGURATION);
 8009024:	2002      	movs	r0, #2
 8009026:	f001 fe9d 	bl	800ad64 <SFU_LL_SECU_CheckApplyRuntimeProtections>
 800902a:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 800902c:	683a      	ldr	r2, [r7, #0]
 800902e:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 8009032:	429a      	cmp	r2, r3
 8009034:	d001      	beq.n	800903a <SFU_BOOT_SM_VerifyUserFwSignature+0x4e>
 8009036:	f000 fce1 	bl	80099fc <SFU_EXCPT_Security_Error>
  if (e_ret_status != SFU_SUCCESS)
 800903a:	4b24      	ldr	r3, [pc, #144]	@ (80090cc <SFU_BOOT_SM_VerifyUserFwSignature+0xe0>)
 800903c:	4e24      	ldr	r6, [pc, #144]	@ (80090d0 <SFU_BOOT_SM_VerifyUserFwSignature+0xe4>)
 800903e:	429c      	cmp	r4, r3
 8009040:	d015      	beq.n	800906e <SFU_BOOT_SM_VerifyUserFwSignature+0x82>
    SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009042:	7873      	ldrb	r3, [r6, #1]
 8009044:	b2db      	uxtb	r3, r3
 8009046:	7033      	strb	r3, [r6, #0]
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_EXECUTE_USER_FW, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009048:	2306      	movs	r3, #6
 800904a:	e038      	b.n	80090be <SFU_BOOT_SM_VerifyUserFwSignature+0xd2>
          FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 800904c:	687a      	ldr	r2, [r7, #4]
 800904e:	f248 435a 	movw	r3, #33882	@ 0x845a
 8009052:	429a      	cmp	r2, r3
 8009054:	d02c      	beq.n	80090b0 <SFU_BOOT_SM_VerifyUserFwSignature+0xc4>
 8009056:	f000 fcd1 	bl	80099fc <SFU_EXCPT_Security_Error>
 800905a:	e029      	b.n	80090b0 <SFU_BOOT_SM_VerifyUserFwSignature+0xc4>
        if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 800905c:	2001      	movs	r0, #1
 800905e:	f000 ff1b 	bl	8009e98 <SFU_IMG_VerifyEmptyActiveSlot>
 8009062:	42a0      	cmp	r0, r4
 8009064:	d024      	beq.n	80090b0 <SFU_BOOT_SM_VerifyUserFwSignature+0xc4>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 8009066:	2001      	movs	r0, #1
 8009068:	f000 fee0 	bl	8009e2c <SFU_IMG_InvalidateCurrentFirmware>
 800906c:	e020      	b.n	80090b0 <SFU_BOOT_SM_VerifyUserFwSignature+0xc4>
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 800906e:	4b19      	ldr	r3, [pc, #100]	@ (80090d4 <SFU_BOOT_SM_VerifyUserFwSignature+0xe8>)
 8009070:	685b      	ldr	r3, [r3, #4]
 8009072:	b1eb      	cbz	r3, 80090b0 <SFU_BOOT_SM_VerifyUserFwSignature+0xc4>
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009074:	2001      	movs	r0, #1
 8009076:	f000 ffc3 	bl	800a000 <SFU_IMG_DetectFW>
 800907a:	42a0      	cmp	r0, r4
 800907c:	d1ee      	bne.n	800905c <SFU_BOOT_SM_VerifyUserFwSignature+0x70>
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 800907e:	f245 7376 	movw	r3, #22390	@ 0x5776
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009082:	2001      	movs	r0, #1
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 8009084:	607b      	str	r3, [r7, #4]
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009086:	f000 ffa5 	bl	8009fd4 <SFU_IMG_VerifyActiveImgMetadata>
        if (SFU_SUCCESS == e_ret_status)
 800908a:	42a0      	cmp	r0, r4
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 800908c:	4605      	mov	r5, r0
        if (SFU_SUCCESS == e_ret_status)
 800908e:	d10b      	bne.n	80090a8 <SFU_BOOT_SM_VerifyUserFwSignature+0xbc>
          e_ret_status = SFU_IMG_VerifyActiveImg(SLOT_ACTIVE_1 + i);
 8009090:	2001      	movs	r0, #1
 8009092:	f000 fedf 	bl	8009e54 <SFU_IMG_VerifyActiveImg>
          if (SFU_SUCCESS == e_ret_status)
 8009096:	42a0      	cmp	r0, r4
          e_ret_status = SFU_IMG_VerifyActiveImg(SLOT_ACTIVE_1 + i);
 8009098:	4605      	mov	r5, r0
          if (SFU_SUCCESS == e_ret_status)
 800909a:	d105      	bne.n	80090a8 <SFU_BOOT_SM_VerifyUserFwSignature+0xbc>
            e_ret_status = SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i);
 800909c:	2001      	movs	r0, #1
 800909e:	f000 fee9 	bl	8009e74 <SFU_IMG_VerifyActiveSlot>
        if (SFU_SUCCESS != e_ret_status)
 80090a2:	42a0      	cmp	r0, r4
            e_ret_status = SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i);
 80090a4:	4605      	mov	r5, r0
        if (SFU_SUCCESS != e_ret_status)
 80090a6:	d0d1      	beq.n	800904c <SFU_BOOT_SM_VerifyUserFwSignature+0x60>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 80090a8:	462c      	mov	r4, r5
 80090aa:	2001      	movs	r0, #1
 80090ac:	f000 febe 	bl	8009e2c <SFU_IMG_InvalidateCurrentFirmware>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_EXECUTE_USER_FW, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 80090b0:	7873      	ldrb	r3, [r6, #1]
 80090b2:	b2db      	uxtb	r3, r3
 80090b4:	7033      	strb	r3, [r6, #0]
 80090b6:	4b05      	ldr	r3, [pc, #20]	@ (80090cc <SFU_BOOT_SM_VerifyUserFwSignature+0xe0>)
 80090b8:	429c      	cmp	r4, r3
 80090ba:	d1c5      	bne.n	8009048 <SFU_BOOT_SM_VerifyUserFwSignature+0x5c>
 80090bc:	2305      	movs	r3, #5
 80090be:	7073      	strb	r3, [r6, #1]
}
 80090c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80090c2:	bf00      	nop
 80090c4:	20001100 	.word	0x20001100
 80090c8:	0800e481 	.word	0x0800e481
 80090cc:	00122f11 	.word	0x00122f11
 80090d0:	200011ac 	.word	0x200011ac
 80090d4:	0800e33c 	.word	0x0800e33c

080090d8 <SFU_BOOT_SM_CheckUserFwStatus>:
{
 80090d8:	b538      	push	{r3, r4, r5, lr}
  if (initialDeviceStatusCheck == 1U)
 80090da:	4c28      	ldr	r4, [pc, #160]	@ (800917c <SFU_BOOT_SM_CheckUserFwStatus+0xa4>)
 80090dc:	6863      	ldr	r3, [r4, #4]
 80090de:	2b01      	cmp	r3, #1
 80090e0:	d102      	bne.n	80090e8 <SFU_BOOT_SM_CheckUserFwStatus+0x10>
    TRACE("\r\n= [SBOOT] STATE: CHECK USER FW STATUS");
 80090e2:	4827      	ldr	r0, [pc, #156]	@ (8009180 <SFU_BOOT_SM_CheckUserFwStatus+0xa8>)
 80090e4:	f004 f944 	bl	800d370 <iprintf>
  m_ActiveSlotToExecute = 0U;
 80090e8:	2300      	movs	r3, #0
    if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
 80090ea:	2001      	movs	r0, #1
  m_ActiveSlotToExecute = 0U;
 80090ec:	60a3      	str	r3, [r4, #8]
    if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
 80090ee:	f000 ff87 	bl	800a000 <SFU_IMG_DetectFW>
 80090f2:	4b24      	ldr	r3, [pc, #144]	@ (8009184 <SFU_BOOT_SM_CheckUserFwStatus+0xac>)
 80090f4:	4298      	cmp	r0, r3
 80090f6:	d109      	bne.n	800910c <SFU_BOOT_SM_CheckUserFwStatus+0x34>
      m_ActiveSlotToExecute = MASTER_SLOT;
 80090f8:	2101      	movs	r1, #1
      TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 80090fa:	4823      	ldr	r0, [pc, #140]	@ (8009188 <SFU_BOOT_SM_CheckUserFwStatus+0xb0>)
      m_ActiveSlotToExecute = MASTER_SLOT;
 80090fc:	60a1      	str	r1, [r4, #8]
      TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 80090fe:	f004 f937 	bl	800d370 <iprintf>
      SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_SIGNATURE);
 8009102:	7863      	ldrb	r3, [r4, #1]
 8009104:	b2db      	uxtb	r3, r3
 8009106:	7023      	strb	r3, [r4, #0]
 8009108:	2304      	movs	r3, #4
 800910a:	7063      	strb	r3, [r4, #1]
  if (m_ActiveSlotToExecute == 0U)
 800910c:	68a3      	ldr	r3, [r4, #8]
 800910e:	2b00      	cmp	r3, #0
 8009110:	d132      	bne.n	8009178 <SFU_BOOT_SM_CheckUserFwStatus+0xa0>
      if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)         /* Slot configured ? */
 8009112:	4b1e      	ldr	r3, [pc, #120]	@ (800918c <SFU_BOOT_SM_CheckUserFwStatus+0xb4>)
 8009114:	685d      	ldr	r5, [r3, #4]
 8009116:	b17d      	cbz	r5, 8009138 <SFU_BOOT_SM_CheckUserFwStatus+0x60>
        if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009118:	2001      	movs	r0, #1
 800911a:	f000 ff71 	bl	800a000 <SFU_IMG_DetectFW>
 800911e:	4b19      	ldr	r3, [pc, #100]	@ (8009184 <SFU_BOOT_SM_CheckUserFwStatus+0xac>)
 8009120:	4298      	cmp	r0, r3
 8009122:	d109      	bne.n	8009138 <SFU_BOOT_SM_CheckUserFwStatus+0x60>
          m_ActiveSlotToExecute = SLOT_ACTIVE_1 + i;
 8009124:	2101      	movs	r1, #1
          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009126:	4818      	ldr	r0, [pc, #96]	@ (8009188 <SFU_BOOT_SM_CheckUserFwStatus+0xb0>)
          m_ActiveSlotToExecute = SLOT_ACTIVE_1 + i;
 8009128:	60a1      	str	r1, [r4, #8]
          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 800912a:	f004 f921 	bl	800d370 <iprintf>
          SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_SIGNATURE);
 800912e:	7863      	ldrb	r3, [r4, #1]
 8009130:	b2db      	uxtb	r3, r3
 8009132:	7023      	strb	r3, [r4, #0]
 8009134:	2304      	movs	r3, #4
 8009136:	7063      	strb	r3, [r4, #1]
  if (m_ActiveSlotToExecute == 0U)
 8009138:	68a3      	ldr	r3, [r4, #8]
 800913a:	b9eb      	cbnz	r3, 8009178 <SFU_BOOT_SM_CheckUserFwStatus+0xa0>
      if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)       /* Slot configured ? */
 800913c:	b165      	cbz	r5, 8009158 <SFU_BOOT_SM_CheckUserFwStatus+0x80>
        if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 800913e:	2001      	movs	r0, #1
 8009140:	f000 feaa 	bl	8009e98 <SFU_IMG_VerifyEmptyActiveSlot>
 8009144:	4b0f      	ldr	r3, [pc, #60]	@ (8009184 <SFU_BOOT_SM_CheckUserFwStatus+0xac>)
 8009146:	4298      	cmp	r0, r3
 8009148:	d006      	beq.n	8009158 <SFU_BOOT_SM_CheckUserFwStatus+0x80>
          TRACE("\r\n\t  Slot SLOT_ACTIVE_%d not empty : erasing ...", SLOT_ACTIVE_1 + i);
 800914a:	2101      	movs	r1, #1
 800914c:	4810      	ldr	r0, [pc, #64]	@ (8009190 <SFU_BOOT_SM_CheckUserFwStatus+0xb8>)
 800914e:	f004 f90f 	bl	800d370 <iprintf>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 8009152:	2001      	movs	r0, #1
 8009154:	f000 fe6a 	bl	8009e2c <SFU_IMG_InvalidateCurrentFirmware>
    if (initialDeviceStatusCheck == 1U)
 8009158:	6863      	ldr	r3, [r4, #4]
 800915a:	2b01      	cmp	r3, #1
 800915c:	d107      	bne.n	800916e <SFU_BOOT_SM_CheckUserFwStatus+0x96>
      TRACE("\r\n\t  No valid FW found in the active slots nor new FW to be installed");
 800915e:	480d      	ldr	r0, [pc, #52]	@ (8009194 <SFU_BOOT_SM_CheckUserFwStatus+0xbc>)
 8009160:	f004 f906 	bl	800d370 <iprintf>
      TRACE("\r\n\t  Waiting for the local download to start... ");
 8009164:	480c      	ldr	r0, [pc, #48]	@ (8009198 <SFU_BOOT_SM_CheckUserFwStatus+0xc0>)
 8009166:	f004 f903 	bl	800d370 <iprintf>
      initialDeviceStatusCheck = 0U;
 800916a:	2300      	movs	r3, #0
 800916c:	6063      	str	r3, [r4, #4]
    SFU_SET_SM_CURR_STATE(SFU_STATE_CHECK_NEW_FW_TO_DOWNLOAD);
 800916e:	7863      	ldrb	r3, [r4, #1]
 8009170:	b2db      	uxtb	r3, r3
 8009172:	7023      	strb	r3, [r4, #0]
 8009174:	2301      	movs	r3, #1
 8009176:	7063      	strb	r3, [r4, #1]
}
 8009178:	bd38      	pop	{r3, r4, r5, pc}
 800917a:	bf00      	nop
 800917c:	200011ac 	.word	0x200011ac
 8009180:	0800e4ad 	.word	0x0800e4ad
 8009184:	00122f11 	.word	0x00122f11
 8009188:	0800e4d5 	.word	0x0800e4d5
 800918c:	0800e33c 	.word	0x0800e33c
 8009190:	0800e506 	.word	0x0800e506
 8009194:	0800e537 	.word	0x0800e537
 8009198:	0800e57d 	.word	0x0800e57d

0800919c <SFU_BOOT_SM_DownloadNewUserFw>:
{
 800919c:	b530      	push	{r4, r5, lr}
  SFU_LOADER_StatusTypeDef  e_ret_status_app = SFU_LOADER_ERR_COM;
 800919e:	2301      	movs	r3, #1
{
 80091a0:	b085      	sub	sp, #20
  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
 80091a2:	4826      	ldr	r0, [pc, #152]	@ (800923c <SFU_BOOT_SM_DownloadNewUserFw+0xa0>)
  SFU_LOADER_StatusTypeDef  e_ret_status_app = SFU_LOADER_ERR_COM;
 80091a4:	f88d 3007 	strb.w	r3, [sp, #7]
  uint32_t                  u_size = 0;
 80091a8:	2300      	movs	r3, #0
  if (e_ret_status == SFU_SUCCESS)
 80091aa:	4d25      	ldr	r5, [pc, #148]	@ (8009240 <SFU_BOOT_SM_DownloadNewUserFw+0xa4>)
  uint32_t                  u_size = 0;
 80091ac:	9303      	str	r3, [sp, #12]
  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
 80091ae:	f004 f8df 	bl	800d370 <iprintf>
  e_ret_status = SFU_LOADER_DownloadNewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
 80091b2:	aa03      	add	r2, sp, #12
 80091b4:	a902      	add	r1, sp, #8
 80091b6:	f10d 0007 	add.w	r0, sp, #7
 80091ba:	f001 f81d 	bl	800a1f8 <SFU_LOADER_DownloadNewUserFw>
  if (e_ret_status == SFU_SUCCESS)
 80091be:	42a8      	cmp	r0, r5
  e_ret_status = SFU_LOADER_DownloadNewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
 80091c0:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 80091c2:	d120      	bne.n	8009206 <SFU_BOOT_SM_DownloadNewUserFw+0x6a>
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, (uint8_t *) SlotStartAdd[dwl_slot],
 80091c4:	4b1f      	ldr	r3, [pc, #124]	@ (8009244 <SFU_BOOT_SM_DownloadNewUserFw+0xa8>)
 80091c6:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 80091ca:	9902      	ldr	r1, [sp, #8]
 80091cc:	481e      	ldr	r0, [pc, #120]	@ (8009248 <SFU_BOOT_SM_DownloadNewUserFw+0xac>)
 80091ce:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 80091d2:	f001 fb6d 	bl	800a8b0 <SFU_LL_FLASH_Read>
  if (e_ret_status == SFU_SUCCESS)
 80091d6:	42a8      	cmp	r0, r5
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, (uint8_t *) SlotStartAdd[dwl_slot],
 80091d8:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 80091da:	d114      	bne.n	8009206 <SFU_BOOT_SM_DownloadNewUserFw+0x6a>
    if (SFU_IMG_Validation(dwl_slot, &fw_image_header_validated) != SFU_SUCCESS)
 80091dc:	491a      	ldr	r1, [pc, #104]	@ (8009248 <SFU_BOOT_SM_DownloadNewUserFw+0xac>)
 80091de:	9802      	ldr	r0, [sp, #8]
 80091e0:	f000 fea4 	bl	8009f2c <SFU_IMG_Validation>
 80091e4:	42a0      	cmp	r0, r4
 80091e6:	d002      	beq.n	80091ee <SFU_BOOT_SM_DownloadNewUserFw+0x52>
      (void) SFU_IMG_InvalidateCurrentFirmware(dwl_slot);
 80091e8:	9802      	ldr	r0, [sp, #8]
 80091ea:	f000 fe1f 	bl	8009e2c <SFU_IMG_InvalidateCurrentFirmware>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_REBOOT_STATE_MACHINE, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 80091ee:	4b17      	ldr	r3, [pc, #92]	@ (800924c <SFU_BOOT_SM_DownloadNewUserFw+0xb0>)
 80091f0:	785a      	ldrb	r2, [r3, #1]
 80091f2:	b2d2      	uxtb	r2, r2
 80091f4:	701a      	strb	r2, [r3, #0]
 80091f6:	4a12      	ldr	r2, [pc, #72]	@ (8009240 <SFU_BOOT_SM_DownloadNewUserFw+0xa4>)
 80091f8:	4294      	cmp	r4, r2
 80091fa:	bf0c      	ite	eq
 80091fc:	2207      	moveq	r2, #7
 80091fe:	2206      	movne	r2, #6
 8009200:	705a      	strb	r2, [r3, #1]
}
 8009202:	b005      	add	sp, #20
 8009204:	bd30      	pop	{r4, r5, pc}
    (void) SFU_IMG_InvalidateCurrentFirmware(dwl_slot);
 8009206:	9802      	ldr	r0, [sp, #8]
 8009208:	f000 fe10 	bl	8009e2c <SFU_IMG_InvalidateCurrentFirmware>
    switch (e_ret_status_app)
 800920c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009210:	3b01      	subs	r3, #1
 8009212:	2b05      	cmp	r3, #5
 8009214:	d8eb      	bhi.n	80091ee <SFU_BOOT_SM_DownloadNewUserFw+0x52>
 8009216:	e8df f003 	tbb	[pc, r3]
 800921a:	0b03      	.short	0x0b03
 800921c:	0f0d0709 	.word	0x0f0d0709
        SFU_EXCPT_SetError(SFU_EXCPT_COM_ERR);
 8009220:	2006      	movs	r0, #6
        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 8009222:	f000 fbb9 	bl	8009998 <SFU_EXCPT_SetError>
        break;
 8009226:	e7e2      	b.n	80091ee <SFU_BOOT_SM_DownloadNewUserFw+0x52>
        SFU_EXCPT_SetError(SFU_EXCPT_VERSION_ERR);
 8009228:	200f      	movs	r0, #15
 800922a:	e7fa      	b.n	8009222 <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_FW_TOO_BIG);
 800922c:	2005      	movs	r0, #5
 800922e:	e7f8      	b.n	8009222 <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_HEADER_AUTH_ERR);
 8009230:	2007      	movs	r0, #7
 8009232:	e7f6      	b.n	8009222 <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_FLASH_ERR);
 8009234:	200a      	movs	r0, #10
 8009236:	e7f4      	b.n	8009222 <SFU_BOOT_SM_DownloadNewUserFw+0x86>
        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 8009238:	2008      	movs	r0, #8
 800923a:	e7f2      	b.n	8009222 <SFU_BOOT_SM_DownloadNewUserFw+0x86>
 800923c:	0800e5ae 	.word	0x0800e5ae
 8009240:	00122f11 	.word	0x00122f11
 8009244:	0800e33c 	.word	0x0800e33c
 8009248:	200015e0 	.word	0x200015e0
 800924c:	200011ac 	.word	0x200011ac

08009250 <SFU_BOOT_SM_CheckNewFwToDownload>:
{
 8009250:	b510      	push	{r4, lr}
  if (initialDeviceStatusCheck == 1U)
 8009252:	4c0d      	ldr	r4, [pc, #52]	@ (8009288 <SFU_BOOT_SM_CheckNewFwToDownload+0x38>)
 8009254:	6863      	ldr	r3, [r4, #4]
 8009256:	2b01      	cmp	r3, #1
 8009258:	d00a      	beq.n	8009270 <SFU_BOOT_SM_CheckNewFwToDownload+0x20>
    e_ret_status = SFU_SUCCESS;
 800925a:	4a0c      	ldr	r2, [pc, #48]	@ (800928c <SFU_BOOT_SM_CheckNewFwToDownload+0x3c>)
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_DOWNLOAD_NEW_USER_FW, SFU_STATE_VERIFY_USER_FW_STATUS);
 800925c:	7863      	ldrb	r3, [r4, #1]
 800925e:	b2db      	uxtb	r3, r3
 8009260:	7023      	strb	r3, [r4, #0]
 8009262:	4b0a      	ldr	r3, [pc, #40]	@ (800928c <SFU_BOOT_SM_CheckNewFwToDownload+0x3c>)
 8009264:	429a      	cmp	r2, r3
 8009266:	bf0c      	ite	eq
 8009268:	2302      	moveq	r3, #2
 800926a:	2303      	movne	r3, #3
 800926c:	7063      	strb	r3, [r4, #1]
}
 800926e:	bd10      	pop	{r4, pc}
    TRACE("\r\n= [SBOOT] STATE: CHECK NEW FIRMWARE TO DOWNLOAD");
 8009270:	4807      	ldr	r0, [pc, #28]	@ (8009290 <SFU_BOOT_SM_CheckNewFwToDownload+0x40>)
 8009272:	f004 f87d 	bl	800d370 <iprintf>
    if (0U != BUTTON_PUSHED())
 8009276:	2000      	movs	r0, #0
 8009278:	f001 fe8c 	bl	800af94 <BSP_PB_GetState>
 800927c:	2801      	cmp	r0, #1
 800927e:	d0ec      	beq.n	800925a <SFU_BOOT_SM_CheckNewFwToDownload+0xa>
      e_ret_status = SFU_ERROR;
 8009280:	f641 72e1 	movw	r2, #8161	@ 0x1fe1
 8009284:	e7ea      	b.n	800925c <SFU_BOOT_SM_CheckNewFwToDownload+0xc>
 8009286:	bf00      	nop
 8009288:	200011ac 	.word	0x200011ac
 800928c:	00122f11 	.word	0x00122f11
 8009290:	0800e5dc 	.word	0x0800e5dc

08009294 <SFU_BOOT_SM_CheckStatusOnReset>:
{
 8009294:	b507      	push	{r0, r1, r2, lr}
  TRACE("\r\n= [SBOOT] STATE: CHECK STATUS ON RESET");
 8009296:	4818      	ldr	r0, [pc, #96]	@ (80092f8 <SFU_BOOT_SM_CheckStatusOnReset+0x64>)
 8009298:	f004 f86a 	bl	800d370 <iprintf>
  * @param  None
  * @retval None
  */
static void SFU_BOOT_ManageResetSources(void)
{
  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
 800929c:	2300      	movs	r3, #0

  /* Check the wakeup sources */
  SFU_LL_SECU_GetResetSources(&e_wakeup_source_id);
 800929e:	f10d 0007 	add.w	r0, sp, #7
  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
 80092a2:	f88d 3007 	strb.w	r3, [sp, #7]
  SFU_LL_SECU_GetResetSources(&e_wakeup_source_id);
 80092a6:	f001 fd8d 	bl	800adc4 <SFU_LL_SECU_GetResetSources>
  switch (e_wakeup_source_id)
 80092aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80092ae:	3b01      	subs	r3, #1
 80092b0:	2b05      	cmp	r3, #5
 80092b2:	d81e      	bhi.n	80092f2 <SFU_BOOT_SM_CheckStatusOnReset+0x5e>
 80092b4:	e8df f003 	tbb	[pc, r3]
 80092b8:	17151303 	.word	0x17151303
 80092bc:	1b19      	.short	0x1b19
       * Please note that the example of reset causes handling below is only a basic example to illustrate the way the
       * RCC_CSR flags can be used to do so.
       */

    case SFU_RESET_WDG_RESET:
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by a Watchdog reset!");
 80092be:	480f      	ldr	r0, [pc, #60]	@ (80092fc <SFU_BOOT_SM_CheckStatusOnReset+0x68>)
         ...
      */
      break;

    default:
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
 80092c0:	f004 f856 	bl	800d370 <iprintf>
      */
      break;
  }

  /* Once the reset sources has been managed and a possible error has been set, clear the reset sources */
  SFU_LL_SECU_ClearResetSources();
 80092c4:	f001 fda0 	bl	800ae08 <SFU_LL_SECU_ClearResetSources>
  SFU_MPU_EnterUnprivilegedMode();
 80092c8:	f001 f97e 	bl	800a5c8 <SFU_MPU_EnterUnprivilegedMode>
  SFU_SET_SM_CURR_STATE(SFU_STATE_CHECK_NEW_FW_TO_DOWNLOAD);
 80092cc:	4b0c      	ldr	r3, [pc, #48]	@ (8009300 <SFU_BOOT_SM_CheckStatusOnReset+0x6c>)
 80092ce:	785a      	ldrb	r2, [r3, #1]
 80092d0:	b2d2      	uxtb	r2, r2
 80092d2:	701a      	strb	r2, [r3, #0]
 80092d4:	2201      	movs	r2, #1
 80092d6:	705a      	strb	r2, [r3, #1]
}
 80092d8:	b003      	add	sp, #12
 80092da:	f85d fb04 	ldr.w	pc, [sp], #4
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a LowPower reset!");
 80092de:	4809      	ldr	r0, [pc, #36]	@ (8009304 <SFU_BOOT_SM_CheckStatusOnReset+0x70>)
 80092e0:	e7ee      	b.n	80092c0 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Hardware reset!");
 80092e2:	4809      	ldr	r0, [pc, #36]	@ (8009308 <SFU_BOOT_SM_CheckStatusOnReset+0x74>)
 80092e4:	e7ec      	b.n	80092c0 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a BOR reset!");
 80092e6:	4809      	ldr	r0, [pc, #36]	@ (800930c <SFU_BOOT_SM_CheckStatusOnReset+0x78>)
 80092e8:	e7ea      	b.n	80092c0 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Software reset!");
 80092ea:	4809      	ldr	r0, [pc, #36]	@ (8009310 <SFU_BOOT_SM_CheckStatusOnReset+0x7c>)
 80092ec:	e7e8      	b.n	80092c0 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Option Bytes reload!");
 80092ee:	4809      	ldr	r0, [pc, #36]	@ (8009314 <SFU_BOOT_SM_CheckStatusOnReset+0x80>)
 80092f0:	e7e6      	b.n	80092c0 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
 80092f2:	4809      	ldr	r0, [pc, #36]	@ (8009318 <SFU_BOOT_SM_CheckStatusOnReset+0x84>)
 80092f4:	e7e4      	b.n	80092c0 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
 80092f6:	bf00      	nop
 80092f8:	0800e60e 	.word	0x0800e60e
 80092fc:	0800e637 	.word	0x0800e637
 8009300:	200011ac 	.word	0x200011ac
 8009304:	0800e676 	.word	0x0800e676
 8009308:	0800e6b2 	.word	0x0800e6b2
 800930c:	0800e6ee 	.word	0x0800e6ee
 8009310:	0800e725 	.word	0x0800e725
 8009314:	0800e761 	.word	0x0800e761
 8009318:	0800e7a6 	.word	0x0800e7a6

0800931c <SFU_BOOT_DeInit.isra.0>:
static SFU_ErrorStatus SFU_BOOT_DeInit(void)
 800931c:	b538      	push	{r3, r4, r5, lr}
  if (SFU_EXCPT_DeInit() != SFU_SUCCESS)
 800931e:	f000 fb95 	bl	8009a4c <SFU_EXCPT_DeInit>
 8009322:	4b09      	ldr	r3, [pc, #36]	@ (8009348 <SFU_BOOT_DeInit.isra.0+0x2c>)
 8009324:	4605      	mov	r5, r0
 8009326:	4298      	cmp	r0, r3
 8009328:	d10c      	bne.n	8009344 <SFU_BOOT_DeInit.isra.0+0x28>
  if (SFU_LOADER_DeInit() != SFU_SUCCESS)
 800932a:	f000 ff61 	bl	800a1f0 <SFU_LOADER_DeInit>
 800932e:	42a8      	cmp	r0, r5
 8009330:	4604      	mov	r4, r0
 8009332:	d107      	bne.n	8009344 <SFU_BOOT_DeInit.isra.0+0x28>
  if (SFU_COM_DeInit() != SFU_SUCCESS)
 8009334:	f000 fb12 	bl	800995c <SFU_COM_DeInit>
 8009338:	42a0      	cmp	r0, r4
 800933a:	d103      	bne.n	8009344 <SFU_BOOT_DeInit.isra.0+0x28>
}
 800933c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (SFU_LL_DeInit() != SFU_SUCCESS)
 8009340:	f001 b96c 	b.w	800a61c <SFU_LL_DeInit>
}
 8009344:	bd38      	pop	{r3, r4, r5, pc}
 8009346:	bf00      	nop
 8009348:	00122f11 	.word	0x00122f11

0800934c <SFU_BOOT_ForceReboot>:
{
 800934c:	b508      	push	{r3, lr}
  TRACE("\r\n========= End of Execution ==========");
 800934e:	480d      	ldr	r0, [pc, #52]	@ (8009384 <SFU_BOOT_ForceReboot+0x38>)
 8009350:	f004 f80e 	bl	800d370 <iprintf>
  TRACE("\r\n\r\n\r\n");
 8009354:	480c      	ldr	r0, [pc, #48]	@ (8009388 <SFU_BOOT_ForceReboot+0x3c>)
 8009356:	f004 f873 	bl	800d440 <puts>
  if (0U != SFU_MPU_IsUnprivileged())
 800935a:	f001 f92b 	bl	800a5b4 <SFU_MPU_IsUnprivileged>
 800935e:	b120      	cbz	r0, 800936a <SFU_BOOT_ForceReboot+0x1e>
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 8009360:	2002      	movs	r0, #2
}
 8009362:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 8009366:	f001 b921 	b.w	800a5ac <SFU_MPU_SysCall>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800936a:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800936e:	4907      	ldr	r1, [pc, #28]	@ (800938c <SFU_BOOT_ForceReboot+0x40>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009370:	4b07      	ldr	r3, [pc, #28]	@ (8009390 <SFU_BOOT_ForceReboot+0x44>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009372:	68ca      	ldr	r2, [r1, #12]
 8009374:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009378:	4313      	orrs	r3, r2
 800937a:	60cb      	str	r3, [r1, #12]
 800937c:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8009380:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8009382:	e7fd      	b.n	8009380 <SFU_BOOT_ForceReboot+0x34>
 8009384:	0800e7ec 	.word	0x0800e7ec
 8009388:	0800e814 	.word	0x0800e814
 800938c:	e000ed00 	.word	0xe000ed00
 8009390:	05fa0004 	.word	0x05fa0004

08009394 <SFU_BOOT_SM_RebootStateMachine>:
{
 8009394:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: REBOOT STATE MACHINE");
 8009396:	4804      	ldr	r0, [pc, #16]	@ (80093a8 <SFU_BOOT_SM_RebootStateMachine+0x14>)
 8009398:	f003 ffea 	bl	800d370 <iprintf>
  (void)SFU_BOOT_DeInit();
 800939c:	f7ff ffbe 	bl	800931c <SFU_BOOT_DeInit.isra.0>
}
 80093a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SFU_BOOT_ForceReboot();
 80093a4:	f7ff bfd2 	b.w	800934c <SFU_BOOT_ForceReboot>
 80093a8:	0800e81a 	.word	0x0800e81a

080093ac <SFU_BOOT_SM_ExecuteUserFw>:
{
 80093ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  SE_StatusTypeDef e_se_status = SE_KO;
 80093ae:	4b38      	ldr	r3, [pc, #224]	@ (8009490 <SFU_BOOT_SM_ExecuteUserFw+0xe4>)
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 80093b0:	4d38      	ldr	r5, [pc, #224]	@ (8009494 <SFU_BOOT_SM_ExecuteUserFw+0xe8>)
  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
 80093b2:	4839      	ldr	r0, [pc, #228]	@ (8009498 <SFU_BOOT_SM_ExecuteUserFw+0xec>)
  SE_StatusTypeDef e_se_status = SE_KO;
 80093b4:	9301      	str	r3, [sp, #4]
  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
 80093b6:	f003 ffdb 	bl	800d370 <iprintf>
  (void) SFU_LL_SECU_IWDG_Refresh();
 80093ba:	f001 fd2f 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 80093be:	686a      	ldr	r2, [r5, #4]
 80093c0:	f248 435a 	movw	r3, #33882	@ 0x845a
 80093c4:	429a      	cmp	r2, r3
 80093c6:	d001      	beq.n	80093cc <SFU_BOOT_SM_ExecuteUserFw+0x20>
 80093c8:	f000 fb18 	bl	80099fc <SFU_EXCPT_Security_Error>
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 80093cc:	4b33      	ldr	r3, [pc, #204]	@ (800949c <SFU_BOOT_SM_ExecuteUserFw+0xf0>)
{
 80093ce:	2400      	movs	r4, #0
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 80093d0:	4e33      	ldr	r6, [pc, #204]	@ (80094a0 <SFU_BOOT_SM_ExecuteUserFw+0xf4>)
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 80093d2:	685f      	ldr	r7, [r3, #4]
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 80093d4:	b324      	cbz	r4, 8009420 <SFU_BOOT_SM_ExecuteUserFw+0x74>
  e_ret_status = SFU_LL_FLASH_Config_Exe(m_ActiveSlotToExecute);
 80093d6:	4c33      	ldr	r4, [pc, #204]	@ (80094a4 <SFU_BOOT_SM_ExecuteUserFw+0xf8>)
 80093d8:	68a0      	ldr	r0, [r4, #8]
 80093da:	f001 fa77 	bl	800a8cc <SFU_LL_FLASH_Config_Exe>
  if (e_ret_status != SFU_SUCCESS)
 80093de:	4b30      	ldr	r3, [pc, #192]	@ (80094a0 <SFU_BOOT_SM_ExecuteUserFw+0xf4>)
 80093e0:	4298      	cmp	r0, r3
 80093e2:	d146      	bne.n	8009472 <SFU_BOOT_SM_ExecuteUserFw+0xc6>
    if (SE_LockRestrictServices(&e_se_status) == SE_SUCCESS)
 80093e4:	a801      	add	r0, sp, #4
 80093e6:	f7fe fe7b 	bl	80080e0 <SE_LockRestrictServices>
 80093ea:	4b2f      	ldr	r3, [pc, #188]	@ (80094a8 <SFU_BOOT_SM_ExecuteUserFw+0xfc>)
 80093ec:	4607      	mov	r7, r0
 80093ee:	4298      	cmp	r0, r3
 80093f0:	d14b      	bne.n	800948a <SFU_BOOT_SM_ExecuteUserFw+0xde>
      if (SE_LockRestrictServices(&e_se_status) == SE_SUCCESS)
 80093f2:	a801      	add	r0, sp, #4
 80093f4:	f7fe fe74 	bl	80080e0 <SE_LockRestrictServices>
 80093f8:	42b8      	cmp	r0, r7
 80093fa:	d146      	bne.n	800948a <SFU_BOOT_SM_ExecuteUserFw+0xde>
        (void)SFU_BOOT_DeInit(); /* the return value is not checked, we will always try launching the UserApp */
 80093fc:	f7ff ff8e 	bl	800931c <SFU_BOOT_DeInit.isra.0>
        FLOW_CONTROL_STEP(uFlowCryptoValue, FLOW_STEP_LOCK_SERVICE, FLOW_CTRL_LOCK_SERVICE);
 8009400:	686a      	ldr	r2, [r5, #4]
 8009402:	f482 4334 	eor.w	r3, r2, #46080	@ 0xb400
 8009406:	f083 03ab 	eor.w	r3, r3, #171	@ 0xab
 800940a:	606b      	str	r3, [r5, #4]
 800940c:	f248 435a 	movw	r3, #33882	@ 0x845a
 8009410:	429a      	cmp	r2, r3
 8009412:	d001      	beq.n	8009418 <SFU_BOOT_SM_ExecuteUserFw+0x6c>
 8009414:	f000 faf2 	bl	80099fc <SFU_EXCPT_Security_Error>
        e_ret_status = SFU_IMG_LaunchActiveImg(m_ActiveSlotToExecute);
 8009418:	68a0      	ldr	r0, [r4, #8]
 800941a:	f000 fd69 	bl	8009ef0 <SFU_IMG_LaunchActiveImg>
        while (1 == 1)
 800941e:	e7fe      	b.n	800941e <SFU_BOOT_SM_ExecuteUserFw+0x72>
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 8009420:	2f00      	cmp	r7, #0
 8009422:	d0d8      	beq.n	80093d6 <SFU_BOOT_SM_ExecuteUserFw+0x2a>
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009424:	2001      	movs	r0, #1
 8009426:	f000 fdeb 	bl	800a000 <SFU_IMG_DetectFW>
 800942a:	42b0      	cmp	r0, r6
 800942c:	d1d3      	bne.n	80093d6 <SFU_BOOT_SM_ExecuteUserFw+0x2a>
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 800942e:	f245 7376 	movw	r3, #22390	@ 0x5776
        if (SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009432:	2001      	movs	r0, #1
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 8009434:	606b      	str	r3, [r5, #4]
        if (SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009436:	f000 fdcd 	bl	8009fd4 <SFU_IMG_VerifyActiveImgMetadata>
 800943a:	42b0      	cmp	r0, r6
 800943c:	d001      	beq.n	8009442 <SFU_BOOT_SM_ExecuteUserFw+0x96>
          SFU_EXCPT_Security_Error();
 800943e:	f000 fadd 	bl	80099fc <SFU_EXCPT_Security_Error>
        if (SFU_IMG_ControlActiveImgTag(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009442:	4c17      	ldr	r4, [pc, #92]	@ (80094a0 <SFU_BOOT_SM_ExecuteUserFw+0xf4>)
 8009444:	2001      	movs	r0, #1
 8009446:	f000 fd35 	bl	8009eb4 <SFU_IMG_ControlActiveImgTag>
 800944a:	42a0      	cmp	r0, r4
 800944c:	d001      	beq.n	8009452 <SFU_BOOT_SM_ExecuteUserFw+0xa6>
          SFU_EXCPT_Security_Error();
 800944e:	f000 fad5 	bl	80099fc <SFU_EXCPT_Security_Error>
        if (SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009452:	2001      	movs	r0, #1
 8009454:	f000 fd0e 	bl	8009e74 <SFU_IMG_VerifyActiveSlot>
 8009458:	42a0      	cmp	r0, r4
 800945a:	d001      	beq.n	8009460 <SFU_BOOT_SM_ExecuteUserFw+0xb4>
          SFU_EXCPT_Security_Error();
 800945c:	f000 face 	bl	80099fc <SFU_EXCPT_Security_Error>
        FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 8009460:	686a      	ldr	r2, [r5, #4]
 8009462:	f248 435a 	movw	r3, #33882	@ 0x845a
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 8009466:	2401      	movs	r4, #1
        FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 8009468:	429a      	cmp	r2, r3
 800946a:	d0b4      	beq.n	80093d6 <SFU_BOOT_SM_ExecuteUserFw+0x2a>
 800946c:	f000 fac6 	bl	80099fc <SFU_EXCPT_Security_Error>
 8009470:	e7b0      	b.n	80093d4 <SFU_BOOT_SM_ExecuteUserFw+0x28>
    SFU_EXCPT_SetError(SFU_EXCPT_FLASH_CFG_ERR);
 8009472:	200b      	movs	r0, #11
        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SERVICES_ERR);
 8009474:	f000 fa90 	bl	8009998 <SFU_EXCPT_SetError>
        SFU_BOOT_ForceReboot();
 8009478:	f7ff ff68 	bl	800934c <SFU_BOOT_ForceReboot>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_HANDLE_CRITICAL_FAILURE, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 800947c:	7863      	ldrb	r3, [r4, #1]
 800947e:	b2db      	uxtb	r3, r3
 8009480:	7023      	strb	r3, [r4, #0]
 8009482:	2306      	movs	r3, #6
 8009484:	7063      	strb	r3, [r4, #1]
}
 8009486:	b003      	add	sp, #12
 8009488:	bdf0      	pop	{r4, r5, r6, r7, pc}
        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SERVICES_ERR);
 800948a:	2004      	movs	r0, #4
 800948c:	e7f2      	b.n	8009474 <SFU_BOOT_SM_ExecuteUserFw+0xc8>
 800948e:	bf00      	nop
 8009490:	0013023d 	.word	0x0013023d
 8009494:	20001100 	.word	0x20001100
 8009498:	0800e842 	.word	0x0800e842
 800949c:	0800e33c 	.word	0x0800e33c
 80094a0:	00122f11 	.word	0x00122f11
 80094a4:	200011ac 	.word	0x200011ac
 80094a8:	0012310f 	.word	0x0012310f

080094ac <SFU_BOOT_RunSecureBootService>:
{
 80094ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (SE_Startup() == SE_SUCCESS)
 80094ae:	f7fe fdf3 	bl	8008098 <SE_Startup>
 80094b2:	4b3c      	ldr	r3, [pc, #240]	@ (80095a4 <SFU_BOOT_RunSecureBootService+0xf8>)
 80094b4:	4604      	mov	r4, r0
 80094b6:	4298      	cmp	r0, r3
 80094b8:	d171      	bne.n	800959e <SFU_BOOT_RunSecureBootService+0xf2>
  (void) SFU_COM_Init();
 80094ba:	f000 fa3f 	bl	800993c <SFU_COM_Init>
  if (SFU_LL_SECU_CheckApplyStaticProtections() == SFU_SUCCESS)
 80094be:	f001 fbe3 	bl	800ac88 <SFU_LL_SECU_CheckApplyStaticProtections>
 80094c2:	4b39      	ldr	r3, [pc, #228]	@ (80095a8 <SFU_BOOT_RunSecureBootService+0xfc>)
 80094c4:	4606      	mov	r6, r0
 80094c6:	4298      	cmp	r0, r3
 80094c8:	d005      	beq.n	80094d6 <SFU_BOOT_RunSecureBootService+0x2a>
    TRACE("\r\n= [SBOOT] System Security Check failed! Rebooting...");
 80094ca:	4838      	ldr	r0, [pc, #224]	@ (80095ac <SFU_BOOT_RunSecureBootService+0x100>)
 80094cc:	f003 ff50 	bl	800d370 <iprintf>
      e_ret_code = SFU_BOOT_SECIPS_CFG_FAIL;
 80094d0:	2001      	movs	r0, #1
}
 80094d2:	b003      	add	sp, #12
 80094d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_INITIAL_CONFIGURATION);
 80094d6:	2000      	movs	r0, #0
 80094d8:	f001 fc44 	bl	800ad64 <SFU_LL_SECU_CheckApplyRuntimeProtections>
  if (SFU_BOOT_CheckApplySecurityProtections() != SFU_SUCCESS)
 80094dc:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_INITIAL_CONFIGURATION);
 80094de:	4605      	mov	r5, r0
  if (SFU_BOOT_CheckApplySecurityProtections() != SFU_SUCCESS)
 80094e0:	d1f3      	bne.n	80094ca <SFU_BOOT_RunSecureBootService+0x1e>
    TRACE("\r\n= [SBOOT] System Security Check successfully passed. Starting...");
 80094e2:	4833      	ldr	r0, [pc, #204]	@ (80095b0 <SFU_BOOT_RunSecureBootService+0x104>)
 80094e4:	f003 ff44 	bl	800d370 <iprintf>
  (void) BSP_LED_Init(SFU_STATUS_LED);
 80094e8:	2000      	movs	r0, #0
 80094ea:	f001 fcc5 	bl	800ae78 <BSP_LED_Init>
  BUTTON_INIT();
 80094ee:	2100      	movs	r1, #0
  initialDeviceStatusCheck = 1U;
 80094f0:	4f30      	ldr	r7, [pc, #192]	@ (80095b4 <SFU_BOOT_RunSecureBootService+0x108>)
  BUTTON_INIT();
 80094f2:	4608      	mov	r0, r1
 80094f4:	f001 fd0e 	bl	800af14 <BSP_PB_Init>
  initialDeviceStatusCheck = 1U;
 80094f8:	2301      	movs	r3, #1
 80094fa:	607b      	str	r3, [r7, #4]
  if (SFU_LL_Init() != SFU_SUCCESS)
 80094fc:	f001 f8d0 	bl	800a6a0 <SFU_LL_Init>
 8009500:	42a8      	cmp	r0, r5
 8009502:	4606      	mov	r6, r0
 8009504:	d134      	bne.n	8009570 <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_LL_FLASH_Init() != SFU_SUCCESS)
 8009506:	f001 f9b7 	bl	800a878 <SFU_LL_FLASH_Init>
 800950a:	42b0      	cmp	r0, r6
 800950c:	4605      	mov	r5, r0
 800950e:	d12f      	bne.n	8009570 <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_COM_Init() != SFU_SUCCESS)
 8009510:	f000 fa14 	bl	800993c <SFU_COM_Init>
 8009514:	42a8      	cmp	r0, r5
 8009516:	4606      	mov	r6, r0
 8009518:	d12a      	bne.n	8009570 <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_LOADER_Init() != SFU_SUCCESS)
 800951a:	f000 fe65 	bl	800a1e8 <SFU_LOADER_Init>
 800951e:	42b0      	cmp	r0, r6
 8009520:	4605      	mov	r5, r0
 8009522:	d125      	bne.n	8009570 <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_EXCPT_Init() != SFU_SUCCESS)
 8009524:	f000 fa8e 	bl	8009a44 <SFU_EXCPT_Init>
 8009528:	42a8      	cmp	r0, r5
 800952a:	d121      	bne.n	8009570 <SFU_BOOT_RunSecureBootService+0xc4>
  if (SFU_IMG_InitImageHandling() != SFU_IMG_INIT_OK)
 800952c:	f000 fc34 	bl	8009d98 <SFU_IMG_InitImageHandling>
 8009530:	b9f0      	cbnz	r0, 8009570 <SFU_BOOT_RunSecureBootService+0xc4>
  TRACE("\r\n\r\n");
 8009532:	4821      	ldr	r0, [pc, #132]	@ (80095b8 <SFU_BOOT_RunSecureBootService+0x10c>)
 8009534:	f003 ff84 	bl	800d440 <puts>
  TRACE("\r\n======================================================================");
 8009538:	4820      	ldr	r0, [pc, #128]	@ (80095bc <SFU_BOOT_RunSecureBootService+0x110>)
 800953a:	f003 ff19 	bl	800d370 <iprintf>
  TRACE("\r\n=              (C) COPYRIGHT 2017 STMicroelectronics                 =");
 800953e:	4820      	ldr	r0, [pc, #128]	@ (80095c0 <SFU_BOOT_RunSecureBootService+0x114>)
 8009540:	f003 ff16 	bl	800d370 <iprintf>
  TRACE("\r\n=                                                                    =");
 8009544:	481f      	ldr	r0, [pc, #124]	@ (80095c4 <SFU_BOOT_RunSecureBootService+0x118>)
 8009546:	f003 ff13 	bl	800d370 <iprintf>
  TRACE("\r\n=              Secure Boot and Secure Firmware Update                =");
 800954a:	481f      	ldr	r0, [pc, #124]	@ (80095c8 <SFU_BOOT_RunSecureBootService+0x11c>)
 800954c:	f003 ff10 	bl	800d370 <iprintf>
  TRACE("\r\n======================================================================");
 8009550:	481a      	ldr	r0, [pc, #104]	@ (80095bc <SFU_BOOT_RunSecureBootService+0x110>)
 8009552:	f003 ff0d 	bl	800d370 <iprintf>
  TRACE("\r\n\r\n");
 8009556:	4818      	ldr	r0, [pc, #96]	@ (80095b8 <SFU_BOOT_RunSecureBootService+0x10c>)
 8009558:	f003 ff72 	bl	800d440 <puts>
  if (SE_Init(&e_se_status, SystemCoreClock) != SE_SUCCESS)
 800955c:	4b1b      	ldr	r3, [pc, #108]	@ (80095cc <SFU_BOOT_RunSecureBootService+0x120>)
 800955e:	a801      	add	r0, sp, #4
 8009560:	6819      	ldr	r1, [r3, #0]
 8009562:	f7fe fd73 	bl	800804c <SE_Init>
 8009566:	42a0      	cmp	r0, r4
 8009568:	d004      	beq.n	8009574 <SFU_BOOT_RunSecureBootService+0xc8>
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION CRITICAL FAILURE!");
 800956a:	4819      	ldr	r0, [pc, #100]	@ (80095d0 <SFU_BOOT_RunSecureBootService+0x124>)
 800956c:	f003 ff00 	bl	800d370 <iprintf>
        e_ret_code = SFU_BOOT_INIT_FAIL;
 8009570:	2002      	movs	r0, #2
 8009572:	e7ae      	b.n	80094d2 <SFU_BOOT_RunSecureBootService+0x26>
    if (SFU_BOOT_SecuritySafetyCheck() == SFU_SUCCESS)
 8009574:	4c0c      	ldr	r4, [pc, #48]	@ (80095a8 <SFU_BOOT_RunSecureBootService+0xfc>)
      fnStateMachineFunction = fnStateMachineTable[(uint8_t)m_StateMachineContext.CurrState];
 8009576:	4d17      	ldr	r5, [pc, #92]	@ (80095d4 <SFU_BOOT_RunSecureBootService+0x128>)
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION SUCCESSFUL");
 8009578:	4817      	ldr	r0, [pc, #92]	@ (80095d8 <SFU_BOOT_RunSecureBootService+0x12c>)
 800957a:	f003 fef9 	bl	800d370 <iprintf>
  e_ret_status = SFU_LL_SECU_IWDG_Refresh();
 800957e:	f001 fc4d 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
    if (SFU_BOOT_SecuritySafetyCheck() == SFU_SUCCESS)
 8009582:	42a0      	cmp	r0, r4
 8009584:	d006      	beq.n	8009594 <SFU_BOOT_RunSecureBootService+0xe8>
  SFU_EXCPT_SetError(SFU_EXCPT_UNKNOWN);
 8009586:	2010      	movs	r0, #16
 8009588:	f000 fa06 	bl	8009998 <SFU_EXCPT_SetError>
  SFU_BOOT_ForceReboot();
 800958c:	f7ff fede 	bl	800934c <SFU_BOOT_ForceReboot>
  SFU_BOOT_InitErrorTypeDef e_ret_code = SFU_BOOT_INIT_ERROR;
 8009590:	2003      	movs	r0, #3
  return e_ret_status;
 8009592:	e79e      	b.n	80094d2 <SFU_BOOT_RunSecureBootService+0x26>
      fnStateMachineFunction = fnStateMachineTable[(uint8_t)m_StateMachineContext.CurrState];
 8009594:	787b      	ldrb	r3, [r7, #1]
      fnStateMachineFunction();
 8009596:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800959a:	4798      	blx	r3
 800959c:	e7ef      	b.n	800957e <SFU_BOOT_RunSecureBootService+0xd2>
    e_ret_code = SFU_BOOT_SECENG_INIT_FAIL;
 800959e:	2000      	movs	r0, #0
 80095a0:	e797      	b.n	80094d2 <SFU_BOOT_RunSecureBootService+0x26>
 80095a2:	bf00      	nop
 80095a4:	0012310f 	.word	0x0012310f
 80095a8:	00122f11 	.word	0x00122f11
 80095ac:	0800e86b 	.word	0x0800e86b
 80095b0:	0800e8a2 	.word	0x0800e8a2
 80095b4:	200011ac 	.word	0x200011ac
 80095b8:	0800e816 	.word	0x0800e816
 80095bc:	0800e8e5 	.word	0x0800e8e5
 80095c0:	0800e92e 	.word	0x0800e92e
 80095c4:	0800e977 	.word	0x0800e977
 80095c8:	0800e9c0 	.word	0x0800e9c0
 80095cc:	20001120 	.word	0x20001120
 80095d0:	0800ea09 	.word	0x0800ea09
 80095d4:	0800e2d8 	.word	0x0800e2d8
 80095d8:	0800ea44 	.word	0x0800ea44

080095dc <MemManage_Handler>:
  * @param  None
  * @retval None
  */
void SFU_CALLBACK_MEMORYFAULT(void)
{
  SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_MEMORY_FAULT);
 80095dc:	2001      	movs	r0, #1
 80095de:	f000 b9e9 	b.w	80099b4 <SFU_EXCPT_IrqExceptionHandler>

080095e2 <SFU_COM_Serial_PutByte>:
  * @brief  Transmit a byte to the COM Port.
  * @param  uParam: The byte to be sent.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_Serial_PutByte(uint8_t uParam)
{
 80095e2:	b507      	push	{r0, r1, r2, lr}
  return SFU_LL_UART_Transmit(&uParam, 1U, SFU_COM_LOADER_SERIAL_TIME_OUT);
 80095e4:	2264      	movs	r2, #100	@ 0x64
 80095e6:	2101      	movs	r1, #1
{
 80095e8:	f88d 0007 	strb.w	r0, [sp, #7]
  return SFU_LL_UART_Transmit(&uParam, 1U, SFU_COM_LOADER_SERIAL_TIME_OUT);
 80095ec:	f10d 0007 	add.w	r0, sp, #7
 80095f0:	f001 f888 	bl	800a704 <SFU_LL_UART_Transmit>
}
 80095f4:	b003      	add	sp, #12
 80095f6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080095fc <SFU_COM_YMODEM_Receive>:
{
 80095fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009600:	b08b      	sub	sp, #44	@ 0x2c
  if ((peCOMStatus == NULL) || (puSize == NULL))
 8009602:	4604      	mov	r4, r0
{
 8009604:	9102      	str	r1, [sp, #8]
  if ((peCOMStatus == NULL) || (puSize == NULL))
 8009606:	2800      	cmp	r0, #0
 8009608:	f000 8133 	beq.w	8009872 <SFU_COM_YMODEM_Receive+0x276>
 800960c:	2900      	cmp	r1, #0
 800960e:	f000 8130 	beq.w	8009872 <SFU_COM_YMODEM_Receive+0x276>
  *peCOMStatus = SFU_COM_YMODEM_OK;
 8009612:	2500      	movs	r5, #0
  /* This operation could last long. Need to refresh the Watchdog if enabled. It could be implemented as a callback*/
  (void) SFU_LL_SECU_IWDG_Refresh();

  eRetStatus = SFU_LL_UART_Receive(&char1, 1, uTimeout);

  if (eRetStatus == SFU_SUCCESS)
 8009614:	f8df 8318 	ldr.w	r8, [pc, #792]	@ 8009930 <SFU_COM_YMODEM_Receive+0x334>
  *peCOMStatus = SFU_COM_YMODEM_OK;
 8009618:	462f      	mov	r7, r5
 800961a:	7005      	strb	r5, [r0, #0]
  uint32_t session_begin = 0U;
 800961c:	9501      	str	r5, [sp, #4]
  while ((session_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 800961e:	7826      	ldrb	r6, [r4, #0]
 8009620:	2e00      	cmp	r6, #0
 8009622:	f040 812e 	bne.w	8009882 <SFU_COM_YMODEM_Receive+0x286>
        break;
      default:
        status = HAL_ERROR;
        break;
    }
    *pData = char1;
 8009626:	f8df 9310 	ldr.w	r9, [pc, #784]	@ 8009938 <SFU_COM_YMODEM_Receive+0x33c>
 800962a:	e14e      	b.n	80098ca <SFU_COM_YMODEM_Receive+0x2ce>
    switch (char1)
 800962c:	2b61      	cmp	r3, #97	@ 0x61
 800962e:	d004      	beq.n	800963a <SFU_COM_YMODEM_Receive+0x3e>
 8009630:	2b72      	cmp	r3, #114	@ 0x72
 8009632:	d019      	beq.n	8009668 <SFU_COM_YMODEM_Receive+0x6c>
 8009634:	2b41      	cmp	r3, #65	@ 0x41
 8009636:	f040 816a 	bne.w	800990e <SFU_COM_YMODEM_Receive+0x312>
        status = HAL_BUSY;
 800963a:	f04f 0a02 	mov.w	sl, #2
  uint32_t packet_size = 0U;
 800963e:	f04f 0b00 	mov.w	fp, #0
 8009642:	e021      	b.n	8009688 <SFU_COM_YMODEM_Receive+0x8c>
        if ((SFU_LL_UART_Receive(&char1, 1U, uTimeout) == SFU_SUCCESS) && (char1 == SFU_COM_YMODEM_CA))
 8009644:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 8009648:	2101      	movs	r1, #1
 800964a:	f10d 0013 	add.w	r0, sp, #19
 800964e:	f001 f86d 	bl	800a72c <SFU_LL_UART_Receive>
 8009652:	4540      	cmp	r0, r8
 8009654:	f040 815b 	bne.w	800990e <SFU_COM_YMODEM_Receive+0x312>
 8009658:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800965c:	2b18      	cmp	r3, #24
 800965e:	f040 8156 	bne.w	800990e <SFU_COM_YMODEM_Receive+0x312>
          packet_size = 2U;
 8009662:	f04f 0b02 	mov.w	fp, #2
 8009666:	e00f      	b.n	8009688 <SFU_COM_YMODEM_Receive+0x8c>
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);             /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 8009668:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 800966c:	2101      	movs	r1, #1
 800966e:	f10d 0013 	add.w	r0, sp, #19
        packet_size = 3U;
 8009672:	f04f 0b03 	mov.w	fp, #3
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);             /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 8009676:	f001 f859 	bl	800a72c <SFU_LL_UART_Receive>
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);
 800967a:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 800967e:	2101      	movs	r1, #1
 8009680:	f10d 0013 	add.w	r0, sp, #19
 8009684:	f001 f852 	bl	800a72c <SFU_LL_UART_Receive>
    *pData = char1;
 8009688:	f89d 2013 	ldrb.w	r2, [sp, #19]

    if (packet_size >= SFU_COM_YMODEM_PACKET_SIZE)
 800968c:	f1bb 0f7f 	cmp.w	fp, #127	@ 0x7f
    *pData = char1;
 8009690:	f889 2000 	strb.w	r2, [r9]
    if (packet_size >= SFU_COM_YMODEM_PACKET_SIZE)
 8009694:	d942      	bls.n	800971c <SFU_COM_YMODEM_Receive+0x120>
    {

#ifndef MINICOM_YMODEM
      eRetStatus = SFU_LL_UART_Receive(&pData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX],
 8009696:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 800969a:	f10b 0104 	add.w	r1, fp, #4
 800969e:	48a2      	ldr	r0, [pc, #648]	@ (8009928 <SFU_COM_YMODEM_Receive+0x32c>)
 80096a0:	f001 f844 	bl	800a72c <SFU_LL_UART_Receive>
        eRetStatus = SFU_SUCCESS;
      }
#endif /* MINICOM_YMODEM */

      /* Simple packet sanity check */
      if (eRetStatus == SFU_SUCCESS)
 80096a4:	4540      	cmp	r0, r8
 80096a6:	d140      	bne.n	800972a <SFU_COM_YMODEM_Receive+0x12e>
      {
        status = HAL_OK;

        if (pData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX] != ((pData[SFU_COM_YMODEM_PACKET_CNUMBER_INDEX]) ^
 80096a8:	f899 2003 	ldrb.w	r2, [r9, #3]
 80096ac:	f899 1002 	ldrb.w	r1, [r9, #2]
 80096b0:	43d2      	mvns	r2, r2
 80096b2:	b2d2      	uxtb	r2, r2
 80096b4:	4291      	cmp	r1, r2
 80096b6:	d138      	bne.n	800972a <SFU_COM_YMODEM_Receive+0x12e>
          status = HAL_ERROR;
        }
        else
        {
          /* Check packet CRC*/
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 80096b8:	eb09 020b 	add.w	r2, r9, fp
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];

          /*Configure CRC with 16-bit polynomial*/
          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT) == SFU_SUCCESS)
 80096bc:	2002      	movs	r0, #2
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 80096be:	7913      	ldrb	r3, [r2, #4]
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];
 80096c0:	f892 a005 	ldrb.w	sl, [r2, #5]
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 80096c4:	9303      	str	r3, [sp, #12]
          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT) == SFU_SUCCESS)
 80096c6:	f000 ffad 	bl	800a624 <SFU_LL_CRC_Config>
 80096ca:	4540      	cmp	r0, r8
 80096cc:	d12d      	bne.n	800972a <SFU_COM_YMODEM_Receive+0x12e>
          {
            if (SFU_LL_CRC_Calculate((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKET_DATA_INDEX], packet_size) != crc)
 80096ce:	4659      	mov	r1, fp
 80096d0:	4896      	ldr	r0, [pc, #600]	@ (800992c <SFU_COM_YMODEM_Receive+0x330>)
 80096d2:	f000 ffe7 	bl	800a6a4 <SFU_LL_CRC_Calculate>
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];
 80096d6:	9b03      	ldr	r3, [sp, #12]
 80096d8:	eb0a 2a03 	add.w	sl, sl, r3, lsl #8
            if (SFU_LL_CRC_Calculate((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKET_DATA_INDEX], packet_size) != crc)
 80096dc:	4582      	cmp	sl, r0
 80096de:	d124      	bne.n	800972a <SFU_COM_YMODEM_Receive+0x12e>
              if (m_aPacketData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX] != (packets_received & 0x000000FFU))
 80096e0:	f899 1002 	ldrb.w	r1, [r9, #2]
 80096e4:	b2f2      	uxtb	r2, r6
 80096e6:	4291      	cmp	r1, r2
 80096e8:	d134      	bne.n	8009754 <SFU_COM_YMODEM_Receive+0x158>
                if (packets_received == 0U)
 80096ea:	2e00      	cmp	r6, #0
 80096ec:	f040 80d1 	bne.w	8009892 <SFU_COM_YMODEM_Receive+0x296>
                  if (m_aPacketData[SFU_COM_YMODEM_PACKET_DATA_INDEX] != 0U)
 80096f0:	f899 3004 	ldrb.w	r3, [r9, #4]
 80096f4:	2b00      	cmp	r3, #0
 80096f6:	f000 80c1 	beq.w	800987c <SFU_COM_YMODEM_Receive+0x280>
 80096fa:	2341      	movs	r3, #65	@ 0x41
                    file_ptr = m_aPacketData + SFU_COM_YMODEM_PACKET_DATA_INDEX;
 80096fc:	4a8b      	ldr	r2, [pc, #556]	@ (800992c <SFU_COM_YMODEM_Receive+0x330>)
                    while ((*file_ptr != 0U) && (i < SFU_COM_YMODEM_FILE_NAME_LENGTH))
 80096fe:	f812 1b01 	ldrb.w	r1, [r2], #1
 8009702:	b109      	cbz	r1, 8009708 <SFU_COM_YMODEM_Receive+0x10c>
 8009704:	3b01      	subs	r3, #1
 8009706:	d1fa      	bne.n	80096fe <SFU_COM_YMODEM_Receive+0x102>
 8009708:	a905      	add	r1, sp, #20
                    file_ptr = m_aPacketData + SFU_COM_YMODEM_PACKET_DATA_INDEX;
 800970a:	2300      	movs	r3, #0
 800970c:	460f      	mov	r7, r1
 800970e:	e033      	b.n	8009778 <SFU_COM_YMODEM_Receive+0x17c>
        packet_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 8009710:	f44f 6b80 	mov.w	fp, #1024	@ 0x400
 8009714:	e7b8      	b.n	8009688 <SFU_COM_YMODEM_Receive+0x8c>
    switch (char1)
 8009716:	f04f 0b80 	mov.w	fp, #128	@ 0x80
 800971a:	e7b5      	b.n	8009688 <SFU_COM_YMODEM_Receive+0x8c>
      switch (ReceivePacket(m_aPacketData, &packet_length, SFU_COM_YMODEM_DOWNLOAD_TIMEOUT))
 800971c:	f1ba 0f00 	cmp.w	sl, #0
 8009720:	d012      	beq.n	8009748 <SFU_COM_YMODEM_Receive+0x14c>
 8009722:	f1ba 0f02 	cmp.w	sl, #2
 8009726:	f000 80c8 	beq.w	80098ba <SFU_COM_YMODEM_Receive+0x2be>
          if (session_begin > 0U)
 800972a:	9b01      	ldr	r3, [sp, #4]
 800972c:	b103      	cbz	r3, 8009730 <SFU_COM_YMODEM_Receive+0x134>
            errors ++;
 800972e:	3701      	adds	r7, #1
          if (errors > SFU_COM_YMODEM_MAX_ERRORS)
 8009730:	2f03      	cmp	r7, #3
 8009732:	f240 80ef 	bls.w	8009914 <SFU_COM_YMODEM_Receive+0x318>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 8009736:	2018      	movs	r0, #24
 8009738:	f7ff ff53 	bl	80095e2 <SFU_COM_Serial_PutByte>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800973c:	2018      	movs	r0, #24
 800973e:	f7ff ff50 	bl	80095e2 <SFU_COM_Serial_PutByte>
            *peCOMStatus = SFU_COM_YMODEM_ABORT;
 8009742:	2302      	movs	r3, #2
 8009744:	7023      	strb	r3, [r4, #0]
 8009746:	e0c0      	b.n	80098ca <SFU_COM_YMODEM_Receive+0x2ce>
          switch (packet_length)
 8009748:	f1bb 0f02 	cmp.w	fp, #2
 800974c:	d004      	beq.n	8009758 <SFU_COM_YMODEM_Receive+0x15c>
 800974e:	f1bb 0f03 	cmp.w	fp, #3
 8009752:	d107      	bne.n	8009764 <SFU_COM_YMODEM_Receive+0x168>
          errors = 0U;
 8009754:	2700      	movs	r7, #0
 8009756:	e0b8      	b.n	80098ca <SFU_COM_YMODEM_Receive+0x2ce>
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 8009758:	2006      	movs	r0, #6
 800975a:	f7ff ff42 	bl	80095e2 <SFU_COM_Serial_PutByte>
              *peCOMStatus = SFU_COM_YMODEM_ABORT;
 800975e:	f884 b000 	strb.w	fp, [r4]
              break;
 8009762:	e7f7      	b.n	8009754 <SFU_COM_YMODEM_Receive+0x158>
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 8009764:	2006      	movs	r0, #6
              *puSize = filesize;
 8009766:	4657      	mov	r7, sl
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 8009768:	f7ff ff3b 	bl	80095e2 <SFU_COM_Serial_PutByte>
              *puSize = filesize;
 800976c:	9b02      	ldr	r3, [sp, #8]
 800976e:	601d      	str	r5, [r3, #0]
  while ((session_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 8009770:	e755      	b.n	800961e <SFU_COM_YMODEM_Receive+0x22>
                      i++;
 8009772:	3301      	adds	r3, #1
                      file_size[i] = *file_ptr;
 8009774:	f807 0b01 	strb.w	r0, [r7], #1
                    while ((*file_ptr != (uint8_t) ' ') && (i < SFU_COM_YMODEM_FILE_SIZE_LENGTH))
 8009778:	5cd0      	ldrb	r0, [r2, r3]
 800977a:	2820      	cmp	r0, #32
 800977c:	d001      	beq.n	8009782 <SFU_COM_YMODEM_Receive+0x186>
 800977e:	2b10      	cmp	r3, #16
 8009780:	d1f7      	bne.n	8009772 <SFU_COM_YMODEM_Receive+0x176>
                    file_size[i] = (uint8_t) '\0';
 8009782:	3328      	adds	r3, #40	@ 0x28
 8009784:	eb0d 0203 	add.w	r2, sp, r3
 8009788:	2300      	movs	r3, #0
 800978a:	f802 3c14 	strb.w	r3, [r2, #-20]
  if ((pInputStr[0] == (uint8_t)'0') && ((pInputStr[1] == (uint8_t)'x') || (pInputStr[1] == (uint8_t)'X')))
 800978e:	f89d 2014 	ldrb.w	r2, [sp, #20]
 8009792:	2a30      	cmp	r2, #48	@ 0x30
 8009794:	d105      	bne.n	80097a2 <SFU_COM_YMODEM_Receive+0x1a6>
 8009796:	f89d 2015 	ldrb.w	r2, [sp, #21]
 800979a:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
 800979e:	2a58      	cmp	r2, #88	@ 0x58
 80097a0:	d03f      	beq.n	8009822 <SFU_COM_YMODEM_Receive+0x226>
 80097a2:	462f      	mov	r7, r5
 80097a4:	4618      	mov	r0, r3
        val = (val * 10U) + digit;
 80097a6:	250a      	movs	r5, #10
      if (pInputStr[i] == (uint8_t)'\0')
 80097a8:	f811 2b01 	ldrb.w	r2, [r1], #1
 80097ac:	b132      	cbz	r2, 80097bc <SFU_COM_YMODEM_Receive+0x1c0>
      else if (((pInputStr[i] == (uint8_t)'k') || (pInputStr[i] == (uint8_t)'K')) && (i > 0U))
 80097ae:	f002 0cdf 	and.w	ip, r2, #223	@ 0xdf
 80097b2:	f1bc 0f4b 	cmp.w	ip, #75	@ 0x4b
 80097b6:	d137      	bne.n	8009828 <SFU_COM_YMODEM_Receive+0x22c>
 80097b8:	b1f8      	cbz	r0, 80097fa <SFU_COM_YMODEM_Receive+0x1fe>
        val = val << 10U;
 80097ba:	029b      	lsls	r3, r3, #10
        *pIntNum = val;
 80097bc:	461f      	mov	r7, r3
        res = 1U;
 80097be:	2201      	movs	r2, #1
 80097c0:	e040      	b.n	8009844 <SFU_COM_YMODEM_Receive+0x248>
        digit = CONVERTHEX(pInputStr[i]);
 80097c2:	3a37      	subs	r2, #55	@ 0x37
 80097c4:	b2d2      	uxtb	r2, r2
      i++;
 80097c6:	3301      	adds	r3, #1
        val = (val << 4U) + digit;
 80097c8:	eb02 1707 	add.w	r7, r2, r7, lsl #4
    while ((i < 11U) && (pInputStr[i] != (uint8_t)'\0'))
 80097cc:	2b0b      	cmp	r3, #11
 80097ce:	d00d      	beq.n	80097ec <SFU_COM_YMODEM_Receive+0x1f0>
 80097d0:	5cca      	ldrb	r2, [r1, r3]
 80097d2:	b15a      	cbz	r2, 80097ec <SFU_COM_YMODEM_Receive+0x1f0>
      if (ISVALIDHEX(pInputStr[i]))
 80097d4:	f1a2 0041 	sub.w	r0, r2, #65	@ 0x41
 80097d8:	2805      	cmp	r0, #5
 80097da:	d9f2      	bls.n	80097c2 <SFU_COM_YMODEM_Receive+0x1c6>
 80097dc:	f1a2 0061 	sub.w	r0, r2, #97	@ 0x61
 80097e0:	2805      	cmp	r0, #5
 80097e2:	d91c      	bls.n	800981e <SFU_COM_YMODEM_Receive+0x222>
 80097e4:	3a30      	subs	r2, #48	@ 0x30
 80097e6:	b2d2      	uxtb	r2, r2
 80097e8:	2a09      	cmp	r2, #9
 80097ea:	d9ec      	bls.n	80097c6 <SFU_COM_YMODEM_Receive+0x1ca>
    if (pInputStr[i] == (uint8_t)'\0')
 80097ec:	3328      	adds	r3, #40	@ 0x28
 80097ee:	446b      	add	r3, sp
 80097f0:	f813 3c14 	ldrb.w	r3, [r3, #-20]
 80097f4:	2b00      	cmp	r3, #0
 80097f6:	bf18      	it	ne
 80097f8:	462f      	movne	r7, r5
                    if (SFU_COM_YMODEM_HeaderPktRxCpltCallback((uint32_t) filesize) == SFU_SUCCESS)
 80097fa:	4638      	mov	r0, r7
 80097fc:	f000 fd66 	bl	800a2cc <SFU_COM_YMODEM_HeaderPktRxCpltCallback>
 8009800:	4540      	cmp	r0, r8
 8009802:	d125      	bne.n	8009850 <SFU_COM_YMODEM_Receive+0x254>
                      (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 8009804:	2006      	movs	r0, #6
 8009806:	f7ff feec 	bl	80095e2 <SFU_COM_Serial_PutByte>
                      (void) SFU_LL_UART_Flush();
 800980a:	f000 ffa3 	bl	800a754 <SFU_LL_UART_Flush>
                      (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CRC16);
 800980e:	2043      	movs	r0, #67	@ 0x43
 8009810:	f7ff fee7 	bl	80095e2 <SFU_COM_Serial_PutByte>
                session_begin = 1;
 8009814:	2301      	movs	r3, #1
                packets_received ++;
 8009816:	3601      	adds	r6, #1
 8009818:	463d      	mov	r5, r7
                session_begin = 1;
 800981a:	9301      	str	r3, [sp, #4]
 800981c:	e79a      	b.n	8009754 <SFU_COM_YMODEM_Receive+0x158>
        digit = CONVERTHEX(pInputStr[i]);
 800981e:	3a57      	subs	r2, #87	@ 0x57
 8009820:	e7d0      	b.n	80097c4 <SFU_COM_YMODEM_Receive+0x1c8>
 8009822:	461f      	mov	r7, r3
 8009824:	2302      	movs	r3, #2
 8009826:	e7d3      	b.n	80097d0 <SFU_COM_YMODEM_Receive+0x1d4>
      else if (((pInputStr[i] == (uint8_t)'m') || (pInputStr[i] == (uint8_t)'M')) && (i > 0U))
 8009828:	f1bc 0f4d 	cmp.w	ip, #77	@ 0x4d
 800982c:	d103      	bne.n	8009836 <SFU_COM_YMODEM_Receive+0x23a>
 800982e:	2800      	cmp	r0, #0
 8009830:	d0e3      	beq.n	80097fa <SFU_COM_YMODEM_Receive+0x1fe>
        val = val << 20U;
 8009832:	051b      	lsls	r3, r3, #20
        res = 1U;
 8009834:	e7c2      	b.n	80097bc <SFU_COM_YMODEM_Receive+0x1c0>
      else if (ISVALIDDEC(pInputStr[i]))
 8009836:	3a30      	subs	r2, #48	@ 0x30
 8009838:	b2d2      	uxtb	r2, r2
 800983a:	2a09      	cmp	r2, #9
 800983c:	d8dd      	bhi.n	80097fa <SFU_COM_YMODEM_Receive+0x1fe>
        val = (val * 10U) + digit;
 800983e:	fb05 2303 	mla	r3, r5, r3, r2
 8009842:	2200      	movs	r2, #0
      i++;
 8009844:	3001      	adds	r0, #1
    while ((i < 11U) && (res != 1U))
 8009846:	280b      	cmp	r0, #11
 8009848:	d0d7      	beq.n	80097fa <SFU_COM_YMODEM_Receive+0x1fe>
 800984a:	2a00      	cmp	r2, #0
 800984c:	d0ac      	beq.n	80097a8 <SFU_COM_YMODEM_Receive+0x1ac>
 800984e:	e7d4      	b.n	80097fa <SFU_COM_YMODEM_Receive+0x1fe>
                      tmp = SFU_COM_YMODEM_CA;
 8009850:	2318      	movs	r3, #24
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 8009852:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8009856:	2101      	movs	r1, #1
 8009858:	f10d 0013 	add.w	r0, sp, #19
                      tmp = SFU_COM_YMODEM_CA;
 800985c:	f88d 3013 	strb.w	r3, [sp, #19]
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 8009860:	f000 ff50 	bl	800a704 <SFU_LL_UART_Transmit>
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 8009864:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8009868:	2101      	movs	r1, #1
 800986a:	f10d 0013 	add.w	r0, sp, #19
 800986e:	f000 ff49 	bl	800a704 <SFU_LL_UART_Transmit>
    return SFU_ERROR;
 8009872:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
}
 8009876:	b00b      	add	sp, #44	@ 0x2c
 8009878:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800987c:	2006      	movs	r0, #6
 800987e:	f7ff feb0 	bl	80095e2 <SFU_COM_Serial_PutByte>
  (void) BSP_LED_Off(SFU_STATUS_LED);
 8009882:	2000      	movs	r0, #0
 8009884:	f001 fb2a 	bl	800aedc <BSP_LED_Off>
  if (*peCOMStatus == SFU_COM_YMODEM_OK)
 8009888:	7823      	ldrb	r3, [r4, #0]
 800988a:	2b00      	cmp	r3, #0
 800988c:	d1f1      	bne.n	8009872 <SFU_COM_YMODEM_Receive+0x276>
    return SFU_SUCCESS;
 800988e:	4828      	ldr	r0, [pc, #160]	@ (8009930 <SFU_COM_YMODEM_Receive+0x334>)
 8009890:	e7f1      	b.n	8009876 <SFU_COM_YMODEM_Receive+0x27a>
                  if (SFU_COM_YMODEM_DataPktRxCpltCallback(&m_aPacketData[SFU_COM_YMODEM_PACKET_DATA_INDEX],
 8009892:	4659      	mov	r1, fp
 8009894:	4825      	ldr	r0, [pc, #148]	@ (800992c <SFU_COM_YMODEM_Receive+0x330>)
 8009896:	f000 fd2d 	bl	800a2f4 <SFU_COM_YMODEM_DataPktRxCpltCallback>
 800989a:	4540      	cmp	r0, r8
 800989c:	d104      	bne.n	80098a8 <SFU_COM_YMODEM_Receive+0x2ac>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800989e:	2006      	movs	r0, #6
 80098a0:	f7ff fe9f 	bl	80095e2 <SFU_COM_Serial_PutByte>
    if (pInputStr[i] == (uint8_t)'\0')
 80098a4:	462f      	mov	r7, r5
 80098a6:	e7b5      	b.n	8009814 <SFU_COM_YMODEM_Receive+0x218>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 80098a8:	2018      	movs	r0, #24
 80098aa:	f7ff fe9a 	bl	80095e2 <SFU_COM_Serial_PutByte>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 80098ae:	2018      	movs	r0, #24
 80098b0:	f7ff fe97 	bl	80095e2 <SFU_COM_Serial_PutByte>
                    *peCOMStatus = SFU_COM_YMODEM_DATA;
 80098b4:	2304      	movs	r3, #4
 80098b6:	7023      	strb	r3, [r4, #0]
 80098b8:	e7f4      	b.n	80098a4 <SFU_COM_YMODEM_Receive+0x2a8>
          (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 80098ba:	2018      	movs	r0, #24
 80098bc:	f7ff fe91 	bl	80095e2 <SFU_COM_Serial_PutByte>
          (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 80098c0:	2018      	movs	r0, #24
 80098c2:	f7ff fe8e 	bl	80095e2 <SFU_COM_Serial_PutByte>
          *peCOMStatus = SFU_COM_YMODEM_ABORT;
 80098c6:	f884 a000 	strb.w	sl, [r4]
    while ((file_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 80098ca:	f894 a000 	ldrb.w	sl, [r4]
 80098ce:	f1ba 0f00 	cmp.w	sl, #0
 80098d2:	f47f aea4 	bne.w	800961e <SFU_COM_YMODEM_Receive+0x22>
  (void) SFU_LL_SECU_IWDG_Refresh();
 80098d6:	f001 faa1 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
  eRetStatus = SFU_LL_UART_Receive(&char1, 1, uTimeout);
 80098da:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 80098de:	2101      	movs	r1, #1
 80098e0:	f10d 0013 	add.w	r0, sp, #19
 80098e4:	f000 ff22 	bl	800a72c <SFU_LL_UART_Receive>
  if (eRetStatus == SFU_SUCCESS)
 80098e8:	4540      	cmp	r0, r8
 80098ea:	f47f af1e 	bne.w	800972a <SFU_COM_YMODEM_Receive+0x12e>
    switch (char1)
 80098ee:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80098f2:	2b18      	cmp	r3, #24
 80098f4:	f43f aea6 	beq.w	8009644 <SFU_COM_YMODEM_Receive+0x48>
 80098f8:	f63f ae98 	bhi.w	800962c <SFU_COM_YMODEM_Receive+0x30>
 80098fc:	2b02      	cmp	r3, #2
 80098fe:	f43f af07 	beq.w	8009710 <SFU_COM_YMODEM_Receive+0x114>
 8009902:	2b04      	cmp	r3, #4
 8009904:	f43f ae9b 	beq.w	800963e <SFU_COM_YMODEM_Receive+0x42>
 8009908:	2b01      	cmp	r3, #1
 800990a:	f43f af04 	beq.w	8009716 <SFU_COM_YMODEM_Receive+0x11a>
          status = HAL_ERROR;
 800990e:	f04f 0a01 	mov.w	sl, #1
 8009912:	e694      	b.n	800963e <SFU_COM_YMODEM_Receive+0x42>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CRC16); /* Ask for a packet */
 8009914:	2043      	movs	r0, #67	@ 0x43
 8009916:	f7ff fe64 	bl	80095e2 <SFU_COM_Serial_PutByte>
            TRACE("\b.");                                 /* Replace C char by . on display console */
 800991a:	4806      	ldr	r0, [pc, #24]	@ (8009934 <SFU_COM_YMODEM_Receive+0x338>)
 800991c:	f003 fd28 	bl	800d370 <iprintf>
            (void) BSP_LED_Toggle(SFU_STATUS_LED);
 8009920:	2000      	movs	r0, #0
 8009922:	f001 fae9 	bl	800aef8 <BSP_LED_Toggle>
 8009926:	e7d0      	b.n	80098ca <SFU_COM_YMODEM_Receive+0x2ce>
 8009928:	200011ba 	.word	0x200011ba
 800992c:	200011bc 	.word	0x200011bc
 8009930:	00122f11 	.word	0x00122f11
 8009934:	0800ea78 	.word	0x0800ea78
 8009938:	200011b8 	.word	0x200011b8

0800993c <SFU_COM_Init>:
  * @brief  SFU Com Init function.
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_Init(void)
{
 800993c:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
 800993e:	4b06      	ldr	r3, [pc, #24]	@ (8009958 <SFU_COM_Init+0x1c>)
 8009940:	2202      	movs	r2, #2
 8009942:	6818      	ldr	r0, [r3, #0]
 8009944:	2300      	movs	r3, #0
 8009946:	6880      	ldr	r0, [r0, #8]
 8009948:	4619      	mov	r1, r3
 800994a:	f003 fd81 	bl	800d450 <setvbuf>
#endif /* __GNUC__ */
  return SFU_LL_UART_Init();
}
 800994e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return SFU_LL_UART_Init();
 8009952:	f000 beaf 	b.w	800a6b4 <SFU_LL_UART_Init>
 8009956:	bf00      	nop
 8009958:	20001138 	.word	0x20001138

0800995c <SFU_COM_DeInit>:
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_DeInit(void)
{
  return SFU_LL_UART_DeInit();
 800995c:	f000 bece 	b.w	800a6fc <SFU_LL_UART_DeInit>

08009960 <SFU_COM_Serial_PutString>:
SFU_ErrorStatus SFU_COM_Serial_PutString(uint8_t *pString)
{
  uint16_t length = 0U;

  /* Check the pointers allocation */
  if (pString == NULL)
 8009960:	b150      	cbz	r0, 8009978 <SFU_COM_Serial_PutString+0x18>
 8009962:	2300      	movs	r3, #0
  {
    return SFU_ERROR;
  }

  while (pString[length] != (uint8_t)'\0')
 8009964:	b29a      	uxth	r2, r3
 8009966:	4619      	mov	r1, r3
 8009968:	3301      	adds	r3, #1
 800996a:	5c82      	ldrb	r2, [r0, r2]
 800996c:	2a00      	cmp	r2, #0
 800996e:	d1f9      	bne.n	8009964 <SFU_COM_Serial_PutString+0x4>
  {
    length++;
  }

  return SFU_LL_UART_Transmit(pString, length, SFU_COM_TRACE_SERIAL_TIME_OUT);
 8009970:	2264      	movs	r2, #100	@ 0x64
 8009972:	b289      	uxth	r1, r1
 8009974:	f000 bec6 	b.w	800a704 <SFU_LL_UART_Transmit>

}
 8009978:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800997c:	4770      	bx	lr

0800997e <__io_putchar>:
  * @brief  Retargets the C library printf function to SFU UART.
  * @param  None
  * @retval ch
  */
PUTCHAR_PROTOTYPE
{
 800997e:	b507      	push	{r0, r1, r2, lr}
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART1 and Loop until the end of transmission */
  (void) SFU_LL_UART_Transmit((uint8_t *)&ch, 1U, 0xFFFFU);
 8009980:	f64f 72ff 	movw	r2, #65535	@ 0xffff
{
 8009984:	9001      	str	r0, [sp, #4]
  (void) SFU_LL_UART_Transmit((uint8_t *)&ch, 1U, 0xFFFFU);
 8009986:	2101      	movs	r1, #1
 8009988:	a801      	add	r0, sp, #4
 800998a:	f000 febb 	bl	800a704 <SFU_LL_UART_Transmit>

  return ch;
}
 800998e:	9801      	ldr	r0, [sp, #4]
 8009990:	b003      	add	sp, #12
 8009992:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009998 <SFU_EXCPT_SetError>:
  * @param  Error Error code.
  * @retval None
  */
void SFU_EXCPT_SetError(SFU_EXCPT_IdTypeDef eExceptionId)
{
  if (eExceptionId <= SFU_EXCPT_UNKNOWN)
 8009998:	2810      	cmp	r0, #16
 800999a:	d805      	bhi.n	80099a8 <SFU_EXCPT_SetError+0x10>
  {
#ifdef SFU_DEBUG_MODE
    TRACE("\r\n\t%s",m_aErrorStrings[(uint32_t) eExceptionId]);
 800999c:	4b03      	ldr	r3, [pc, #12]	@ (80099ac <SFU_EXCPT_SetError+0x14>)
 800999e:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80099a2:	4803      	ldr	r0, [pc, #12]	@ (80099b0 <SFU_EXCPT_SetError+0x18>)
 80099a4:	f003 bce4 	b.w	800d370 <iprintf>
#endif /* SFU_DEBUG_MODE */
  }
}
 80099a8:	4770      	bx	lr
 80099aa:	bf00      	nop
 80099ac:	0800e2f8 	.word	0x0800e2f8
 80099b0:	0800ea7b 	.word	0x0800ea7b

080099b4 <SFU_EXCPT_IrqExceptionHandler>:
  *         it's not possible to continue without compromising the stability or
  *         the security of the solution. A System Reset is forced at the end.
  * @retval None
  */
void SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_IdTypeDef eExceptionId)
{
 80099b4:	b510      	push	{r4, lr}
 80099b6:	b0a6      	sub	sp, #152	@ 0x98
#ifdef SFU_DEBUG_MODE
  uint8_t message[150];
  uint32_t i = 0U;

  /* Avoid warning with cast frombetween char* and uint8_t* */
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 80099b8:	4b0e      	ldr	r3, [pc, #56]	@ (80099f4 <SFU_EXCPT_IrqExceptionHandler+0x40>)
 80099ba:	466a      	mov	r2, sp
 80099bc:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
  uint32_t i = 0U;
 80099c0:	2300      	movs	r3, #0
 80099c2:	4614      	mov	r4, r2
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 80099c4:	5cc1      	ldrb	r1, [r0, r3]
 80099c6:	b109      	cbz	r1, 80099cc <SFU_EXCPT_IrqExceptionHandler+0x18>
 80099c8:	2b95      	cmp	r3, #149	@ 0x95
 80099ca:	d10e      	bne.n	80099ea <SFU_EXCPT_IrqExceptionHandler+0x36>
  {
    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
    i++;
  }
  message[i] = 0U;
 80099cc:	3398      	adds	r3, #152	@ 0x98
 80099ce:	2200      	movs	r2, #0

  /* Print relevant error message */
  TRACE_IRQ((uint8_t *)"\r\n\t  ");
 80099d0:	4809      	ldr	r0, [pc, #36]	@ (80099f8 <SFU_EXCPT_IrqExceptionHandler+0x44>)
  message[i] = 0U;
 80099d2:	446b      	add	r3, sp
 80099d4:	f803 2c98 	strb.w	r2, [r3, #-152]
  TRACE_IRQ((uint8_t *)"\r\n\t  ");
 80099d8:	f7ff ffc2 	bl	8009960 <SFU_COM_Serial_PutString>
  TRACE_IRQ(message);
 80099dc:	4620      	mov	r0, r4
 80099de:	f7ff ffbf 	bl	8009960 <SFU_COM_Serial_PutString>
  /* Try to take an action */
  SFU_EXCPT_RuntimeExceptionHandler(eExceptionId);

  /* It's not possible to continue without compromising the stability or the security of the solution.
  The State Machine needs to be aborted and a Reset must be triggered */
  SFU_BOOT_ForceReboot();
 80099e2:	f7ff fcb3 	bl	800934c <SFU_BOOT_ForceReboot>
}
 80099e6:	b026      	add	sp, #152	@ 0x98
 80099e8:	bd10      	pop	{r4, pc}
    i++;
 80099ea:	3301      	adds	r3, #1
    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
 80099ec:	f802 1b01 	strb.w	r1, [r2], #1
    i++;
 80099f0:	e7e8      	b.n	80099c4 <SFU_EXCPT_IrqExceptionHandler+0x10>
 80099f2:	bf00      	nop
 80099f4:	0800e2f8 	.word	0x0800e2f8
 80099f8:	0800ea81 	.word	0x0800ea81

080099fc <SFU_EXCPT_Security_Error>:
  *         This parameter can be a value of @ref SFU_EXCPT_ID_Structure_definition.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */

void SFU_EXCPT_Security_Error(void)
{
 80099fc:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] Security issue : execution stopped !");
 80099fe:	480e      	ldr	r0, [pc, #56]	@ (8009a38 <SFU_EXCPT_Security_Error+0x3c>)
 8009a00:	f003 fcb6 	bl	800d370 <iprintf>
  HAL_Delay(1000);
 8009a04:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8009a08:	f001 fba6 	bl	800b158 <HAL_Delay>
  /* While(1) by-passed by an fault injection attack ==> Reset */
  if (0U != SFU_MPU_IsUnprivileged())
 8009a0c:	f000 fdd2 	bl	800a5b4 <SFU_MPU_IsUnprivileged>
 8009a10:	b120      	cbz	r0, 8009a1c <SFU_EXCPT_Security_Error+0x20>
  {
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 8009a12:	2002      	movs	r0, #2
  }
  else
  {
    NVIC_SystemReset();
  }
}
 8009a14:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SFU_MPU_SysCall((uint32_t)SB_SYSCALL_RESET);
 8009a18:	f000 bdc8 	b.w	800a5ac <SFU_MPU_SysCall>
 8009a1c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009a20:	4906      	ldr	r1, [pc, #24]	@ (8009a3c <SFU_EXCPT_Security_Error+0x40>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009a22:	4b07      	ldr	r3, [pc, #28]	@ (8009a40 <SFU_EXCPT_Security_Error+0x44>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009a24:	68ca      	ldr	r2, [r1, #12]
 8009a26:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009a2a:	4313      	orrs	r3, r2
 8009a2c:	60cb      	str	r3, [r1, #12]
 8009a2e:	f3bf 8f4f 	dsb	sy
    __NOP();
 8009a32:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8009a34:	e7fd      	b.n	8009a32 <SFU_EXCPT_Security_Error+0x36>
 8009a36:	bf00      	nop
 8009a38:	0800ea87 	.word	0x0800ea87
 8009a3c:	e000ed00 	.word	0xe000ed00
 8009a40:	05fa0004 	.word	0x05fa0004

08009a44 <SFU_EXCPT_Init>:
       ...
  */
  e_ret_status = SFU_SUCCESS;

  return e_ret_status;
}
 8009a44:	4800      	ldr	r0, [pc, #0]	@ (8009a48 <SFU_EXCPT_Init+0x4>)
 8009a46:	4770      	bx	lr
 8009a48:	00122f11 	.word	0x00122f11

08009a4c <SFU_EXCPT_DeInit>:
/**
  * @brief  SFU Exception DeInitialization.
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_EXCPT_DeInit(void)
 8009a4c:	4800      	ldr	r0, [pc, #0]	@ (8009a50 <SFU_EXCPT_DeInit+0x4>)
 8009a4e:	4770      	bx	lr
 8009a50:	00122f11 	.word	0x00122f11

08009a54 <MemoryCompare>:
  * @retval SFU_ SUCCESS if equal, a SFU_error otherwise.
  */
SFU_ErrorStatus MemoryCompare(uint8_t *pAdd1, uint8_t *pAdd2, uint32_t Size)
{
  /* Use of __IO to force recheck of these variables values */
  uint8_t __IO result = 0x00U;
 8009a54:	2300      	movs	r3, #0
{
 8009a56:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t __IO result = 0x00U;
 8009a58:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t __IO i;
  uint32_t tmp;

  for (i = 0U; i < Size; i++)
 8009a5c:	9301      	str	r3, [sp, #4]
 8009a5e:	9b01      	ldr	r3, [sp, #4]
 8009a60:	4293      	cmp	r3, r2
 8009a62:	d311      	bcc.n	8009a88 <MemoryCompare+0x34>
    tmp = pAdd1[i];
    tmp ^= pAdd2[i];
    result |= tmp;
  }

  if ((result == 0x00U) && (i == Size)) /* Add check that loop exited normally without any fault injection */
 8009a64:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a68:	b9db      	cbnz	r3, 8009aa2 <MemoryCompare+0x4e>
 8009a6a:	9b01      	ldr	r3, [sp, #4]
 8009a6c:	4293      	cmp	r3, r2
 8009a6e:	d118      	bne.n	8009aa2 <MemoryCompare+0x4e>
  {
    return (((result != 0x00U) || (i != Size))? SFU_ERROR : SFU_SUCCESS);
 8009a70:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a74:	b9ab      	cbnz	r3, 8009aa2 <MemoryCompare+0x4e>
 8009a76:	9901      	ldr	r1, [sp, #4]
 8009a78:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 8009a7c:	4b0a      	ldr	r3, [pc, #40]	@ (8009aa8 <MemoryCompare+0x54>)
 8009a7e:	4291      	cmp	r1, r2
 8009a80:	bf08      	it	eq
 8009a82:	4618      	moveq	r0, r3
  }
  else
  {
    return SFU_ERROR;
  }
}
 8009a84:	b003      	add	sp, #12
 8009a86:	bd30      	pop	{r4, r5, pc}
    tmp = pAdd1[i];
 8009a88:	9c01      	ldr	r4, [sp, #4]
    tmp ^= pAdd2[i];
 8009a8a:	9d01      	ldr	r5, [sp, #4]
    result |= tmp;
 8009a8c:	5d04      	ldrb	r4, [r0, r4]
 8009a8e:	5d4d      	ldrb	r5, [r1, r5]
 8009a90:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a94:	406c      	eors	r4, r5
 8009a96:	4323      	orrs	r3, r4
 8009a98:	f88d 3003 	strb.w	r3, [sp, #3]
  for (i = 0U; i < Size; i++)
 8009a9c:	9b01      	ldr	r3, [sp, #4]
 8009a9e:	3301      	adds	r3, #1
 8009aa0:	e7dc      	b.n	8009a5c <MemoryCompare+0x8>
    return (((result != 0x00U) || (i != Size))? SFU_ERROR : SFU_SUCCESS);
 8009aa2:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 8009aa6:	e7ed      	b.n	8009a84 <MemoryCompare+0x30>
 8009aa8:	00122f11 	.word	0x00122f11

08009aac <VerifyFwSignatureScatter>:
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SFU_ErrorStatus VerifyFwSignatureScatter(SE_StatusTypeDef *pSeStatus, uint32_t SlotNumber,
                                         SE_FwRawHeaderTypeDef *pSE_Metadata,
                                         SE_Ex_PayloadDescTypeDef  *pSE_Payload, uint32_t SE_FwType)
{
 8009aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009ab0:	f6ad 0d4c 	subw	sp, sp, #2124	@ 0x84c
 8009ab4:	461c      	mov	r4, r3
  /* Variables to handle FW image size and tag */
  uint32_t fw_size;
  uint8_t *fw_tag;

  /* Check the pointers allocation */
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 8009ab6:	4605      	mov	r5, r0
{
 8009ab8:	9107      	str	r1, [sp, #28]
 8009aba:	4611      	mov	r1, r2
 8009abc:	f8dd 2870 	ldr.w	r2, [sp, #2160]	@ 0x870
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 8009ac0:	b930      	cbnz	r0, 8009ad0 <VerifyFwSignatureScatter+0x24>
  {
    return SFU_ERROR;
 8009ac2:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
  else
  {
    sfu_ret_status = SFU_ERROR;
  }
  return sfu_ret_status;
}
 8009ac6:	4638      	mov	r0, r7
 8009ac8:	f60d 0d4c 	addw	sp, sp, #2124	@ 0x84c
 8009acc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 8009ad0:	2900      	cmp	r1, #0
 8009ad2:	d0f6      	beq.n	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009ad4:	2b00      	cmp	r3, #0
 8009ad6:	d0f4      	beq.n	8009ac2 <VerifyFwSignatureScatter+0x16>
  if ((pSE_Payload->pPayload[0] == 0U) || ((pSE_Payload->pPayload[1] == 0U) && (pSE_Payload->PayloadSize[1] != 0U)))
 8009ad8:	681b      	ldr	r3, [r3, #0]
 8009ada:	2b00      	cmp	r3, #0
 8009adc:	d0f1      	beq.n	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009ade:	6863      	ldr	r3, [r4, #4]
 8009ae0:	b913      	cbnz	r3, 8009ae8 <VerifyFwSignatureScatter+0x3c>
 8009ae2:	68e3      	ldr	r3, [r4, #12]
 8009ae4:	2b00      	cmp	r3, #0
 8009ae6:	d1ec      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
  if (SE_FwType == SE_FW_IMAGE_COMPLETE)
 8009ae8:	2a00      	cmp	r2, #0
 8009aea:	f040 8096 	bne.w	8009c1a <VerifyFwSignatureScatter+0x16e>
    fw_size = pSE_Metadata->FwSize;
 8009aee:	688b      	ldr	r3, [r1, #8]
 8009af0:	9302      	str	r3, [sp, #8]
    fw_tag = pSE_Metadata->FwTag;
 8009af2:	f101 0314 	add.w	r3, r1, #20
    fw_tag = pSE_Metadata->PartialFwTag;
 8009af6:	9303      	str	r3, [sp, #12]
  if ((pSE_Payload->PayloadSize[0] + pSE_Payload->PayloadSize[1]) != fw_size)
 8009af8:	9e02      	ldr	r6, [sp, #8]
 8009afa:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 8009afe:	4403      	add	r3, r0
 8009b00:	42b3      	cmp	r3, r6
 8009b02:	d1de      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
    scatter_nb = 2U;
 8009b04:	2800      	cmp	r0, #0
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b06:	f8df b1bc 	ldr.w	fp, [pc, #444]	@ 8009cc4 <VerifyFwSignatureScatter+0x218>
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 8009b0a:	4628      	mov	r0, r5
    scatter_nb = 2U;
 8009b0c:	bf0c      	ite	eq
 8009b0e:	2601      	moveq	r6, #1
 8009b10:	2602      	movne	r6, #2
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 8009b12:	f7fe fcc3 	bl	800849c <SE_AuthenticateFW_Init>
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b16:	4558      	cmp	r0, fp
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 8009b18:	4603      	mov	r3, r0
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b1a:	d1d2      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009b1c:	6829      	ldr	r1, [r5, #0]
 8009b1e:	4a62      	ldr	r2, [pc, #392]	@ (8009ca8 <VerifyFwSignatureScatter+0x1fc>)
 8009b20:	4291      	cmp	r1, r2
 8009b22:	d1ce      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009b24:	eb04 0286 	add.w	r2, r4, r6, lsl #2
  uint32_t fw_verified_total_size = 0; /* number of bytes that have been processed during authentication check */
 8009b28:	f04f 0800 	mov.w	r8, #0
  SFU_ErrorStatus sfu_ret_status = SFU_SUCCESS;
 8009b2c:	4e5f      	ldr	r6, [pc, #380]	@ (8009cac <VerifyFwSignatureScatter+0x200>)
      fw_chunk_size = CHUNK_SIZE_SIGN_VERIFICATION;
 8009b2e:	af09      	add	r7, sp, #36	@ 0x24
 8009b30:	9206      	str	r2, [sp, #24]
      payloadsize = pSE_Payload->PayloadSize[j];
 8009b32:	68a2      	ldr	r2, [r4, #8]
      i = 0;
 8009b34:	f04f 0a00 	mov.w	sl, #0
      ppayload = pSE_Payload->pPayload[j];
 8009b38:	f854 9b04 	ldr.w	r9, [r4], #4
      payloadsize = pSE_Payload->PayloadSize[j];
 8009b3c:	9204      	str	r2, [sp, #16]
      fw_chunk_size = CHUNK_SIZE_SIGN_VERIFICATION;
 8009b3e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8009b42:	603a      	str	r2, [r7, #0]
      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERIFICATION)) && (*pSeStatus == SE_OK) &&
 8009b44:	9a04      	ldr	r2, [sp, #16]
 8009b46:	0a92      	lsrs	r2, r2, #10
 8009b48:	9205      	str	r2, [sp, #20]
 8009b4a:	9a05      	ldr	r2, [sp, #20]
 8009b4c:	4552      	cmp	r2, sl
 8009b4e:	d006      	beq.n	8009b5e <VerifyFwSignatureScatter+0xb2>
 8009b50:	682a      	ldr	r2, [r5, #0]
 8009b52:	4955      	ldr	r1, [pc, #340]	@ (8009ca8 <VerifyFwSignatureScatter+0x1fc>)
 8009b54:	428a      	cmp	r2, r1
 8009b56:	d102      	bne.n	8009b5e <VerifyFwSignatureScatter+0xb2>
 8009b58:	4a54      	ldr	r2, [pc, #336]	@ (8009cac <VerifyFwSignatureScatter+0x200>)
 8009b5a:	4296      	cmp	r6, r2
 8009b5c:	d065      	beq.n	8009c2a <VerifyFwSignatureScatter+0x17e>
      fw_chunk_size = pSE_Payload->pPayload[j] + pSE_Payload->PayloadSize[j] - ppayload;
 8009b5e:	f854 2c04 	ldr.w	r2, [r4, #-4]
 8009b62:	6861      	ldr	r1, [r4, #4]
 8009b64:	440a      	add	r2, r1
 8009b66:	eba2 0209 	sub.w	r2, r2, r9
 8009b6a:	603a      	str	r2, [r7, #0]
      if ((fw_chunk_size != 0U) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009b6c:	b1da      	cbz	r2, 8009ba6 <VerifyFwSignatureScatter+0xfa>
 8009b6e:	455b      	cmp	r3, fp
 8009b70:	d119      	bne.n	8009ba6 <VerifyFwSignatureScatter+0xfa>
 8009b72:	6828      	ldr	r0, [r5, #0]
 8009b74:	494c      	ldr	r1, [pc, #304]	@ (8009ca8 <VerifyFwSignatureScatter+0x1fc>)
 8009b76:	4288      	cmp	r0, r1
 8009b78:	d115      	bne.n	8009ba6 <VerifyFwSignatureScatter+0xfa>
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009b7a:	4649      	mov	r1, r9
 8009b7c:	f50d 6089 	add.w	r0, sp, #1096	@ 0x448
 8009b80:	f000 fe96 	bl	800a8b0 <SFU_LL_FLASH_Read>
        if (sfu_ret_status == SFU_SUCCESS)
 8009b84:	4b49      	ldr	r3, [pc, #292]	@ (8009cac <VerifyFwSignatureScatter+0x200>)
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009b86:	4606      	mov	r6, r0
        if (sfu_ret_status == SFU_SUCCESS)
 8009b88:	4298      	cmp	r0, r3
 8009b8a:	d16d      	bne.n	8009c68 <VerifyFwSignatureScatter+0x1bc>
          se_ret_status = SE_AuthenticateFW_Append(pSeStatus, fw_image_chunk,
 8009b8c:	9a04      	ldr	r2, [sp, #16]
 8009b8e:	ab12      	add	r3, sp, #72	@ 0x48
 8009b90:	f50d 6189 	add.w	r1, sp, #1096	@ 0x448
 8009b94:	4628      	mov	r0, r5
 8009b96:	eba2 228a 	sub.w	r2, r2, sl, lsl #10
 8009b9a:	9700      	str	r7, [sp, #0]
 8009b9c:	f7fe fcb4 	bl	8008508 <SE_AuthenticateFW_Append>
 8009ba0:	4603      	mov	r3, r0
        fw_verified_total_size += fw_chunk_size;
 8009ba2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8009ba4:	4490      	add	r8, r2
    for (j = 0; j < scatter_nb; j++)
 8009ba6:	9a06      	ldr	r2, [sp, #24]
 8009ba8:	4294      	cmp	r4, r2
 8009baa:	d1c2      	bne.n	8009b32 <VerifyFwSignatureScatter+0x86>
  if ((sfu_ret_status == SFU_SUCCESS) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 8009bac:	4a3f      	ldr	r2, [pc, #252]	@ (8009cac <VerifyFwSignatureScatter+0x200>)
 8009bae:	4296      	cmp	r6, r2
 8009bb0:	d187      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009bb2:	455b      	cmp	r3, fp
 8009bb4:	d185      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009bb6:	682c      	ldr	r4, [r5, #0]
 8009bb8:	4a3b      	ldr	r2, [pc, #236]	@ (8009ca8 <VerifyFwSignatureScatter+0x1fc>)
 8009bba:	4294      	cmp	r4, r2
 8009bbc:	d181      	bne.n	8009ac2 <VerifyFwSignatureScatter+0x16>
    if (fw_verified_total_size <= fw_size)
 8009bbe:	9a02      	ldr	r2, [sp, #8]
 8009bc0:	4590      	cmp	r8, r2
 8009bc2:	f63f af7e 	bhi.w	8009ac2 <VerifyFwSignatureScatter+0x16>
      fw_tag_len = sizeof(fw_tag_output);
 8009bc6:	2220      	movs	r2, #32
      se_ret_status =   SE_AuthenticateFW_Finish(pSeStatus, fw_tag_output, (int32_t *)&fw_tag_len);
 8009bc8:	a90a      	add	r1, sp, #40	@ 0x28
 8009bca:	4628      	mov	r0, r5
 8009bcc:	9302      	str	r3, [sp, #8]
      fw_tag_len = sizeof(fw_tag_output);
 8009bce:	9208      	str	r2, [sp, #32]
      se_ret_status =   SE_AuthenticateFW_Finish(pSeStatus, fw_tag_output, (int32_t *)&fw_tag_len);
 8009bd0:	446a      	add	r2, sp
 8009bd2:	f7fe fcd7 	bl	8008584 <SE_AuthenticateFW_Finish>
      if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK) && (fw_tag_len == SE_TAG_LEN))
 8009bd6:	9b02      	ldr	r3, [sp, #8]
 8009bd8:	4298      	cmp	r0, r3
 8009bda:	f47f af72 	bne.w	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009bde:	682b      	ldr	r3, [r5, #0]
 8009be0:	42a3      	cmp	r3, r4
 8009be2:	f47f af6e 	bne.w	8009ac2 <VerifyFwSignatureScatter+0x16>
 8009be6:	9a08      	ldr	r2, [sp, #32]
 8009be8:	2a20      	cmp	r2, #32
 8009bea:	f47f af6a 	bne.w	8009ac2 <VerifyFwSignatureScatter+0x16>
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 8009bee:	9903      	ldr	r1, [sp, #12]
 8009bf0:	a80a      	add	r0, sp, #40	@ 0x28
 8009bf2:	f7ff ff2f 	bl	8009a54 <MemoryCompare>
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009bf6:	9b07      	ldr	r3, [sp, #28]
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 8009bf8:	42b0      	cmp	r0, r6
 8009bfa:	4607      	mov	r7, r0
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009bfc:	f103 34ff 	add.w	r4, r3, #4294967295
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 8009c00:	d038      	beq.n	8009c74 <VerifyFwSignatureScatter+0x1c8>
          *pSeStatus = SE_SIGNATURE_ERR;
 8009c02:	4b2b      	ldr	r3, [pc, #172]	@ (8009cb0 <VerifyFwSignatureScatter+0x204>)
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c04:	2c02      	cmp	r4, #2
          *pSeStatus = SE_SIGNATURE_ERR;
 8009c06:	602b      	str	r3, [r5, #0]
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c08:	f63f af5b 	bhi.w	8009ac2 <VerifyFwSignatureScatter+0x16>
            (void) memset(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], 0x00, SE_TAG_LEN);
 8009c0c:	4829      	ldr	r0, [pc, #164]	@ (8009cb4 <VerifyFwSignatureScatter+0x208>)
 8009c0e:	2100      	movs	r1, #0
 8009c10:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 8009c14:	f003 fdb8 	bl	800d788 <memset>
 8009c18:	e753      	b.n	8009ac2 <VerifyFwSignatureScatter+0x16>
  else if (SE_FwType == SE_FW_IMAGE_PARTIAL)
 8009c1a:	2a01      	cmp	r2, #1
 8009c1c:	f47f af51 	bne.w	8009ac2 <VerifyFwSignatureScatter+0x16>
    fw_size = pSE_Metadata->PartialFwSize;
 8009c20:	690b      	ldr	r3, [r1, #16]
 8009c22:	9302      	str	r3, [sp, #8]
    fw_tag = pSE_Metadata->PartialFwTag;
 8009c24:	f101 0334 	add.w	r3, r1, #52	@ 0x34
 8009c28:	e765      	b.n	8009af6 <VerifyFwSignatureScatter+0x4a>
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009c2a:	683a      	ldr	r2, [r7, #0]
 8009c2c:	4649      	mov	r1, r9
 8009c2e:	f50d 6089 	add.w	r0, sp, #1096	@ 0x448
 8009c32:	f000 fe3d 	bl	800a8b0 <SFU_LL_FLASH_Read>
        if (sfu_ret_status == SFU_SUCCESS)
 8009c36:	4b1d      	ldr	r3, [pc, #116]	@ (8009cac <VerifyFwSignatureScatter+0x200>)
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 8009c38:	4606      	mov	r6, r0
        if (sfu_ret_status == SFU_SUCCESS)
 8009c3a:	4298      	cmp	r0, r3
 8009c3c:	d10e      	bne.n	8009c5c <VerifyFwSignatureScatter+0x1b0>
          se_ret_status = SE_AuthenticateFW_Append(pSeStatus, fw_image_chunk, (int32_t)fw_chunk_size,
 8009c3e:	9700      	str	r7, [sp, #0]
 8009c40:	ab12      	add	r3, sp, #72	@ 0x48
 8009c42:	683a      	ldr	r2, [r7, #0]
 8009c44:	f50d 6189 	add.w	r1, sp, #1096	@ 0x448
 8009c48:	4628      	mov	r0, r5
 8009c4a:	f7fe fc5d 	bl	8008508 <SE_AuthenticateFW_Append>
 8009c4e:	4603      	mov	r3, r0
        ppayload += fw_chunk_size;
 8009c50:	683a      	ldr	r2, [r7, #0]
        i++;
 8009c52:	f10a 0a01 	add.w	sl, sl, #1
        ppayload += fw_chunk_size;
 8009c56:	4491      	add	r9, r2
        fw_verified_total_size += fw_chunk_size;
 8009c58:	4490      	add	r8, r2
        i++;
 8009c5a:	e776      	b.n	8009b4a <VerifyFwSignatureScatter+0x9e>
          *pSeStatus = SE_ERR_FLASH_READ;
 8009c5c:	4b16      	ldr	r3, [pc, #88]	@ (8009cb8 <VerifyFwSignatureScatter+0x20c>)
          sfu_ret_status = SFU_ERROR;
 8009c5e:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
          *pSeStatus = SE_ERR_FLASH_READ;
 8009c62:	602b      	str	r3, [r5, #0]
          se_ret_status = SE_ERROR;
 8009c64:	4b15      	ldr	r3, [pc, #84]	@ (8009cbc <VerifyFwSignatureScatter+0x210>)
 8009c66:	e7f3      	b.n	8009c50 <VerifyFwSignatureScatter+0x1a4>
          *pSeStatus = SE_ERR_FLASH_READ;
 8009c68:	4b13      	ldr	r3, [pc, #76]	@ (8009cb8 <VerifyFwSignatureScatter+0x20c>)
          sfu_ret_status = SFU_ERROR;
 8009c6a:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
          *pSeStatus = SE_ERR_FLASH_READ;
 8009c6e:	602b      	str	r3, [r5, #0]
          se_ret_status = SE_ERROR;
 8009c70:	4b12      	ldr	r3, [pc, #72]	@ (8009cbc <VerifyFwSignatureScatter+0x210>)
 8009c72:	e796      	b.n	8009ba2 <VerifyFwSignatureScatter+0xf6>
          FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009c74:	4a12      	ldr	r2, [pc, #72]	@ (8009cc0 <VerifyFwSignatureScatter+0x214>)
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c76:	2c02      	cmp	r4, #2
          FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009c78:	6813      	ldr	r3, [r2, #0]
 8009c7a:	f483 432a 	eor.w	r3, r3, #43520	@ 0xaa00
 8009c7e:	f083 03b5 	eor.w	r3, r3, #181	@ 0xb5
 8009c82:	6013      	str	r3, [r2, #0]
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 8009c84:	f63f af1f 	bhi.w	8009ac6 <VerifyFwSignatureScatter+0x1a>
            (void) memcpy(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], fw_tag_output, SE_TAG_LEN);
 8009c88:	4a0a      	ldr	r2, [pc, #40]	@ (8009cb4 <VerifyFwSignatureScatter+0x208>)
 8009c8a:	ab0a      	add	r3, sp, #40	@ 0x28
 8009c8c:	ad12      	add	r5, sp, #72	@ 0x48
 8009c8e:	eb02 1244 	add.w	r2, r2, r4, lsl #5
 8009c92:	461c      	mov	r4, r3
 8009c94:	3208      	adds	r2, #8
 8009c96:	cc03      	ldmia	r4!, {r0, r1}
 8009c98:	42ac      	cmp	r4, r5
 8009c9a:	f842 0c08 	str.w	r0, [r2, #-8]
 8009c9e:	f842 1c04 	str.w	r1, [r2, #-4]
 8009ca2:	4623      	mov	r3, r4
 8009ca4:	d1f5      	bne.n	8009c92 <VerifyFwSignatureScatter+0x1e6>
 8009ca6:	e70e      	b.n	8009ac6 <VerifyFwSignatureScatter+0x1a>
 8009ca8:	0012e223 	.word	0x0012e223
 8009cac:	00122f11 	.word	0x00122f11
 8009cb0:	00146ac1 	.word	0x00146ac1
 8009cb4:	200015c0 	.word	0x200015c0
 8009cb8:	0014b817 	.word	0x0014b817
 8009cbc:	00018799 	.word	0x00018799
 8009cc0:	20001104 	.word	0x20001104
 8009cc4:	0012310f 	.word	0x0012310f

08009cc8 <VerifyFwSignature>:
  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
  */
SFU_ErrorStatus VerifyFwSignature(SE_StatusTypeDef  *pSeStatus, uint32_t SlotNumber,
                                  SE_FwRawHeaderTypeDef *pFwImageHeader,
                                  uint32_t SE_FwType)
{
 8009cc8:	b570      	push	{r4, r5, r6, lr}
  SE_Ex_PayloadDescTypeDef  pse_payload;
  uint32_t fw_size;
  uint32_t fw_offset;

  /*  put it OK, to discriminate error in SFU FWIMG parts */
  *pSeStatus = SE_OK;
 8009cca:	4c10      	ldr	r4, [pc, #64]	@ (8009d0c <VerifyFwSignature+0x44>)
{
 8009ccc:	b086      	sub	sp, #24
  *pSeStatus = SE_OK;
 8009cce:	6004      	str	r4, [r0, #0]

  /* Check the parameters value */
  if (pFwImageHeader == NULL)
 8009cd0:	b1c2      	cbz	r2, 8009d04 <VerifyFwSignature+0x3c>
  {
    return SFU_ERROR;
  }
  if ((SE_FwType != SE_FW_IMAGE_PARTIAL) && (SE_FwType != SE_FW_IMAGE_COMPLETE))
 8009cd2:	2b01      	cmp	r3, #1
 8009cd4:	d816      	bhi.n	8009d04 <VerifyFwSignature+0x3c>
      fw_size = 0U;
      fw_offset = 0U;
      break;
  }

  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009cd6:	4c0e      	ldr	r4, [pc, #56]	@ (8009d10 <VerifyFwSignature+0x48>)
      fw_offset = 0U;
 8009cd8:	bf1c      	itt	ne
 8009cda:	2600      	movne	r6, #0
      fw_size = pFwImageHeader->FwSize;
 8009cdc:	6895      	ldrne	r5, [r2, #8]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009cde:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
  pse_payload.PayloadSize[0] = fw_size;
  pse_payload.pPayload[1] = 0U;
  pse_payload.PayloadSize[1] = 0U;

  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 8009ce2:	9300      	str	r3, [sp, #0]
 8009ce4:	ab02      	add	r3, sp, #8
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009ce6:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
      fw_offset = pFwImageHeader->PartialFwOffset;
 8009cea:	bf08      	it	eq
 8009cec:	e9d2 6503 	ldrdeq	r6, r5, [r2, #12]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009cf0:	4434      	add	r4, r6
  pse_payload.PayloadSize[0] = fw_size;
 8009cf2:	9504      	str	r5, [sp, #16]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 8009cf4:	9402      	str	r4, [sp, #8]
  pse_payload.pPayload[1] = 0U;
 8009cf6:	2400      	movs	r4, #0
 8009cf8:	9403      	str	r4, [sp, #12]
  pse_payload.PayloadSize[1] = 0U;
 8009cfa:	9405      	str	r4, [sp, #20]
  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 8009cfc:	f7ff fed6 	bl	8009aac <VerifyFwSignatureScatter>
}
 8009d00:	b006      	add	sp, #24
 8009d02:	bd70      	pop	{r4, r5, r6, pc}
    return SFU_ERROR;
 8009d04:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 8009d08:	e7fa      	b.n	8009d00 <VerifyFwSignature+0x38>
 8009d0a:	bf00      	nop
 8009d0c:	0012e223 	.word	0x0012e223
 8009d10:	0800e33c 	.word	0x0800e33c

08009d14 <VerifySlot>:
  uint32_t length;
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check is already clean */
  pdata = pSlotBegin + SFU_IMG_IMAGE_OFFSET + uFwSize;
  length = uSlotSize - SFU_IMG_IMAGE_OFFSET - uFwSize;
 8009d14:	f5a1 6380 	sub.w	r3, r1, #1024	@ 0x400
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 8009d18:	2100      	movs	r1, #0
{
 8009d1a:	b410      	push	{r4}
  pdata = pSlotBegin + SFU_IMG_IMAGE_OFFSET + uFwSize;
 8009d1c:	f502 6480 	add.w	r4, r2, #1024	@ 0x400
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 8009d20:	1a9b      	subs	r3, r3, r2
 8009d22:	f04f 32ff 	mov.w	r2, #4294967295
 8009d26:	4420      	add	r0, r4

  return e_ret_status;
}
 8009d28:	f85d 4b04 	ldr.w	r4, [sp], #4
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 8009d2c:	f000 bdc7 	b.w	800a8be <SFU_LL_FLASH_Compare>

08009d30 <CleanUpSlot>:
  * @param  uSlotSize Size of a slot.
  * @param  uOffset Offset in the slot to start cleanup, until end of the slot.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus CleanUpSlot(uint8_t *pSlotBegin, uint32_t uSlotSize, uint32_t uOffset)
{
 8009d30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009d32:	4606      	mov	r6, r0
 8009d34:	460f      	mov	r7, r1
 8009d36:	4615      	mov	r5, r2
 8009d38:	b093      	sub	sp, #76	@ 0x4c
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 8009d3a:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
  SFU_LL_FLASH_write_t pattern;
  SFU_LL_FLASH_write_t value;
  SFU_FLASH_StatusTypeDef flash_if_info;

  /* Clean-up pattern initialization */
  (void) memset((void *)&pattern, 0x00, sizeof(SFU_LL_FLASH_write_t));
 8009d3e:	2220      	movs	r2, #32

  /* Cleaning operation */
  slot_begin = (uint32_t) pSlotBegin;
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 8009d40:	4435      	add	r5, r6
 8009d42:	443e      	add	r6, r7
  {
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));

    if (e_ret_status == SFU_SUCCESS)
 8009d44:	4f13      	ldr	r7, [pc, #76]	@ (8009d94 <CleanUpSlot+0x64>)
  (void) memset((void *)&pattern, 0x00, sizeof(SFU_LL_FLASH_write_t));
 8009d46:	2100      	movs	r1, #0
 8009d48:	a802      	add	r0, sp, #8
 8009d4a:	f003 fd1d 	bl	800d788 <memset>
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 8009d4e:	42ae      	cmp	r6, r5
 8009d50:	d802      	bhi.n	8009d58 <CleanUpSlot+0x28>
    {
      (void) SFU_LL_SECU_IWDG_Refresh();
    }
  }
  return e_ret_status;
}
 8009d52:	4620      	mov	r0, r4
 8009d54:	b013      	add	sp, #76	@ 0x4c
 8009d56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));
 8009d58:	2220      	movs	r2, #32
 8009d5a:	4629      	mov	r1, r5
 8009d5c:	a80a      	add	r0, sp, #40	@ 0x28
 8009d5e:	f000 fda7 	bl	800a8b0 <SFU_LL_FLASH_Read>
    if (e_ret_status == SFU_SUCCESS)
 8009d62:	42b8      	cmp	r0, r7
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));
 8009d64:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 8009d66:	d105      	bne.n	8009d74 <CleanUpSlot+0x44>
      if (memcmp((void *) &value, (void *) &pattern, sizeof(SFU_LL_FLASH_write_t)) != 0)
 8009d68:	2220      	movs	r2, #32
 8009d6a:	a902      	add	r1, sp, #8
 8009d6c:	a80a      	add	r0, sp, #40	@ 0x28
 8009d6e:	f003 fcfb 	bl	800d768 <memcmp>
 8009d72:	b138      	cbz	r0, 8009d84 <CleanUpSlot+0x54>
      e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *) pdata, (uint8_t *) &pattern,
 8009d74:	2320      	movs	r3, #32
 8009d76:	aa02      	add	r2, sp, #8
 8009d78:	4629      	mov	r1, r5
 8009d7a:	f10d 0007 	add.w	r0, sp, #7
 8009d7e:	f000 fd90 	bl	800a8a2 <SFU_LL_FLASH_Write>
 8009d82:	4604      	mov	r4, r0
    if ((pdata % 0x1000U) == 0U)
 8009d84:	f3c5 030b 	ubfx	r3, r5, #0, #12
 8009d88:	b90b      	cbnz	r3, 8009d8e <CleanUpSlot+0x5e>
      (void) SFU_LL_SECU_IWDG_Refresh();
 8009d8a:	f001 f847 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 8009d8e:	3520      	adds	r5, #32
 8009d90:	e7dd      	b.n	8009d4e <CleanUpSlot+0x1e>
 8009d92:	bf00      	nop
 8009d94:	00122f11 	.word	0x00122f11

08009d98 <SFU_IMG_InitImageHandling>:
  *        Must be called first (and once) before calling the other Image handling services.
  * @param  None.
  * @retval SFU_IMG_InitStatusTypeDef SFU_IMG_INIT_OK if successful, an error code otherwise.
  */
SFU_IMG_InitStatusTypeDef SFU_IMG_InitImageHandling(void)
{
 8009d98:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
#if defined(__GNUC__)
    __IO uint32_t start_add;
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009d9a:	4c1c      	ldr	r4, [pc, #112]	@ (8009e0c <SFU_IMG_InitImageHandling+0x74>)
  (void) memset((uint8_t *) &fw_image_header_validated, 0xFE, sizeof(fw_image_header_validated));
 8009d9c:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 8009da0:	21fe      	movs	r1, #254	@ 0xfe
 8009da2:	481b      	ldr	r0, [pc, #108]	@ (8009e10 <SFU_IMG_InitImageHandling+0x78>)
 8009da4:	f003 fcf0 	bl	800d788 <memset>
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009da8:	9401      	str	r4, [sp, #4]
    if (start_add != 0U)
 8009daa:	9801      	ldr	r0, [sp, #4]
 8009dac:	b140      	cbz	r0, 8009dc0 <SFU_IMG_InitImageHandling+0x28>
#else
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
#endif /* (__GNUC__) */
    {
      if (!IS_ALIGNED(SlotStartAdd[SLOT_ACTIVE_1 + i]))
 8009dae:	f3c4 0010 	ubfx	r0, r4, #0, #17
 8009db2:	b128      	cbz	r0, 8009dc0 <SFU_IMG_InitImageHandling+0x28>
      {
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d (%x) is not properly aligned\r\n",
 8009db4:	4622      	mov	r2, r4
 8009db6:	2101      	movs	r1, #1
 8009db8:	4816      	ldr	r0, [pc, #88]	@ (8009e14 <SFU_IMG_InitImageHandling+0x7c>)
 8009dba:	f003 fad9 	bl	800d370 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009dbe:	2003      	movs	r0, #3
   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
#if defined(__GNUC__)
    __IO uint32_t start_add;
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009dc0:	9402      	str	r4, [sp, #8]
    if (start_add != 0U)
 8009dc2:	9b02      	ldr	r3, [sp, #8]
 8009dc4:	b153      	cbz	r3, 8009ddc <SFU_IMG_InitImageHandling+0x44>
#else
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
#endif /* (__GNUC__) */
    {
      if (((SlotStartAdd[SLOT_ACTIVE_1 + i] - FLASH_BASE) / FLASH_SECTOR_SIZE) <= SFU_PROTECT_WRP_PAGE_END_1)
 8009dc6:	4b14      	ldr	r3, [pc, #80]	@ (8009e18 <SFU_IMG_InitImageHandling+0x80>)
 8009dc8:	4a14      	ldr	r2, [pc, #80]	@ (8009e1c <SFU_IMG_InitImageHandling+0x84>)
 8009dca:	0c5b      	lsrs	r3, r3, #17
 8009dcc:	ebb3 4f52 	cmp.w	r3, r2, lsr #17
 8009dd0:	d304      	bcc.n	8009ddc <SFU_IMG_InitImageHandling+0x44>
      {
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
 8009dd2:	2101      	movs	r1, #1
 8009dd4:	4812      	ldr	r0, [pc, #72]	@ (8009e20 <SFU_IMG_InitImageHandling+0x88>)
 8009dd6:	f003 facb 	bl	800d370 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009dda:	2003      	movs	r0, #3
 8009ddc:	2209      	movs	r2, #9

  /*
   * Sanity check: let's make sure headers are under the MPU protection
   */
  /* Calculate size of image header MPU region */
  mpu_max_size = 2U;
 8009dde:	2302      	movs	r3, #2
  for (i = 0U; i < SFU_PROTECT_MPU_HEADER_SIZE; i++)
 8009de0:	3a01      	subs	r2, #1
  {
    mpu_max_size = mpu_max_size * 2U;
 8009de2:	ea4f 0343 	mov.w	r3, r3, lsl #1
  for (i = 0U; i < SFU_PROTECT_MPU_HEADER_SIZE; i++)
 8009de6:	d1fb      	bne.n	8009de0 <SFU_IMG_InitImageHandling+0x48>

  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
#if defined(__GNUC__)
    __IO uint32_t start_add;
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 8009de8:	9403      	str	r4, [sp, #12]
    if (start_add != 0U)
 8009dea:	9a03      	ldr	r2, [sp, #12]
 8009dec:	b162      	cbz	r2, 8009e08 <SFU_IMG_InitImageHandling+0x70>
#else
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
#endif /* (__GNUC__) */
    {
      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_MPU_HEADER_START)
 8009dee:	4a0d      	ldr	r2, [pc, #52]	@ (8009e24 <SFU_IMG_InitImageHandling+0x8c>)
            && ((SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SE_FW_HEADER_TOT_LEN) <=
                (SFU_PROTECT_MPU_HEADER_START + mpu_size))))
 8009df0:	f023 0307 	bic.w	r3, r3, #7
            && ((SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SE_FW_HEADER_TOT_LEN) <=
 8009df4:	f502 71a0 	add.w	r1, r2, #320	@ 0x140
                (SFU_PROTECT_MPU_HEADER_START + mpu_size))))
 8009df8:	4413      	add	r3, r2
      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_MPU_HEADER_START)
 8009dfa:	4299      	cmp	r1, r3
 8009dfc:	d904      	bls.n	8009e08 <SFU_IMG_InitImageHandling+0x70>
      {
        TRACE("\r\n= [FWIMG] Header of SLOT_ACTIVE_%d is not under the MPU protection\r\n", i + 1U);
 8009dfe:	2101      	movs	r1, #1
 8009e00:	4809      	ldr	r0, [pc, #36]	@ (8009e28 <SFU_IMG_InitImageHandling+0x90>)
 8009e02:	f003 fab5 	bl	800d370 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 8009e06:	2003      	movs	r0, #3




  return e_ret_status;
}
 8009e08:	b004      	add	sp, #16
 8009e0a:	bd10      	pop	{r4, pc}
 8009e0c:	08020000 	.word	0x08020000
 8009e10:	200015e0 	.word	0x200015e0
 8009e14:	0800ec2d 	.word	0x0800ec2d
 8009e18:	0001ffff 	.word	0x0001ffff
 8009e1c:	00020000 	.word	0x00020000
 8009e20:	0800ec67 	.word	0x0800ec67
 8009e24:	08020000 	.word	0x08020000
 8009e28:	0800ecae 	.word	0x0800ecae

08009e2c <SFU_IMG_InvalidateCurrentFirmware>:
  *       running the procedure).
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_SUCCESS if successful,SFU_ERROR error otherwise.
  */
SFU_ErrorStatus SFU_IMG_InvalidateCurrentFirmware(uint32_t SlotNumber)
{
 8009e2c:	b510      	push	{r4, lr}
 8009e2e:	4604      	mov	r4, r0
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Reload Watchdog */
  (void) SFU_LL_SECU_IWDG_Refresh();
 8009e30:	f000 fff4 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>

  /* erase active slot except Header (under SECoreBin protection) for the anti-rollback check during next Fw update */
  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET);
 8009e34:	4b06      	ldr	r3, [pc, #24]	@ (8009e50 <SFU_IMG_InvalidateCurrentFirmware+0x24>)
 8009e36:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8009e3a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8009e3e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8009e42:	6a19      	ldr	r1, [r3, #32]
 8009e44:	3101      	adds	r1, #1

  return (e_ret_status);
}
 8009e46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET);
 8009e4a:	1a09      	subs	r1, r1, r0
 8009e4c:	f7ff bf70 	b.w	8009d30 <CleanUpSlot>
 8009e50:	0800e33c 	.word	0x0800e33c

08009e54 <SFU_IMG_VerifyActiveImg>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
  */
SFU_ErrorStatus SFU_IMG_VerifyActiveImg(uint32_t SlotNumber)
{
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  SE_StatusTypeDef e_se_status = SE_KO;
 8009e54:	4b05      	ldr	r3, [pc, #20]	@ (8009e6c <SFU_IMG_VerifyActiveImg+0x18>)
{
 8009e56:	b507      	push	{r0, r1, r2, lr}
 8009e58:	4601      	mov	r1, r0
  SE_StatusTypeDef e_se_status = SE_KO;
 8009e5a:	9301      	str	r3, [sp, #4]

  /*
   * fw_image_header_validated MUST have been populated with valid metadata first,
   */
  e_ret_status = VerifyFwSignature(&e_se_status, SlotNumber, &fw_image_header_validated, SE_FW_IMAGE_COMPLETE);
 8009e5c:	4a04      	ldr	r2, [pc, #16]	@ (8009e70 <SFU_IMG_VerifyActiveImg+0x1c>)
 8009e5e:	2300      	movs	r3, #0
 8009e60:	a801      	add	r0, sp, #4
 8009e62:	f7ff ff31 	bl	8009cc8 <VerifyFwSignature>
    TRACE("\r\n=         SFU_IMG_VerifyActiveImg failure with se_status=%d!", e_se_status);
  }
#endif /* SFU_VERBOSE_DEBUG_MODE */

  return (e_ret_status);
}
 8009e66:	b003      	add	sp, #12
 8009e68:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e6c:	0013023d 	.word	0x0013023d
 8009e70:	200015e0 	.word	0x200015e0

08009e74 <SFU_IMG_VerifyActiveSlot>:
  * @note SFU_IMG_VerifyActiveImgMetadata() must have been called first to populate fw_image_header_validated.
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
  */
SFU_ErrorStatus SFU_IMG_VerifyActiveSlot(uint32_t SlotNumber)
{
 8009e74:	4602      	mov	r2, r0
  /*
   * fw_image_header_validated MUST have been populated with valid metadata first,
   */
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), fw_image_header_validated.FwSize));
 8009e76:	4b06      	ldr	r3, [pc, #24]	@ (8009e90 <SFU_IMG_VerifyActiveSlot+0x1c>)
 8009e78:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8009e7c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8009e80:	6a19      	ldr	r1, [r3, #32]
 8009e82:	4b04      	ldr	r3, [pc, #16]	@ (8009e94 <SFU_IMG_VerifyActiveSlot+0x20>)
 8009e84:	3101      	adds	r1, #1
 8009e86:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8009e88:	1a09      	subs	r1, r1, r0
 8009e8a:	f7ff bf43 	b.w	8009d14 <VerifySlot>
 8009e8e:	bf00      	nop
 8009e90:	0800e33c 	.word	0x0800e33c
 8009e94:	200015c0 	.word	0x200015c0

08009e98 <SFU_IMG_VerifyEmptyActiveSlot>:
  * @brief Verifies if no malicious code in active slot.
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
  */
SFU_ErrorStatus SFU_IMG_VerifyEmptyActiveSlot(uint32_t SlotNumber)
{
 8009e98:	4602      	mov	r2, r0
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), 0U));
 8009e9a:	4b05      	ldr	r3, [pc, #20]	@ (8009eb0 <SFU_IMG_VerifyEmptyActiveSlot+0x18>)
 8009e9c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8009ea0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8009ea4:	2200      	movs	r2, #0
 8009ea6:	6a19      	ldr	r1, [r3, #32]
 8009ea8:	3101      	adds	r1, #1
 8009eaa:	1a09      	subs	r1, r1, r0
 8009eac:	f7ff bf32 	b.w	8009d14 <VerifySlot>
 8009eb0:	0800e33c 	.word	0x0800e33c

08009eb4 <SFU_IMG_ControlActiveImgTag>:
  * @note   This control will be done twice for security reasons (first control done in VerifyFwSignatureScatter)
  * @param  SlotNumber index of the slot in the list
  * @retval SFU_SUCCESS if successful,SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_IMG_ControlActiveImgTag(uint32_t SlotNumber)
{
 8009eb4:	b508      	push	{r3, lr}
  /*
   * fw_image_header_validated MUST have been populated with valid metadata first,
   */
  if (MemoryCompare(fw_tag_validated[SlotNumber - SLOT_ACTIVE_1], fw_image_header_validated.FwTag,
 8009eb6:	3801      	subs	r0, #1
 8009eb8:	4b0a      	ldr	r3, [pc, #40]	@ (8009ee4 <SFU_IMG_ControlActiveImgTag+0x30>)
 8009eba:	2220      	movs	r2, #32
 8009ebc:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 8009ec0:	eb03 1040 	add.w	r0, r3, r0, lsl #5
 8009ec4:	f7ff fdc6 	bl	8009a54 <MemoryCompare>
 8009ec8:	4b07      	ldr	r3, [pc, #28]	@ (8009ee8 <SFU_IMG_ControlActiveImgTag+0x34>)
 8009eca:	4298      	cmp	r0, r3
  {
    return SFU_ERROR;
  }
  else
  {
    FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009ecc:	bf09      	itett	eq
 8009ece:	4a07      	ldreq	r2, [pc, #28]	@ (8009eec <SFU_IMG_ControlActiveImgTag+0x38>)
    return SFU_ERROR;
 8009ed0:	f641 70e1 	movwne	r0, #8161	@ 0x1fe1
    FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 8009ed4:	6813      	ldreq	r3, [r2, #0]
 8009ed6:	f483 432a 	eoreq.w	r3, r3, #43520	@ 0xaa00
 8009eda:	bf04      	itt	eq
 8009edc:	f083 03b5 	eoreq.w	r3, r3, #181	@ 0xb5
 8009ee0:	6013      	streq	r3, [r2, #0]
    return SFU_SUCCESS;
  }

}
 8009ee2:	bd08      	pop	{r3, pc}
 8009ee4:	200015c0 	.word	0x200015c0
 8009ee8:	00122f11 	.word	0x00122f11
 8009eec:	20001104 	.word	0x20001104

08009ef0 <SFU_IMG_LaunchActiveImg>:
SFU_ErrorStatus SFU_IMG_LaunchActiveImg(uint32_t SlotNumber)
{
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;

  /* Verify if authentication/integrity/lock SE service performed */
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVICE);
 8009ef0:	4b0b      	ldr	r3, [pc, #44]	@ (8009f20 <SFU_IMG_LaunchActiveImg+0x30>)
 8009ef2:	681a      	ldr	r2, [r3, #0]
 8009ef4:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 8009ef8:	429a      	cmp	r2, r3
{
 8009efa:	b510      	push	{r4, lr}
 8009efc:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVICE);
 8009efe:	d001      	beq.n	8009f04 <SFU_IMG_LaunchActiveImg+0x14>
 8009f00:	f7ff fd7c 	bl	80099fc <SFU_EXCPT_Security_Error>
   * interrupt is triggered during the SVC routine, the Systick interrupt will be served at the end of
   * the SVC routine.
   * This is a problem when the secure user memory is activated and the SBSFU code is no more accessible.
   * Systick will be re-initialized by HAL_Init() during execution of main() from UserApp.
   */
  SFU_MPU_SysCall((uint32_t)SB_SYSCALL_SYSTICK_SUSPEND);
 8009f04:	2007      	movs	r0, #7
 8009f06:	f000 fb51 	bl	800a5ac <SFU_MPU_SysCall>

  /* this function does not return */
  /* first image identified as master image */
  SFU_MPU_SysCall((uint32_t)SB_SYSCALL_LAUNCH_APP, SlotStartAdd[SlotNumber] + SFU_IMG_IMAGE_OFFSET);
 8009f0a:	4b06      	ldr	r3, [pc, #24]	@ (8009f24 <SFU_IMG_LaunchActiveImg+0x34>)
 8009f0c:	2001      	movs	r0, #1
 8009f0e:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 8009f12:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8009f16:	f000 fb49 	bl	800a5ac <SFU_MPU_SysCall>

  /* The point below should NOT be reached */
  return (e_ret_status);
}
 8009f1a:	4803      	ldr	r0, [pc, #12]	@ (8009f28 <SFU_IMG_LaunchActiveImg+0x38>)
 8009f1c:	bd10      	pop	{r4, pc}
 8009f1e:	bf00      	nop
 8009f20:	20001104 	.word	0x20001104
 8009f24:	0800e33c 	.word	0x0800e33c
 8009f28:	00122f11 	.word	0x00122f11

08009f2c <SFU_IMG_Validation>:
#else

  /* Nothing to do header already written */
  return SFU_SUCCESS;
#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALONE_LOADER) */
}
 8009f2c:	4800      	ldr	r0, [pc, #0]	@ (8009f30 <SFU_IMG_Validation+0x4>)
 8009f2e:	4770      	bx	lr
 8009f30:	00122f11 	.word	0x00122f11

08009f34 <SFU_IMG_GetFwImageSlot>:
  */
uint32_t SFU_IMG_GetFwImageSlot(SE_FwRawHeaderTypeDef *pFwImageHeader)
{
  uint32_t active_slot;

  if (memcmp(pFwImageHeader->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8009f34:	2204      	movs	r2, #4
 8009f36:	4904      	ldr	r1, [pc, #16]	@ (8009f48 <SFU_IMG_GetFwImageSlot+0x14>)
{
 8009f38:	b508      	push	{r3, lr}
  if (memcmp(pFwImageHeader->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 8009f3a:	f003 fc15 	bl	800d768 <memcmp>
  {
    active_slot = SLOT_INACTIVE;
  }

  return active_slot;
}
 8009f3e:	fab0 f080 	clz	r0, r0
 8009f42:	0940      	lsrs	r0, r0, #5
 8009f44:	bd08      	pop	{r3, pc}
 8009f46:	bf00      	nop
 8009f48:	0800ecf5 	.word	0x0800ecf5

08009f4c <VerifyHeaderSignature>:
{
 8009f4c:	b513      	push	{r0, r1, r4, lr}
 8009f4e:	4604      	mov	r4, r0
  if (SFU_IMG_GetFwImageSlot(pFwImageHeader) != SLOT_INACTIVE)
 8009f50:	f7ff fff0 	bl	8009f34 <SFU_IMG_GetFwImageSlot>
 8009f54:	b918      	cbnz	r0, 8009f5e <VerifyHeaderSignature+0x12>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 8009f56:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
}
 8009f5a:	b002      	add	sp, #8
 8009f5c:	bd10      	pop	{r4, pc}
 8009f5e:	f104 0263 	add.w	r2, r4, #99	@ 0x63
 8009f62:	f104 017f 	add.w	r1, r4, #127	@ 0x7f
  uint8_t result = 0x00U;
 8009f66:	2300      	movs	r3, #0
      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
 8009f68:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
 8009f6c:	428a      	cmp	r2, r1
      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
 8009f6e:	ea43 0300 	orr.w	r3, r3, r0
    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
 8009f72:	d1f9      	bne.n	8009f68 <VerifyHeaderSignature+0x1c>
    if (result == 0x00U)
 8009f74:	2b00      	cmp	r3, #0
 8009f76:	d1ee      	bne.n	8009f56 <VerifyHeaderSignature+0xa>
      if (SE_VerifyHeaderSignature(&se_status, pFwImageHeader) == SE_SUCCESS)
 8009f78:	4621      	mov	r1, r4
 8009f7a:	a801      	add	r0, sp, #4
 8009f7c:	f7fe fb36 	bl	80085ec <SE_VerifyHeaderSignature>
 8009f80:	4b05      	ldr	r3, [pc, #20]	@ (8009f98 <VerifyHeaderSignature+0x4c>)
 8009f82:	4298      	cmp	r0, r3
 8009f84:	d1e7      	bne.n	8009f56 <VerifyHeaderSignature+0xa>
        FLOW_STEP(uFlowCryptoValue, FLOW_STEP_AUTHENTICATE);
 8009f86:	4a05      	ldr	r2, [pc, #20]	@ (8009f9c <VerifyHeaderSignature+0x50>)
 8009f88:	4805      	ldr	r0, [pc, #20]	@ (8009fa0 <VerifyHeaderSignature+0x54>)
 8009f8a:	6813      	ldr	r3, [r2, #0]
 8009f8c:	f483 43f3 	eor.w	r3, r3, #31104	@ 0x7980
 8009f90:	f083 0319 	eor.w	r3, r3, #25
 8009f94:	6013      	str	r3, [r2, #0]
  return e_ret_status;
 8009f96:	e7e0      	b.n	8009f5a <VerifyHeaderSignature+0xe>
 8009f98:	0012310f 	.word	0x0012310f
 8009f9c:	20001104 	.word	0x20001104
 8009fa0:	00122f11 	.word	0x00122f11

08009fa4 <CheckAndGetFWHeader>:
  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
 8009fa4:	4b09      	ldr	r3, [pc, #36]	@ (8009fcc <CheckAndGetFWHeader+0x28>)
 8009fa6:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 8009faa:	eb03 0080 	add.w	r0, r3, r0, lsl #2
{
 8009fae:	b510      	push	{r4, lr}
 8009fb0:	460c      	mov	r4, r1
  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
 8009fb2:	6c01      	ldr	r1, [r0, #64]	@ 0x40
 8009fb4:	4620      	mov	r0, r4
 8009fb6:	f000 fc7b 	bl	800a8b0 <SFU_LL_FLASH_Read>
  if (e_ret_status == SFU_SUCCESS)
 8009fba:	4b05      	ldr	r3, [pc, #20]	@ (8009fd0 <CheckAndGetFWHeader+0x2c>)
 8009fbc:	4298      	cmp	r0, r3
 8009fbe:	d104      	bne.n	8009fca <CheckAndGetFWHeader+0x26>
    e_ret_status = VerifyHeaderSignature(pFwImageHeader);
 8009fc0:	4620      	mov	r0, r4
}
 8009fc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e_ret_status = VerifyHeaderSignature(pFwImageHeader);
 8009fc6:	f7ff bfc1 	b.w	8009f4c <VerifyHeaderSignature>
}
 8009fca:	bd10      	pop	{r4, pc}
 8009fcc:	0800e33c 	.word	0x0800e33c
 8009fd0:	00122f11 	.word	0x00122f11

08009fd4 <SFU_IMG_VerifyActiveImgMetadata>:
  return (CheckAndGetFWHeader(SlotNumber, &fw_image_header_validated));
 8009fd4:	4901      	ldr	r1, [pc, #4]	@ (8009fdc <SFU_IMG_VerifyActiveImgMetadata+0x8>)
 8009fd6:	f7ff bfe5 	b.w	8009fa4 <CheckAndGetFWHeader>
 8009fda:	bf00      	nop
 8009fdc:	200015e0 	.word	0x200015e0

08009fe0 <SFU_IMG_GetActiveFwVersion>:
{
 8009fe0:	b500      	push	{lr}
 8009fe2:	b0d1      	sub	sp, #324	@ 0x144
  e_ret_status = CheckAndGetFWHeader(SlotNumber, &fw_image_header);
 8009fe4:	4669      	mov	r1, sp
 8009fe6:	f7ff ffdd 	bl	8009fa4 <CheckAndGetFWHeader>
  if (e_ret_status == SFU_SUCCESS)
 8009fea:	4b04      	ldr	r3, [pc, #16]	@ (8009ffc <SFU_IMG_GetActiveFwVersion+0x1c>)
 8009fec:	4298      	cmp	r0, r3
    version = fw_image_header.FwVersion;
 8009fee:	bf0c      	ite	eq
 8009ff0:	f8bd 0006 	ldrheq.w	r0, [sp, #6]
  uint16_t version = 0;
 8009ff4:	2000      	movne	r0, #0
}
 8009ff6:	b051      	add	sp, #324	@ 0x144
 8009ff8:	f85d fb04 	ldr.w	pc, [sp], #4
 8009ffc:	00122f11 	.word	0x00122f11

0800a000 <SFU_IMG_DetectFW>:
{
 800a000:	b570      	push	{r4, r5, r6, lr}
  pbuffer = (uint8_t *) SlotHeaderAdd[SlotNumber];
 800a002:	4e11      	ldr	r6, [pc, #68]	@ (800a048 <SFU_IMG_DetectFW+0x48>)
{
 800a004:	b0d0      	sub	sp, #320	@ 0x140
 800a006:	4605      	mov	r5, r0
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800a008:	f44f 72a0 	mov.w	r2, #320	@ 0x140
  pbuffer = (uint8_t *) SlotHeaderAdd[SlotNumber];
 800a00c:	eb06 0380 	add.w	r3, r6, r0, lsl #2
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800a010:	4668      	mov	r0, sp
 800a012:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 800a014:	f000 fc4c 	bl	800a8b0 <SFU_LL_FLASH_Read>
 800a018:	4b0c      	ldr	r3, [pc, #48]	@ (800a04c <SFU_IMG_DetectFW+0x4c>)
 800a01a:	4604      	mov	r4, r0
 800a01c:	4298      	cmp	r0, r3
 800a01e:	d004      	beq.n	800a02a <SFU_IMG_DetectFW+0x2a>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a020:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
}
 800a024:	4620      	mov	r0, r4
 800a026:	b050      	add	sp, #320	@ 0x140
 800a028:	bd70      	pop	{r4, r5, r6, pc}
    if (SFU_IMG_GetFwImageSlot(p_header) != SLOT_INACTIVE)
 800a02a:	4668      	mov	r0, sp
 800a02c:	f7ff ff82 	bl	8009f34 <SFU_IMG_GetFwImageSlot>
 800a030:	2800      	cmp	r0, #0
 800a032:	d0f5      	beq.n	800a020 <SFU_IMG_DetectFW+0x20>
      if (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SFU_IMG_IMAGE_OFFSET + 0x20U, 0U) != SFU_SUCCESS)
 800a034:	2200      	movs	r2, #0
 800a036:	f44f 6184 	mov.w	r1, #1056	@ 0x420
 800a03a:	f856 0025 	ldr.w	r0, [r6, r5, lsl #2]
 800a03e:	f7ff fe69 	bl	8009d14 <VerifySlot>
 800a042:	42a0      	cmp	r0, r4
 800a044:	d1ee      	bne.n	800a024 <SFU_IMG_DetectFW+0x24>
 800a046:	e7eb      	b.n	800a020 <SFU_IMG_DetectFW+0x20>
 800a048:	0800e33c 	.word	0x0800e33c
 800a04c:	00122f11 	.word	0x00122f11

0800a050 <SFU_IMG_CheckFwVersion>:
  * @param  CandidateVersion Version of candidate image
  * @retval SFU_SUCCESS if candidate image version is allowed, SFU_ErrorStatus error otherwise.
  */
SFU_ErrorStatus SFU_IMG_CheckFwVersion(uint32_t ActiveSlot, uint16_t CurrentVersion, uint16_t CandidateVersion)
{
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a050:	4b05      	ldr	r3, [pc, #20]	@ (800a068 <SFU_IMG_CheckFwVersion+0x18>)
 800a052:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  UNUSED(ActiveSlot);

  /* If the header of the active firmware is not valid, the CurrentVersion is 0 */
  if (CurrentVersion == 0U)
 800a056:	b919      	cbnz	r1, 800a060 <SFU_IMG_CheckFwVersion+0x10>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a058:	2a01      	cmp	r2, #1
 800a05a:	bf08      	it	eq
 800a05c:	4618      	moveq	r0, r3
 800a05e:	4770      	bx	lr
 800a060:	4291      	cmp	r1, r2
 800a062:	bf98      	it	ls
 800a064:	4618      	movls	r0, r3
#endif /* SFU_VERBOSE_DEBUG_MODE */

  }

  return e_ret_status;
}
 800a066:	4770      	bx	lr
 800a068:	00122f11 	.word	0x00122f11

0800a06c <SFU_LOADER_VerifyFwHeader>:
#elif defined ( __GNUC__ )
__attribute__((optimize("O0")))
#endif /* __ICCARM__ */

static SFU_ErrorStatus SFU_LOADER_VerifyFwHeader(uint8_t *pBuffer)
{
 800a06c:	b580      	push	{r7, lr}
 800a06e:	b08c      	sub	sp, #48	@ 0x30
 800a070:	af00      	add	r7, sp, #0
 800a072:	6078      	str	r0, [r7, #4]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a074:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 800a078:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint16_t                      cur_ver;
  uint16_t                      verif_ver;
  uint32_t                      active_slot;

  /*Parse the received buffer*/
  p_x_fw_raw_header = (SE_FwRawHeaderTypeDef *)(uint32_t)pBuffer;
 800a07a:	687b      	ldr	r3, [r7, #4]
 800a07c:	62bb      	str	r3, [r7, #40]	@ 0x28

  /*Check if the received header packet is authentic*/
  if (SE_VerifyHeaderSignature(&e_se_status, p_x_fw_raw_header) != SE_ERROR)
 800a07e:	f107 031c 	add.w	r3, r7, #28
 800a082:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800a084:	4618      	mov	r0, r3
 800a086:	f7fe fab1 	bl	80085ec <SE_VerifyHeaderSignature>
 800a08a:	4603      	mov	r3, r0
 800a08c:	4a4c      	ldr	r2, [pc, #304]	@ (800a1c0 <SFU_LOADER_VerifyFwHeader+0x154>)
 800a08e:	4293      	cmp	r3, r2
 800a090:	f000 808e 	beq.w	800a1b0 <SFU_LOADER_VerifyFwHeader+0x144>
  {
    active_slot = SFU_IMG_GetFwImageSlot(p_x_fw_raw_header);
 800a094:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800a096:	f7ff ff4d 	bl	8009f34 <SFU_IMG_GetFwImageSlot>
 800a09a:	6278      	str	r0, [r7, #36]	@ 0x24
     * 1 slot per image configuration. Identify the download area.
     *   It will be based on SFU magic :
     *   - dwl slot is the active_slot if configured.
     *   - else : SLOT_ACTIVE_1
     */
    m_uDwlSlot = active_slot;
 800a09c:	4a49      	ldr	r2, [pc, #292]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a09e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a0a0:	6013      	str	r3, [r2, #0]
    if (SLOT_SIZE(m_uDwlSlot) == 1U)
 800a0a2:	4b48      	ldr	r3, [pc, #288]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a0a4:	681b      	ldr	r3, [r3, #0]
 800a0a6:	4a48      	ldr	r2, [pc, #288]	@ (800a1c8 <SFU_LOADER_VerifyFwHeader+0x15c>)
 800a0a8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800a0ac:	4b45      	ldr	r3, [pc, #276]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a0ae:	681b      	ldr	r3, [r3, #0]
 800a0b0:	4946      	ldr	r1, [pc, #280]	@ (800a1cc <SFU_LOADER_VerifyFwHeader+0x160>)
 800a0b2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800a0b6:	429a      	cmp	r2, r3
 800a0b8:	d102      	bne.n	800a0c0 <SFU_LOADER_VerifyFwHeader+0x54>
    {
      m_uDwlSlot = SLOT_ACTIVE_1;
 800a0ba:	4b42      	ldr	r3, [pc, #264]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a0bc:	2201      	movs	r2, #1
 800a0be:	601a      	str	r2, [r3, #0]
    }
    SFU_IMG_GetDownloadAreaInfo(m_uDwlSlot, &fw_image_flash_data);
 800a0c0:	4b40      	ldr	r3, [pc, #256]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a0c2:	681b      	ldr	r3, [r3, #0]
 800a0c4:	f107 0208 	add.w	r2, r7, #8
 800a0c8:	4611      	mov	r1, r2
 800a0ca:	4618      	mov	r0, r3
 800a0cc:	f000 fa8e 	bl	800a5ec <SFU_IMG_GetDownloadAreaInfo>

    /* Assign the download flash address to be used during the YMODEM process */
    m_uDwlAreaStart = fw_image_flash_data.DownloadAddr;
 800a0d0:	68fb      	ldr	r3, [r7, #12]
 800a0d2:	4a3f      	ldr	r2, [pc, #252]	@ (800a1d0 <SFU_LOADER_VerifyFwHeader+0x164>)
 800a0d4:	6013      	str	r3, [r2, #0]
    m_uDwlAreaSize = fw_image_flash_data.MaxSizeInBytes;
 800a0d6:	68bb      	ldr	r3, [r7, #8]
 800a0d8:	4a3e      	ldr	r2, [pc, #248]	@ (800a1d4 <SFU_LOADER_VerifyFwHeader+0x168>)
 800a0da:	6013      	str	r3, [r2, #0]
    m_uActiveHeaderStart = fw_image_flash_data.ActiveHeaderAddr;
 800a0dc:	69bb      	ldr	r3, [r7, #24]
 800a0de:	4a3e      	ldr	r2, [pc, #248]	@ (800a1d8 <SFU_LOADER_VerifyFwHeader+0x16c>)
 800a0e0:	6013      	str	r3, [r2, #0]

    /*
     * Check if the version is allowed
     * ==> SFU_IMG_GetActiveFwVersion() returns 0 if the header of active firmware is not valid
     */
    cur_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800a0e2:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a0e4:	f7ff ff7c 	bl	8009fe0 <SFU_IMG_GetActiveFwVersion>
 800a0e8:	4603      	mov	r3, r0
 800a0ea:	847b      	strh	r3, [r7, #34]	@ 0x22
    if (SFU_IMG_CheckFwVersion(active_slot, cur_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
 800a0ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a0ee:	88da      	ldrh	r2, [r3, #6]
 800a0f0:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 800a0f2:	4619      	mov	r1, r3
 800a0f4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a0f6:	f7ff ffab 	bl	800a050 <SFU_IMG_CheckFwVersion>
 800a0fa:	4603      	mov	r3, r0
 800a0fc:	4a37      	ldr	r2, [pc, #220]	@ (800a1dc <SFU_LOADER_VerifyFwHeader+0x170>)
 800a0fe:	4293      	cmp	r3, r2
 800a100:	d117      	bne.n	800a132 <SFU_LOADER_VerifyFwHeader+0xc6>
    {
      /*
       * Check length : Let's make sure the Firmware image can be written in the destination slot.
       */
      if (p_x_fw_raw_header->FwSize > (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET))
 800a102:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a104:	689a      	ldr	r2, [r3, #8]
 800a106:	4b2f      	ldr	r3, [pc, #188]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a108:	681b      	ldr	r3, [r3, #0]
 800a10a:	492f      	ldr	r1, [pc, #188]	@ (800a1c8 <SFU_LOADER_VerifyFwHeader+0x15c>)
 800a10c:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800a110:	4b2c      	ldr	r3, [pc, #176]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a112:	681b      	ldr	r3, [r3, #0]
 800a114:	482d      	ldr	r0, [pc, #180]	@ (800a1cc <SFU_LOADER_VerifyFwHeader+0x160>)
 800a116:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800a11a:	1acb      	subs	r3, r1, r3
 800a11c:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
 800a120:	429a      	cmp	r2, r3
 800a122:	d903      	bls.n	800a12c <SFU_LOADER_VerifyFwHeader+0xc0>
      {
        /* The firmware cannot be written in dwl slot */
        m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800a124:	4b2e      	ldr	r3, [pc, #184]	@ (800a1e0 <SFU_LOADER_VerifyFwHeader+0x174>)
 800a126:	2203      	movs	r2, #3
 800a128:	701a      	strb	r2, [r3, #0]
 800a12a:	e00d      	b.n	800a148 <SFU_LOADER_VerifyFwHeader+0xdc>
      }
      else
      {
        /* Installation authorized */
        e_ret_status = SFU_SUCCESS;
 800a12c:	4b2b      	ldr	r3, [pc, #172]	@ (800a1dc <SFU_LOADER_VerifyFwHeader+0x170>)
 800a12e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800a130:	e00a      	b.n	800a148 <SFU_LOADER_VerifyFwHeader+0xdc>
    }
    else
    {
      /* The installation is forbidden */
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
            p_x_fw_raw_header->FwVersion, cur_ver, SFU_FW_VERSION_START_NUM);
 800a132:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a134:	88db      	ldrh	r3, [r3, #6]
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
 800a136:	4619      	mov	r1, r3
 800a138:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 800a13a:	2301      	movs	r3, #1
 800a13c:	4829      	ldr	r0, [pc, #164]	@ (800a1e4 <SFU_LOADER_VerifyFwHeader+0x178>)
 800a13e:	f003 f917 	bl	800d370 <iprintf>
      m_LoaderStatus = SFU_LOADER_ERR_FW_VERSION;
 800a142:	4b27      	ldr	r3, [pc, #156]	@ (800a1e0 <SFU_LOADER_VerifyFwHeader+0x174>)
 800a144:	2204      	movs	r2, #4
 800a146:	701a      	strb	r2, [r3, #0]
    /*
     * Control of version and length is done twice to avoid basic hardware attack
     * This more important for the 1 image configuration as the installation is done during the download procedure
     * For the 2 images configuration anti-rollback will be checked again during installation process
     */
    verif_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800a148:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a14a:	f7ff ff49 	bl	8009fe0 <SFU_IMG_GetActiveFwVersion>
 800a14e:	4603      	mov	r3, r0
 800a150:	843b      	strh	r3, [r7, #32]
    if (SFU_IMG_CheckFwVersion(active_slot, verif_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
 800a152:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a154:	88da      	ldrh	r2, [r3, #6]
 800a156:	8c3b      	ldrh	r3, [r7, #32]
 800a158:	4619      	mov	r1, r3
 800a15a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a15c:	f7ff ff78 	bl	800a050 <SFU_IMG_CheckFwVersion>
 800a160:	4603      	mov	r3, r0
 800a162:	4a1e      	ldr	r2, [pc, #120]	@ (800a1dc <SFU_LOADER_VerifyFwHeader+0x170>)
 800a164:	4293      	cmp	r3, r2
 800a166:	d117      	bne.n	800a198 <SFU_LOADER_VerifyFwHeader+0x12c>
    {
      /*
       * Check length : Let's make sure the Firmware image can be written in the destination slot.
       */
      if (p_x_fw_raw_header->FwSize > (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET))
 800a168:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a16a:	689a      	ldr	r2, [r3, #8]
 800a16c:	4b15      	ldr	r3, [pc, #84]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a16e:	681b      	ldr	r3, [r3, #0]
 800a170:	4915      	ldr	r1, [pc, #84]	@ (800a1c8 <SFU_LOADER_VerifyFwHeader+0x15c>)
 800a172:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800a176:	4b13      	ldr	r3, [pc, #76]	@ (800a1c4 <SFU_LOADER_VerifyFwHeader+0x158>)
 800a178:	681b      	ldr	r3, [r3, #0]
 800a17a:	4814      	ldr	r0, [pc, #80]	@ (800a1cc <SFU_LOADER_VerifyFwHeader+0x160>)
 800a17c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800a180:	1acb      	subs	r3, r1, r3
 800a182:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
 800a186:	429a      	cmp	r2, r3
 800a188:	d903      	bls.n	800a192 <SFU_LOADER_VerifyFwHeader+0x126>
      {
        /* The firmware cannot be written in dwl slot */
        m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800a18a:	4b15      	ldr	r3, [pc, #84]	@ (800a1e0 <SFU_LOADER_VerifyFwHeader+0x174>)
 800a18c:	2203      	movs	r2, #3
 800a18e:	701a      	strb	r2, [r3, #0]
 800a190:	e011      	b.n	800a1b6 <SFU_LOADER_VerifyFwHeader+0x14a>
      }
      else
      {
        /* Installation authorized */
        e_ret_status = SFU_SUCCESS;
 800a192:	4b12      	ldr	r3, [pc, #72]	@ (800a1dc <SFU_LOADER_VerifyFwHeader+0x170>)
 800a194:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800a196:	e00e      	b.n	800a1b6 <SFU_LOADER_VerifyFwHeader+0x14a>
    }
    else
    {
      /* The installation is forbidden */
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
            p_x_fw_raw_header->FwVersion, verif_ver, SFU_FW_VERSION_START_NUM);
 800a198:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a19a:	88db      	ldrh	r3, [r3, #6]
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
 800a19c:	4619      	mov	r1, r3
 800a19e:	8c3a      	ldrh	r2, [r7, #32]
 800a1a0:	2301      	movs	r3, #1
 800a1a2:	4810      	ldr	r0, [pc, #64]	@ (800a1e4 <SFU_LOADER_VerifyFwHeader+0x178>)
 800a1a4:	f003 f8e4 	bl	800d370 <iprintf>
      m_LoaderStatus = SFU_LOADER_ERR_FW_VERSION;
 800a1a8:	4b0d      	ldr	r3, [pc, #52]	@ (800a1e0 <SFU_LOADER_VerifyFwHeader+0x174>)
 800a1aa:	2204      	movs	r2, #4
 800a1ac:	701a      	strb	r2, [r3, #0]
 800a1ae:	e002      	b.n	800a1b6 <SFU_LOADER_VerifyFwHeader+0x14a>
    }
  }
  else
  {
    /* Header authentication failure */
    m_LoaderStatus = SFU_LOADER_ERR_AUTH_FAILED;
 800a1b0:	4b0b      	ldr	r3, [pc, #44]	@ (800a1e0 <SFU_LOADER_VerifyFwHeader+0x174>)
 800a1b2:	2202      	movs	r2, #2
 800a1b4:	701a      	strb	r2, [r3, #0]
  }

  return e_ret_status;
 800a1b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 800a1b8:	4618      	mov	r0, r3
 800a1ba:	3730      	adds	r7, #48	@ 0x30
 800a1bc:	46bd      	mov	sp, r7
 800a1be:	bd80      	pop	{r7, pc}
 800a1c0:	00018799 	.word	0x00018799
 800a1c4:	2000172c 	.word	0x2000172c
 800a1c8:	0800e35c 	.word	0x0800e35c
 800a1cc:	0800e33c 	.word	0x0800e33c
 800a1d0:	20001738 	.word	0x20001738
 800a1d4:	20001734 	.word	0x20001734
 800a1d8:	20001730 	.word	0x20001730
 800a1dc:	00122f11 	.word	0x00122f11
 800a1e0:	20001728 	.word	0x20001728
 800a1e4:	0800e39c 	.word	0x0800e39c

0800a1e8 <SFU_LOADER_Init>:
}
 800a1e8:	4800      	ldr	r0, [pc, #0]	@ (800a1ec <SFU_LOADER_Init+0x4>)
 800a1ea:	4770      	bx	lr
 800a1ec:	00122f11 	.word	0x00122f11

0800a1f0 <SFU_LOADER_DeInit>:
SFU_ErrorStatus SFU_LOADER_DeInit(void)
 800a1f0:	4800      	ldr	r0, [pc, #0]	@ (800a1f4 <SFU_LOADER_DeInit+0x4>)
 800a1f2:	4770      	bx	lr
 800a1f4:	00122f11 	.word	0x00122f11

0800a1f8 <SFU_LOADER_DownloadNewUserFw>:
{
 800a1f8:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
  SFU_COM_YMODEM_StatusTypeDef e_com_status = SFU_COM_YMODEM_ERROR;
 800a1fc:	f04f 0a01 	mov.w	sl, #1
{
 800a200:	b08c      	sub	sp, #48	@ 0x30
  int32_t fw_tag_len = 0;
 800a202:	2400      	movs	r4, #0
{
 800a204:	4689      	mov	r9, r1
 800a206:	4616      	mov	r6, r2
  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
 800a208:	4680      	mov	r8, r0
  SFU_COM_YMODEM_StatusTypeDef e_com_status = SFU_COM_YMODEM_ERROR;
 800a20a:	f88d a007 	strb.w	sl, [sp, #7]
  int32_t fw_tag_len = 0;
 800a20e:	9403      	str	r4, [sp, #12]
  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
 800a210:	b108      	cbz	r0, 800a216 <SFU_LOADER_DownloadNewUserFw+0x1e>
 800a212:	b102      	cbz	r2, 800a216 <SFU_LOADER_DownloadNewUserFw+0x1e>
 800a214:	b921      	cbnz	r1, 800a220 <SFU_LOADER_DownloadNewUserFw+0x28>
    return SFU_ERROR;
 800a216:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
}
 800a21a:	b00c      	add	sp, #48	@ 0x30
 800a21c:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
  (void) SFU_LL_SECU_IWDG_Refresh();
 800a220:	f000 fdfc 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
  TRACE("\r\n\t  File> Transfer> YMODEM> Send ");
 800a224:	481f      	ldr	r0, [pc, #124]	@ (800a2a4 <SFU_LOADER_DownloadNewUserFw+0xac>)
 800a226:	f003 f8a3 	bl	800d370 <iprintf>
  m_uDwlAreaStart = 0U;
 800a22a:	4a1f      	ldr	r2, [pc, #124]	@ (800a2a8 <SFU_LOADER_DownloadNewUserFw+0xb0>)
  m_uDwlAreaAddress = 0U;
 800a22c:	4b1f      	ldr	r3, [pc, #124]	@ (800a2ac <SFU_LOADER_DownloadNewUserFw+0xb4>)
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800a22e:	4631      	mov	r1, r6
  m_uDwlAreaStart = 0U;
 800a230:	6014      	str	r4, [r2, #0]
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800a232:	f10d 0007 	add.w	r0, sp, #7
  m_uDwlAreaSize = 0U;
 800a236:	4a1e      	ldr	r2, [pc, #120]	@ (800a2b0 <SFU_LOADER_DownloadNewUserFw+0xb8>)
  m_uDwlSlot = SLOT_ACTIVE_1;
 800a238:	f8df b08c 	ldr.w	fp, [pc, #140]	@ 800a2c8 <SFU_LOADER_DownloadNewUserFw+0xd0>
  m_uDwlAreaSize = 0U;
 800a23c:	6014      	str	r4, [r2, #0]
  m_LoaderStatus = SFU_LOADER_ERR_COM;
 800a23e:	4d1d      	ldr	r5, [pc, #116]	@ (800a2b4 <SFU_LOADER_DownloadNewUserFw+0xbc>)
  m_uActiveHeaderStart = 0U;
 800a240:	4a1d      	ldr	r2, [pc, #116]	@ (800a2b8 <SFU_LOADER_DownloadNewUserFw+0xc0>)
  m_uDwlAreaAddress = 0U;
 800a242:	601c      	str	r4, [r3, #0]
  m_uActiveHeaderStart = 0U;
 800a244:	6014      	str	r4, [r2, #0]
  m_uDwlSlot = SLOT_ACTIVE_1;
 800a246:	f8cb a000 	str.w	sl, [fp]
  m_LoaderStatus = SFU_LOADER_ERR_COM;
 800a24a:	f885 a000 	strb.w	sl, [r5]
  m_uFileSizeYmodem = 0U;
 800a24e:	e9c3 4401 	strd	r4, r4, [r3, #4]
  m_uPacketsReceived = 0U;
 800a252:	e9c3 4403 	strd	r4, r4, [r3, #12]
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800a256:	f7ff f9d1 	bl	80095fc <SFU_COM_YMODEM_Receive>
 800a25a:	4b18      	ldr	r3, [pc, #96]	@ (800a2bc <SFU_LOADER_DownloadNewUserFw+0xc4>)
 800a25c:	4298      	cmp	r0, r3
 800a25e:	d102      	bne.n	800a266 <SFU_LOADER_DownloadNewUserFw+0x6e>
    if (*pSize > 0U)
 800a260:	6833      	ldr	r3, [r6, #0]
 800a262:	b103      	cbz	r3, 800a266 <SFU_LOADER_DownloadNewUserFw+0x6e>
      m_LoaderStatus = SFU_LOADER_OK;
 800a264:	702c      	strb	r4, [r5, #0]
  *pDwlSlot = m_uDwlSlot;
 800a266:	f8db 3000 	ldr.w	r3, [fp]
 800a26a:	f8c9 3000 	str.w	r3, [r9]
  if (m_LoaderStatus == SFU_LOADER_OK)
 800a26e:	782b      	ldrb	r3, [r5, #0]
 800a270:	b95b      	cbnz	r3, 800a28a <SFU_LOADER_DownloadNewUserFw+0x92>
    fw_tag_len = sizeof(fw_tag_output);
 800a272:	2320      	movs	r3, #32
    if (SE_Decrypt_Finish(&e_se_status, fw_tag_output, &fw_tag_len) != SE_SUCCESS)
 800a274:	aa03      	add	r2, sp, #12
 800a276:	a904      	add	r1, sp, #16
 800a278:	a802      	add	r0, sp, #8
    fw_tag_len = sizeof(fw_tag_output);
 800a27a:	9303      	str	r3, [sp, #12]
    if (SE_Decrypt_Finish(&e_se_status, fw_tag_output, &fw_tag_len) != SE_SUCCESS)
 800a27c:	f7fe f8da 	bl	8008434 <SE_Decrypt_Finish>
 800a280:	4b0f      	ldr	r3, [pc, #60]	@ (800a2c0 <SFU_LOADER_DownloadNewUserFw+0xc8>)
 800a282:	4298      	cmp	r0, r3
 800a284:	d008      	beq.n	800a298 <SFU_LOADER_DownloadNewUserFw+0xa0>
      m_LoaderStatus = SFU_LOADER_ERR_CRYPTO;
 800a286:	2306      	movs	r3, #6
 800a288:	702b      	strb	r3, [r5, #0]
  *peSFU_LOADER_Status = m_LoaderStatus;
 800a28a:	782b      	ldrb	r3, [r5, #0]
 800a28c:	f888 3000 	strb.w	r3, [r8]
  if (m_LoaderStatus == SFU_LOADER_OK)
 800a290:	2b00      	cmp	r3, #0
 800a292:	d1c0      	bne.n	800a216 <SFU_LOADER_DownloadNewUserFw+0x1e>
    e_ret_status = SFU_SUCCESS;
 800a294:	4809      	ldr	r0, [pc, #36]	@ (800a2bc <SFU_LOADER_DownloadNewUserFw+0xc4>)
 800a296:	e7c0      	b.n	800a21a <SFU_LOADER_DownloadNewUserFw+0x22>
    else if (e_se_status != SE_OK)
 800a298:	4b0a      	ldr	r3, [pc, #40]	@ (800a2c4 <SFU_LOADER_DownloadNewUserFw+0xcc>)
 800a29a:	9a02      	ldr	r2, [sp, #8]
 800a29c:	429a      	cmp	r2, r3
 800a29e:	d1f2      	bne.n	800a286 <SFU_LOADER_DownloadNewUserFw+0x8e>
 800a2a0:	e7f3      	b.n	800a28a <SFU_LOADER_DownloadNewUserFw+0x92>
 800a2a2:	bf00      	nop
 800a2a4:	0800e400 	.word	0x0800e400
 800a2a8:	20001738 	.word	0x20001738
 800a2ac:	20001740 	.word	0x20001740
 800a2b0:	20001734 	.word	0x20001734
 800a2b4:	20001728 	.word	0x20001728
 800a2b8:	20001730 	.word	0x20001730
 800a2bc:	00122f11 	.word	0x00122f11
 800a2c0:	0012310f 	.word	0x0012310f
 800a2c4:	0012e223 	.word	0x0012e223
 800a2c8:	2000172c 	.word	0x2000172c

0800a2cc <SFU_COM_YMODEM_HeaderPktRxCpltCallback>:
{
 800a2cc:	b508      	push	{r3, lr}
  m_uPacketsReceived = 0U;
 800a2ce:	4b07      	ldr	r3, [pc, #28]	@ (800a2ec <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x20>)
 800a2d0:	2200      	movs	r2, #0
  m_uFileSizeYmodem = uFileSize;
 800a2d2:	6098      	str	r0, [r3, #8]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKET_1K_SIZE - 1U)) / SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a2d4:	f200 30ff 	addw	r0, r0, #1023	@ 0x3ff
  m_uPacketsReceived = 0U;
 800a2d8:	611a      	str	r2, [r3, #16]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKET_1K_SIZE - 1U)) / SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a2da:	0a80      	lsrs	r0, r0, #10
 800a2dc:	60d8      	str	r0, [r3, #12]
  HAL_Delay(1000U);
 800a2de:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800a2e2:	f000 ff39 	bl	800b158 <HAL_Delay>
}
 800a2e6:	4802      	ldr	r0, [pc, #8]	@ (800a2f0 <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x24>)
 800a2e8:	bd08      	pop	{r3, pc}
 800a2ea:	bf00      	nop
 800a2ec:	20001740 	.word	0x20001740
 800a2f0:	00122f11 	.word	0x00122f11

0800a2f4 <SFU_COM_YMODEM_DataPktRxCpltCallback>:
{
 800a2f4:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  SE_StatusTypeDef e_se_status = SE_KO;
 800a2f8:	4b72      	ldr	r3, [pc, #456]	@ (800a4c4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d0>)
{
 800a2fa:	b086      	sub	sp, #24
 800a2fc:	460d      	mov	r5, r1
  if (p_data == NULL)
 800a2fe:	4680      	mov	r8, r0
  SE_StatusTypeDef e_se_status = SE_KO;
 800a300:	9305      	str	r3, [sp, #20]
  if (p_data == NULL)
 800a302:	2800      	cmp	r0, #0
 800a304:	f000 80db 	beq.w	800a4be <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ca>
  m_uPacketsReceived++;
 800a308:	4c6f      	ldr	r4, [pc, #444]	@ (800a4c8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d4>)
 800a30a:	6923      	ldr	r3, [r4, #16]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a30c:	68e2      	ldr	r2, [r4, #12]
  m_uPacketsReceived++;
 800a30e:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a310:	4293      	cmp	r3, r2
  m_uPacketsReceived++;
 800a312:	6123      	str	r3, [r4, #16]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a314:	d106      	bne.n	800a324 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x30>
    if (0U == (m_uFileSizeYmodem % SFU_COM_YMODEM_PACKET_1K_SIZE))
 800a316:	68a5      	ldr	r5, [r4, #8]
 800a318:	f3c5 0509 	ubfx	r5, r5, #0, #10
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a31c:	2d00      	cmp	r5, #0
 800a31e:	bf08      	it	eq
 800a320:	f44f 6580 	moveq.w	r5, #1024	@ 0x400
  if (m_uPacketsReceived == 1U)
 800a324:	2b01      	cmp	r3, #1
 800a326:	d16d      	bne.n	800a404 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x110>
    (void) memcpy(fw_header, p_data, SE_FW_HEADER_TOT_LEN);
 800a328:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 800a32c:	4641      	mov	r1, r8
 800a32e:	4867      	ldr	r0, [pc, #412]	@ (800a4cc <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d8>)
 800a330:	f003 faa5 	bl	800d87e <memcpy>
    e_ret_status = SFU_LOADER_VerifyFwHeader(p_data);
 800a334:	4640      	mov	r0, r8
 800a336:	f7ff fe99 	bl	800a06c <SFU_LOADER_VerifyFwHeader>
    if (e_ret_status == SFU_SUCCESS)
 800a33a:	4b65      	ldr	r3, [pc, #404]	@ (800a4d0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1dc>)
    e_ret_status = SFU_LOADER_VerifyFwHeader(p_data);
 800a33c:	4606      	mov	r6, r0
    if (e_ret_status == SFU_SUCCESS)
 800a33e:	4298      	cmp	r0, r3
 800a340:	d118      	bne.n	800a374 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x80>
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800a342:	4b64      	ldr	r3, [pc, #400]	@ (800a4d4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e0>)
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uActiveHeaderAddress, SFU_IMG_IMAGE_OFFSET) !=
 800a344:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800a348:	f10d 000f 	add.w	r0, sp, #15
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800a34c:	681b      	ldr	r3, [r3, #0]
 800a34e:	6023      	str	r3, [r4, #0]
      m_uActiveHeaderAddress = m_uActiveHeaderStart;
 800a350:	4b61      	ldr	r3, [pc, #388]	@ (800a4d8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e4>)
 800a352:	6819      	ldr	r1, [r3, #0]
      m_uDwlImgSize = ((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->FwSize + SFU_IMG_IMAGE_OFFSET;
 800a354:	6a23      	ldr	r3, [r4, #32]
      m_uActiveHeaderAddress = m_uActiveHeaderStart;
 800a356:	6061      	str	r1, [r4, #4]
      m_uDwlImgSize = ((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->FwSize + SFU_IMG_IMAGE_OFFSET;
 800a358:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800a35c:	f8c4 3158 	str.w	r3, [r4, #344]	@ 0x158
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uActiveHeaderAddress, SFU_IMG_IMAGE_OFFSET) !=
 800a360:	f000 fa98 	bl	800a894 <SFU_LL_FLASH_Erase_Size>
 800a364:	42b0      	cmp	r0, r6
 800a366:	4681      	mov	r9, r0
 800a368:	d016      	beq.n	800a398 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xa4>
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a36a:	2305      	movs	r3, #5
        m_LoaderStatus = SFU_LOADER_ERR_CRYPTO;
 800a36c:	4a5b      	ldr	r2, [pc, #364]	@ (800a4dc <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e8>)
      e_ret_status = SFU_ERROR;
 800a36e:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
        m_LoaderStatus = SFU_LOADER_ERR_CRYPTO;
 800a372:	7013      	strb	r3, [r2, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800a374:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 800a378:	429a      	cmp	r2, r3
    m_uPacketsReceived = 0U;
 800a37a:	bf04      	itt	eq
 800a37c:	2300      	moveq	r3, #0
 800a37e:	6123      	streq	r3, [r4, #16]
  if (e_ret_status == SFU_ERROR)
 800a380:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 800a384:	429e      	cmp	r6, r3
 800a386:	d103      	bne.n	800a390 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x9c>
    m_uFileSizeYmodem = 0U;
 800a388:	2300      	movs	r3, #0
 800a38a:	60a3      	str	r3, [r4, #8]
    m_uNbrBlocksYmodem = 0U;
 800a38c:	e9c4 3303 	strd	r3, r3, [r4, #12]
}
 800a390:	4630      	mov	r0, r6
 800a392:	b006      	add	sp, #24
 800a394:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uDwlAreaAddress, SLOT_SIZE(m_uDwlSlot)) !=
 800a398:	4b51      	ldr	r3, [pc, #324]	@ (800a4e0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ec>)
 800a39a:	f10d 000f 	add.w	r0, sp, #15
 800a39e:	4951      	ldr	r1, [pc, #324]	@ (800a4e4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f0>)
 800a3a0:	681a      	ldr	r2, [r3, #0]
 800a3a2:	4b51      	ldr	r3, [pc, #324]	@ (800a4e8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f4>)
 800a3a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a3a8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800a3ac:	3301      	adds	r3, #1
 800a3ae:	6821      	ldr	r1, [r4, #0]
 800a3b0:	1a9a      	subs	r2, r3, r2
 800a3b2:	f000 fa6f 	bl	800a894 <SFU_LL_FLASH_Erase_Size>
 800a3b6:	4548      	cmp	r0, r9
 800a3b8:	4606      	mov	r6, r0
 800a3ba:	d1d6      	bne.n	800a36a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x76>
      if (SE_Decrypt_Init(&e_se_status, (SE_FwRawHeaderTypeDef *)fw_header, SE_FW_IMAGE_COMPLETE) != SE_SUCCESS)
 800a3bc:	2200      	movs	r2, #0
 800a3be:	4943      	ldr	r1, [pc, #268]	@ (800a4cc <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d8>)
 800a3c0:	a805      	add	r0, sp, #20
 800a3c2:	f7fd ffc3 	bl	800834c <SE_Decrypt_Init>
 800a3c6:	4b49      	ldr	r3, [pc, #292]	@ (800a4ec <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f8>)
 800a3c8:	4298      	cmp	r0, r3
 800a3ca:	d001      	beq.n	800a3d0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xdc>
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a3cc:	2306      	movs	r3, #6
 800a3ce:	e7cd      	b.n	800a36c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x78>
      else if (e_se_status != SE_OK)
 800a3d0:	4b47      	ldr	r3, [pc, #284]	@ (800a4f0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1fc>)
 800a3d2:	9a05      	ldr	r2, [sp, #20]
 800a3d4:	429a      	cmp	r2, r3
 800a3d6:	d1f9      	bne.n	800a3cc <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
        if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uActiveHeaderAddress, p_data, SE_FW_HEADER_TOT_LEN) ==
 800a3d8:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 800a3dc:	4642      	mov	r2, r8
 800a3de:	6861      	ldr	r1, [r4, #4]
 800a3e0:	f10d 000f 	add.w	r0, sp, #15
 800a3e4:	f000 fa5d 	bl	800a8a2 <SFU_LL_FLASH_Write>
 800a3e8:	42b0      	cmp	r0, r6
 800a3ea:	d1be      	bne.n	800a36a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x76>
          m_uDwlAreaAddress += SE_FW_HEADER_TOT_LEN;
 800a3ec:	6823      	ldr	r3, [r4, #0]
          rx_size -= SE_FW_HEADER_TOT_LEN;
 800a3ee:	f5a5 75a0 	sub.w	r5, r5, #320	@ 0x140
          p_data += SE_FW_HEADER_TOT_LEN;
 800a3f2:	f508 78a0 	add.w	r8, r8, #320	@ 0x140
          m_uDwlAreaAddress += SE_FW_HEADER_TOT_LEN;
 800a3f6:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 800a3fa:	6023      	str	r3, [r4, #0]
          m_uActiveHeaderAddress += SE_FW_HEADER_TOT_LEN;
 800a3fc:	6863      	ldr	r3, [r4, #4]
 800a3fe:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 800a402:	6063      	str	r3, [r4, #4]
    if (m_uDwlAreaAddress < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET))
 800a404:	4e33      	ldr	r6, [pc, #204]	@ (800a4d4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e0>)
 800a406:	6823      	ldr	r3, [r4, #0]
 800a408:	6830      	ldr	r0, [r6, #0]
 800a40a:	f500 6280 	add.w	r2, r0, #1024	@ 0x400
 800a40e:	429a      	cmp	r2, r3
 800a410:	d91d      	bls.n	800a44e <SFU_COM_YMODEM_DataPktRxCpltCallback+0x15a>
      if ((m_uDwlAreaAddress + rx_size) < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET))
 800a412:	1959      	adds	r1, r3, r5
 800a414:	428a      	cmp	r2, r1
 800a416:	d90e      	bls.n	800a436 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x142>
        m_uActiveHeaderAddress += rx_size;
 800a418:	6863      	ldr	r3, [r4, #4]
        m_uDwlAreaAddress += rx_size;
 800a41a:	6021      	str	r1, [r4, #0]
        m_uActiveHeaderAddress += rx_size;
 800a41c:	442b      	add	r3, r5
 800a41e:	6063      	str	r3, [r4, #4]
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a420:	2500      	movs	r5, #0
    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlImgSize))
 800a422:	6821      	ldr	r1, [r4, #0]
 800a424:	6833      	ldr	r3, [r6, #0]
 800a426:	f8d4 2158 	ldr.w	r2, [r4, #344]	@ 0x158
 800a42a:	1948      	adds	r0, r1, r5
 800a42c:	441a      	add	r2, r3
 800a42e:	4290      	cmp	r0, r2
 800a430:	d923      	bls.n	800a47a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x186>
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a432:	2303      	movs	r3, #3
 800a434:	e79a      	b.n	800a36c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x78>
        rx_size -= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a436:	f5a3 6180 	sub.w	r1, r3, #1024	@ 0x400
        p_data += (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a43a:	1ad3      	subs	r3, r2, r3
        m_uDwlAreaAddress += (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a43c:	6022      	str	r2, [r4, #0]
        p_data += (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a43e:	4498      	add	r8, r3
        m_uActiveHeaderAddress += (m_uActiveHeaderStart + SFU_IMG_IMAGE_OFFSET - m_uActiveHeaderAddress);
 800a440:	4b25      	ldr	r3, [pc, #148]	@ (800a4d8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1e4>)
        rx_size -= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a442:	1a09      	subs	r1, r1, r0
        m_uActiveHeaderAddress += (m_uActiveHeaderStart + SFU_IMG_IMAGE_OFFSET - m_uActiveHeaderAddress);
 800a444:	681b      	ldr	r3, [r3, #0]
        rx_size -= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET - m_uDwlAreaAddress);
 800a446:	440d      	add	r5, r1
        m_uActiveHeaderAddress += (m_uActiveHeaderStart + SFU_IMG_IMAGE_OFFSET - m_uActiveHeaderAddress);
 800a448:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800a44c:	6063      	str	r3, [r4, #4]
    if (rx_size != 0U)
 800a44e:	2d00      	cmp	r5, #0
 800a450:	d0e6      	beq.n	800a420 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x12c>
          && (SE_Decrypt_Append(&e_se_status, p_data, rx_size, fw_decrypted_chunk, &fw_decrypted_chunk_size)
 800a452:	ab04      	add	r3, sp, #16
 800a454:	462a      	mov	r2, r5
 800a456:	4641      	mov	r1, r8
 800a458:	a805      	add	r0, sp, #20
 800a45a:	9300      	str	r3, [sp, #0]
 800a45c:	4b25      	ldr	r3, [pc, #148]	@ (800a4f4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x200>)
      fw_decrypted_chunk_size = rx_size;
 800a45e:	9504      	str	r5, [sp, #16]
          && (SE_Decrypt_Append(&e_se_status, p_data, rx_size, fw_decrypted_chunk, &fw_decrypted_chunk_size)
 800a460:	f7fd ffaa 	bl	80083b8 <SE_Decrypt_Append>
 800a464:	4b21      	ldr	r3, [pc, #132]	@ (800a4ec <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1f8>)
 800a466:	4298      	cmp	r0, r3
 800a468:	d1b0      	bne.n	800a3cc <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
      else if ((e_se_status != SE_OK) || (fw_decrypted_chunk_size != rx_size))
 800a46a:	4b21      	ldr	r3, [pc, #132]	@ (800a4f0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1fc>)
 800a46c:	9a05      	ldr	r2, [sp, #20]
 800a46e:	429a      	cmp	r2, r3
 800a470:	d1ac      	bne.n	800a3cc <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
 800a472:	9b04      	ldr	r3, [sp, #16]
 800a474:	429d      	cmp	r5, r3
 800a476:	d1a9      	bne.n	800a3cc <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd8>
 800a478:	e7d3      	b.n	800a422 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x12e>
    if ((rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)) != 0U)
 800a47a:	06ea      	lsls	r2, r5, #27
 800a47c:	d007      	beq.n	800a48e <SFU_COM_YMODEM_DataPktRxCpltCallback+0x19a>
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800a47e:	f025 021f 	bic.w	r2, r5, #31
        fw_decrypted_chunk[uOldSize] = 0xFF;
 800a482:	481c      	ldr	r0, [pc, #112]	@ (800a4f4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x200>)
 800a484:	26ff      	movs	r6, #255	@ 0xff
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800a486:	3220      	adds	r2, #32
      while (uOldSize < rx_size)
 800a488:	4295      	cmp	r5, r2
 800a48a:	d315      	bcc.n	800a4b8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c4>
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800a48c:	4615      	mov	r5, r2
    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlAreaSize))
 800a48e:	481a      	ldr	r0, [pc, #104]	@ (800a4f8 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x204>)
 800a490:	194a      	adds	r2, r1, r5
 800a492:	6800      	ldr	r0, [r0, #0]
 800a494:	4403      	add	r3, r0
 800a496:	429a      	cmp	r2, r3
 800a498:	d8cb      	bhi.n	800a432 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x13e>
    if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, fw_decrypted_chunk, rx_size) == SFU_SUCCESS)
 800a49a:	462b      	mov	r3, r5
 800a49c:	4a15      	ldr	r2, [pc, #84]	@ (800a4f4 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x200>)
 800a49e:	f10d 000f 	add.w	r0, sp, #15
 800a4a2:	f000 f9fe 	bl	800a8a2 <SFU_LL_FLASH_Write>
 800a4a6:	4b0a      	ldr	r3, [pc, #40]	@ (800a4d0 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1dc>)
 800a4a8:	4606      	mov	r6, r0
 800a4aa:	4298      	cmp	r0, r3
 800a4ac:	f47f af5d 	bne.w	800a36a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x76>
      m_uDwlAreaAddress += (rx_size);
 800a4b0:	6823      	ldr	r3, [r4, #0]
 800a4b2:	442b      	add	r3, r5
 800a4b4:	6023      	str	r3, [r4, #0]
 800a4b6:	e75d      	b.n	800a374 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x80>
        fw_decrypted_chunk[uOldSize] = 0xFF;
 800a4b8:	542e      	strb	r6, [r5, r0]
        uOldSize++;
 800a4ba:	3501      	adds	r5, #1
 800a4bc:	e7e4      	b.n	800a488 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x194>
    return SFU_ERROR;
 800a4be:	f641 76e1 	movw	r6, #8161	@ 0x1fe1
 800a4c2:	e765      	b.n	800a390 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x9c>
 800a4c4:	0013023d 	.word	0x0013023d
 800a4c8:	20001740 	.word	0x20001740
 800a4cc:	20001758 	.word	0x20001758
 800a4d0:	00122f11 	.word	0x00122f11
 800a4d4:	20001738 	.word	0x20001738
 800a4d8:	20001730 	.word	0x20001730
 800a4dc:	20001728 	.word	0x20001728
 800a4e0:	2000172c 	.word	0x2000172c
 800a4e4:	0800e33c 	.word	0x0800e33c
 800a4e8:	0800e35c 	.word	0x0800e35c
 800a4ec:	0012310f 	.word	0x0012310f
 800a4f0:	0012e223 	.word	0x0012e223
 800a4f4:	2000189c 	.word	0x2000189c
 800a4f8:	20001734 	.word	0x20001734

0800a4fc <SFU_MPU_SVC_Handler>:
  *             The first argument is the identifier of the requested operation.
  * @retval void
  */
void SFU_MPU_SVC_Handler(uint32_t *args)
{
  switch (args[0])
 800a4fc:	6803      	ldr	r3, [r0, #0]
 800a4fe:	2b06      	cmp	r3, #6
{
 800a500:	b570      	push	{r4, r5, r6, lr}
 800a502:	4604      	mov	r4, r0
  switch (args[0])
 800a504:	d807      	bhi.n	800a516 <SFU_MPU_SVC_Handler+0x1a>
 800a506:	2b02      	cmp	r3, #2
 800a508:	d839      	bhi.n	800a57e <SFU_MPU_SVC_Handler+0x82>
 800a50a:	2b01      	cmp	r3, #1
 800a50c:	d009      	beq.n	800a522 <SFU_MPU_SVC_Handler+0x26>
    default:
      /* Force a reset */
      HAL_NVIC_SystemReset();
      break;
  }
}
 800a50e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      HAL_NVIC_SystemReset();
 800a512:	f000 be93 	b.w	800b23c <HAL_NVIC_SystemReset>
  switch (args[0])
 800a516:	2b07      	cmp	r3, #7
 800a518:	d1f9      	bne.n	800a50e <SFU_MPU_SVC_Handler+0x12>
}
 800a51a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      HAL_SuspendTick();
 800a51e:	f000 be2d 	b.w	800b17c <HAL_SuspendTick>
  uint32_t sp_base = SE_REGION_RAM_START;
 800a522:	4b17      	ldr	r3, [pc, #92]	@ (800a580 <SFU_MPU_SVC_Handler+0x84>)
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800a524:	f3ef 8208 	mrs	r2, MSP
  if ((sp > sp_base) && (sp <= sp_top))
 800a528:	4293      	cmp	r3, r2
 800a52a:	d219      	bcs.n	800a560 <SFU_MPU_SVC_Handler+0x64>
 800a52c:	4915      	ldr	r1, [pc, #84]	@ (800a584 <SFU_MPU_SVC_Handler+0x88>)
 800a52e:	428a      	cmp	r2, r1
 800a530:	d816      	bhi.n	800a560 <SFU_MPU_SVC_Handler+0x64>
      *(__IO uint32_t *)sp_base = 0U;
 800a532:	2100      	movs	r1, #0
 800a534:	f843 1b04 	str.w	r1, [r3], #4
    while (sp_base < sp)
 800a538:	429a      	cmp	r2, r3
 800a53a:	d8fb      	bhi.n	800a534 <SFU_MPU_SVC_Handler+0x38>
      SFU_SecUserActivationInRam(args[1]);
 800a53c:	6860      	ldr	r0, [r4, #4]
  while (psrc < psrc_end)
 800a53e:	4b12      	ldr	r3, [pc, #72]	@ (800a588 <SFU_MPU_SVC_Handler+0x8c>)
  pdest = (uint32_t *)SB_HDP_CODE_REGION_RAM_START;
 800a540:	4a12      	ldr	r2, [pc, #72]	@ (800a58c <SFU_MPU_SVC_Handler+0x90>)
  while (psrc < psrc_end)
 800a542:	4c13      	ldr	r4, [pc, #76]	@ (800a590 <SFU_MPU_SVC_Handler+0x94>)
 800a544:	42a3      	cmp	r3, r4
 800a546:	4619      	mov	r1, r3
 800a548:	d30d      	bcc.n	800a566 <SFU_MPU_SVC_Handler+0x6a>
 800a54a:	4d10      	ldr	r5, [pc, #64]	@ (800a58c <SFU_MPU_SVC_Handler+0x90>)
  uint32_t result = 0U;
 800a54c:	2300      	movs	r3, #0
  psrc = (uint32_t *)(SB_HDP_REGION_ROM_START);
 800a54e:	4a0e      	ldr	r2, [pc, #56]	@ (800a588 <SFU_MPU_SVC_Handler+0x8c>)
  while (psrc < psrc_end)
 800a550:	42a2      	cmp	r2, r4
 800a552:	d30d      	bcc.n	800a570 <SFU_MPU_SVC_Handler+0x74>
  if (result == 0U)
 800a554:	2b00      	cmp	r3, #0
 800a556:	d1da      	bne.n	800a50e <SFU_MPU_SVC_Handler+0x12>
}
 800a558:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    SFU_LL_SECU_ActivateSecUser(Address);
 800a55c:	f003 beb8 	b.w	800e2d0 <__SFU_LL_SECU_ActivateSecUser_veneer>
    HAL_NVIC_SystemReset();
 800a560:	f000 fe6c 	bl	800b23c <HAL_NVIC_SystemReset>
 800a564:	e7ea      	b.n	800a53c <SFU_MPU_SVC_Handler+0x40>
    *pdest = *psrc;
 800a566:	6809      	ldr	r1, [r1, #0]
 800a568:	3304      	adds	r3, #4
 800a56a:	f842 1b04 	str.w	r1, [r2], #4
    psrc++;
 800a56e:	e7e9      	b.n	800a544 <SFU_MPU_SVC_Handler+0x48>
    result |= (*pdest ^ *psrc);
 800a570:	f855 1b04 	ldr.w	r1, [r5], #4
 800a574:	f852 6b04 	ldr.w	r6, [r2], #4
 800a578:	4071      	eors	r1, r6
 800a57a:	430b      	orrs	r3, r1
    psrc++;
 800a57c:	e7e8      	b.n	800a550 <SFU_MPU_SVC_Handler+0x54>
}
 800a57e:	bd70      	pop	{r4, r5, r6, pc}
 800a580:	20000000 	.word	0x20000000
 800a584:	20000400 	.word	0x20000400
 800a588:	08008900 	.word	0x08008900
 800a58c:	20001000 	.word	0x20001000
 800a590:	080089ff 	.word	0x080089ff

0800a594 <MPU_SVC_Handler>:
  uint8_t code = ((uint8_t *)args[6])[-2];
 800a594:	6983      	ldr	r3, [r0, #24]
 800a596:	f813 3c02 	ldrb.w	r3, [r3, #-2]
  switch (code)
 800a59a:	b11b      	cbz	r3, 800a5a4 <MPU_SVC_Handler+0x10>
 800a59c:	2b01      	cmp	r3, #1
 800a59e:	d003      	beq.n	800a5a8 <MPU_SVC_Handler+0x14>
      HAL_NVIC_SystemReset();
 800a5a0:	f000 be4c 	b.w	800b23c <HAL_NVIC_SystemReset>
      SE_SVC_Handler(args);
 800a5a4:	f7fe b868 	b.w	8008678 <SE_SVC_Handler>
      SFU_MPU_SVC_Handler(args);
 800a5a8:	f7ff bfa8 	b.w	800a4fc <SFU_MPU_SVC_Handler>

0800a5ac <SFU_MPU_SysCall>:
  * @param syscall The identifier of the operation to be called (see @ref SFU_MPU_PrivilegedOpId)
  * @param arguments arguments of the privileged operation
  * @retval void
  */
void SFU_MPU_SysCall(uint32_t syscall, ...)
{
 800a5ac:	b40f      	push	{r0, r1, r2, r3}
  /*
    * You cannot directly change to privileged mode from unprivileged mode without going through an exception, for
    * example an SVC.
    * Handled by @ref MPU_SVC_Handler() and finally @ref SFU_MPU_SVC_Handler()
    */
  __ASM volatile("SVC #1");   /* 1 is the hard-coded value to indicate a SB_SFU syscall */
 800a5ae:	df01      	svc	1
}
 800a5b0:	b004      	add	sp, #16
 800a5b2:	4770      	bx	lr

0800a5b4 <SFU_MPU_IsUnprivileged>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800a5b4:	f3ef 8305 	mrs	r3, IPSR
  * @param void
  * @retval 0 if we are in privileged mode, 1 if we are in non-privileged mode
  */
uint32_t SFU_MPU_IsUnprivileged(void)
{
  return ((__get_IPSR() == 0U) && ((__get_CONTROL() & 1U) == 1U));
 800a5b8:	b923      	cbnz	r3, 800a5c4 <SFU_MPU_IsUnprivileged+0x10>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 800a5ba:	f3ef 8014 	mrs	r0, CONTROL
 800a5be:	f000 0001 	and.w	r0, r0, #1
 800a5c2:	4770      	bx	lr
 800a5c4:	2000      	movs	r0, #0
}
 800a5c6:	4770      	bx	lr

0800a5c8 <SFU_MPU_EnterUnprivilegedMode>:
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800a5c8:	f3ef 8308 	mrs	r3, MSP
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800a5cc:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800a5d0:	4b05      	ldr	r3, [pc, #20]	@ (800a5e8 <SFU_MPU_EnterUnprivilegedMode+0x20>)
 800a5d2:	f383 8808 	msr	MSP, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 800a5d6:	f3ef 8314 	mrs	r3, CONTROL
  */
void SFU_MPU_EnterUnprivilegedMode(void)
{
  __set_PSP(__get_MSP()); /* set up Process Stack Pointer to current stack pointer */
  __set_MSP(SE_REGION_RAM_STACK_TOP); /* change main stack to point on privileged stack */
  __set_CONTROL(__get_CONTROL() | 3U); /* bit 0 = 1: unprivileged      bit 1=1: stack=PSP */
 800a5da:	f043 0303 	orr.w	r3, r3, #3
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 800a5de:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
 800a5e2:	f3bf 8f6f 	isb	sy
  __ISB();
}
 800a5e6:	4770      	bx	lr
 800a5e8:	20000400 	.word	0x20000400

0800a5ec <SFU_IMG_GetDownloadAreaInfo>:
  * @param  pArea pointer to area descriptor
  * @retval none
  */
void SFU_IMG_GetDownloadAreaInfo(uint32_t DwlSlot, SFU_FwImageFlashTypeDef *pArea)
{
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800a5ec:	4b08      	ldr	r3, [pc, #32]	@ (800a610 <SFU_IMG_GetDownloadAreaInfo+0x24>)
 800a5ee:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
 800a5f2:	4b08      	ldr	r3, [pc, #32]	@ (800a614 <SFU_IMG_GetDownloadAreaInfo+0x28>)
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800a5f4:	604a      	str	r2, [r1, #4]
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
 800a5f6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800a5fa:	3301      	adds	r3, #1
 800a5fc:	1a9b      	subs	r3, r3, r2
 800a5fe:	600b      	str	r3, [r1, #0]
  pArea->ImageOffsetInBytes = SFU_IMG_IMAGE_OFFSET;
 800a600:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800a604:	608b      	str	r3, [r1, #8]
#if  (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LOADER)
  pArea->ActiveHeaderAddr = SlotHeaderAdd[DwlSlot];
 800a606:	4b04      	ldr	r3, [pc, #16]	@ (800a618 <SFU_IMG_GetDownloadAreaInfo+0x2c>)
 800a608:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800a60c:	610b      	str	r3, [r1, #16]
#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LOADER) */
}
 800a60e:	4770      	bx	lr
 800a610:	0800e33c 	.word	0x0800e33c
 800a614:	0800e35c 	.word	0x0800e35c
 800a618:	0800e37c 	.word	0x0800e37c

0800a61c <SFU_LL_DeInit>:

  /* ADD SRC CODE HERE
       ...
  */
  return e_ret_status;
}
 800a61c:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a620:	4770      	bx	lr
	...

0800a624 <SFU_LL_CRC_Config>:
  * @param  eCRCConfg: SFU_CRC_ConfigTypeDef.
  *         This parameter can be a value of @ref SFU_CRC_ConfigTypeDef.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_CRC_Config(SFU_CRC_ConfigTypeDef eCRCConfg)
{
 800a624:	b508      	push	{r3, lr}

  /* Check the parameters */
  assert_param(IS_SFU_CRC_CONF(eCRCConfg));

  /* Switch to the selected configuration */
  CrcHandle.Instance = CRC;
 800a626:	4a11      	ldr	r2, [pc, #68]	@ (800a66c <SFU_LL_CRC_Config+0x48>)
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;

  switch (eCRCConfg)
 800a628:	2801      	cmp	r0, #1
  CrcHandle.Instance = CRC;
 800a62a:	4b11      	ldr	r3, [pc, #68]	@ (800a670 <SFU_LL_CRC_Config+0x4c>)
 800a62c:	601a      	str	r2, [r3, #0]
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 800a62e:	f04f 0200 	mov.w	r2, #0
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 800a632:	e9c3 2205 	strd	r2, r2, [r3, #20]
  switch (eCRCConfg)
 800a636:	d004      	beq.n	800a642 <SFU_LL_CRC_Config+0x1e>
 800a638:	2802      	cmp	r0, #2
 800a63a:	d00c      	beq.n	800a656 <SFU_LL_CRC_Config+0x32>
      e_ret_status = SFU_SUCCESS;
      break;

    default:
      /* Invalid parameter */
      e_ret_status = SFU_ERROR;
 800a63c:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
      e_ret_status = SFU_ERROR;
    }
  }

  return e_ret_status;
}
 800a640:	bd08      	pop	{r3, pc}
      CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800a642:	809a      	strh	r2, [r3, #4]
 800a644:	2203      	movs	r2, #3
    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 800a646:	480a      	ldr	r0, [pc, #40]	@ (800a670 <SFU_LL_CRC_Config+0x4c>)
      CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 800a648:	621a      	str	r2, [r3, #32]
    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 800a64a:	f000 fe63 	bl	800b314 <HAL_CRC_Init>
 800a64e:	2800      	cmp	r0, #0
 800a650:	d1f4      	bne.n	800a63c <SFU_LL_CRC_Config+0x18>
 800a652:	4808      	ldr	r0, [pc, #32]	@ (800a674 <SFU_LL_CRC_Config+0x50>)
  return e_ret_status;
 800a654:	e7f4      	b.n	800a640 <SFU_LL_CRC_Config+0x1c>
      CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 800a656:	2108      	movs	r1, #8
 800a658:	f241 0021 	movw	r0, #4129	@ 0x1021
      CrcHandle.Init.InitValue               = 0U;
 800a65c:	611a      	str	r2, [r3, #16]
 800a65e:	2201      	movs	r2, #1
      CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 800a660:	e9c3 0102 	strd	r0, r1, [r3, #8]
      CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
 800a664:	f240 1101 	movw	r1, #257	@ 0x101
 800a668:	8099      	strh	r1, [r3, #4]
  if (e_ret_status == SFU_SUCCESS)
 800a66a:	e7ec      	b.n	800a646 <SFU_LL_CRC_Config+0x22>
 800a66c:	58024c00 	.word	0x58024c00
 800a670:	20001c9c 	.word	0x20001c9c
 800a674:	00122f11 	.word	0x00122f11

0800a678 <SFU_LL_CRC_Init>:
  __HAL_RCC_CRC_CLK_ENABLE();
 800a678:	4b08      	ldr	r3, [pc, #32]	@ (800a69c <SFU_LL_CRC_Init+0x24>)
{
 800a67a:	b082      	sub	sp, #8
  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAULT);
 800a67c:	2001      	movs	r0, #1
  __HAL_RCC_CRC_CLK_ENABLE();
 800a67e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a682:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 800a686:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a68a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800a68e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800a692:	9301      	str	r3, [sp, #4]
 800a694:	9b01      	ldr	r3, [sp, #4]
}
 800a696:	b002      	add	sp, #8
  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAULT);
 800a698:	f7ff bfc4 	b.w	800a624 <SFU_LL_CRC_Config>
 800a69c:	58024400 	.word	0x58024400

0800a6a0 <SFU_LL_Init>:
  e_ret_status = SFU_LL_CRC_Init();
 800a6a0:	f7ff bfea 	b.w	800a678 <SFU_LL_CRC_Init>

0800a6a4 <SFU_LL_CRC_Calculate>:
  * @param  pBuffer: pointer to data buffer.
  * @param  BufferLength: buffer length in bytes.
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
uint32_t SFU_LL_CRC_Calculate(uint32_t pBuffer[], uint32_t BufferLength)
{
 800a6a4:	460a      	mov	r2, r1
  return HAL_CRC_Calculate(&CrcHandle, pBuffer, BufferLength);
 800a6a6:	4601      	mov	r1, r0
 800a6a8:	4801      	ldr	r0, [pc, #4]	@ (800a6b0 <SFU_LL_CRC_Calculate+0xc>)
 800a6aa:	f000 be6d 	b.w	800b388 <HAL_CRC_Calculate>
 800a6ae:	bf00      	nop
 800a6b0:	20001c9c 	.word	0x20001c9c

0800a6b4 <SFU_LL_UART_Init>:
  * @retval status of the Init operation
  *         SFU_ERROR : if the Init operation failed.
  *         SFU_SUCCESS : if the Init operation is successfully performed.
  */
SFU_ErrorStatus SFU_LL_UART_Init(void)
{
 800a6b4:	b508      	push	{r3, lr}
  - One Stop Bit
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = SFU_UART;
 800a6b6:	480e      	ldr	r0, [pc, #56]	@ (800a6f0 <SFU_LL_UART_Init+0x3c>)
  UartHandle.Init.BaudRate = 115200U;
 800a6b8:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 800a6bc:	4a0d      	ldr	r2, [pc, #52]	@ (800a6f4 <SFU_LL_UART_Init+0x40>)
 800a6be:	e9c0 2309 	strd	r2, r3, [r0, #36]	@ 0x24
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800a6c2:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 800a6c4:	e9c0 330b 	strd	r3, r3, [r0, #44]	@ 0x2c
  UartHandle.Init.Parity = UART_PARITY_NONE;
 800a6c8:	6343      	str	r3, [r0, #52]	@ 0x34
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
  if (HAL_UART_Init(&UartHandle) == HAL_OK)
 800a6ca:	3024      	adds	r0, #36	@ 0x24
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a6cc:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 800a6ce:	230c      	movs	r3, #12
 800a6d0:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 800a6d2:	2310      	movs	r3, #16
 800a6d4:	6283      	str	r3, [r0, #40]	@ 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 800a6d6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800a6da:	63c3      	str	r3, [r0, #60]	@ 0x3c
  if (HAL_UART_Init(&UartHandle) == HAL_OK)
 800a6dc:	f002 fd56 	bl	800d18c <HAL_UART_Init>
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;

}
 800a6e0:	4a05      	ldr	r2, [pc, #20]	@ (800a6f8 <SFU_LL_UART_Init+0x44>)
 800a6e2:	f641 73e1 	movw	r3, #8161	@ 0x1fe1
 800a6e6:	2800      	cmp	r0, #0
 800a6e8:	bf0c      	ite	eq
 800a6ea:	4610      	moveq	r0, r2
 800a6ec:	4618      	movne	r0, r3
 800a6ee:	bd08      	pop	{r3, pc}
 800a6f0:	20001c9c 	.word	0x20001c9c
 800a6f4:	40004800 	.word	0x40004800
 800a6f8:	00122f11 	.word	0x00122f11

0800a6fc <SFU_LL_UART_DeInit>:

  e_ret_status = SFU_SUCCESS;

  return e_ret_status;

}
 800a6fc:	4800      	ldr	r0, [pc, #0]	@ (800a700 <SFU_LL_UART_DeInit+0x4>)
 800a6fe:	4770      	bx	lr
 800a700:	00122f11 	.word	0x00122f11

0800a704 <SFU_LL_UART_Transmit>:
  * @retval status of the write operation
  *         SFU_ERROR : if the write operation is not performed
  *         SFU_SUCCESS : if the write operation is successfully performed
  */
SFU_ErrorStatus SFU_LL_UART_Transmit(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
{
 800a704:	b510      	push	{r4, lr}
 800a706:	4613      	mov	r3, r2
 800a708:	460c      	mov	r4, r1
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check the pointers allocation */
  if (pData == NULL)
 800a70a:	4601      	mov	r1, r0
 800a70c:	b910      	cbnz	r0, 800a714 <SFU_LL_UART_Transmit+0x10>
  {
    return SFU_ERROR;
 800a70e:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  {
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;
}
 800a712:	bd10      	pop	{r4, pc}
  if (HAL_UART_Transmit(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
 800a714:	4622      	mov	r2, r4
 800a716:	4803      	ldr	r0, [pc, #12]	@ (800a724 <SFU_LL_UART_Transmit+0x20>)
 800a718:	f002 fc1d 	bl	800cf56 <HAL_UART_Transmit>
 800a71c:	2800      	cmp	r0, #0
 800a71e:	d1f6      	bne.n	800a70e <SFU_LL_UART_Transmit+0xa>
    e_ret_status = SFU_SUCCESS;
 800a720:	4801      	ldr	r0, [pc, #4]	@ (800a728 <SFU_LL_UART_Transmit+0x24>)
 800a722:	e7f6      	b.n	800a712 <SFU_LL_UART_Transmit+0xe>
 800a724:	20001cc0 	.word	0x20001cc0
 800a728:	00122f11 	.word	0x00122f11

0800a72c <SFU_LL_UART_Receive>:
  * @retval status of the read operation
  *         SFU_ERROR : if the read operation is not performed
  *         SFU_SUCCESS : if the read operation is successfully performed
  */
SFU_ErrorStatus SFU_LL_UART_Receive(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
{
 800a72c:	b510      	push	{r4, lr}
 800a72e:	4613      	mov	r3, r2
 800a730:	460c      	mov	r4, r1
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check the pointers allocation */
  if (pData == NULL)
 800a732:	4601      	mov	r1, r0
 800a734:	b910      	cbnz	r0, 800a73c <SFU_LL_UART_Receive+0x10>
  {
    return SFU_ERROR;
 800a736:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  {
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;
}
 800a73a:	bd10      	pop	{r4, pc}
  if (HAL_UART_Receive(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
 800a73c:	4622      	mov	r2, r4
 800a73e:	4803      	ldr	r0, [pc, #12]	@ (800a74c <SFU_LL_UART_Receive+0x20>)
 800a740:	f002 fc5e 	bl	800d000 <HAL_UART_Receive>
 800a744:	2800      	cmp	r0, #0
 800a746:	d1f6      	bne.n	800a736 <SFU_LL_UART_Receive+0xa>
    e_ret_status = SFU_SUCCESS;
 800a748:	4801      	ldr	r0, [pc, #4]	@ (800a750 <SFU_LL_UART_Receive+0x24>)
 800a74a:	e7f6      	b.n	800a73a <SFU_LL_UART_Receive+0xe>
 800a74c:	20001cc0 	.word	0x20001cc0
 800a750:	00122f11 	.word	0x00122f11

0800a754 <SFU_LL_UART_Flush>:
  * @retval status of the operation.
  */
SFU_ErrorStatus SFU_LL_UART_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 800a754:	4b05      	ldr	r3, [pc, #20]	@ (800a76c <SFU_LL_UART_Flush+0x18>)

  return SFU_SUCCESS;
}
 800a756:	4806      	ldr	r0, [pc, #24]	@ (800a770 <SFU_LL_UART_Flush+0x1c>)
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 800a758:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a75a:	699a      	ldr	r2, [r3, #24]
 800a75c:	f042 0208 	orr.w	r2, r2, #8
 800a760:	619a      	str	r2, [r3, #24]
 800a762:	699a      	ldr	r2, [r3, #24]
 800a764:	f042 0210 	orr.w	r2, r2, #16
 800a768:	619a      	str	r2, [r3, #24]
}
 800a76a:	4770      	bx	lr
 800a76c:	20001c9c 	.word	0x20001c9c
 800a770:	00122f11 	.word	0x00122f11

0800a774 <SFU_LL_UART_MspInit>:
  */
void SFU_LL_UART_MspInit(UART_HandleTypeDef *huart)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == SFU_UART)
 800a774:	6802      	ldr	r2, [r0, #0]
 800a776:	4b23      	ldr	r3, [pc, #140]	@ (800a804 <SFU_LL_UART_MspInit+0x90>)
 800a778:	429a      	cmp	r2, r3
{
 800a77a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a77c:	b089      	sub	sp, #36	@ 0x24
  if (huart->Instance == SFU_UART)
 800a77e:	d13e      	bne.n	800a7fe <SFU_LL_UART_MspInit+0x8a>
  {
    /* Peripheral Clock Enable */
    SFU_UART_CLK_ENABLE();
 800a780:	4b21      	ldr	r3, [pc, #132]	@ (800a808 <SFU_LL_UART_MspInit+0x94>)
    SFU_UART_TX_GPIO_CLK_ENABLE();
    SFU_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : SFU_UART_TX_Pin  */
    GPIO_InitStruct.Pin = SFU_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a782:	2702      	movs	r7, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a784:	2600      	movs	r6, #0
 800a786:	2503      	movs	r5, #3
    SFU_UART_CLK_ENABLE();
 800a788:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
 800a78c:	2407      	movs	r4, #7
    HAL_GPIO_Init(SFU_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 800a78e:	a903      	add	r1, sp, #12
 800a790:	481e      	ldr	r0, [pc, #120]	@ (800a80c <SFU_LL_UART_MspInit+0x98>)
    SFU_UART_CLK_ENABLE();
 800a792:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 800a796:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
 800a79a:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 800a79e:	f402 2280 	and.w	r2, r2, #262144	@ 0x40000
 800a7a2:	9200      	str	r2, [sp, #0]
 800a7a4:	9a00      	ldr	r2, [sp, #0]
    SFU_UART_TX_GPIO_CLK_ENABLE();
 800a7a6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a7aa:	f042 0208 	orr.w	r2, r2, #8
 800a7ae:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a7b2:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a7b6:	f002 0208 	and.w	r2, r2, #8
 800a7ba:	9201      	str	r2, [sp, #4]
 800a7bc:	9a01      	ldr	r2, [sp, #4]
    SFU_UART_RX_GPIO_CLK_ENABLE();
 800a7be:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800a7c2:	f042 0208 	orr.w	r2, r2, #8
 800a7c6:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a7ca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
 800a7ce:	9407      	str	r4, [sp, #28]
    SFU_UART_RX_GPIO_CLK_ENABLE();
 800a7d0:	f003 0308 	and.w	r3, r3, #8
 800a7d4:	9302      	str	r3, [sp, #8]
 800a7d6:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a7d8:	f44f 7380 	mov.w	r3, #256	@ 0x100
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a7dc:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a7e0:	e9cd 3703 	strd	r3, r7, [sp, #12]
    HAL_GPIO_Init(SFU_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 800a7e4:	f001 fa34 	bl	800bc50 <HAL_GPIO_Init>

    /*Configure GPIO pins : SFU_UART_RX_Pin  */
    GPIO_InitStruct.Pin = SFU_UART_RX_PIN;
 800a7e8:	f44f 7300 	mov.w	r3, #512	@ 0x200
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
    HAL_GPIO_Init(SFU_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 800a7ec:	a903      	add	r1, sp, #12
 800a7ee:	4807      	ldr	r0, [pc, #28]	@ (800a80c <SFU_LL_UART_MspInit+0x98>)
    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
 800a7f0:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a7f2:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a7f6:	e9cd 6505 	strd	r6, r5, [sp, #20]
    HAL_GPIO_Init(SFU_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 800a7fa:	f001 fa29 	bl	800bc50 <HAL_GPIO_Init>

  }

}
 800a7fe:	b009      	add	sp, #36	@ 0x24
 800a800:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a802:	bf00      	nop
 800a804:	40004800 	.word	0x40004800
 800a808:	58024400 	.word	0x58024400
 800a80c:	58020c00 	.word	0x58020c00

0800a810 <SFU_LL_BufferCheck_in_se_ram>:
  * @param pBuff: Secure Engine protected function ID.
  * @param length: length of buffer in bytes
  * @retval SE_ErrorStatus SE_SUCCESS for buffer in se ram, SE_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_BufferCheck_in_se_ram(const void *pBuff, uint32_t length)
{
 800a810:	4603      	mov	r3, r0
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  uint32_t addr_start = (uint32_t)pBuff;
  uint32_t addr_end = addr_start + length - 1U;

  /* Check if length is positive with no overflow and included in the correct range */
  if ((length != 0U) && (!((0xFFFFFFFFUL - addr_start) < length))
 800a812:	b171      	cbz	r1, 800a832 <SFU_LL_BufferCheck_in_se_ram+0x22>
 800a814:	1842      	adds	r2, r0, r1
 800a816:	d20c      	bcs.n	800a832 <SFU_LL_BufferCheck_in_se_ram+0x22>
  uint32_t addr_end = addr_start + length - 1U;
 800a818:	3901      	subs	r1, #1
      && ((addr_end  <= SE_REGION_RAM_END) && (addr_start >= SE_REGION_RAM_START)))
 800a81a:	4a07      	ldr	r2, [pc, #28]	@ (800a838 <SFU_LL_BufferCheck_in_se_ram+0x28>)
  uint32_t addr_end = addr_start + length - 1U;
 800a81c:	4401      	add	r1, r0
      && ((addr_end  <= SE_REGION_RAM_END) && (addr_start >= SE_REGION_RAM_START)))
 800a81e:	4291      	cmp	r1, r2
 800a820:	d807      	bhi.n	800a832 <SFU_LL_BufferCheck_in_se_ram+0x22>
  {
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
    e_ret_status = SFU_ERROR;
 800a822:	4906      	ldr	r1, [pc, #24]	@ (800a83c <SFU_LL_BufferCheck_in_se_ram+0x2c>)
 800a824:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a828:	4a05      	ldr	r2, [pc, #20]	@ (800a840 <SFU_LL_BufferCheck_in_se_ram+0x30>)
 800a82a:	428b      	cmp	r3, r1
 800a82c:	bf28      	it	cs
 800a82e:	4610      	movcs	r0, r2
 800a830:	4770      	bx	lr
 800a832:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  }
  return e_ret_status;
}
 800a836:	4770      	bx	lr
 800a838:	20000fff 	.word	0x20000fff
 800a83c:	20000000 	.word	0x20000000
 800a840:	00122f11 	.word	0x00122f11

0800a844 <SFU_LL_Buffer_in_ram>:
  * @brief Check if an array is inside the RAM of the product
  * @param Addr : address  of array
  * @param Length : length of array in byte
  */
SFU_ErrorStatus SFU_LL_Buffer_in_ram(void *pBuff, uint32_t Length)
{
 800a844:	4603      	mov	r3, r0
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  uint32_t addr_start = (uint32_t)pBuff;
  uint32_t addr_end = addr_start + Length - 1U;

  /* Check if length is positive with no overflow and included in the correct range */
  if ((Length != 0U) && (!((0xFFFFFFFFUL - addr_start) < Length))
 800a846:	b171      	cbz	r1, 800a866 <SFU_LL_Buffer_in_ram+0x22>
 800a848:	1842      	adds	r2, r0, r1
 800a84a:	d20c      	bcs.n	800a866 <SFU_LL_Buffer_in_ram+0x22>
  uint32_t addr_end = addr_start + Length - 1U;
 800a84c:	3901      	subs	r1, #1
      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= SB_REGION_RAM_START)))
 800a84e:	4a07      	ldr	r2, [pc, #28]	@ (800a86c <SFU_LL_Buffer_in_ram+0x28>)
  uint32_t addr_end = addr_start + Length - 1U;
 800a850:	4401      	add	r1, r0
      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= SB_REGION_RAM_START)))
 800a852:	4291      	cmp	r1, r2
 800a854:	d807      	bhi.n	800a866 <SFU_LL_Buffer_in_ram+0x22>
  {
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
    e_ret_status = SFU_ERROR;
 800a856:	4906      	ldr	r1, [pc, #24]	@ (800a870 <SFU_LL_Buffer_in_ram+0x2c>)
 800a858:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a85c:	4a05      	ldr	r2, [pc, #20]	@ (800a874 <SFU_LL_Buffer_in_ram+0x30>)
 800a85e:	428b      	cmp	r3, r1
 800a860:	bf28      	it	cs
 800a862:	4610      	movcs	r0, r2
 800a864:	4770      	bx	lr
 800a866:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
  }
  return e_ret_status;
}
 800a86a:	4770      	bx	lr
 800a86c:	2001ffff 	.word	0x2001ffff
 800a870:	20001100 	.word	0x20001100
 800a874:	00122f11 	.word	0x00122f11

0800a878 <SFU_LL_FLASH_Init>:
  * @brief  Initialize internal and external flash interface (OSPI/QSPI)
  * @param  none
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Init(void)
{
 800a878:	b508      	push	{r3, lr}
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;

  e_ret_status = SFU_LL_FLASH_INT_Init();
 800a87a:	f000 f861 	bl	800a940 <SFU_LL_FLASH_INT_Init>
  if (e_ret_status == SFU_SUCCESS)
 800a87e:	4b04      	ldr	r3, [pc, #16]	@ (800a890 <SFU_LL_FLASH_Init+0x18>)
 800a880:	4298      	cmp	r0, r3
 800a882:	d103      	bne.n	800a88c <SFU_LL_FLASH_Init+0x14>
  {
    e_ret_status = SFU_LL_FLASH_EXT_Init();
  }
  return e_ret_status;
}
 800a884:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    e_ret_status = SFU_LL_FLASH_EXT_Init();
 800a888:	f000 b82e 	b.w	800a8e8 <SFU_LL_FLASH_EXT_Init>
}
 800a88c:	bd08      	pop	{r3, pc}
 800a88e:	bf00      	nop
 800a890:	00122f11 	.word	0x00122f11

0800a894 <SFU_LL_FLASH_Erase_Size>:
  */
SFU_ErrorStatus SFU_LL_FLASH_Erase_Size(SFU_FLASH_StatusTypeDef *pFlashStatus, uint8_t *pStart, uint32_t Length)
{

  /* Check Flash start address */
  if ((uint32_t) pStart < EXTERNAL_FLASH_ADDRESS)
 800a894:	f1b1 4f10 	cmp.w	r1, #2415919104	@ 0x90000000
 800a898:	d201      	bcs.n	800a89e <SFU_LL_FLASH_Erase_Size+0xa>
  {
    return SFU_LL_FLASH_INT_Erase_Size(pFlashStatus, pStart, Length);
 800a89a:	f000 b93d 	b.w	800ab18 <SFU_LL_FLASH_INT_Erase_Size>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Erase_Size(pFlashStatus, pStart, Length);
 800a89e:	f000 b827 	b.w	800a8f0 <SFU_LL_FLASH_EXT_Erase_Size>

0800a8a2 <SFU_LL_FLASH_Write>:
  */
SFU_ErrorStatus SFU_LL_FLASH_Write(SFU_FLASH_StatusTypeDef *pFlashStatus, uint8_t  *pDestination,
                                   const uint8_t *pSource, uint32_t Length)
{
  /* Check Flash destination address */
  if ((uint32_t) pDestination < EXTERNAL_FLASH_ADDRESS)
 800a8a2:	f1b1 4f10 	cmp.w	r1, #2415919104	@ 0x90000000
 800a8a6:	d201      	bcs.n	800a8ac <SFU_LL_FLASH_Write+0xa>
  {
    return SFU_LL_FLASH_INT_Write(pFlashStatus, pDestination, pSource, Length);
 800a8a8:	f000 b84e 	b.w	800a948 <SFU_LL_FLASH_INT_Write>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Write(pFlashStatus, pDestination, pSource, Length);
 800a8ac:	f000 b823 	b.w	800a8f6 <SFU_LL_FLASH_EXT_Write>

0800a8b0 <SFU_LL_FLASH_Read>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
{
  /* Check Flash source address */
  if ((uint32_t) pSource < EXTERNAL_FLASH_ADDRESS)
 800a8b0:	f1b1 4f10 	cmp.w	r1, #2415919104	@ 0x90000000
 800a8b4:	d201      	bcs.n	800a8ba <SFU_LL_FLASH_Read+0xa>
  {
    return SFU_LL_FLASH_INT_Read(pDestination, pSource, Length);
 800a8b6:	f000 b8b3 	b.w	800aa20 <SFU_LL_FLASH_INT_Read>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Read(pDestination, pSource, Length);
 800a8ba:	f000 b81f 	b.w	800a8fc <SFU_LL_FLASH_EXT_Read>

0800a8be <SFU_LL_FLASH_Compare>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Compare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length)
{
  /* Check Flash source address */
  if ((uint32_t) pFlash < EXTERNAL_FLASH_ADDRESS)
 800a8be:	f1b0 4f10 	cmp.w	r0, #2415919104	@ 0x90000000
 800a8c2:	d201      	bcs.n	800a8c8 <SFU_LL_FLASH_Compare+0xa>
  {
    return SFU_LL_FLASH_INT_Compare(pFlash, Pattern1, Pattern2, Length);
 800a8c4:	f000 b8f2 	b.w	800aaac <SFU_LL_FLASH_INT_Compare>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Compare(pFlash, Pattern1, Pattern2, Length);
 800a8c8:	f000 b81b 	b.w	800a902 <SFU_LL_FLASH_EXT_Compare>

0800a8cc <SFU_LL_FLASH_Config_Exe>:
   * Internal flash : nothing to do
   * External flash : configure memory mapped mode
   */

  /* Check Flash address */
  if (SlotStartAdd[SlotNumber] < EXTERNAL_FLASH_ADDRESS)
 800a8cc:	4b04      	ldr	r3, [pc, #16]	@ (800a8e0 <SFU_LL_FLASH_Config_Exe+0x14>)
 800a8ce:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800a8d2:	f1b3 4f10 	cmp.w	r3, #2415919104	@ 0x90000000
 800a8d6:	d301      	bcc.n	800a8dc <SFU_LL_FLASH_Config_Exe+0x10>
  {
    return SFU_SUCCESS;
  }
  else
  {
    return SFU_LL_FLASH_EXT_Config_Exe(SlotNumber);
 800a8d8:	f000 b816 	b.w	800a908 <SFU_LL_FLASH_EXT_Config_Exe>
  }
}
 800a8dc:	4801      	ldr	r0, [pc, #4]	@ (800a8e4 <SFU_LL_FLASH_Config_Exe+0x18>)
 800a8de:	4770      	bx	lr
 800a8e0:	0800e33c 	.word	0x0800e33c
 800a8e4:	00122f11 	.word	0x00122f11

0800a8e8 <SFU_LL_FLASH_EXT_Init>:
       systematically during startup phase */

SFU_ErrorStatus SFU_LL_FLASH_EXT_Init(void)
{
  return SFU_SUCCESS;
}
 800a8e8:	4800      	ldr	r0, [pc, #0]	@ (800a8ec <SFU_LL_FLASH_EXT_Init+0x4>)
 800a8ea:	4770      	bx	lr
 800a8ec:	00122f11 	.word	0x00122f11

0800a8f0 <SFU_LL_FLASH_EXT_Erase_Size>:
{
  UNUSED(pFlashStatus);
  UNUSED(pStart);
  UNUSED(Length);
  return SFU_ERROR;
}
 800a8f0:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a8f4:	4770      	bx	lr

0800a8f6 <SFU_LL_FLASH_EXT_Write>:
  UNUSED(pFlashStatus);
  UNUSED(pDestination);
  UNUSED(pSource);
  UNUSED(Length);
  return SFU_ERROR;
}
 800a8f6:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a8fa:	4770      	bx	lr

0800a8fc <SFU_LL_FLASH_EXT_Read>:

SFU_ErrorStatus SFU_LL_FLASH_EXT_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
 800a8fc:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a900:	4770      	bx	lr

0800a902 <SFU_LL_FLASH_EXT_Compare>:
  UNUSED(pFlash);
  UNUSED(Pattern1);
  UNUSED(Pattern2);
  UNUSED(Length);
  return SFU_ERROR;
}
 800a902:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800a906:	4770      	bx	lr

0800a908 <SFU_LL_FLASH_EXT_Config_Exe>:
SFU_ErrorStatus SFU_LL_FLASH_EXT_Config_Exe(uint32_t SlotNumber)
{
  UNUSED(SlotNumber);
  return SFU_SUCCESS;
}
 800a908:	4800      	ldr	r0, [pc, #0]	@ (800a90c <SFU_LL_FLASH_EXT_Config_Exe+0x4>)
 800a90a:	4770      	bx	lr
 800a90c:	00122f11 	.word	0x00122f11

0800a910 <SFU_LL_FLASH_INT_Clear_Error>:
  * @brief  Clear error flags raised during previous operation
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
static SFU_ErrorStatus SFU_LL_FLASH_INT_Clear_Error(void)
{
 800a910:	b508      	push	{r3, lr}
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Unlock the Program memory */
  if (HAL_FLASH_Unlock() == HAL_OK)
 800a912:	f000 fd85 	bl	800b420 <HAL_FLASH_Unlock>
 800a916:	b110      	cbz	r0, 800a91e <SFU_LL_FLASH_INT_Clear_Error+0xe>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a918:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
    }
  }

  return e_ret_status;

}
 800a91c:	bd08      	pop	{r3, pc}
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS_BANK1);
 800a91e:	4b05      	ldr	r3, [pc, #20]	@ (800a934 <SFU_LL_FLASH_INT_Clear_Error+0x24>)
 800a920:	4a05      	ldr	r2, [pc, #20]	@ (800a938 <SFU_LL_FLASH_INT_Clear_Error+0x28>)
 800a922:	615a      	str	r2, [r3, #20]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS_BANK2);
 800a924:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
    if (HAL_FLASH_Lock() == HAL_OK)
 800a928:	f000 fda0 	bl	800b46c <HAL_FLASH_Lock>
 800a92c:	2800      	cmp	r0, #0
 800a92e:	d1f3      	bne.n	800a918 <SFU_LL_FLASH_INT_Clear_Error+0x8>
      e_ret_status = SFU_SUCCESS;
 800a930:	4802      	ldr	r0, [pc, #8]	@ (800a93c <SFU_LL_FLASH_INT_Clear_Error+0x2c>)
  return e_ret_status;
 800a932:	e7f3      	b.n	800a91c <SFU_LL_FLASH_INT_Clear_Error+0xc>
 800a934:	52002000 	.word	0x52002000
 800a938:	17ee0000 	.word	0x17ee0000
 800a93c:	00122f11 	.word	0x00122f11

0800a940 <SFU_LL_FLASH_INT_Init>:
}
 800a940:	4800      	ldr	r0, [pc, #0]	@ (800a944 <SFU_LL_FLASH_INT_Init+0x4>)
 800a942:	4770      	bx	lr
 800a944:	00122f11 	.word	0x00122f11

0800a948 <SFU_LL_FLASH_INT_Write>:
{
 800a948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a94c:	4690      	mov	r8, r2
 800a94e:	b085      	sub	sp, #20
 800a950:	461f      	mov	r7, r3
  uint32_t destination = (uint32_t)pDestination;
 800a952:	4689      	mov	r9, r1
  if ((pFlashStatus == NULL) || (pSource == NULL))
 800a954:	4606      	mov	r6, r0
 800a956:	2800      	cmp	r0, #0
 800a958:	d038      	beq.n	800a9cc <SFU_LL_FLASH_INT_Write+0x84>
 800a95a:	2a00      	cmp	r2, #0
 800a95c:	d036      	beq.n	800a9cc <SFU_LL_FLASH_INT_Write+0x84>
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800a95e:	4b2d      	ldr	r3, [pc, #180]	@ (800aa14 <SFU_LL_FLASH_INT_Write+0xcc>)
        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800a960:	19c8      	adds	r0, r1, r7
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800a962:	685b      	ldr	r3, [r3, #4]
 800a964:	428b      	cmp	r3, r1
        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800a966:	f503 6280 	add.w	r2, r3, #1024	@ 0x400
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800a96a:	d815      	bhi.n	800a998 <SFU_LL_FLASH_INT_Write+0x50>
 800a96c:	4290      	cmp	r0, r2
 800a96e:	d813      	bhi.n	800a998 <SFU_LL_FLASH_INT_Write+0x50>
  if ((inside_header == 1U) && (Length != 0U))
 800a970:	b197      	cbz	r7, 800a998 <SFU_LL_FLASH_INT_Write+0x50>
    SE_ErrorStatus se_ret_status = SE_SFU_IMG_Write(&se_status, (uint8_t *)destination, pSource, Length);
 800a972:	463b      	mov	r3, r7
 800a974:	4642      	mov	r2, r8
 800a976:	a803      	add	r0, sp, #12
      *pFlashStatus = SFU_FLASH_SUCCESS;
 800a978:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
    SE_ErrorStatus se_ret_status = SE_SFU_IMG_Write(&se_status, (uint8_t *)destination, pSource, Length);
 800a97c:	f7fd fc7a 	bl	8008274 <SE_SFU_IMG_Write>
    if (se_ret_status == SE_SUCCESS)
 800a980:	4b25      	ldr	r3, [pc, #148]	@ (800aa18 <SFU_LL_FLASH_INT_Write+0xd0>)
      *pFlashStatus = SFU_FLASH_SUCCESS;
 800a982:	4a26      	ldr	r2, [pc, #152]	@ (800aa1c <SFU_LL_FLASH_INT_Write+0xd4>)
 800a984:	4298      	cmp	r0, r3
 800a986:	bf12      	itee	ne
 800a988:	2300      	movne	r3, #0
 800a98a:	2305      	moveq	r3, #5
 800a98c:	4614      	moveq	r4, r2
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800a98e:	7033      	strb	r3, [r6, #0]
}
 800a990:	4620      	mov	r0, r4
 800a992:	b005      	add	sp, #20
 800a994:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *pFlashStatus = SFU_FLASH_ERROR;
 800a998:	2300      	movs	r3, #0
 800a99a:	7033      	strb	r3, [r6, #0]
    e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800a99c:	f7ff ffb8 	bl	800a910 <SFU_LL_FLASH_INT_Clear_Error>
    if (e_ret_status == SFU_SUCCESS)
 800a9a0:	4b1e      	ldr	r3, [pc, #120]	@ (800aa1c <SFU_LL_FLASH_INT_Write+0xd4>)
    e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800a9a2:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 800a9a4:	4298      	cmp	r0, r3
 800a9a6:	d1f3      	bne.n	800a990 <SFU_LL_FLASH_INT_Write+0x48>
      if (HAL_FLASH_Unlock() != HAL_OK)
 800a9a8:	f000 fd3a 	bl	800b420 <HAL_FLASH_Unlock>
 800a9ac:	4605      	mov	r5, r0
 800a9ae:	b980      	cbnz	r0, 800a9d2 <SFU_LL_FLASH_INT_Write+0x8a>
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800a9b0:	46a2      	mov	sl, r4
          *pFlashStatus = SFU_FLASH_ERROR;
 800a9b2:	4683      	mov	fp, r0
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800a9b4:	42bd      	cmp	r5, r7
 800a9b6:	d203      	bcs.n	800a9c0 <SFU_LL_FLASH_INT_Write+0x78>
 800a9b8:	4554      	cmp	r4, sl
 800a9ba:	d00c      	beq.n	800a9d6 <SFU_LL_FLASH_INT_Write+0x8e>
 800a9bc:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
        if (HAL_FLASH_Lock() != HAL_OK)
 800a9c0:	f000 fd54 	bl	800b46c <HAL_FLASH_Lock>
 800a9c4:	2800      	cmp	r0, #0
 800a9c6:	d0e3      	beq.n	800a990 <SFU_LL_FLASH_INT_Write+0x48>
          *pFlashStatus = SFU_FLASH_ERR_HAL;
 800a9c8:	2301      	movs	r3, #1
 800a9ca:	7033      	strb	r3, [r6, #0]
    return SFU_ERROR;
 800a9cc:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
 800a9d0:	e7de      	b.n	800a990 <SFU_LL_FLASH_INT_Write+0x48>
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800a9d2:	2301      	movs	r3, #1
 800a9d4:	e7db      	b.n	800a98e <SFU_LL_FLASH_INT_Write+0x46>
          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, destination, (source + i)) == HAL_OK)
 800a9d6:	eb08 0305 	add.w	r3, r8, r5
 800a9da:	4649      	mov	r1, r9
 800a9dc:	2001      	movs	r0, #1
          *pFlashStatus = SFU_FLASH_ERROR;
 800a9de:	f886 b000 	strb.w	fp, [r6]
          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, destination, (source + i)) == HAL_OK)
 800a9e2:	461a      	mov	r2, r3
 800a9e4:	9301      	str	r3, [sp, #4]
 800a9e6:	f000 fdd3 	bl	800b590 <HAL_FLASH_Program>
 800a9ea:	b960      	cbnz	r0, 800aa06 <SFU_LL_FLASH_INT_Write+0xbe>
            if (memcmp((void *)destination, (void *)(source + i), sizeof(SFU_LL_FLASH_write_t)) != 0)
 800a9ec:	9b01      	ldr	r3, [sp, #4]
 800a9ee:	2220      	movs	r2, #32
 800a9f0:	4648      	mov	r0, r9
 800a9f2:	4619      	mov	r1, r3
 800a9f4:	f002 feb8 	bl	800d768 <memcmp>
 800a9f8:	b948      	cbnz	r0, 800aa0e <SFU_LL_FLASH_INT_Write+0xc6>
              destination = destination + sizeof(SFU_LL_FLASH_write_t);
 800a9fa:	f109 0920 	add.w	r9, r9, #32
 800a9fe:	2305      	movs	r3, #5
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800aa00:	3520      	adds	r5, #32
              *pFlashStatus = SFU_FLASH_SUCCESS;
 800aa02:	7033      	strb	r3, [r6, #0]
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS); i += sizeof(SFU_LL_FLASH_write_t))
 800aa04:	e7d6      	b.n	800a9b4 <SFU_LL_FLASH_INT_Write+0x6c>
 800aa06:	2303      	movs	r3, #3
            e_ret_status = SFU_ERROR;
 800aa08:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
 800aa0c:	e7f8      	b.n	800aa00 <SFU_LL_FLASH_INT_Write+0xb8>
 800aa0e:	2304      	movs	r3, #4
 800aa10:	e7fa      	b.n	800aa08 <SFU_LL_FLASH_INT_Write+0xc0>
 800aa12:	bf00      	nop
 800aa14:	0800e37c 	.word	0x0800e37c
 800aa18:	0012310f 	.word	0x0012310f
 800aa1c:	00122f11 	.word	0x00122f11

0800aa20 <SFU_LL_FLASH_INT_Read>:
{
 800aa20:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800aa22:	4613      	mov	r3, r2
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800aa24:	4a1d      	ldr	r2, [pc, #116]	@ (800aa9c <SFU_LL_FLASH_INT_Read+0x7c>)
 800aa26:	6852      	ldr	r2, [r2, #4]
        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800aa28:	18cd      	adds	r5, r1, r3
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800aa2a:	428a      	cmp	r2, r1
        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800aa2c:	f502 6480 	add.w	r4, r2, #1024	@ 0x400
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800aa30:	d81b      	bhi.n	800aa6a <SFU_LL_FLASH_INT_Read+0x4a>
 800aa32:	42a5      	cmp	r5, r4
 800aa34:	d819      	bhi.n	800aa6a <SFU_LL_FLASH_INT_Read+0x4a>
    DoubleECC_Error_Counter = 0U;
 800aa36:	2200      	movs	r2, #0
 800aa38:	4c19      	ldr	r4, [pc, #100]	@ (800aaa0 <SFU_LL_FLASH_INT_Read+0x80>)
 800aa3a:	6022      	str	r2, [r4, #0]
    se_ret_status = SE_SFU_IMG_Read(&se_status, pDestination, (uint8_t *)source, Length);
 800aa3c:	460a      	mov	r2, r1
 800aa3e:	4601      	mov	r1, r0
 800aa40:	a801      	add	r0, sp, #4
 800aa42:	f7fd fbdf 	bl	8008204 <SE_SFU_IMG_Read>
    if ((se_ret_status == SE_SUCCESS) && (DoubleECC_Error_Counter == 0U))
 800aa46:	4b17      	ldr	r3, [pc, #92]	@ (800aaa4 <SFU_LL_FLASH_INT_Read+0x84>)
 800aa48:	4298      	cmp	r0, r3
 800aa4a:	d10b      	bne.n	800aa64 <SFU_LL_FLASH_INT_Read+0x44>
 800aa4c:	6822      	ldr	r2, [r4, #0]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800aa4e:	f5a3 73ff 	sub.w	r3, r3, #510	@ 0x1fe
 800aa52:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800aa56:	2a00      	cmp	r2, #0
 800aa58:	bf08      	it	eq
 800aa5a:	4618      	moveq	r0, r3
    DoubleECC_Error_Counter = 0U;
 800aa5c:	2300      	movs	r3, #0
 800aa5e:	6023      	str	r3, [r4, #0]
}
 800aa60:	b003      	add	sp, #12
 800aa62:	bd30      	pop	{r4, r5, pc}
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800aa64:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800aa68:	e7f8      	b.n	800aa5c <SFU_LL_FLASH_INT_Read+0x3c>
    DoubleECC_Error_Counter = 0U;
 800aa6a:	4a0d      	ldr	r2, [pc, #52]	@ (800aaa0 <SFU_LL_FLASH_INT_Read+0x80>)
 800aa6c:	2400      	movs	r4, #0
 800aa6e:	3901      	subs	r1, #1
 800aa70:	4403      	add	r3, r0
 800aa72:	6014      	str	r4, [r2, #0]
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800aa74:	4298      	cmp	r0, r3
 800aa76:	d109      	bne.n	800aa8c <SFU_LL_FLASH_INT_Read+0x6c>
    if (DoubleECC_Error_Counter == 0U)
 800aa78:	6811      	ldr	r1, [r2, #0]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800aa7a:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800aa7e:	4b0a      	ldr	r3, [pc, #40]	@ (800aaa8 <SFU_LL_FLASH_INT_Read+0x88>)
 800aa80:	2900      	cmp	r1, #0
 800aa82:	bf08      	it	eq
 800aa84:	4618      	moveq	r0, r3
    DoubleECC_Error_Counter = 0U;
 800aa86:	2300      	movs	r3, #0
 800aa88:	6013      	str	r3, [r2, #0]
  return e_ret_status;
 800aa8a:	e7e9      	b.n	800aa60 <SFU_LL_FLASH_INT_Read+0x40>
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800aa8c:	6814      	ldr	r4, [r2, #0]
 800aa8e:	2c00      	cmp	r4, #0
 800aa90:	d1f2      	bne.n	800aa78 <SFU_LL_FLASH_INT_Read+0x58>
      *pDestination = *pSource;
 800aa92:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800aa96:	f800 4b01 	strb.w	r4, [r0], #1
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800aa9a:	e7eb      	b.n	800aa74 <SFU_LL_FLASH_INT_Read+0x54>
 800aa9c:	0800e37c 	.word	0x0800e37c
 800aaa0:	20001d54 	.word	0x20001d54
 800aaa4:	0012310f 	.word	0x0012310f
 800aaa8:	00122f11 	.word	0x00122f11

0800aaac <SFU_LL_FLASH_INT_Compare>:
{
 800aaac:	b570      	push	{r4, r5, r6, lr}
  DoubleECC_Error_Counter = 0U;
 800aaae:	4d0a      	ldr	r5, [pc, #40]	@ (800aad8 <SFU_LL_FLASH_INT_Compare+0x2c>)
 800aab0:	2400      	movs	r4, #0
 800aab2:	602c      	str	r4, [r5, #0]
  for ( i = 0U; i < Length; i += 4U)
 800aab4:	429c      	cmp	r4, r3
 800aab6:	d305      	bcc.n	800aac4 <SFU_LL_FLASH_INT_Compare+0x18>
  if (i != Length)
 800aab8:	d10b      	bne.n	800aad2 <SFU_LL_FLASH_INT_Compare+0x26>
  if (DoubleECC_Error_Counter != 0U)
 800aaba:	682b      	ldr	r3, [r5, #0]
 800aabc:	b94b      	cbnz	r3, 800aad2 <SFU_LL_FLASH_INT_Compare+0x26>
  return SFU_SUCCESS;
 800aabe:	4807      	ldr	r0, [pc, #28]	@ (800aadc <SFU_LL_FLASH_INT_Compare+0x30>)
  DoubleECC_Error_Counter = 0U;
 800aac0:	602b      	str	r3, [r5, #0]
}
 800aac2:	bd70      	pop	{r4, r5, r6, pc}
    if ((*(uint32_t *)(flash + i) != Pattern1) &&  (*(uint32_t *)(flash + i) != Pattern2))
 800aac4:	5906      	ldr	r6, [r0, r4]
 800aac6:	428e      	cmp	r6, r1
 800aac8:	d001      	beq.n	800aace <SFU_LL_FLASH_INT_Compare+0x22>
 800aaca:	4296      	cmp	r6, r2
 800aacc:	d101      	bne.n	800aad2 <SFU_LL_FLASH_INT_Compare+0x26>
  for ( i = 0U; i < Length; i += 4U)
 800aace:	3404      	adds	r4, #4
 800aad0:	e7f0      	b.n	800aab4 <SFU_LL_FLASH_INT_Compare+0x8>
      return SFU_ERROR;
 800aad2:	f641 70e1 	movw	r0, #8161	@ 0x1fe1
 800aad6:	e7f4      	b.n	800aac2 <SFU_LL_FLASH_INT_Compare+0x16>
 800aad8:	20001d54 	.word	0x20001d54
 800aadc:	00122f11 	.word	0x00122f11

0800aae0 <SFU_LL_FLASH_INT_GetSector>:
  if (Add < (FLASH_BASE + (SFU_FLASH_BANK_SIZE)))
 800aae0:	f1b0 6f01 	cmp.w	r0, #135266304	@ 0x8100000
    sector = (Add - FLASH_BASE) / FLASH_SECTOR_SIZE;
 800aae4:	bf34      	ite	cc
 800aae6:	f100 4078 	addcc.w	r0, r0, #4160749568	@ 0xf8000000
    sector = (Add - (FLASH_BASE + (SFU_FLASH_BANK_SIZE))) / FLASH_SECTOR_SIZE;
 800aaea:	f1a0 6001 	subcs.w	r0, r0, #135266304	@ 0x8100000
 800aaee:	0c40      	lsrs	r0, r0, #17
}
 800aaf0:	4770      	bx	lr
	...

0800aaf4 <SFU_LL_FLASH_INT_GetBank>:
  if (READ_BIT(FLASH->OPTCCR, FLASH_OPTCR_SWAP_BANK) == 0U)
 800aaf4:	4b07      	ldr	r3, [pc, #28]	@ (800ab14 <SFU_LL_FLASH_INT_GetBank+0x20>)
 800aaf6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aaf8:	2b00      	cmp	r3, #0
 800aafa:	db05      	blt.n	800ab08 <SFU_LL_FLASH_INT_GetBank+0x14>
      bank = FLASH_BANK_2;
 800aafc:	f1b0 6f01 	cmp.w	r0, #135266304	@ 0x8100000
 800ab00:	bf34      	ite	cc
 800ab02:	2001      	movcc	r0, #1
 800ab04:	2002      	movcs	r0, #2
 800ab06:	4770      	bx	lr
      bank = FLASH_BANK_1;
 800ab08:	f1b0 6f01 	cmp.w	r0, #135266304	@ 0x8100000
 800ab0c:	bf34      	ite	cc
 800ab0e:	2002      	movcc	r0, #2
 800ab10:	2001      	movcs	r0, #1
}
 800ab12:	4770      	bx	lr
 800ab14:	52002000 	.word	0x52002000

0800ab18 <SFU_LL_FLASH_INT_Erase_Size>:
{
 800ab18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t sector_error = 0U;
 800ab1c:	2300      	movs	r3, #0
{
 800ab1e:	b086      	sub	sp, #24
 800ab20:	460c      	mov	r4, r1
 800ab22:	4690      	mov	r8, r2
  if (pFlashStatus == NULL)
 800ab24:	4606      	mov	r6, r0
  uint32_t sector_error = 0U;
 800ab26:	9300      	str	r3, [sp, #0]
  if (pFlashStatus == NULL)
 800ab28:	2800      	cmp	r0, #0
 800ab2a:	d045      	beq.n	800abb8 <SFU_LL_FLASH_INT_Erase_Size+0xa0>
  *pFlashStatus = SFU_FLASH_SUCCESS;
 800ab2c:	2305      	movs	r3, #5
 800ab2e:	7003      	strb	r3, [r0, #0]
  e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800ab30:	f7ff feee 	bl	800a910 <SFU_LL_FLASH_INT_Clear_Error>
  if (e_ret_status == SFU_SUCCESS)
 800ab34:	4b36      	ldr	r3, [pc, #216]	@ (800ac10 <SFU_LL_FLASH_INT_Erase_Size+0xf8>)
  e_ret_status = SFU_LL_FLASH_INT_Clear_Error();
 800ab36:	4607      	mov	r7, r0
  if (e_ret_status == SFU_SUCCESS)
 800ab38:	4298      	cmp	r0, r3
 800ab3a:	d13f      	bne.n	800abbc <SFU_LL_FLASH_INT_Erase_Size+0xa4>
    if (HAL_FLASH_Unlock() == HAL_OK)
 800ab3c:	f000 fc70 	bl	800b420 <HAL_FLASH_Unlock>
 800ab40:	2800      	cmp	r0, #0
 800ab42:	d162      	bne.n	800ac0a <SFU_LL_FLASH_INT_Erase_Size+0xf2>
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800ab44:	f04f 0a02 	mov.w	sl, #2
        if (SFU_LL_FLASH_INT_GetBank(start + length - 1U) == bank_number)
 800ab48:	44a0      	add	r8, r4
        first_sector = SFU_LL_FLASH_INT_GetSector(start);
 800ab4a:	4620      	mov	r0, r4
 800ab4c:	f7ff ffc8 	bl	800aae0 <SFU_LL_FLASH_INT_GetSector>
 800ab50:	4605      	mov	r5, r0
        if (SFU_LL_FLASH_INT_GetBank(start + length - 1U) == bank_number)
 800ab52:	f108 31ff 	add.w	r1, r8, #4294967295
        bank_number = SFU_LL_FLASH_INT_GetBank(start);
 800ab56:	4620      	mov	r0, r4
 800ab58:	f7ff ffcc 	bl	800aaf4 <SFU_LL_FLASH_INT_GetBank>
 800ab5c:	4602      	mov	r2, r0
        if (SFU_LL_FLASH_INT_GetBank(start + length - 1U) == bank_number)
 800ab5e:	4608      	mov	r0, r1
 800ab60:	f7ff ffc8 	bl	800aaf4 <SFU_LL_FLASH_INT_GetBank>
 800ab64:	4290      	cmp	r0, r2
 800ab66:	4603      	mov	r3, r0
 800ab68:	d12c      	bne.n	800abc4 <SFU_LL_FLASH_INT_Erase_Size+0xac>
          nb_sectors = SFU_LL_FLASH_INT_GetSector(start + length - 1U) - first_sector + 1U;
 800ab6a:	f1c5 0401 	rsb	r4, r5, #1
          p_erase_init.TypeErase     = FLASH_TYPEERASE_SECTORS;
 800ab6e:	2200      	movs	r2, #0
          nb_sectors = SFU_LL_FLASH_INT_GetSector(start + length - 1U) - first_sector + 1U;
 800ab70:	4608      	mov	r0, r1
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800ab72:	f04f 0802 	mov.w	r8, #2
          nb_sectors = SFU_LL_FLASH_INT_GetSector(start + length - 1U) - first_sector + 1U;
 800ab76:	f7ff ffb3 	bl	800aae0 <SFU_LL_FLASH_INT_GetSector>
 800ab7a:	4404      	add	r4, r0
          p_erase_init.Banks         = bank_number;
 800ab7c:	e9cd 2301 	strd	r2, r3, [sp, #4]
          p_erase_init.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
 800ab80:	2320      	movs	r3, #32
 800ab82:	9305      	str	r3, [sp, #20]
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800ab84:	2c02      	cmp	r4, #2
 800ab86:	4623      	mov	r3, r4
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800ab88:	4669      	mov	r1, sp
 800ab8a:	a801      	add	r0, sp, #4
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800ab8c:	bf28      	it	cs
 800ab8e:	2302      	movcs	r3, #2
            p_erase_init.NbSectors = chunk_nb_sectors;
 800ab90:	e9cd 5303 	strd	r5, r3, [sp, #12]
            nb_sectors -= chunk_nb_sectors;
 800ab94:	1ae4      	subs	r4, r4, r3
            first_sector += chunk_nb_sectors;
 800ab96:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800ab98:	f000 ffc8 	bl	800bb2c <HAL_FLASHEx_Erase>
 800ab9c:	b118      	cbz	r0, 800aba6 <SFU_LL_FLASH_INT_Erase_Size+0x8e>
              e_ret_status = SFU_ERROR;
 800ab9e:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800aba2:	f886 8000 	strb.w	r8, [r6]
            SFU_LL_SECU_IWDG_Refresh(); /* calling this function which checks the compiler switch */
 800aba6:	f000 f939 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
          } while (nb_sectors > 0U);
 800abaa:	2c00      	cmp	r4, #0
 800abac:	d1ea      	bne.n	800ab84 <SFU_LL_FLASH_INT_Erase_Size+0x6c>
      if (HAL_FLASH_Lock() != HAL_OK)
 800abae:	f000 fc5d 	bl	800b46c <HAL_FLASH_Lock>
 800abb2:	b118      	cbz	r0, 800abbc <SFU_LL_FLASH_INT_Erase_Size+0xa4>
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800abb4:	2301      	movs	r3, #1
 800abb6:	7033      	strb	r3, [r6, #0]
    return SFU_ERROR;
 800abb8:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
}
 800abbc:	4638      	mov	r0, r7
 800abbe:	b006      	add	sp, #24
 800abc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          p_erase_init.TypeErase     = FLASH_TYPEERASE_SECTORS;
 800abc4:	2300      	movs	r3, #0
          nb_sectors = SFU_LL_FLASH_INT_GetSector(startbank2 - 1U) - first_sector + 1U;
 800abc6:	f1c5 0908 	rsb	r9, r5, #8
          length = length  - (startbank2 - start);
 800abca:	f1a8 6801 	sub.w	r8, r8, #135266304	@ 0x8100000
          p_erase_init.TypeErase     = FLASH_TYPEERASE_SECTORS;
 800abce:	f04f 6401 	mov.w	r4, #135266304	@ 0x8100000
          p_erase_init.Banks         = bank_number;
 800abd2:	e9cd 3201 	strd	r3, r2, [sp, #4]
          p_erase_init.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
 800abd6:	2320      	movs	r3, #32
 800abd8:	9305      	str	r3, [sp, #20]
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800abda:	464b      	mov	r3, r9
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800abdc:	4669      	mov	r1, sp
 800abde:	a801      	add	r0, sp, #4
            chunk_nb_sectors = (nb_sectors >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_sectors;
 800abe0:	2b02      	cmp	r3, #2
 800abe2:	bf28      	it	cs
 800abe4:	2302      	movcs	r3, #2
            p_erase_init.NbSectors = chunk_nb_sectors;
 800abe6:	e9cd 5303 	strd	r5, r3, [sp, #12]
            nb_sectors -= chunk_nb_sectors;
 800abea:	eba9 0903 	sub.w	r9, r9, r3
            first_sector += chunk_nb_sectors;
 800abee:	441d      	add	r5, r3
            if (HAL_FLASHEx_Erase(&p_erase_init, &sector_error) != HAL_OK)
 800abf0:	f000 ff9c 	bl	800bb2c <HAL_FLASHEx_Erase>
 800abf4:	b118      	cbz	r0, 800abfe <SFU_LL_FLASH_INT_Erase_Size+0xe6>
              e_ret_status = SFU_ERROR;
 800abf6:	f641 77e1 	movw	r7, #8161	@ 0x1fe1
              *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800abfa:	f886 a000 	strb.w	sl, [r6]
            SFU_LL_SECU_IWDG_Refresh(); /* calling this function which checks the compiler switch */
 800abfe:	f000 f90d 	bl	800ae1c <SFU_LL_SECU_IWDG_Refresh>
          } while (nb_sectors > 0U);
 800ac02:	f1b9 0f00 	cmp.w	r9, #0
 800ac06:	d1e8      	bne.n	800abda <SFU_LL_FLASH_INT_Erase_Size+0xc2>
 800ac08:	e79e      	b.n	800ab48 <SFU_LL_FLASH_INT_Erase_Size+0x30>
      *pFlashStatus = SFU_FLASH_ERR_HAL;
 800ac0a:	2301      	movs	r3, #1
 800ac0c:	7033      	strb	r3, [r6, #0]
 800ac0e:	e7d5      	b.n	800abbc <SFU_LL_FLASH_INT_Erase_Size+0xa4>
 800ac10:	00122f11 	.word	0x00122f11

0800ac14 <NMI_Handler>:
  * @param  None.
  * @retval None.
  */
void NMI_Handler(void)
{
  while (1 == 1)
 800ac14:	e7fe      	b.n	800ac14 <NMI_Handler>
	...

0800ac18 <HardFault_Handler>:
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;

  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_DBECCE_BANK1RR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_DBECCE_BANK2RR))
 800ac18:	4b19      	ldr	r3, [pc, #100]	@ (800ac80 <HardFault_Handler+0x68>)
 800ac1a:	691a      	ldr	r2, [r3, #16]
 800ac1c:	0152      	lsls	r2, r2, #5
 800ac1e:	d403      	bmi.n	800ac28 <HardFault_Handler+0x10>
 800ac20:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 800ac24:	0150      	lsls	r0, r2, #5
 800ac26:	d528      	bpl.n	800ac7a <HardFault_Handler+0x62>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_DBECCE_BANK1RR);
 800ac28:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 800ac2c:	615a      	str	r2, [r3, #20]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_DBECCE_BANK2RR);
 800ac2e:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114

    /* Memorize error to ignore the read value */
    DoubleECC_Error_Counter++;
 800ac32:	4a14      	ldr	r2, [pc, #80]	@ (800ac84 <HardFault_Handler+0x6c>)
 800ac34:	6813      	ldr	r3, [r2, #0]
 800ac36:	3301      	adds	r3, #1
 800ac38:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 800ac3a:	4673      	mov	r3, lr

    lr = get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 800ac3c:	f003 030f 	and.w	r3, r3, #15
 800ac40:	2b0d      	cmp	r3, #13
 800ac42:	d114      	bne.n	800ac6e <HardFault_Handler+0x56>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800ac44:	f3ef 8209 	mrs	r2, PSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 800ac48:	e9d2 3106 	ldrd	r3, r1, [r2, #24]
 800ac4c:	01c9      	lsls	r1, r1, #7
 800ac4e:	d50c      	bpl.n	800ac6a <HardFault_Handler+0x52>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 800ac50:	f023 0101 	bic.w	r1, r3, #1
 800ac54:	8809      	ldrh	r1, [r1, #0]
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 800ac56:	f401 4068 	and.w	r0, r1, #59392	@ 0xe800
 800ac5a:	f5b0 4f68 	cmp.w	r0, #59392	@ 0xe800
 800ac5e:	d004      	beq.n	800ac6a <HardFault_Handler+0x52>
 800ac60:	f401 4178 	and.w	r1, r1, #63488	@ 0xf800
 800ac64:	f5b1 4f70 	cmp.w	r1, #61440	@ 0xf000
 800ac68:	d104      	bne.n	800ac74 <HardFault_Handler+0x5c>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 800ac6a:	3304      	adds	r3, #4
 800ac6c:	e003      	b.n	800ac76 <HardFault_Handler+0x5e>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800ac6e:	f3ef 8208 	mrs	r2, MSP
  return(result);
 800ac72:	e7e9      	b.n	800ac48 <HardFault_Handler+0x30>
        *(p_sp + 6U) += 2U;
 800ac74:	3302      	adds	r3, #2
      *(p_sp + 6U) += 4U;
 800ac76:	6193      	str	r3, [r2, #24]
  }
  else
  {
    SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_HARD_FAULT);
  }
}
 800ac78:	4770      	bx	lr
    SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_HARD_FAULT);
 800ac7a:	2002      	movs	r0, #2
 800ac7c:	f7fe be9a 	b.w	80099b4 <SFU_EXCPT_IrqExceptionHandler>
 800ac80:	52002000 	.word	0x52002000
 800ac84:	20001d54 	.word	0x20001d54

0800ac88 <SFU_LL_SECU_CheckApplyStaticProtections>:
  *         flash sections in order to maximize the security level for the specific MCU.
  * @retval uint32_t CRC (returned value is the combination of all the applied protections.
  *         If different from SFU_STD_PROTECTION_ALL, 1 or more protections cannot be applied)
  */
SFU_ErrorStatus SFU_LL_SECU_CheckApplyStaticProtections(void)
{
 800ac88:	b510      	push	{r4, lr}
 800ac8a:	b092      	sub	sp, #72	@ 0x48

  /* Unlock the Options Bytes *************************************************/
  (void) HAL_FLASH_OB_Unlock();

  /* Get Option Bytes status for FLASH_BANK_1: WRP, PCRoP, SecureArea **********/
  flash_option_bytes.Banks = FLASH_BANK_1;
 800ac8c:	2401      	movs	r4, #1
  (void) HAL_FLASH_Unlock();
 800ac8e:	f000 fbc7 	bl	800b420 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_ALL_ERRORS_BANK1);
 800ac92:	4b2f      	ldr	r3, [pc, #188]	@ (800ad50 <SFU_LL_SECU_CheckApplyStaticProtections+0xc8>)
 800ac94:	4a2f      	ldr	r2, [pc, #188]	@ (800ad54 <SFU_LL_SECU_CheckApplyStaticProtections+0xcc>)
 800ac96:	615a      	str	r2, [r3, #20]
  (void) HAL_FLASH_OB_Unlock();
 800ac98:	f000 fc00 	bl	800b49c <HAL_FLASH_OB_Unlock>
  (void) HAL_FLASHEx_OBGetConfig(&flash_option_bytes);
 800ac9c:	a801      	add	r0, sp, #4
  flash_option_bytes.Banks = FLASH_BANK_1;
 800ac9e:	9408      	str	r4, [sp, #32]
  (void) HAL_FLASHEx_OBGetConfig(&flash_option_bytes);
 800aca0:	f000 feb8 	bl	800ba14 <HAL_FLASHEx_OBGetConfig>

  /* Check/Apply RDP_Level 1. This is the minimum protection allowed */
  /* if RDP_Level 2 is already applied it's not possible to modify the OptionBytes anymore */
  if (flash_option_bytes.RDPLevel == OB_RDP_LEVEL_2)
 800aca4:	9b04      	ldr	r3, [sp, #16]
 800aca6:	f5b3 4f4c 	cmp.w	r3, #52224	@ 0xcc00
 800acaa:	9b07      	ldr	r3, [sp, #28]
 800acac:	d121      	bne.n	800acf2 <SFU_LL_SECU_CheckApplyStaticProtections+0x6a>
  /*
   * The Flash interface allows swapping bank 1 and bank 2 memory mapping.
   * Check that we do not swap Bank1 and Bank2.
   * Bank swapping is controlled by the SWAP_BANK bit located in the FLASH_OPTCR register.
   */
  if ((psFlashOptionBytes->USERConfig & OB_SWAP_BANK_ENABLE) == OB_SWAP_BANK_DISABLE)
 800acae:	2b00      	cmp	r3, #0
 800acb0:	4c29      	ldr	r4, [pc, #164]	@ (800ad58 <SFU_LL_SECU_CheckApplyStaticProtections+0xd0>)
 800acb2:	da05      	bge.n	800acc0 <SFU_LL_SECU_CheckApplyStaticProtections+0x38>
      TRACE("\r\n= [SBOOT] Flash configuration failed! Product blocked.");
 800acb4:	4829      	ldr	r0, [pc, #164]	@ (800ad5c <SFU_LL_SECU_CheckApplyStaticProtections+0xd4>)
 800acb6:	f002 fb5b 	bl	800d370 <iprintf>
  }

  if (e_ret_status == SFU_SUCCESS)
  {
    /* Execution stopped if flow control failed */
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800acba:	f7fe fe9f 	bl	80099fc <SFU_EXCPT_Security_Error>
  }
  return e_ret_status;
 800acbe:	e009      	b.n	800acd4 <SFU_LL_SECU_CheckApplyStaticProtections+0x4c>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800acc0:	6822      	ldr	r2, [r4, #0]
 800acc2:	f482 43cf 	eor.w	r3, r2, #26496	@ 0x6780
 800acc6:	f083 0307 	eor.w	r3, r3, #7
 800acca:	6023      	str	r3, [r4, #0]
 800accc:	f245 7376 	movw	r3, #22390	@ 0x5776
 800acd0:	429a      	cmp	r2, r3
 800acd2:	d1f2      	bne.n	800acba <SFU_LL_SECU_CheckApplyStaticProtections+0x32>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_RDP, FLOW_CTRL_RDP);
 800acd4:	6822      	ldr	r2, [r4, #0]
 800acd6:	f243 03f1 	movw	r3, #12529	@ 0x30f1
 800acda:	429a      	cmp	r2, r3
 800acdc:	d001      	beq.n	800ace2 <SFU_LL_SECU_CheckApplyStaticProtections+0x5a>
 800acde:	f7fe fe8d 	bl	80099fc <SFU_EXCPT_Security_Error>
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
 800ace2:	4c1f      	ldr	r4, [pc, #124]	@ (800ad60 <SFU_LL_SECU_CheckApplyStaticProtections+0xd8>)
  (void) HAL_FLASH_OB_Lock();
 800ace4:	f000 fbec 	bl	800b4c0 <HAL_FLASH_OB_Lock>
  (void) HAL_FLASH_Lock();
 800ace8:	f000 fbc0 	bl	800b46c <HAL_FLASH_Lock>
}
 800acec:	4620      	mov	r0, r4
 800acee:	b012      	add	sp, #72	@ 0x48
 800acf0:	bd10      	pop	{r4, pc}
  if ((psFlashOptionBytes->USERConfig & OB_SWAP_BANK_ENABLE) == OB_SWAP_BANK_DISABLE)
 800acf2:	2b00      	cmp	r3, #0
 800acf4:	db09      	blt.n	800ad0a <SFU_LL_SECU_CheckApplyStaticProtections+0x82>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800acf6:	4918      	ldr	r1, [pc, #96]	@ (800ad58 <SFU_LL_SECU_CheckApplyStaticProtections+0xd0>)
 800acf8:	680a      	ldr	r2, [r1, #0]
 800acfa:	f482 43cf 	eor.w	r3, r2, #26496	@ 0x6780
 800acfe:	f083 0307 	eor.w	r3, r3, #7
 800ad02:	600b      	str	r3, [r1, #0]
 800ad04:	f245 7376 	movw	r3, #22390	@ 0x5776
 800ad08:	e7e7      	b.n	800acda <SFU_LL_SECU_CheckApplyStaticProtections+0x52>
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
#if defined(SECBOOT_OB_DEV_MODE)
    if (HAL_FLASHEx_OBProgram(psFlashOptionBytes) == HAL_OK)
 800ad0a:	a801      	add	r0, sp, #4
 800ad0c:	f000 fd64 	bl	800b7d8 <HAL_FLASHEx_OBProgram>
 800ad10:	b110      	cbz	r0, 800ad18 <SFU_LL_SECU_CheckApplyStaticProtections+0x90>
    e_ret_status = SFU_LL_SECU_SetFlashConfiguration(&flash_option_bytes, &is_protection_to_be_applied);
 800ad12:	f641 74e1 	movw	r4, #8161	@ 0x1fe1
 800ad16:	e7e5      	b.n	800ace4 <SFU_LL_SECU_CheckApplyStaticProtections+0x5c>
    {
      /* Making sure bank 1 is selected */
      psFlashOptionBytes->Banks = FLASH_BANK_1;
      psFlashOptionBytes->OptionType = OPTIONBYTE_USER;
 800ad18:	2304      	movs	r3, #4
      psFlashOptionBytes->Banks = FLASH_BANK_1;
 800ad1a:	9408      	str	r4, [sp, #32]
      psFlashOptionBytes->OptionType = OPTIONBYTE_USER;
 800ad1c:	9301      	str	r3, [sp, #4]
      psFlashOptionBytes->USERType = OB_USER_SWAP_BANK;
 800ad1e:	f44f 7380 	mov.w	r3, #256	@ 0x100
      psFlashOptionBytes->USERConfig = OB_SWAP_BANK_DISABLE;
 800ad22:	e9cd 3006 	strd	r3, r0, [sp, #24]
      if (HAL_FLASHEx_OBProgram(psFlashOptionBytes) == HAL_OK)
 800ad26:	a801      	add	r0, sp, #4
 800ad28:	f000 fd56 	bl	800b7d8 <HAL_FLASHEx_OBProgram>
 800ad2c:	2800      	cmp	r0, #0
 800ad2e:	d1f0      	bne.n	800ad12 <SFU_LL_SECU_CheckApplyStaticProtections+0x8a>
      {
        *pbIsProtectionToBeApplied |= 1U;
        e_ret_status = SFU_SUCCESS;
        /* Execution stopped if flow control failed */
        FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800ad30:	4909      	ldr	r1, [pc, #36]	@ (800ad58 <SFU_LL_SECU_CheckApplyStaticProtections+0xd0>)
 800ad32:	680a      	ldr	r2, [r1, #0]
 800ad34:	f482 43cf 	eor.w	r3, r2, #26496	@ 0x6780
 800ad38:	f083 0307 	eor.w	r3, r3, #7
 800ad3c:	600b      	str	r3, [r1, #0]
 800ad3e:	f245 7376 	movw	r3, #22390	@ 0x5776
 800ad42:	429a      	cmp	r2, r3
 800ad44:	d001      	beq.n	800ad4a <SFU_LL_SECU_CheckApplyStaticProtections+0xc2>
 800ad46:	f7fe fe59 	bl	80099fc <SFU_EXCPT_Security_Error>
        (void) HAL_FLASH_OB_Launch();
 800ad4a:	f000 fce7 	bl	800b71c <HAL_FLASH_OB_Launch>
 800ad4e:	e7c8      	b.n	800ace2 <SFU_LL_SECU_CheckApplyStaticProtections+0x5a>
 800ad50:	52002000 	.word	0x52002000
 800ad54:	17ee0000 	.word	0x17ee0000
 800ad58:	20001100 	.word	0x20001100
 800ad5c:	0800ecfa 	.word	0x0800ecfa
 800ad60:	00122f11 	.word	0x00122f11

0800ad64 <SFU_LL_SECU_CheckApplyRuntimeProtections>:
{
 800ad64:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  if (uStep == SFU_INITIAL_CONFIGURATION)
 800ad66:	bb10      	cbnz	r0, 800adae <SFU_LL_SECU_CheckApplyRuntimeProtections+0x4a>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable clock of DBG GPIO port */
  SFU_DBG_CLK_ENABLE();
 800ad68:	4b13      	ldr	r3, [pc, #76]	@ (800adb8 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x54>)
  GPIO_InitStruct.Pin = SFU_DBG_SWCLK_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF0_SWJ;
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ad6a:	a901      	add	r1, sp, #4
  SFU_DBG_CLK_ENABLE();
 800ad6c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800ad70:	f042 0201 	orr.w	r2, r2, #1
 800ad74:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ad78:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
  SFU_DBG_CLK_ENABLE();
 800ad7c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800ad80:	f003 0301 	and.w	r3, r3, #1
 800ad84:	9300      	str	r3, [sp, #0]
 800ad86:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ad88:	2302      	movs	r3, #2
 800ad8a:	e9cd 2301 	strd	r2, r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800ad8e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ad90:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = GPIO_AF0_SWJ;
 800ad92:	e9cd 3004 	strd	r3, r0, [sp, #16]
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ad96:	4809      	ldr	r0, [pc, #36]	@ (800adbc <SFU_LL_SECU_CheckApplyRuntimeProtections+0x58>)
 800ad98:	f000 ff5a 	bl	800bc50 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SFU_DBG_SWDIO_PIN;
 800ad9c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800ada0:	a901      	add	r1, sp, #4
 800ada2:	4806      	ldr	r0, [pc, #24]	@ (800adbc <SFU_LL_SECU_CheckApplyRuntimeProtections+0x58>)
  GPIO_InitStruct.Pin = SFU_DBG_SWDIO_PIN;
 800ada4:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800ada6:	2301      	movs	r3, #1
 800ada8:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
 800adaa:	f000 ff51 	bl	800bc50 <HAL_GPIO_Init>
}
 800adae:	4804      	ldr	r0, [pc, #16]	@ (800adc0 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x5c>)
 800adb0:	b007      	add	sp, #28
 800adb2:	f85d fb04 	ldr.w	pc, [sp], #4
 800adb6:	bf00      	nop
 800adb8:	58024400 	.word	0x58024400
 800adbc:	58020000 	.word	0x58020000
 800adc0:	00122f11 	.word	0x00122f11

0800adc4 <SFU_LL_SECU_GetResetSources>:
  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDG1RST) != RESET) ||
 800adc4:	4b0f      	ldr	r3, [pc, #60]	@ (800ae04 <SFU_LL_SECU_GetResetSources+0x40>)
 800adc6:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
 800adca:	0151      	lsls	r1, r2, #5
 800adcc:	d414      	bmi.n	800adf8 <SFU_LL_SECU_GetResetSources+0x34>
      (__HAL_RCC_GET_FLAG(RCC_FLAG_WWDG1RST) != RESET))
 800adce:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDG1RST) != RESET) ||
 800add2:	00d2      	lsls	r2, r2, #3
 800add4:	d410      	bmi.n	800adf8 <SFU_LL_SECU_GetResetSources+0x34>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_LPWR1RST) != RESET)
 800add6:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
 800adda:	0051      	lsls	r1, r2, #1
 800addc:	d40e      	bmi.n	800adfc <SFU_LL_SECU_GetResetSources+0x38>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST) != RESET)
 800adde:	f8d3 20d0 	ldr.w	r2, [r3, #208]	@ 0xd0
 800ade2:	01d2      	lsls	r2, r2, #7
 800ade4:	d40c      	bmi.n	800ae00 <SFU_LL_SECU_GetResetSources+0x3c>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
 800ade6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 800adea:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 800adee:	bf14      	ite	ne
 800adf0:	2303      	movne	r3, #3
 800adf2:	2300      	moveq	r3, #0
    *peResetpSourceId = SFU_RESET_WDG_RESET;
 800adf4:	7003      	strb	r3, [r0, #0]
}
 800adf6:	4770      	bx	lr
 800adf8:	2301      	movs	r3, #1
 800adfa:	e7fb      	b.n	800adf4 <SFU_LL_SECU_GetResetSources+0x30>
 800adfc:	2302      	movs	r3, #2
 800adfe:	e7f9      	b.n	800adf4 <SFU_LL_SECU_GetResetSources+0x30>
 800ae00:	2305      	movs	r3, #5
 800ae02:	e7f7      	b.n	800adf4 <SFU_LL_SECU_GetResetSources+0x30>
 800ae04:	58024400 	.word	0x58024400

0800ae08 <SFU_LL_SECU_ClearResetSources>:
  __HAL_RCC_CLEAR_RESET_FLAGS();
 800ae08:	4a03      	ldr	r2, [pc, #12]	@ (800ae18 <SFU_LL_SECU_ClearResetSources+0x10>)
 800ae0a:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
 800ae0e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800ae12:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
}
 800ae16:	4770      	bx	lr
 800ae18:	58024400 	.word	0x58024400

0800ae1c <SFU_LL_SECU_IWDG_Refresh>:
}
 800ae1c:	4800      	ldr	r0, [pc, #0]	@ (800ae20 <SFU_LL_SECU_IWDG_Refresh+0x4>)
 800ae1e:	4770      	bx	lr
 800ae20:	00122f11 	.word	0x00122f11

0800ae24 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 800ae24:	f8df d034 	ldr.w	sp, [pc, #52]	@ 800ae5c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800ae28:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800ae2a:	e003      	b.n	800ae34 <LoopCopyDataInit>

0800ae2c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800ae2c:	4b0c      	ldr	r3, [pc, #48]	@ (800ae60 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800ae2e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800ae30:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800ae32:	3104      	adds	r1, #4

0800ae34 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800ae34:	480b      	ldr	r0, [pc, #44]	@ (800ae64 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800ae36:	4b0c      	ldr	r3, [pc, #48]	@ (800ae68 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800ae38:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800ae3a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800ae3c:	d3f6      	bcc.n	800ae2c <CopyDataInit>
  ldr  r2, =_sbss
 800ae3e:	4a0b      	ldr	r2, [pc, #44]	@ (800ae6c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800ae40:	e002      	b.n	800ae48 <LoopFillZerobss>

0800ae42 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800ae42:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800ae44:	f842 3b04 	str.w	r3, [r2], #4

0800ae48 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
 800ae48:	4b09      	ldr	r3, [pc, #36]	@ (800ae70 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800ae4a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800ae4c:	d3f9      	bcc.n	800ae42 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit
 800ae4e:	f000 f8ad 	bl	800afac <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800ae52:	f002 fced 	bl	800d830 <__libc_init_array>
/* Call the application entry point.*/
  bl  main
 800ae56:	f7fd ffe1 	bl	8008e1c <main>
  bx  lr
 800ae5a:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 800ae5c:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 800ae60:	0800ed80 	.word	0x0800ed80
  ldr  r0, =_sdata
 800ae64:	20001100 	.word	0x20001100
  ldr  r3, =_edata
 800ae68:	20001188 	.word	0x20001188
  ldr  r2, =_sbss
 800ae6c:	20001188 	.word	0x20001188
  ldr  r3, = _ebss
 800ae70:	20001ec8 	.word	0x20001ec8

0800ae74 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800ae74:	e7fe      	b.n	800ae74 <ADC3_IRQHandler>
	...

0800ae78 <BSP_LED_Init>:
void BSP_LED_Init(Led_TypeDef Led)
{
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 800ae78:	4b15      	ldr	r3, [pc, #84]	@ (800aed0 <BSP_LED_Init+0x58>)
 800ae7a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800ae7e:	f042 0202 	orr.w	r2, r2, #2
{
 800ae82:	b570      	push	{r4, r5, r6, lr}
 800ae84:	b088      	sub	sp, #32
  LEDx_GPIO_CLK_ENABLE(Led);
 800ae86:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800ae8a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800ae8e:	f003 0302 	and.w	r3, r3, #2
 800ae92:	b9c8      	cbnz	r0, 800aec8 <BSP_LED_Init+0x50>
 800ae94:	9301      	str	r3, [sp, #4]
 800ae96:	9b01      	ldr	r3, [sp, #4]

  /* Configure the GPIO_LED pin */
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800ae98:	4b0e      	ldr	r3, [pc, #56]	@ (800aed4 <BSP_LED_Init+0x5c>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ae9a:	2600      	movs	r6, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;

  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800ae9c:	4c0e      	ldr	r4, [pc, #56]	@ (800aed8 <BSP_LED_Init+0x60>)
 800ae9e:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800aea0:	f833 5010 	ldrh.w	r5, [r3, r0, lsl #1]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800aea4:	2301      	movs	r3, #1
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800aea6:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800aeaa:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800aeac:	6860      	ldr	r0, [r4, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800aeae:	e9cd 3604 	strd	r3, r6, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800aeb2:	2303      	movs	r3, #3
 800aeb4:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800aeb6:	f000 fecb 	bl	800bc50 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 800aeba:	4632      	mov	r2, r6
 800aebc:	4629      	mov	r1, r5
 800aebe:	6860      	ldr	r0, [r4, #4]
 800aec0:	f000 ffb4 	bl	800be2c <HAL_GPIO_WritePin>
}
 800aec4:	b008      	add	sp, #32
 800aec6:	bd70      	pop	{r4, r5, r6, pc}
  LEDx_GPIO_CLK_ENABLE(Led);
 800aec8:	9302      	str	r3, [sp, #8]
 800aeca:	9b02      	ldr	r3, [sp, #8]
 800aecc:	e7e4      	b.n	800ae98 <BSP_LED_Init+0x20>
 800aece:	bf00      	nop
 800aed0:	58024400 	.word	0x58024400
 800aed4:	0800e424 	.word	0x0800e424
 800aed8:	20001108 	.word	0x20001108

0800aedc <BSP_LED_Off>:
  *     @arg  LED3
  * @retval None
  */
void BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 800aedc:	4b04      	ldr	r3, [pc, #16]	@ (800aef0 <BSP_LED_Off+0x14>)
 800aede:	2200      	movs	r2, #0
 800aee0:	4904      	ldr	r1, [pc, #16]	@ (800aef4 <BSP_LED_Off+0x18>)
 800aee2:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800aee6:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
 800aeea:	6858      	ldr	r0, [r3, #4]
 800aeec:	f000 bf9e 	b.w	800be2c <HAL_GPIO_WritePin>
 800aef0:	20001108 	.word	0x20001108
 800aef4:	0800e424 	.word	0x0800e424

0800aef8 <BSP_LED_Toggle>:
  *     @arg  LED3
  * @retval None
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 800aef8:	4b04      	ldr	r3, [pc, #16]	@ (800af0c <BSP_LED_Toggle+0x14>)
 800aefa:	4a05      	ldr	r2, [pc, #20]	@ (800af10 <BSP_LED_Toggle+0x18>)
 800aefc:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800af00:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
 800af04:	6858      	ldr	r0, [r3, #4]
 800af06:	f000 bf96 	b.w	800be36 <HAL_GPIO_TogglePin>
 800af0a:	bf00      	nop
 800af0c:	20001108 	.word	0x20001108
 800af10:	0800e424 	.word	0x0800e424

0800af14 <BSP_PB_Init>:
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800af14:	4b1d      	ldr	r3, [pc, #116]	@ (800af8c <BSP_PB_Init+0x78>)
 800af16:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800af1a:	f042 0204 	orr.w	r2, r2, #4
{
 800af1e:	b510      	push	{r4, lr}
 800af20:	b086      	sub	sp, #24
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800af22:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800af26:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800af2a:	f003 0304 	and.w	r3, r3, #4
 800af2e:	9300      	str	r3, [sp, #0]
 800af30:	9b00      	ldr	r3, [sp, #0]

  if(ButtonMode == BUTTON_MODE_GPIO)
 800af32:	b981      	cbnz	r1, 800af56 <BSP_PB_Init+0x42>
  {
    /* Configure Button pin as input */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 800af34:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800af38:	2202      	movs	r2, #2
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800af3a:	e9cd 3101 	strd	r3, r1, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800af3e:	2303      	movs	r3, #3
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800af40:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800af42:	e9cd 2303 	strd	r2, r3, [sp, #12]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800af46:	4b12      	ldr	r3, [pc, #72]	@ (800af90 <BSP_PB_Init+0x7c>)
 800af48:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800af4c:	6918      	ldr	r0, [r3, #16]
 800af4e:	f000 fe7f 	bl	800bc50 <HAL_GPIO_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
  }
}
 800af52:	b006      	add	sp, #24
 800af54:	bd10      	pop	{r4, pc}
  if(ButtonMode == BUTTON_MODE_EXTI)
 800af56:	2901      	cmp	r1, #1
 800af58:	d1fb      	bne.n	800af52 <BSP_PB_Init+0x3e>
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 800af5a:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800af5e:	2400      	movs	r4, #0
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800af60:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 800af62:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800af64:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 800af68:	e9cd 3402 	strd	r3, r4, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800af6c:	4b08      	ldr	r3, [pc, #32]	@ (800af90 <BSP_PB_Init+0x7c>)
 800af6e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800af72:	6918      	ldr	r0, [r3, #16]
 800af74:	f000 fe6c 	bl	800bc50 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 800af78:	4622      	mov	r2, r4
 800af7a:	210f      	movs	r1, #15
 800af7c:	2028      	movs	r0, #40	@ 0x28
 800af7e:	f000 f91d 	bl	800b1bc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 800af82:	2028      	movs	r0, #40	@ 0x28
 800af84:	f000 f94c 	bl	800b220 <HAL_NVIC_EnableIRQ>
}
 800af88:	e7e3      	b.n	800af52 <BSP_PB_Init+0x3e>
 800af8a:	bf00      	nop
 800af8c:	58024400 	.word	0x58024400
 800af90:	20001108 	.word	0x20001108

0800af94 <BSP_PB_GetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_USER
  * @retval The Button GPIO pin value.
  */
uint32_t BSP_PB_GetState(Button_TypeDef Button)
{
 800af94:	b508      	push	{r3, lr}
  return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 800af96:	4b04      	ldr	r3, [pc, #16]	@ (800afa8 <BSP_PB_GetState+0x14>)
 800af98:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800af9c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800afa0:	6900      	ldr	r0, [r0, #16]
 800afa2:	f000 ff3d 	bl	800be20 <HAL_GPIO_ReadPin>
}
 800afa6:	bd08      	pop	{r3, pc}
 800afa8:	20001108 	.word	0x20001108

0800afac <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 800afac:	4a2e      	ldr	r2, [pc, #184]	@ (800b068 <SystemInit+0xbc>)
 800afae:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 800afb2:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800afb6:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800afba:	4a2c      	ldr	r2, [pc, #176]	@ (800b06c <SystemInit+0xc0>)
 800afbc:	6813      	ldr	r3, [r2, #0]
 800afbe:	f003 030f 	and.w	r3, r3, #15
 800afc2:	2b06      	cmp	r3, #6
 800afc4:	d805      	bhi.n	800afd2 <SystemInit+0x26>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 800afc6:	6813      	ldr	r3, [r2, #0]
 800afc8:	f023 030f 	bic.w	r3, r3, #15
 800afcc:	f043 0307 	orr.w	r3, r3, #7
 800afd0:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 800afd2:	4b27      	ldr	r3, [pc, #156]	@ (800b070 <SystemInit+0xc4>)
 800afd4:	681a      	ldr	r2, [r3, #0]
 800afd6:	f042 0201 	orr.w	r2, r2, #1
 800afda:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800afdc:	2200      	movs	r2, #0
 800afde:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 800afe0:	4a24      	ldr	r2, [pc, #144]	@ (800b074 <SystemInit+0xc8>)
 800afe2:	6819      	ldr	r1, [r3, #0]
 800afe4:	400a      	ands	r2, r1

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800afe6:	4921      	ldr	r1, [pc, #132]	@ (800b06c <SystemInit+0xc0>)
  RCC->CR &= 0xEAF6ED7FU;
 800afe8:	601a      	str	r2, [r3, #0]
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800afea:	680a      	ldr	r2, [r1, #0]
 800afec:	0710      	lsls	r0, r2, #28
 800afee:	d505      	bpl.n	800affc <SystemInit+0x50>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 800aff0:	680a      	ldr	r2, [r1, #0]
 800aff2:	f022 020f 	bic.w	r2, r2, #15
 800aff6:	f042 0207 	orr.w	r2, r2, #7
 800affa:	600a      	str	r2, [r1, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 800affc:	2200      	movs	r2, #0

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
 800affe:	491e      	ldr	r1, [pc, #120]	@ (800b078 <SystemInit+0xcc>)
  RCC->D1CFGR = 0x00000000;
 800b000:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
 800b002:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
 800b004:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x02020200;
 800b006:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
 800b008:	491c      	ldr	r1, [pc, #112]	@ (800b07c <SystemInit+0xd0>)
 800b00a:	62d9      	str	r1, [r3, #44]	@ 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 800b00c:	491c      	ldr	r1, [pc, #112]	@ (800b080 <SystemInit+0xd4>)
 800b00e:	6319      	str	r1, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 800b010:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 800b012:	6399      	str	r1, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 800b014:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 800b016:	6419      	str	r1, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 800b018:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800b01a:	6819      	ldr	r1, [r3, #0]
 800b01c:	f421 2180 	bic.w	r1, r1, #262144	@ 0x40000
 800b020:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800b022:	661a      	str	r2, [r3, #96]	@ 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 800b024:	4b17      	ldr	r3, [pc, #92]	@ (800b084 <SystemInit+0xd8>)
 800b026:	681b      	ldr	r3, [r3, #0]
 800b028:	f36f 030f 	bfc	r3, #0, #16
 800b02c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800b030:	d203      	bcs.n	800b03a <SystemInit+0x8e>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 800b032:	4b15      	ldr	r3, [pc, #84]	@ (800b088 <SystemInit+0xdc>)
 800b034:	2201      	movs	r2, #1
 800b036:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#else
  if(READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN) == 0U)
 800b03a:	4b0d      	ldr	r3, [pc, #52]	@ (800b070 <SystemInit+0xc4>)
 800b03c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
 800b040:	04d2      	lsls	r2, r2, #19
 800b042:	d40f      	bmi.n	800b064 <SystemInit+0xb8>
  {
    /* Enable the FMC interface clock */
    SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 800b044:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
    /*
     * Disable the FMC bank1 (enabled after reset).
     * This, prevents CPU speculation access on this bank which blocks the use of FMC during
     * 24us. During this time the others FMC master (such as LTDC) cannot use it!
     */
    FMC_Bank1_R->BTCR[0] = 0x000030D2;
 800b048:	f243 01d2 	movw	r1, #12498	@ 0x30d2
    SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 800b04c:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 800b050:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
    FMC_Bank1_R->BTCR[0] = 0x000030D2;
 800b054:	4a0d      	ldr	r2, [pc, #52]	@ (800b08c <SystemInit+0xe0>)
 800b056:	6011      	str	r1, [r2, #0]

    /* Disable the FMC interface clock */
    CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 800b058:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
 800b05c:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 800b060:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
 800b064:	4770      	bx	lr
 800b066:	bf00      	nop
 800b068:	e000ed00 	.word	0xe000ed00
 800b06c:	52002000 	.word	0x52002000
 800b070:	58024400 	.word	0x58024400
 800b074:	eaf6ed7f 	.word	0xeaf6ed7f
 800b078:	02020200 	.word	0x02020200
 800b07c:	01ff0000 	.word	0x01ff0000
 800b080:	01010280 	.word	0x01010280
 800b084:	5c001000 	.word	0x5c001000
 800b088:	51008000 	.word	0x51008000
 800b08c:	52004000 	.word	0x52004000

0800b090 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800b090:	b570      	push	{r4, r5, r6, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 800b092:	4e0f      	ldr	r6, [pc, #60]	@ (800b0d0 <HAL_InitTick+0x40>)
{
 800b094:	4605      	mov	r5, r0
  if((uint32_t)uwTickFreq == 0UL)
 800b096:	7832      	ldrb	r2, [r6, #0]
 800b098:	b90a      	cbnz	r2, 800b09e <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
 800b09a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 800b09c:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 800b09e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800b0a2:	fbb3 f3f2 	udiv	r3, r3, r2
 800b0a6:	4a0b      	ldr	r2, [pc, #44]	@ (800b0d4 <HAL_InitTick+0x44>)
 800b0a8:	6810      	ldr	r0, [r2, #0]
 800b0aa:	fbb0 f0f3 	udiv	r0, r0, r3
 800b0ae:	f000 f8d7 	bl	800b260 <HAL_SYSTICK_Config>
 800b0b2:	4604      	mov	r4, r0
 800b0b4:	2800      	cmp	r0, #0
 800b0b6:	d1f0      	bne.n	800b09a <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800b0b8:	2d0f      	cmp	r5, #15
 800b0ba:	d8ee      	bhi.n	800b09a <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800b0bc:	4602      	mov	r2, r0
 800b0be:	4629      	mov	r1, r5
 800b0c0:	f04f 30ff 	mov.w	r0, #4294967295
 800b0c4:	f000 f87a 	bl	800b1bc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800b0c8:	4620      	mov	r0, r4
 800b0ca:	6075      	str	r5, [r6, #4]
  return HAL_OK;
 800b0cc:	e7e6      	b.n	800b09c <HAL_InitTick+0xc>
 800b0ce:	bf00      	nop
 800b0d0:	20001124 	.word	0x20001124
 800b0d4:	20001120 	.word	0x20001120

0800b0d8 <HAL_Init>:
{
 800b0d8:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800b0da:	2003      	movs	r0, #3
 800b0dc:	f000 f85c 	bl	800b198 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800b0e0:	f001 f97e 	bl	800c3e0 <HAL_RCC_GetSysClockFreq>
 800b0e4:	490f      	ldr	r1, [pc, #60]	@ (800b124 <HAL_Init+0x4c>)
 800b0e6:	4a10      	ldr	r2, [pc, #64]	@ (800b128 <HAL_Init+0x50>)
 800b0e8:	698b      	ldr	r3, [r1, #24]
 800b0ea:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800b0ee:	5cd3      	ldrb	r3, [r2, r3]
 800b0f0:	f003 031f 	and.w	r3, r3, #31
 800b0f4:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800b0f6:	698b      	ldr	r3, [r1, #24]
 800b0f8:	f003 030f 	and.w	r3, r3, #15
 800b0fc:	5cd3      	ldrb	r3, [r2, r3]
 800b0fe:	4a0b      	ldr	r2, [pc, #44]	@ (800b12c <HAL_Init+0x54>)
 800b100:	f003 031f 	and.w	r3, r3, #31
 800b104:	fa20 f303 	lsr.w	r3, r0, r3
 800b108:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 800b10a:	4b09      	ldr	r3, [pc, #36]	@ (800b130 <HAL_Init+0x58>)
 800b10c:	6018      	str	r0, [r3, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800b10e:	2000      	movs	r0, #0
 800b110:	f7ff ffbe 	bl	800b090 <HAL_InitTick>
 800b114:	4604      	mov	r4, r0
 800b116:	b918      	cbnz	r0, 800b120 <HAL_Init+0x48>
  HAL_MspInit();
 800b118:	f7fd feda 	bl	8008ed0 <HAL_MspInit>
}
 800b11c:	4620      	mov	r0, r4
 800b11e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800b120:	2401      	movs	r4, #1
 800b122:	e7fb      	b.n	800b11c <HAL_Init+0x44>
 800b124:	58024400 	.word	0x58024400
 800b128:	0800e42e 	.word	0x0800e42e
 800b12c:	2000111c 	.word	0x2000111c
 800b130:	20001120 	.word	0x20001120

0800b134 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 800b134:	4a03      	ldr	r2, [pc, #12]	@ (800b144 <HAL_IncTick+0x10>)
 800b136:	4b04      	ldr	r3, [pc, #16]	@ (800b148 <HAL_IncTick+0x14>)
 800b138:	6811      	ldr	r1, [r2, #0]
 800b13a:	781b      	ldrb	r3, [r3, #0]
 800b13c:	440b      	add	r3, r1
 800b13e:	6013      	str	r3, [r2, #0]
}
 800b140:	4770      	bx	lr
 800b142:	bf00      	nop
 800b144:	20001d58 	.word	0x20001d58
 800b148:	20001124 	.word	0x20001124

0800b14c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800b14c:	4b01      	ldr	r3, [pc, #4]	@ (800b154 <HAL_GetTick+0x8>)
 800b14e:	6818      	ldr	r0, [r3, #0]
}
 800b150:	4770      	bx	lr
 800b152:	bf00      	nop
 800b154:	20001d58 	.word	0x20001d58

0800b158 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800b158:	b538      	push	{r3, r4, r5, lr}
 800b15a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800b15c:	f7ff fff6 	bl	800b14c <HAL_GetTick>
 800b160:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800b162:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 800b164:	bf1e      	ittt	ne
 800b166:	4b04      	ldrne	r3, [pc, #16]	@ (800b178 <HAL_Delay+0x20>)
 800b168:	781b      	ldrbne	r3, [r3, #0]
 800b16a:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800b16c:	f7ff ffee 	bl	800b14c <HAL_GetTick>
 800b170:	1b43      	subs	r3, r0, r5
 800b172:	42a3      	cmp	r3, r4
 800b174:	d3fa      	bcc.n	800b16c <HAL_Delay+0x14>
  {
  }
}
 800b176:	bd38      	pop	{r3, r4, r5, pc}
 800b178:	20001124 	.word	0x20001124

0800b17c <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 800b17c:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 800b180:	6913      	ldr	r3, [r2, #16]
 800b182:	f023 0302 	bic.w	r3, r3, #2
 800b186:	6113      	str	r3, [r2, #16]
}
 800b188:	4770      	bx	lr
	...

0800b18c <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 800b18c:	4b01      	ldr	r3, [pc, #4]	@ (800b194 <HAL_GetREVID+0x8>)
 800b18e:	6818      	ldr	r0, [r3, #0]
}
 800b190:	0c00      	lsrs	r0, r0, #16
 800b192:	4770      	bx	lr
 800b194:	5c001000 	.word	0x5c001000

0800b198 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800b198:	4907      	ldr	r1, [pc, #28]	@ (800b1b8 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800b19a:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800b19c:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800b19e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800b1a2:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b1a6:	0412      	lsls	r2, r2, #16
 800b1a8:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800b1aa:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800b1ac:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800b1b0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800b1b4:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800b1b6:	4770      	bx	lr
 800b1b8:	e000ed00 	.word	0xe000ed00

0800b1bc <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800b1bc:	4b16      	ldr	r3, [pc, #88]	@ (800b218 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800b1be:	b530      	push	{r4, r5, lr}
 800b1c0:	68dc      	ldr	r4, [r3, #12]
 800b1c2:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800b1c6:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b1ca:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800b1cc:	2b04      	cmp	r3, #4
 800b1ce:	bf28      	it	cs
 800b1d0:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b1d2:	2d06      	cmp	r5, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b1d4:	f04f 35ff 	mov.w	r5, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b1d8:	bf8c      	ite	hi
 800b1da:	3c03      	subhi	r4, #3
 800b1dc:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b1de:	fa05 f303 	lsl.w	r3, r5, r3
  if ((int32_t)(IRQn) >= 0)
 800b1e2:	2800      	cmp	r0, #0
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800b1e4:	fa05 f504 	lsl.w	r5, r5, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b1e8:	ea21 0303 	bic.w	r3, r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800b1ec:	ea22 0205 	bic.w	r2, r2, r5
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b1f0:	fa03 f304 	lsl.w	r3, r3, r4
 800b1f4:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b1f8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800b1fc:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 800b1fe:	db06      	blt.n	800b20e <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b200:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 800b204:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 800b208:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800b20c:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b20e:	f000 000f 	and.w	r0, r0, #15
 800b212:	4a02      	ldr	r2, [pc, #8]	@ (800b21c <HAL_NVIC_SetPriority+0x60>)
 800b214:	5413      	strb	r3, [r2, r0]
 800b216:	e7f9      	b.n	800b20c <HAL_NVIC_SetPriority+0x50>
 800b218:	e000ed00 	.word	0xe000ed00
 800b21c:	e000ed14 	.word	0xe000ed14

0800b220 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800b220:	2800      	cmp	r0, #0
 800b222:	db07      	blt.n	800b234 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800b224:	0941      	lsrs	r1, r0, #5
 800b226:	2301      	movs	r3, #1
 800b228:	f000 001f 	and.w	r0, r0, #31
 800b22c:	4a02      	ldr	r2, [pc, #8]	@ (800b238 <HAL_NVIC_EnableIRQ+0x18>)
 800b22e:	4083      	lsls	r3, r0
 800b230:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800b234:	4770      	bx	lr
 800b236:	bf00      	nop
 800b238:	e000e100 	.word	0xe000e100

0800b23c <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 800b23c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800b240:	4905      	ldr	r1, [pc, #20]	@ (800b258 <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800b242:	4b06      	ldr	r3, [pc, #24]	@ (800b25c <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800b244:	68ca      	ldr	r2, [r1, #12]
 800b246:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800b24a:	4313      	orrs	r3, r2
 800b24c:	60cb      	str	r3, [r1, #12]
 800b24e:	f3bf 8f4f 	dsb	sy
    __NOP();
 800b252:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 800b254:	e7fd      	b.n	800b252 <HAL_NVIC_SystemReset+0x16>
 800b256:	bf00      	nop
 800b258:	e000ed00 	.word	0xe000ed00
 800b25c:	05fa0004 	.word	0x05fa0004

0800b260 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800b260:	3801      	subs	r0, #1
 800b262:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 800b266:	d20b      	bcs.n	800b280 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800b268:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b26c:	4a05      	ldr	r2, [pc, #20]	@ (800b284 <HAL_SYSTICK_Config+0x24>)
 800b26e:	21f0      	movs	r1, #240	@ 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800b270:	6158      	str	r0, [r3, #20]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800b272:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b274:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b278:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800b27a:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b27c:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800b27e:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800b280:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 800b282:	4770      	bx	lr
 800b284:	e000ed00 	.word	0xe000ed00

0800b288 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800b288:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b28a:	f022 0603 	bic.w	r6, r2, #3
 800b28e:	460b      	mov	r3, r1
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 800b290:	0897      	lsrs	r7, r2, #2
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b292:	6805      	ldr	r5, [r0, #0]
 800b294:	440e      	add	r6, r1
  for (i = 0U; i < (BufferLength / 4U); i++)
 800b296:	42b3      	cmp	r3, r6
 800b298:	d10a      	bne.n	800b2b0 <CRC_Handle_8+0x28>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 800b29a:	f012 0203 	ands.w	r2, r2, #3
 800b29e:	d004      	beq.n	800b2aa <CRC_Handle_8+0x22>
  {
    if ((BufferLength % 4U) == 1U)
 800b2a0:	2a01      	cmp	r2, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b2a2:	f811 4027 	ldrb.w	r4, [r1, r7, lsl #2]
    if ((BufferLength % 4U) == 1U)
 800b2a6:	d114      	bne.n	800b2d2 <CRC_Handle_8+0x4a>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 800b2a8:	702c      	strb	r4, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800b2aa:	6803      	ldr	r3, [r0, #0]
 800b2ac:	6818      	ldr	r0, [r3, #0]
}
 800b2ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800b2b0:	785c      	ldrb	r4, [r3, #1]
 800b2b2:	3304      	adds	r3, #4
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b2b4:	f813 cc04 	ldrb.w	ip, [r3, #-4]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800b2b8:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800b2ba:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 800b2be:	f813 cc01 	ldrb.w	ip, [r3, #-1]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800b2c2:	ea44 040c 	orr.w	r4, r4, ip
 800b2c6:	f813 cc02 	ldrb.w	ip, [r3, #-2]
 800b2ca:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800b2ce:	602c      	str	r4, [r5, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800b2d0:	e7e1      	b.n	800b296 <CRC_Handle_8+0xe>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800b2d2:	7859      	ldrb	r1, [r3, #1]
    if ((BufferLength % 4U) == 2U)
 800b2d4:	2a02      	cmp	r2, #2
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800b2d6:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
      *pReg = data;
 800b2da:	8029      	strh	r1, [r5, #0]
    if ((BufferLength % 4U) == 2U)
 800b2dc:	d0e5      	beq.n	800b2aa <CRC_Handle_8+0x22>
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800b2de:	789b      	ldrb	r3, [r3, #2]
 800b2e0:	702b      	strb	r3, [r5, #0]
 800b2e2:	e7e2      	b.n	800b2aa <CRC_Handle_8+0x22>

0800b2e4 <CRC_Handle_16>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 800b2e4:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b2e6:	6800      	ldr	r0, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b2e8:	0855      	lsrs	r5, r2, #1
 800b2ea:	2300      	movs	r3, #0
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b2ec:	1c8e      	adds	r6, r1, #2
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b2ee:	429d      	cmp	r5, r3
 800b2f0:	d106      	bne.n	800b300 <CRC_Handle_16+0x1c>
  }
  if ((BufferLength % 2U) != 0U)
 800b2f2:	07d3      	lsls	r3, r2, #31
 800b2f4:	d502      	bpl.n	800b2fc <CRC_Handle_16+0x18>
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 800b2f6:	f831 3025 	ldrh.w	r3, [r1, r5, lsl #2]
 800b2fa:	8003      	strh	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800b2fc:	6800      	ldr	r0, [r0, #0]
}
 800b2fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b300:	f831 7023 	ldrh.w	r7, [r1, r3, lsl #2]
 800b304:	f836 4023 	ldrh.w	r4, [r6, r3, lsl #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b308:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b30a:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 800b30e:	6004      	str	r4, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b310:	e7ed      	b.n	800b2ee <CRC_Handle_16+0xa>

0800b312 <HAL_CRC_MspInit>:
}
 800b312:	4770      	bx	lr

0800b314 <HAL_CRC_Init>:
{
 800b314:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 800b316:	4604      	mov	r4, r0
 800b318:	b908      	cbnz	r0, 800b31e <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 800b31a:	2001      	movs	r0, #1
}
 800b31c:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 800b31e:	7f43      	ldrb	r3, [r0, #29]
 800b320:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 800b324:	b913      	cbnz	r3, 800b32c <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 800b326:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800b328:	f7ff fff3 	bl	800b312 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 800b32c:	2302      	movs	r3, #2
 800b32e:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800b330:	7923      	ldrb	r3, [r4, #4]
 800b332:	b9e3      	cbnz	r3, 800b36e <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800b334:	6823      	ldr	r3, [r4, #0]
 800b336:	4a13      	ldr	r2, [pc, #76]	@ (800b384 <HAL_CRC_Init+0x70>)
 800b338:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800b33a:	689a      	ldr	r2, [r3, #8]
 800b33c:	f022 0218 	bic.w	r2, r2, #24
 800b340:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800b342:	7962      	ldrb	r2, [r4, #5]
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800b344:	6823      	ldr	r3, [r4, #0]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800b346:	b9d2      	cbnz	r2, 800b37e <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800b348:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800b34c:	611a      	str	r2, [r3, #16]
  return HAL_OK;
 800b34e:	2000      	movs	r0, #0
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800b350:	689a      	ldr	r2, [r3, #8]
 800b352:	6961      	ldr	r1, [r4, #20]
 800b354:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800b358:	430a      	orrs	r2, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800b35a:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800b35c:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800b35e:	689a      	ldr	r2, [r3, #8]
 800b360:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 800b364:	430a      	orrs	r2, r1
 800b366:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800b368:	2301      	movs	r3, #1
 800b36a:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 800b36c:	e7d6      	b.n	800b31c <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800b36e:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 800b372:	4620      	mov	r0, r4
 800b374:	f000 f82c 	bl	800b3d0 <HAL_CRCEx_Polynomial_Set>
 800b378:	2800      	cmp	r0, #0
 800b37a:	d0e2      	beq.n	800b342 <HAL_CRC_Init+0x2e>
 800b37c:	e7cd      	b.n	800b31a <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800b37e:	6922      	ldr	r2, [r4, #16]
 800b380:	e7e4      	b.n	800b34c <HAL_CRC_Init+0x38>
 800b382:	bf00      	nop
 800b384:	04c11db7 	.word	0x04c11db7

0800b388 <HAL_CRC_Calculate>:
{
 800b388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 800b38a:	2602      	movs	r6, #2
{
 800b38c:	4604      	mov	r4, r0
  hcrc->State = HAL_CRC_STATE_BUSY;
 800b38e:	7746      	strb	r6, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 800b390:	6806      	ldr	r6, [r0, #0]
 800b392:	68b7      	ldr	r7, [r6, #8]
 800b394:	f047 0701 	orr.w	r7, r7, #1
 800b398:	60b7      	str	r7, [r6, #8]
  switch (hcrc->InputDataFormat)
 800b39a:	6a07      	ldr	r7, [r0, #32]
 800b39c:	2f02      	cmp	r7, #2
 800b39e:	d014      	beq.n	800b3ca <HAL_CRC_Calculate+0x42>
 800b3a0:	2f03      	cmp	r7, #3
 800b3a2:	d005      	beq.n	800b3b0 <HAL_CRC_Calculate+0x28>
 800b3a4:	2f01      	cmp	r7, #1
 800b3a6:	d00d      	beq.n	800b3c4 <HAL_CRC_Calculate+0x3c>
 800b3a8:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 800b3aa:	2301      	movs	r3, #1
 800b3ac:	7763      	strb	r3, [r4, #29]
}
 800b3ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b3b0:	eb01 0582 	add.w	r5, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 800b3b4:	42a9      	cmp	r1, r5
 800b3b6:	d101      	bne.n	800b3bc <HAL_CRC_Calculate+0x34>
      temp = hcrc->Instance->DR;
 800b3b8:	6830      	ldr	r0, [r6, #0]
      break;
 800b3ba:	e7f6      	b.n	800b3aa <HAL_CRC_Calculate+0x22>
        hcrc->Instance->DR = pBuffer[index];
 800b3bc:	f851 3b04 	ldr.w	r3, [r1], #4
 800b3c0:	6033      	str	r3, [r6, #0]
      for (index = 0U; index < BufferLength; index++)
 800b3c2:	e7f7      	b.n	800b3b4 <HAL_CRC_Calculate+0x2c>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800b3c4:	f7ff ff60 	bl	800b288 <CRC_Handle_8>
      break;
 800b3c8:	e7ef      	b.n	800b3aa <HAL_CRC_Calculate+0x22>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 800b3ca:	f7ff ff8b 	bl	800b2e4 <CRC_Handle_16>
      break;
 800b3ce:	e7ec      	b.n	800b3aa <HAL_CRC_Calculate+0x22>

0800b3d0 <HAL_CRCEx_Polynomial_Set>:

  /* Check the parameters */
  assert_param(IS_CRC_POL_LENGTH(PolyLength));

  /* Ensure that the generating polynomial is odd */
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 800b3d0:	07cb      	lsls	r3, r1, #31
{
 800b3d2:	b510      	push	{r4, lr}
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 800b3d4:	d50d      	bpl.n	800b3f2 <HAL_CRCEx_Polynomial_Set+0x22>
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 800b3d6:	231f      	movs	r3, #31
     * definition. HAL_ERROR is reported if Pol degree is
     * larger than that indicated by PolyLength.
     * Look for MSB position: msb will contain the degree of
     *  the second to the largest polynomial member. E.g., for
     *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
    while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800b3d8:	3b01      	subs	r3, #1
 800b3da:	d31d      	bcc.n	800b418 <HAL_CRCEx_Polynomial_Set+0x48>
 800b3dc:	fa21 f403 	lsr.w	r4, r1, r3
 800b3e0:	07e4      	lsls	r4, r4, #31
 800b3e2:	d5f9      	bpl.n	800b3d8 <HAL_CRCEx_Polynomial_Set+0x8>
    {
    }

    switch (PolyLength)
 800b3e4:	2a10      	cmp	r2, #16
 800b3e6:	d013      	beq.n	800b410 <HAL_CRCEx_Polynomial_Set+0x40>
 800b3e8:	2a10      	cmp	r2, #16
 800b3ea:	d804      	bhi.n	800b3f6 <HAL_CRCEx_Polynomial_Set+0x26>
 800b3ec:	b13a      	cbz	r2, 800b3fe <HAL_CRCEx_Polynomial_Set+0x2e>
 800b3ee:	2a08      	cmp	r2, #8
 800b3f0:	d010      	beq.n	800b414 <HAL_CRCEx_Polynomial_Set+0x44>
    {

      case CRC_POLYLENGTH_7B:
        if (msb >= HAL_CRC_LENGTH_7B)
        {
          status =   HAL_ERROR;
 800b3f2:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 800b3f4:	e00b      	b.n	800b40e <HAL_CRCEx_Polynomial_Set+0x3e>
    switch (PolyLength)
 800b3f6:	2a18      	cmp	r2, #24
 800b3f8:	d1fb      	bne.n	800b3f2 <HAL_CRCEx_Polynomial_Set+0x22>
        if (msb >= HAL_CRC_LENGTH_7B)
 800b3fa:	2b06      	cmp	r3, #6
        if (msb >= HAL_CRC_LENGTH_16B)
 800b3fc:	d8f9      	bhi.n	800b3f2 <HAL_CRCEx_Polynomial_Set+0x22>
    WRITE_REG(hcrc->Instance->POL, Pol);
 800b3fe:	6800      	ldr	r0, [r0, #0]
 800b400:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800b402:	6883      	ldr	r3, [r0, #8]
 800b404:	f023 0318 	bic.w	r3, r3, #24
 800b408:	4313      	orrs	r3, r2
 800b40a:	6083      	str	r3, [r0, #8]
 800b40c:	2000      	movs	r0, #0
}
 800b40e:	bd10      	pop	{r4, pc}
        if (msb >= HAL_CRC_LENGTH_8B)
 800b410:	2b07      	cmp	r3, #7
 800b412:	e7f3      	b.n	800b3fc <HAL_CRCEx_Polynomial_Set+0x2c>
        if (msb >= HAL_CRC_LENGTH_16B)
 800b414:	2b0f      	cmp	r3, #15
 800b416:	e7f1      	b.n	800b3fc <HAL_CRCEx_Polynomial_Set+0x2c>
    switch (PolyLength)
 800b418:	2a10      	cmp	r2, #16
 800b41a:	d1e5      	bne.n	800b3e8 <HAL_CRCEx_Polynomial_Set+0x18>
 800b41c:	e7e9      	b.n	800b3f2 <HAL_CRCEx_Polynomial_Set+0x22>
	...

0800b420 <HAL_FLASH_Unlock>:
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 800b420:	4b10      	ldr	r3, [pc, #64]	@ (800b464 <HAL_FLASH_Unlock+0x44>)
 800b422:	68da      	ldr	r2, [r3, #12]
 800b424:	07d2      	lsls	r2, r2, #31
 800b426:	d406      	bmi.n	800b436 <HAL_FLASH_Unlock+0x16>
      return HAL_ERROR;
    }
  }

#if defined (DUAL_BANK)
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 800b428:	4b0e      	ldr	r3, [pc, #56]	@ (800b464 <HAL_FLASH_Unlock+0x44>)
 800b42a:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800b42e:	f010 0001 	ands.w	r0, r0, #1
 800b432:	d10a      	bne.n	800b44a <HAL_FLASH_Unlock+0x2a>
 800b434:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 800b436:	4a0c      	ldr	r2, [pc, #48]	@ (800b468 <HAL_FLASH_Unlock+0x48>)
 800b438:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 800b43a:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 800b43e:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 800b440:	68db      	ldr	r3, [r3, #12]
 800b442:	07db      	lsls	r3, r3, #31
 800b444:	d5f0      	bpl.n	800b428 <HAL_FLASH_Unlock+0x8>
      return HAL_ERROR;
 800b446:	2001      	movs	r0, #1
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
}
 800b448:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 800b44a:	4a07      	ldr	r2, [pc, #28]	@ (800b468 <HAL_FLASH_Unlock+0x48>)
 800b44c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 800b450:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 800b454:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 800b458:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800b45c:	f000 0001 	and.w	r0, r0, #1
 800b460:	4770      	bx	lr
 800b462:	bf00      	nop
 800b464:	52002000 	.word	0x52002000
 800b468:	45670123 	.word	0x45670123

0800b46c <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
 800b46c:	4b0a      	ldr	r3, [pc, #40]	@ (800b498 <HAL_FLASH_Lock+0x2c>)
 800b46e:	68da      	ldr	r2, [r3, #12]
 800b470:	f042 0201 	orr.w	r2, r2, #1
 800b474:	60da      	str	r2, [r3, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
 800b476:	68da      	ldr	r2, [r3, #12]
 800b478:	07d2      	lsls	r2, r2, #31
 800b47a:	d50b      	bpl.n	800b494 <HAL_FLASH_Lock+0x28>
    return HAL_ERROR;
  }

#if defined (DUAL_BANK)
  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
 800b47c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b480:	f042 0201 	orr.w	r2, r2, #1
 800b484:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c

  /* Verify Flash Bank2 is locked */
  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
 800b488:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
 800b48c:	43c0      	mvns	r0, r0
 800b48e:	f000 0001 	and.w	r0, r0, #1
 800b492:	4770      	bx	lr
    return HAL_ERROR;
 800b494:	2001      	movs	r0, #1
    return HAL_ERROR;
  }
#endif /* DUAL_BANK */

  return HAL_OK;
}
 800b496:	4770      	bx	lr
 800b498:	52002000 	.word	0x52002000

0800b49c <HAL_FLASH_OB_Unlock>:
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
 800b49c:	4b06      	ldr	r3, [pc, #24]	@ (800b4b8 <HAL_FLASH_OB_Unlock+0x1c>)
 800b49e:	6998      	ldr	r0, [r3, #24]
 800b4a0:	f010 0001 	ands.w	r0, r0, #1
 800b4a4:	d007      	beq.n	800b4b6 <HAL_FLASH_OB_Unlock+0x1a>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
 800b4a6:	4a05      	ldr	r2, [pc, #20]	@ (800b4bc <HAL_FLASH_OB_Unlock+0x20>)
 800b4a8:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
 800b4aa:	f102 3244 	add.w	r2, r2, #1145324612	@ 0x44444444
 800b4ae:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
 800b4b0:	6998      	ldr	r0, [r3, #24]
 800b4b2:	f000 0001 	and.w	r0, r0, #1
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
 800b4b6:	4770      	bx	lr
 800b4b8:	52002000 	.word	0x52002000
 800b4bc:	08192a3b 	.word	0x08192a3b

0800b4c0 <HAL_FLASH_OB_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
 800b4c0:	4b04      	ldr	r3, [pc, #16]	@ (800b4d4 <HAL_FLASH_OB_Lock+0x14>)
 800b4c2:	699a      	ldr	r2, [r3, #24]
 800b4c4:	f042 0201 	orr.w	r2, r2, #1
 800b4c8:	619a      	str	r2, [r3, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
 800b4ca:	6998      	ldr	r0, [r3, #24]
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 800b4cc:	43c0      	mvns	r0, r0
 800b4ce:	f000 0001 	and.w	r0, r0, #1
 800b4d2:	4770      	bx	lr
 800b4d4:	52002000 	.word	0x52002000

0800b4d8 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
 800b4d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b4dc:	460c      	mov	r4, r1
 800b4de:	4605      	mov	r5, r0
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
  uint32_t errorflag = 0;
  uint32_t tickstart = HAL_GetTick();
 800b4e0:	f7ff fe34 	bl	800b14c <HAL_GetTick>
 800b4e4:	4f27      	ldr	r7, [pc, #156]	@ (800b584 <FLASH_WaitForLastOperation+0xac>)
  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
 800b4e6:	2c02      	cmp	r4, #2
  uint32_t tickstart = HAL_GetTick();
 800b4e8:	4606      	mov	r6, r0
    /* Select bsyflag depending on Bank */
    bsyflag = FLASH_FLAG_QW_BANK2;
  }
#endif /* DUAL_BANK */

  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b4ea:	bf0c      	ite	eq
 800b4ec:	f04f 4800 	moveq.w	r8, #2147483648	@ 0x80000000
 800b4f0:	f04f 0800 	movne.w	r8, #0
 800b4f4:	f1b8 0f00 	cmp.w	r8, #0
 800b4f8:	d122      	bne.n	800b540 <FLASH_WaitForLastOperation+0x68>
 800b4fa:	693b      	ldr	r3, [r7, #16]
 800b4fc:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800b500:	b99b      	cbnz	r3, 800b52a <FLASH_WaitForLastOperation+0x52>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
 800b502:	2c01      	cmp	r4, #1
 800b504:	4b1f      	ldr	r3, [pc, #124]	@ (800b584 <FLASH_WaitForLastOperation+0xac>)
 800b506:	4a20      	ldr	r2, [pc, #128]	@ (800b588 <FLASH_WaitForLastOperation+0xb0>)
 800b508:	d11d      	bne.n	800b546 <FLASH_WaitForLastOperation+0x6e>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 800b50a:	691b      	ldr	r3, [r3, #16]
 800b50c:	4013      	ands	r3, r2
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
  }
#endif /* DUAL_BANK */

  /* In case of error reported in Flash SR1 or SR2 register */
  if((errorflag & 0x7FFFFFFFU) != 0U)
 800b50e:	f033 4000 	bics.w	r0, r3, #2147483648	@ 0x80000000
 800b512:	d021      	beq.n	800b558 <FLASH_WaitForLastOperation+0x80>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
 800b514:	491d      	ldr	r1, [pc, #116]	@ (800b58c <FLASH_WaitForLastOperation+0xb4>)

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800b516:	2b00      	cmp	r3, #0
    pFlash.ErrorCode |= errorflag;
 800b518:	698a      	ldr	r2, [r1, #24]
 800b51a:	ea42 0203 	orr.w	r2, r2, r3
 800b51e:	618a      	str	r2, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800b520:	4a18      	ldr	r2, [pc, #96]	@ (800b584 <FLASH_WaitForLastOperation+0xac>)
 800b522:	db16      	blt.n	800b552 <FLASH_WaitForLastOperation+0x7a>
 800b524:	6153      	str	r3, [r2, #20]

    return HAL_ERROR;
 800b526:	2001      	movs	r0, #1
 800b528:	e020      	b.n	800b56c <FLASH_WaitForLastOperation+0x94>
    if(Timeout != HAL_MAX_DELAY)
 800b52a:	1c68      	adds	r0, r5, #1
 800b52c:	d0e2      	beq.n	800b4f4 <FLASH_WaitForLastOperation+0x1c>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800b52e:	f7ff fe0d 	bl	800b14c <HAL_GetTick>
 800b532:	1b80      	subs	r0, r0, r6
 800b534:	42a8      	cmp	r0, r5
 800b536:	d801      	bhi.n	800b53c <FLASH_WaitForLastOperation+0x64>
 800b538:	2d00      	cmp	r5, #0
 800b53a:	d1db      	bne.n	800b4f4 <FLASH_WaitForLastOperation+0x1c>
        return HAL_TIMEOUT;
 800b53c:	2003      	movs	r0, #3
 800b53e:	e015      	b.n	800b56c <FLASH_WaitForLastOperation+0x94>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b540:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800b544:	e7da      	b.n	800b4fc <FLASH_WaitForLastOperation+0x24>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 800b546:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
 800b54a:	4013      	ands	r3, r2
 800b54c:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800b550:	e7dd      	b.n	800b50e <FLASH_WaitForLastOperation+0x36>
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800b552:	f8c2 0114 	str.w	r0, [r2, #276]	@ 0x114
 800b556:	e7e6      	b.n	800b526 <FLASH_WaitForLastOperation+0x4e>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
 800b558:	2c01      	cmp	r4, #1
 800b55a:	4b0a      	ldr	r3, [pc, #40]	@ (800b584 <FLASH_WaitForLastOperation+0xac>)
 800b55c:	d108      	bne.n	800b570 <FLASH_WaitForLastOperation+0x98>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
 800b55e:	691a      	ldr	r2, [r3, #16]
 800b560:	03d1      	lsls	r1, r2, #15
 800b562:	d502      	bpl.n	800b56a <FLASH_WaitForLastOperation+0x92>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
 800b564:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800b568:	615a      	str	r2, [r3, #20]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
 800b56a:	2000      	movs	r0, #0
}
 800b56c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
 800b570:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 800b574:	03d2      	lsls	r2, r2, #15
 800b576:	d5f8      	bpl.n	800b56a <FLASH_WaitForLastOperation+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
 800b578:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800b57c:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
 800b580:	e7f3      	b.n	800b56a <FLASH_WaitForLastOperation+0x92>
 800b582:	bf00      	nop
 800b584:	52002000 	.word	0x52002000
 800b588:	17ee0000 	.word	0x17ee0000
 800b58c:	20001d5c 	.word	0x20001d5c

0800b590 <HAL_FLASH_Program>:
{
 800b590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 800b592:	4e28      	ldr	r6, [pc, #160]	@ (800b634 <HAL_FLASH_Program+0xa4>)
{
 800b594:	460d      	mov	r5, r1
 800b596:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 800b598:	7d33      	ldrb	r3, [r6, #20]
 800b59a:	2b01      	cmp	r3, #1
 800b59c:	d048      	beq.n	800b630 <HAL_FLASH_Program+0xa0>
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 800b59e:	f101 4378 	add.w	r3, r1, #4160749568	@ 0xf8000000
  __HAL_LOCK(&pFlash);
 800b5a2:	2001      	movs	r0, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 800b5a4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
  __HAL_LOCK(&pFlash);
 800b5a8:	7530      	strb	r0, [r6, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 800b5aa:	d331      	bcc.n	800b610 <HAL_FLASH_Program+0x80>
  else if(IS_FLASH_PROGRAM_ADDRESS_BANK2(FlashAddress))
 800b5ac:	f1a1 6301 	sub.w	r3, r1, #135266304	@ 0x8100000
 800b5b0:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800b5b4:	d22b      	bcs.n	800b60e <HAL_FLASH_Program+0x7e>
    bank = FLASH_BANK_2;
 800b5b6:	2402      	movs	r4, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b5b8:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 800b5ba:	4621      	mov	r1, r4
 800b5bc:	f24c 3050 	movw	r0, #50000	@ 0xc350
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b5c0:	61b3      	str	r3, [r6, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 800b5c2:	f7ff ff89 	bl	800b4d8 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 800b5c6:	bb00      	cbnz	r0, 800b60a <HAL_FLASH_Program+0x7a>
    if(bank == FLASH_BANK_1)
 800b5c8:	2c01      	cmp	r4, #1
 800b5ca:	4b1b      	ldr	r3, [pc, #108]	@ (800b638 <HAL_FLASH_Program+0xa8>)
 800b5cc:	d122      	bne.n	800b614 <HAL_FLASH_Program+0x84>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
 800b5ce:	68da      	ldr	r2, [r3, #12]
 800b5d0:	f042 0202 	orr.w	r2, r2, #2
 800b5d4:	60da      	str	r2, [r3, #12]
  __ASM volatile ("isb 0xF":::"memory");
 800b5d6:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 800b5da:	f3bf 8f4f 	dsb	sy
}
 800b5de:	2300      	movs	r3, #0
        *dest_addr = *src_addr;
 800b5e0:	58fa      	ldr	r2, [r7, r3]
 800b5e2:	50ea      	str	r2, [r5, r3]
     } while (row_index != 0U);
 800b5e4:	3304      	adds	r3, #4
 800b5e6:	2b20      	cmp	r3, #32
 800b5e8:	d1fa      	bne.n	800b5e0 <HAL_FLASH_Program+0x50>
  __ASM volatile ("isb 0xF":::"memory");
 800b5ea:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 800b5ee:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 800b5f2:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b5f6:	4621      	mov	r1, r4
 800b5f8:	f7ff ff6e 	bl	800b4d8 <FLASH_WaitForLastOperation>
      if(bank == FLASH_BANK_1)
 800b5fc:	2c01      	cmp	r4, #1
 800b5fe:	4b0e      	ldr	r3, [pc, #56]	@ (800b638 <HAL_FLASH_Program+0xa8>)
 800b600:	d10f      	bne.n	800b622 <HAL_FLASH_Program+0x92>
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 800b602:	68da      	ldr	r2, [r3, #12]
 800b604:	f022 0202 	bic.w	r2, r2, #2
 800b608:	60da      	str	r2, [r3, #12]
  __HAL_UNLOCK(&pFlash);
 800b60a:	2300      	movs	r3, #0
 800b60c:	7533      	strb	r3, [r6, #20]
}
 800b60e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    bank = FLASH_BANK_1;
 800b610:	4604      	mov	r4, r0
 800b612:	e7d1      	b.n	800b5b8 <HAL_FLASH_Program+0x28>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
 800b614:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b618:	f042 0202 	orr.w	r2, r2, #2
 800b61c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 800b620:	e7d9      	b.n	800b5d6 <HAL_FLASH_Program+0x46>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
 800b622:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b626:	f022 0202 	bic.w	r2, r2, #2
 800b62a:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 800b62e:	e7ec      	b.n	800b60a <HAL_FLASH_Program+0x7a>
  __HAL_LOCK(&pFlash);
 800b630:	2002      	movs	r0, #2
 800b632:	e7ec      	b.n	800b60e <HAL_FLASH_Program+0x7e>
 800b634:	20001d5c 	.word	0x20001d5c
 800b638:	52002000 	.word	0x52002000

0800b63c <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
 800b63c:	b570      	push	{r4, r5, r6, lr}
 800b63e:	4604      	mov	r4, r0
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
 800b640:	4d10      	ldr	r5, [pc, #64]	@ (800b684 <FLASH_OB_WaitForLastOperation+0x48>)
  uint32_t tickstart = HAL_GetTick();
 800b642:	f7ff fd83 	bl	800b14c <HAL_GetTick>
 800b646:	4606      	mov	r6, r0
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
 800b648:	69eb      	ldr	r3, [r5, #28]
 800b64a:	07db      	lsls	r3, r3, #31
 800b64c:	d40e      	bmi.n	800b66c <FLASH_OB_WaitForLastOperation+0x30>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
 800b64e:	69e8      	ldr	r0, [r5, #28]
 800b650:	f010 4080 	ands.w	r0, r0, #1073741824	@ 0x40000000
 800b654:	d009      	beq.n	800b66a <FLASH_OB_WaitForLastOperation+0x2e>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
 800b656:	4a0c      	ldr	r2, [pc, #48]	@ (800b688 <FLASH_OB_WaitForLastOperation+0x4c>)

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
 800b658:	2001      	movs	r0, #1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
 800b65a:	6993      	ldr	r3, [r2, #24]
 800b65c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800b660:	6193      	str	r3, [r2, #24]
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
 800b662:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800b664:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800b668:	626b      	str	r3, [r5, #36]	@ 0x24
    return HAL_ERROR;
  }

  /* If there is no error flag set */
  return HAL_OK;
}
 800b66a:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
 800b66c:	1c62      	adds	r2, r4, #1
 800b66e:	d0eb      	beq.n	800b648 <FLASH_OB_WaitForLastOperation+0xc>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800b670:	f7ff fd6c 	bl	800b14c <HAL_GetTick>
 800b674:	1b80      	subs	r0, r0, r6
 800b676:	42a0      	cmp	r0, r4
 800b678:	d801      	bhi.n	800b67e <FLASH_OB_WaitForLastOperation+0x42>
 800b67a:	2c00      	cmp	r4, #0
 800b67c:	d1e4      	bne.n	800b648 <FLASH_OB_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 800b67e:	2003      	movs	r0, #3
 800b680:	e7f3      	b.n	800b66a <FLASH_OB_WaitForLastOperation+0x2e>
 800b682:	bf00      	nop
 800b684:	52002000 	.word	0x52002000
 800b688:	20001d5c 	.word	0x20001d5c

0800b68c <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
 800b68c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b690:	460d      	mov	r5, r1
 800b692:	4604      	mov	r4, r0
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
 800b694:	f7ff fd5a 	bl	800b14c <HAL_GetTick>
 800b698:	4f1e      	ldr	r7, [pc, #120]	@ (800b714 <FLASH_CRC_WaitForLastOperation+0x88>)
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
 800b69a:	2d01      	cmp	r5, #1
  uint32_t tickstart = HAL_GetTick();
 800b69c:	4606      	mov	r6, r0
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b69e:	bf14      	ite	ne
 800b6a0:	f04f 4800 	movne.w	r8, #2147483648	@ 0x80000000
 800b6a4:	f04f 0800 	moveq.w	r8, #0
 800b6a8:	f1b8 0f00 	cmp.w	r8, #0
 800b6ac:	d11f      	bne.n	800b6ee <FLASH_CRC_WaitForLastOperation+0x62>
 800b6ae:	693b      	ldr	r3, [r7, #16]
 800b6b0:	071b      	lsls	r3, r3, #28
 800b6b2:	d411      	bmi.n	800b6d8 <FLASH_CRC_WaitForLastOperation+0x4c>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
 800b6b4:	2d01      	cmp	r5, #1
 800b6b6:	4b17      	ldr	r3, [pc, #92]	@ (800b714 <FLASH_CRC_WaitForLastOperation+0x88>)
 800b6b8:	d11c      	bne.n	800b6f4 <FLASH_CRC_WaitForLastOperation+0x68>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
 800b6ba:	6918      	ldr	r0, [r3, #16]
 800b6bc:	f010 5080 	ands.w	r0, r0, #268435456	@ 0x10000000
 800b6c0:	d008      	beq.n	800b6d4 <FLASH_CRC_WaitForLastOperation+0x48>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
 800b6c2:	4915      	ldr	r1, [pc, #84]	@ (800b718 <FLASH_CRC_WaitForLastOperation+0x8c>)
 800b6c4:	698a      	ldr	r2, [r1, #24]
 800b6c6:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 800b6ca:	618a      	str	r2, [r1, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
 800b6cc:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800b6d0:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
 800b6d2:	2001      	movs	r0, #1
  }
#endif /* DUAL_BANK */

  /* If there is no error flag set */
  return HAL_OK;
}
 800b6d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 800b6d8:	1c62      	adds	r2, r4, #1
 800b6da:	d0e5      	beq.n	800b6a8 <FLASH_CRC_WaitForLastOperation+0x1c>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800b6dc:	f7ff fd36 	bl	800b14c <HAL_GetTick>
 800b6e0:	1b80      	subs	r0, r0, r6
 800b6e2:	42a0      	cmp	r0, r4
 800b6e4:	d801      	bhi.n	800b6ea <FLASH_CRC_WaitForLastOperation+0x5e>
 800b6e6:	2c00      	cmp	r4, #0
 800b6e8:	d1de      	bne.n	800b6a8 <FLASH_CRC_WaitForLastOperation+0x1c>
        return HAL_TIMEOUT;
 800b6ea:	2003      	movs	r0, #3
 800b6ec:	e7f2      	b.n	800b6d4 <FLASH_CRC_WaitForLastOperation+0x48>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800b6ee:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 800b6f2:	e7dd      	b.n	800b6b0 <FLASH_CRC_WaitForLastOperation+0x24>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
 800b6f4:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
 800b6f8:	f010 5080 	ands.w	r0, r0, #268435456	@ 0x10000000
 800b6fc:	d0ea      	beq.n	800b6d4 <FLASH_CRC_WaitForLastOperation+0x48>
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
 800b6fe:	4906      	ldr	r1, [pc, #24]	@ (800b718 <FLASH_CRC_WaitForLastOperation+0x8c>)
 800b700:	698a      	ldr	r2, [r1, #24]
 800b702:	f042 4210 	orr.w	r2, r2, #2415919104	@ 0x90000000
 800b706:	618a      	str	r2, [r1, #24]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
 800b708:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800b70c:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
      return HAL_ERROR;
 800b710:	e7df      	b.n	800b6d2 <FLASH_CRC_WaitForLastOperation+0x46>
 800b712:	bf00      	nop
 800b714:	52002000 	.word	0x52002000
 800b718:	20001d5c 	.word	0x20001d5c

0800b71c <HAL_FLASH_OB_Launch>:
{
 800b71c:	b508      	push	{r3, lr}
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800b71e:	2101      	movs	r1, #1
 800b720:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b724:	f7ff ffb2 	bl	800b68c <FLASH_CRC_WaitForLastOperation>
 800b728:	b980      	cbnz	r0, 800b74c <HAL_FLASH_OB_Launch+0x30>
  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800b72a:	2102      	movs	r1, #2
 800b72c:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b730:	f7ff ffac 	bl	800b68c <FLASH_CRC_WaitForLastOperation>
 800b734:	b950      	cbnz	r0, 800b74c <HAL_FLASH_OB_Launch+0x30>
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
 800b736:	4a06      	ldr	r2, [pc, #24]	@ (800b750 <HAL_FLASH_OB_Launch+0x34>)
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800b738:	f24c 3050 	movw	r0, #50000	@ 0xc350
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
 800b73c:	6993      	ldr	r3, [r2, #24]
 800b73e:	f043 0302 	orr.w	r3, r3, #2
 800b742:	6193      	str	r3, [r2, #24]
}
 800b744:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800b748:	f7ff bf78 	b.w	800b63c <FLASH_OB_WaitForLastOperation>
}
 800b74c:	2001      	movs	r0, #1
 800b74e:	bd08      	pop	{r3, pc}
 800b750:	52002000 	.word	0x52002000

0800b754 <FLASH_MassErase>:
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));

#if defined (DUAL_BANK)
  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
 800b754:	f001 0303 	and.w	r3, r1, #3
 800b758:	2b03      	cmp	r3, #3
 800b75a:	d117      	bne.n	800b78c <FLASH_MassErase+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
 800b75c:	4b1d      	ldr	r3, [pc, #116]	@ (800b7d4 <FLASH_MassErase+0x80>)
 800b75e:	68da      	ldr	r2, [r3, #12]
 800b760:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b764:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
 800b766:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b76a:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b76e:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c

    /* Set voltage range */
    FLASH->CR1 |= VoltageRange;
 800b772:	68da      	ldr	r2, [r3, #12]
 800b774:	4302      	orrs	r2, r0
 800b776:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
 800b778:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b77c:	4302      	orrs	r2, r0
 800b77e:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
#endif /* FLASH_CR_PSIZE */

    /* Set Mass Erase Bit */
    FLASH->OPTCR |= FLASH_OPTCR_MER;
 800b782:	699a      	ldr	r2, [r3, #24]
 800b784:	f042 0210 	orr.w	r2, r2, #16
 800b788:	619a      	str	r2, [r3, #24]
 800b78a:	4770      	bx	lr
  }
  else
#endif /* DUAL_BANK */
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b78c:	07ca      	lsls	r2, r1, #31
 800b78e:	d50b      	bpl.n	800b7a8 <FLASH_MassErase+0x54>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
 800b790:	4b10      	ldr	r3, [pc, #64]	@ (800b7d4 <FLASH_MassErase+0x80>)
 800b792:	68da      	ldr	r2, [r3, #12]
 800b794:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b798:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
 800b79a:	68da      	ldr	r2, [r3, #12]
 800b79c:	4302      	orrs	r2, r0
 800b79e:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
 800b7a0:	68da      	ldr	r2, [r3, #12]
 800b7a2:	f042 0288 	orr.w	r2, r2, #136	@ 0x88
 800b7a6:	60da      	str	r2, [r3, #12]
    }

#if defined (DUAL_BANK)
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b7a8:	078b      	lsls	r3, r1, #30
 800b7aa:	d511      	bpl.n	800b7d0 <FLASH_MassErase+0x7c>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
 800b7ac:	4b09      	ldr	r3, [pc, #36]	@ (800b7d4 <FLASH_MassErase+0x80>)
 800b7ae:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b7b2:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800b7b6:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
      FLASH->CR2 |= VoltageRange;
 800b7ba:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b7be:	4310      	orrs	r0, r2
 800b7c0:	f8c3 010c 	str.w	r0, [r3, #268]	@ 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
 800b7c4:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
 800b7c8:	f042 0288 	orr.w	r2, r2, #136	@ 0x88
 800b7cc:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    }
#endif /* DUAL_BANK */
  }
}
 800b7d0:	4770      	bx	lr
 800b7d2:	bf00      	nop
 800b7d4:	52002000 	.word	0x52002000

0800b7d8 <HAL_FLASHEx_OBProgram>:
{
 800b7d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 800b7da:	4e8c      	ldr	r6, [pc, #560]	@ (800ba0c <HAL_FLASHEx_OBProgram+0x234>)
{
 800b7dc:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 800b7de:	7d33      	ldrb	r3, [r6, #20]
 800b7e0:	2b01      	cmp	r3, #1
 800b7e2:	f000 8111 	beq.w	800ba08 <HAL_FLASHEx_OBProgram+0x230>
 800b7e6:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b7e8:	2300      	movs	r3, #0
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800b7ea:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
 800b7ee:	7531      	strb	r1, [r6, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800b7f0:	61b3      	str	r3, [r6, #24]
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800b7f2:	f7ff fe71 	bl	800b4d8 <FLASH_WaitForLastOperation>
 800b7f6:	b118      	cbz	r0, 800b800 <HAL_FLASHEx_OBProgram+0x28>
    status = HAL_ERROR;
 800b7f8:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 800b7fa:	2300      	movs	r3, #0
 800b7fc:	7533      	strb	r3, [r6, #20]
}
 800b7fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800b800:	2102      	movs	r1, #2
 800b802:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800b806:	f7ff fe67 	bl	800b4d8 <FLASH_WaitForLastOperation>
 800b80a:	2800      	cmp	r0, #0
 800b80c:	d1f4      	bne.n	800b7f8 <HAL_FLASHEx_OBProgram+0x20>
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
 800b80e:	6827      	ldr	r7, [r4, #0]
 800b810:	07f9      	lsls	r1, r7, #31
 800b812:	d51a      	bpl.n	800b84a <HAL_FLASHEx_OBProgram+0x72>
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
 800b814:	6865      	ldr	r5, [r4, #4]
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
 800b816:	69e2      	ldr	r2, [r4, #28]
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
 800b818:	2d01      	cmp	r5, #1
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
 800b81a:	68a3      	ldr	r3, [r4, #8]
{
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b81c:	f002 0101 	and.w	r1, r2, #1
 800b820:	f002 0202 	and.w	r2, r2, #2
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
 800b824:	f040 80dd 	bne.w	800b9e2 <HAL_FLASHEx_OBProgram+0x20a>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b828:	b131      	cbz	r1, 800b838 <HAL_FLASHEx_OBProgram+0x60>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
 800b82a:	4d79      	ldr	r5, [pc, #484]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b82c:	fa5f fc83 	uxtb.w	ip, r3
 800b830:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 800b832:	ea21 010c 	bic.w	r1, r1, ip
 800b836:	63e9      	str	r1, [r5, #60]	@ 0x3c
  }

#if defined (DUAL_BANK)
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b838:	b13a      	cbz	r2, 800b84a <HAL_FLASHEx_OBProgram+0x72>
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
 800b83a:	4975      	ldr	r1, [pc, #468]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b83c:	b2db      	uxtb	r3, r3
 800b83e:	f8d1 213c 	ldr.w	r2, [r1, #316]	@ 0x13c
 800b842:	ea22 0303 	bic.w	r3, r2, r3
 800b846:	f8c1 313c 	str.w	r3, [r1, #316]	@ 0x13c
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 800b84a:	07ba      	lsls	r2, r7, #30
 800b84c:	d506      	bpl.n	800b85c <HAL_FLASHEx_OBProgram+0x84>
{
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
 800b84e:	4a70      	ldr	r2, [pc, #448]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b850:	68e1      	ldr	r1, [r4, #12]
 800b852:	6a13      	ldr	r3, [r2, #32]
 800b854:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800b858:	430b      	orrs	r3, r1
 800b85a:	6213      	str	r3, [r2, #32]
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 800b85c:	077b      	lsls	r3, r7, #29
 800b85e:	d554      	bpl.n	800b90a <HAL_FLASHEx_OBProgram+0x132>
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
 800b860:	e9d4 5105 	ldrd	r5, r1, [r4, #20]
  uint32_t optr_reg_mask = 0;

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
 800b864:	f015 0301 	ands.w	r3, r5, #1
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
 800b868:	bf1a      	itte	ne
 800b86a:	f001 0310 	andne.w	r3, r1, #16
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
 800b86e:	2210      	movne	r2, #16
  uint32_t optr_reg_mask = 0;
 800b870:	461a      	moveq	r2, r3
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
 800b872:	f015 0f02 	tst.w	r5, #2
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
 800b876:	bf1e      	ittt	ne
 800b878:	f001 0c40 	andne.w	ip, r1, #64	@ 0x40
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
 800b87c:	f042 0240 	orrne.w	r2, r2, #64	@ 0x40
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
 800b880:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
 800b884:	f015 0f04 	tst.w	r5, #4
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
 800b888:	bf1e      	ittt	ne
 800b88a:	f001 0c80 	andne.w	ip, r1, #128	@ 0x80
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
 800b88e:	f042 0280 	orrne.w	r2, r2, #128	@ 0x80
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
 800b892:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
 800b896:	f015 0f08 	tst.w	r5, #8
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
 800b89a:	bf1e      	ittt	ne
 800b89c:	f401 3c00 	andne.w	ip, r1, #131072	@ 0x20000
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
 800b8a0:	f442 3200 	orrne.w	r2, r2, #131072	@ 0x20000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
 800b8a4:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
 800b8a8:	f015 0f10 	tst.w	r5, #16
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
 800b8ac:	bf1e      	ittt	ne
 800b8ae:	f401 2c80 	andne.w	ip, r1, #262144	@ 0x40000
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
 800b8b2:	f442 2280 	orrne.w	r2, r2, #262144	@ 0x40000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
 800b8b6:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
 800b8ba:	f015 0f20 	tst.w	r5, #32
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
 800b8be:	bf1e      	ittt	ne
 800b8c0:	f401 1cc0 	andne.w	ip, r1, #1572864	@ 0x180000
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
 800b8c4:	f442 12c0 	orrne.w	r2, r2, #1572864	@ 0x180000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
 800b8c8:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_SECURITY) != 0U)
 800b8cc:	f015 0f40 	tst.w	r5, #64	@ 0x40
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
 800b8d0:	bf1e      	ittt	ne
 800b8d2:	f401 1c00 	andne.w	ip, r1, #2097152	@ 0x200000
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
 800b8d6:	f442 1200 	orrne.w	r2, r2, #2097152	@ 0x200000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
 800b8da:	ea43 030c 	orrne.w	r3, r3, ip
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;
  }
#endif /* FLASH_OPTSR_NRST_STOP_D2 */

#if defined (DUAL_BANK)
  if((UserType & OB_USER_SWAP_BANK) != 0U)
 800b8de:	f415 7f80 	tst.w	r5, #256	@ 0x100
  {
    /* SWAP_BANK_OPT option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));

    /* Set value and mask for SWAP_BANK_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
 800b8e2:	bf1e      	ittt	ne
 800b8e4:	f001 4c00 	andne.w	ip, r1, #2147483648	@ 0x80000000
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
 800b8e8:	f042 4200 	orrne.w	r2, r2, #2147483648	@ 0x80000000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
 800b8ec:	ea43 030c 	orrne.w	r3, r3, ip
  }
#endif /* DUAL_BANK */

  if((UserType & OB_USER_IOHSLV) != 0U)
 800b8f0:	062d      	lsls	r5, r5, #24
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
 800b8f2:	4d47      	ldr	r5, [pc, #284]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
 800b8f4:	bf42      	ittt	mi
 800b8f6:	f001 5100 	andmi.w	r1, r1, #536870912	@ 0x20000000
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
 800b8fa:	f042 5200 	orrmi.w	r2, r2, #536870912	@ 0x20000000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
 800b8fe:	430b      	orrmi	r3, r1
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
 800b900:	6a29      	ldr	r1, [r5, #32]
 800b902:	ea21 0202 	bic.w	r2, r1, r2
 800b906:	4313      	orrs	r3, r2
 800b908:	622b      	str	r3, [r5, #32]
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
 800b90a:	073b      	lsls	r3, r7, #28
 800b90c:	d523      	bpl.n	800b956 <HAL_FLASHEx_OBProgram+0x17e>
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
 800b90e:	f8d4 e01c 	ldr.w	lr, [r4, #28]
 800b912:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b914:	f01e 0f01 	tst.w	lr, #1
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
 800b918:	e9d4 3508 	ldrd	r3, r5, [r4, #32]
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b91c:	d00c      	beq.n	800b938 <HAL_FLASHEx_OBProgram+0x160>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800b91e:	0211      	lsls	r1, r2, #8
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
 800b920:	f105 4c78 	add.w	ip, r5, #4160749568	@ 0xf8000000
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800b924:	f36f 010f 	bfc	r1, #0, #16
 800b928:	ea43 2c1c 	orr.w	ip, r3, ip, lsr #8
 800b92c:	ea41 010c 	orr.w	r1, r1, ip
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
 800b930:	f8df c0dc 	ldr.w	ip, [pc, #220]	@ 800ba10 <HAL_FLASHEx_OBProgram+0x238>
 800b934:	f8cc 102c 	str.w	r1, [ip, #44]	@ 0x2c
                       PCROPConfig;
  }

#if defined (DUAL_BANK)
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b938:	f01e 0f02 	tst.w	lr, #2
 800b93c:	d00b      	beq.n	800b956 <HAL_FLASHEx_OBProgram+0x17e>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800b93e:	f1a2 6201 	sub.w	r2, r2, #135266304	@ 0x8100000
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
 800b942:	f1a5 6501 	sub.w	r5, r5, #135266304	@ 0x8100000
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
 800b946:	0a12      	lsrs	r2, r2, #8
 800b948:	ea43 2315 	orr.w	r3, r3, r5, lsr #8
 800b94c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
 800b950:	4a2f      	ldr	r2, [pc, #188]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b952:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
 800b956:	06fd      	lsls	r5, r7, #27
 800b958:	d506      	bpl.n	800b968 <HAL_FLASHEx_OBProgram+0x190>
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
 800b95a:	4a2d      	ldr	r2, [pc, #180]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b95c:	6921      	ldr	r1, [r4, #16]
 800b95e:	6a13      	ldr	r3, [r2, #32]
 800b960:	f023 030c 	bic.w	r3, r3, #12
 800b964:	430b      	orrs	r3, r1
 800b966:	6213      	str	r3, [r2, #32]
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
 800b968:	0679      	lsls	r1, r7, #25
 800b96a:	d513      	bpl.n	800b994 <HAL_FLASHEx_OBProgram+0x1bc>
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
 800b96c:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800b96e:	f8d4 c034 	ldr.w	ip, [r4, #52]	@ 0x34
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
 800b972:	07ca      	lsls	r2, r1, #31
 800b974:	d506      	bpl.n	800b984 <HAL_FLASHEx_OBProgram+0x1ac>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
 800b976:	4d26      	ldr	r5, [pc, #152]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b978:	8e63      	ldrh	r3, [r4, #50]	@ 0x32
 800b97a:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
 800b97c:	f36f 020f 	bfc	r2, #0, #16
 800b980:	4313      	orrs	r3, r2
 800b982:	646b      	str	r3, [r5, #68]	@ 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
 800b984:	078b      	lsls	r3, r1, #30
 800b986:	d505      	bpl.n	800b994 <HAL_FLASHEx_OBProgram+0x1bc>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
 800b988:	4a21      	ldr	r2, [pc, #132]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b98a:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800b98c:	b29b      	uxth	r3, r3
 800b98e:	ea43 030c 	orr.w	r3, r3, ip
 800b992:	6453      	str	r3, [r2, #68]	@ 0x44
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
 800b994:	06bd      	lsls	r5, r7, #26
 800b996:	f57f af30 	bpl.w	800b7fa <HAL_FLASHEx_OBProgram+0x22>
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
 800b99a:	69e5      	ldr	r5, [r4, #28]
 800b99c:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 800b99e:	e9d4 370e 	ldrd	r3, r7, [r4, #56]	@ 0x38
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b9a2:	07ec      	lsls	r4, r5, #31
 800b9a4:	d50b      	bpl.n	800b9be <HAL_FLASHEx_OBProgram+0x1e6>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
 800b9a6:	f107 4478 	add.w	r4, r7, #4160749568	@ 0xf8000000
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
 800b9aa:	f003 4100 	and.w	r1, r3, #2147483648	@ 0x80000000
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
 800b9ae:	ea41 2114 	orr.w	r1, r1, r4, lsr #8
 800b9b2:	0214      	lsls	r4, r2, #8
 800b9b4:	f36f 040f 	bfc	r4, #0, #16
 800b9b8:	4321      	orrs	r1, r4
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
 800b9ba:	4c15      	ldr	r4, [pc, #84]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b9bc:	6361      	str	r1, [r4, #52]	@ 0x34
  }

#if defined (DUAL_BANK)
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b9be:	07a9      	lsls	r1, r5, #30
 800b9c0:	f57f af1b 	bpl.w	800b7fa <HAL_FLASHEx_OBProgram+0x22>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
 800b9c4:	f1a7 6101 	sub.w	r1, r7, #135266304	@ 0x8100000
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
 800b9c8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
 800b9cc:	f1a2 6201 	sub.w	r2, r2, #135266304	@ 0x8100000
 800b9d0:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
 800b9d4:	0a12      	lsrs	r2, r2, #8
 800b9d6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
 800b9da:	4a0d      	ldr	r2, [pc, #52]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b9dc:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
 800b9e0:	e70b      	b.n	800b7fa <HAL_FLASHEx_OBProgram+0x22>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800b9e2:	b131      	cbz	r1, 800b9f2 <HAL_FLASHEx_OBProgram+0x21a>
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
 800b9e4:	4d0a      	ldr	r5, [pc, #40]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b9e6:	b2d9      	uxtb	r1, r3
 800b9e8:	f8d5 c03c 	ldr.w	ip, [r5, #60]	@ 0x3c
 800b9ec:	ea41 010c 	orr.w	r1, r1, ip
 800b9f0:	63e9      	str	r1, [r5, #60]	@ 0x3c
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800b9f2:	2a00      	cmp	r2, #0
 800b9f4:	f43f af29 	beq.w	800b84a <HAL_FLASHEx_OBProgram+0x72>
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
 800b9f8:	4a05      	ldr	r2, [pc, #20]	@ (800ba10 <HAL_FLASHEx_OBProgram+0x238>)
 800b9fa:	b2db      	uxtb	r3, r3
 800b9fc:	f8d2 113c 	ldr.w	r1, [r2, #316]	@ 0x13c
 800ba00:	430b      	orrs	r3, r1
 800ba02:	f8c2 313c 	str.w	r3, [r2, #316]	@ 0x13c
 800ba06:	e720      	b.n	800b84a <HAL_FLASHEx_OBProgram+0x72>
  __HAL_LOCK(&pFlash);
 800ba08:	2002      	movs	r0, #2
 800ba0a:	e6f8      	b.n	800b7fe <HAL_FLASHEx_OBProgram+0x26>
 800ba0c:	20001d5c 	.word	0x20001d5c
 800ba10:	52002000 	.word	0x52002000

0800ba14 <HAL_FLASHEx_OBGetConfig>:
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
 800ba14:	2316      	movs	r3, #22
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
 800ba16:	4a31      	ldr	r2, [pc, #196]	@ (800badc <HAL_FLASHEx_OBGetConfig+0xc8>)
{
 800ba18:	b530      	push	{r4, r5, lr}
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
 800ba1a:	6003      	str	r3, [r0, #0]
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
 800ba1c:	69d3      	ldr	r3, [r2, #28]
 800ba1e:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
 800ba22:	f5b3 4f2a 	cmp.w	r3, #43520	@ 0xaa00
 800ba26:	d006      	beq.n	800ba36 <HAL_FLASHEx_OBGetConfig+0x22>
 800ba28:	f5b3 4f4c 	cmp.w	r3, #52224	@ 0xcc00
 800ba2c:	bf0c      	ite	eq
 800ba2e:	f44f 434c 	moveq.w	r3, #52224	@ 0xcc00
 800ba32:	f44f 43aa 	movne.w	r3, #21760	@ 0x5500
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 800ba36:	60c3      	str	r3, [r0, #12]
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
 800ba38:	69d3      	ldr	r3, [r2, #28]
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
 800ba3a:	69c4      	ldr	r4, [r0, #28]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
 800ba3c:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800ba40:	f023 030c 	bic.w	r3, r3, #12
  pOBInit->USERConfig = FLASH_OB_GetUser();
 800ba44:	6183      	str	r3, [r0, #24]
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
 800ba46:	69d3      	ldr	r3, [r2, #28]
 800ba48:	f003 030c 	and.w	r3, r3, #12
  pOBInit->BORLevel = FLASH_OB_GetBOR();
 800ba4c:	6103      	str	r3, [r0, #16]
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
 800ba4e:	1e63      	subs	r3, r4, #1
 800ba50:	2b01      	cmp	r3, #1
 800ba52:	d82c      	bhi.n	800baae <HAL_FLASHEx_OBGetConfig+0x9a>
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
 800ba54:	233f      	movs	r3, #63	@ 0x3f
  if(Bank == FLASH_BANK_1)
 800ba56:	2c01      	cmp	r4, #1
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
 800ba58:	6003      	str	r3, [r0, #0]
  if(Bank == FLASH_BANK_1)
 800ba5a:	d134      	bne.n	800bac6 <HAL_FLASHEx_OBGetConfig+0xb2>
    regvalue = FLASH->WPSN_CUR1;
 800ba5c:	6b93      	ldr	r3, [r2, #56]	@ 0x38
  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
 800ba5e:	43db      	mvns	r3, r3
 800ba60:	b2db      	uxtb	r3, r3
 800ba62:	6083      	str	r3, [r0, #8]
  if(*WRPSector == 0U)
 800ba64:	3b00      	subs	r3, #0
 800ba66:	bf18      	it	ne
 800ba68:	2301      	movne	r3, #1
  if(Bank == FLASH_BANK_1)
 800ba6a:	2c01      	cmp	r4, #1
 800ba6c:	6043      	str	r3, [r0, #4]
 800ba6e:	4b1b      	ldr	r3, [pc, #108]	@ (800badc <HAL_FLASHEx_OBGetConfig+0xc8>)
 800ba70:	d12c      	bne.n	800bacc <HAL_FLASHEx_OBGetConfig+0xb8>
    regvalue = FLASH->PRAR_CUR1;
 800ba72:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
    bankBase = FLASH_BANK1_BASE;
 800ba74:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
 800ba78:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
{
  uint32_t regvalue = 0;
  uint32_t bankBase = 0;

  /* Check Bank parameter value */
  if(Bank == FLASH_BANK_1)
 800ba7c:	2c01      	cmp	r4, #1
  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
 800ba7e:	6203      	str	r3, [r0, #32]
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
 800ba80:	4b17      	ldr	r3, [pc, #92]	@ (800bae0 <HAL_FLASHEx_OBGetConfig+0xcc>)
 800ba82:	ea03 2502 	and.w	r5, r3, r2, lsl #8
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
 800ba86:	ea03 2212 	and.w	r2, r3, r2, lsr #8
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
 800ba8a:	440d      	add	r5, r1
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
 800ba8c:	440a      	add	r2, r1
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
 800ba8e:	6245      	str	r5, [r0, #36]	@ 0x24
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
 800ba90:	6282      	str	r2, [r0, #40]	@ 0x28
  if(Bank == FLASH_BANK_1)
 800ba92:	4a12      	ldr	r2, [pc, #72]	@ (800badc <HAL_FLASHEx_OBGetConfig+0xc8>)
 800ba94:	d11f      	bne.n	800bad6 <HAL_FLASHEx_OBGetConfig+0xc2>
  {
    regvalue = FLASH->SCAR_CUR1;
 800ba96:	6b12      	ldr	r2, [r2, #48]	@ 0x30
    bankBase = FLASH_BANK2_BASE;
  }
#endif /* DUAL_BANK */

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
 800ba98:	f002 4400 	and.w	r4, r2, #2147483648	@ 0x80000000
 800ba9c:	6384      	str	r4, [r0, #56]	@ 0x38
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
 800ba9e:	ea03 2402 	and.w	r4, r3, r2, lsl #8
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
 800baa2:	ea03 2312 	and.w	r3, r3, r2, lsr #8
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
 800baa6:	440c      	add	r4, r1
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
 800baa8:	440b      	add	r3, r1
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
 800baaa:	63c4      	str	r4, [r0, #60]	@ 0x3c
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
 800baac:	6403      	str	r3, [r0, #64]	@ 0x40
  regvalue = FLASH->BOOT_CUR;
 800baae:	4b0b      	ldr	r3, [pc, #44]	@ (800badc <HAL_FLASHEx_OBGetConfig+0xc8>)
 800bab0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
 800bab2:	041a      	lsls	r2, r3, #16
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
 800bab4:	f36f 030f 	bfc	r3, #0, #16
 800bab8:	6343      	str	r3, [r0, #52]	@ 0x34
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
 800baba:	6803      	ldr	r3, [r0, #0]
  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
 800babc:	6302      	str	r2, [r0, #48]	@ 0x30
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
 800babe:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800bac2:	6003      	str	r3, [r0, #0]
}
 800bac4:	bd30      	pop	{r4, r5, pc}
    regvalue = FLASH->WPSN_CUR2;
 800bac6:	f8d2 3138 	ldr.w	r3, [r2, #312]	@ 0x138
 800baca:	e7c8      	b.n	800ba5e <HAL_FLASHEx_OBGetConfig+0x4a>
    regvalue = FLASH->PRAR_CUR2;
 800bacc:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
    bankBase = FLASH_BANK2_BASE;
 800bad0:	f04f 6101 	mov.w	r1, #135266304	@ 0x8100000
 800bad4:	e7d0      	b.n	800ba78 <HAL_FLASHEx_OBGetConfig+0x64>
    regvalue = FLASH->SCAR_CUR2;
 800bad6:	f8d2 2130 	ldr.w	r2, [r2, #304]	@ 0x130
    bankBase = FLASH_BANK2_BASE;
 800bada:	e7dd      	b.n	800ba98 <HAL_FLASHEx_OBGetConfig+0x84>
 800badc:	52002000 	.word	0x52002000
 800bae0:	000fff00 	.word	0x000fff00

0800bae4 <FLASH_Erase_Sector>:
{
 800bae4:	b510      	push	{r4, lr}
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bae6:	07cc      	lsls	r4, r1, #31
 800bae8:	d50b      	bpl.n	800bb02 <FLASH_Erase_Sector+0x1e>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 800baea:	4c0f      	ldr	r4, [pc, #60]	@ (800bb28 <FLASH_Erase_Sector+0x44>)
 800baec:	68e3      	ldr	r3, [r4, #12]
 800baee:	f423 63e6 	bic.w	r3, r3, #1840	@ 0x730
 800baf2:	60e3      	str	r3, [r4, #12]
    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 800baf4:	68e3      	ldr	r3, [r4, #12]
 800baf6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800bafa:	4313      	orrs	r3, r2
 800bafc:	f043 0384 	orr.w	r3, r3, #132	@ 0x84
 800bb00:	60e3      	str	r3, [r4, #12]
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bb02:	078b      	lsls	r3, r1, #30
 800bb04:	d50f      	bpl.n	800bb26 <FLASH_Erase_Sector+0x42>
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 800bb06:	4908      	ldr	r1, [pc, #32]	@ (800bb28 <FLASH_Erase_Sector+0x44>)
 800bb08:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
 800bb0c:	f423 63e6 	bic.w	r3, r3, #1840	@ 0x730
 800bb10:	f8c1 310c 	str.w	r3, [r1, #268]	@ 0x10c
    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 800bb14:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
 800bb18:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 800bb1c:	4302      	orrs	r2, r0
 800bb1e:	f042 0284 	orr.w	r2, r2, #132	@ 0x84
 800bb22:	f8c1 210c 	str.w	r2, [r1, #268]	@ 0x10c
}
 800bb26:	bd10      	pop	{r4, pc}
 800bb28:	52002000 	.word	0x52002000

0800bb2c <HAL_FLASHEx_Erase>:
{
 800bb2c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_LOCK(&pFlash);
 800bb30:	4f44      	ldr	r7, [pc, #272]	@ (800bc44 <HAL_FLASHEx_Erase+0x118>)
{
 800bb32:	4605      	mov	r5, r0
 800bb34:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 800bb36:	7d3b      	ldrb	r3, [r7, #20]
 800bb38:	2b01      	cmp	r3, #1
 800bb3a:	f000 8081 	beq.w	800bc40 <HAL_FLASHEx_Erase+0x114>
 800bb3e:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800bb40:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
 800bb42:	7539      	strb	r1, [r7, #20]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bb44:	6844      	ldr	r4, [r0, #4]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800bb46:	61bb      	str	r3, [r7, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bb48:	400c      	ands	r4, r1
 800bb4a:	d006      	beq.n	800bb5a <HAL_FLASHEx_Erase+0x2e>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bb4c:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bb50:	f7ff fcc2 	bl	800b4d8 <FLASH_WaitForLastOperation>
 800bb54:	1e04      	subs	r4, r0, #0
 800bb56:	bf18      	it	ne
 800bb58:	2401      	movne	r4, #1
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bb5a:	686b      	ldr	r3, [r5, #4]
 800bb5c:	0798      	lsls	r0, r3, #30
 800bb5e:	d406      	bmi.n	800bb6e <HAL_FLASHEx_Erase+0x42>
  if(status == HAL_OK)
 800bb60:	b16c      	cbz	r4, 800bb7e <HAL_FLASHEx_Erase+0x52>
 800bb62:	2401      	movs	r4, #1
  __HAL_UNLOCK(&pFlash);
 800bb64:	2300      	movs	r3, #0
 800bb66:	753b      	strb	r3, [r7, #20]
}
 800bb68:	4620      	mov	r0, r4
 800bb6a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800bb6e:	2102      	movs	r1, #2
 800bb70:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bb74:	f7ff fcb0 	bl	800b4d8 <FLASH_WaitForLastOperation>
 800bb78:	2800      	cmp	r0, #0
 800bb7a:	d0f1      	beq.n	800bb60 <HAL_FLASHEx_Erase+0x34>
 800bb7c:	e7f1      	b.n	800bb62 <HAL_FLASHEx_Erase+0x36>
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 800bb7e:	682e      	ldr	r6, [r5, #0]
 800bb80:	2e01      	cmp	r6, #1
 800bb82:	d125      	bne.n	800bbd0 <HAL_FLASHEx_Erase+0xa4>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
 800bb84:	6869      	ldr	r1, [r5, #4]
 800bb86:	6928      	ldr	r0, [r5, #16]
 800bb88:	f7ff fde4 	bl	800b754 <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bb8c:	07c9      	lsls	r1, r1, #31
 800bb8e:	d50c      	bpl.n	800bbaa <HAL_FLASHEx_Erase+0x7e>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bb90:	4631      	mov	r1, r6
 800bb92:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bb96:	f7ff fc9f 	bl	800b4d8 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
 800bb9a:	4a2b      	ldr	r2, [pc, #172]	@ (800bc48 <HAL_FLASHEx_Erase+0x11c>)
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bb9c:	1e04      	subs	r4, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
 800bb9e:	68d3      	ldr	r3, [r2, #12]
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 800bba0:	bf18      	it	ne
 800bba2:	2401      	movne	r4, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
 800bba4:	f023 0308 	bic.w	r3, r3, #8
 800bba8:	60d3      	str	r3, [r2, #12]
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bbaa:	686b      	ldr	r3, [r5, #4]
 800bbac:	079a      	lsls	r2, r3, #30
 800bbae:	d5d9      	bpl.n	800bb64 <HAL_FLASHEx_Erase+0x38>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 800bbb0:	2102      	movs	r1, #2
 800bbb2:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bbb6:	f7ff fc8f 	bl	800b4d8 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
 800bbba:	4a23      	ldr	r2, [pc, #140]	@ (800bc48 <HAL_FLASHEx_Erase+0x11c>)
          status = HAL_ERROR;
 800bbbc:	2800      	cmp	r0, #0
        FLASH->CR2 &= (~FLASH_CR_BER);
 800bbbe:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
          status = HAL_ERROR;
 800bbc2:	bf18      	it	ne
 800bbc4:	2401      	movne	r4, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
 800bbc6:	f023 0308 	bic.w	r3, r3, #8
 800bbca:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
 800bbce:	e7c9      	b.n	800bb64 <HAL_FLASHEx_Erase+0x38>
      *SectorError = 0xFFFFFFFFU;
 800bbd0:	f04f 33ff 	mov.w	r3, #4294967295
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 800bbd4:	f8df 9070 	ldr.w	r9, [pc, #112]	@ 800bc48 <HAL_FLASHEx_Erase+0x11c>
 800bbd8:	f8df a070 	ldr.w	sl, [pc, #112]	@ 800bc4c <HAL_FLASHEx_Erase+0x120>
      *SectorError = 0xFFFFFFFFU;
 800bbdc:	f8c8 3000 	str.w	r3, [r8]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 800bbe0:	68ae      	ldr	r6, [r5, #8]
 800bbe2:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 800bbe6:	4413      	add	r3, r2
 800bbe8:	42b3      	cmp	r3, r6
 800bbea:	d9bb      	bls.n	800bb64 <HAL_FLASHEx_Erase+0x38>
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
 800bbec:	f8d5 b004 	ldr.w	fp, [r5, #4]
 800bbf0:	4630      	mov	r0, r6
 800bbf2:	692a      	ldr	r2, [r5, #16]
 800bbf4:	4659      	mov	r1, fp
 800bbf6:	f7ff ff75 	bl	800bae4 <FLASH_Erase_Sector>
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 800bbfa:	f01b 0001 	ands.w	r0, fp, #1
 800bbfe:	d00a      	beq.n	800bc16 <HAL_FLASHEx_Erase+0xea>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
 800bc00:	2101      	movs	r1, #1
 800bc02:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bc06:	f7ff fc67 	bl	800b4d8 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 800bc0a:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800bc0e:	ea03 030a 	and.w	r3, r3, sl
 800bc12:	f8c9 300c 	str.w	r3, [r9, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800bc16:	686b      	ldr	r3, [r5, #4]
 800bc18:	079b      	lsls	r3, r3, #30
 800bc1a:	d50a      	bpl.n	800bc32 <HAL_FLASHEx_Erase+0x106>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
 800bc1c:	2102      	movs	r1, #2
 800bc1e:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800bc22:	f7ff fc59 	bl	800b4d8 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 800bc26:	f8d9 310c 	ldr.w	r3, [r9, #268]	@ 0x10c
 800bc2a:	ea03 030a 	and.w	r3, r3, sl
 800bc2e:	f8c9 310c 	str.w	r3, [r9, #268]	@ 0x10c
        if(status != HAL_OK)
 800bc32:	b118      	cbz	r0, 800bc3c <HAL_FLASHEx_Erase+0x110>
          break;
 800bc34:	4604      	mov	r4, r0
          *SectorError = sector_index;
 800bc36:	f8c8 6000 	str.w	r6, [r8]
          break;
 800bc3a:	e793      	b.n	800bb64 <HAL_FLASHEx_Erase+0x38>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 800bc3c:	3601      	adds	r6, #1
 800bc3e:	e7d0      	b.n	800bbe2 <HAL_FLASHEx_Erase+0xb6>
  __HAL_LOCK(&pFlash);
 800bc40:	2402      	movs	r4, #2
 800bc42:	e791      	b.n	800bb68 <HAL_FLASHEx_Erase+0x3c>
 800bc44:	20001d5c 	.word	0x20001d5c
 800bc48:	52002000 	.word	0x52002000
 800bc4c:	fffff8fb 	.word	0xfffff8fb

0800bc50 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
 800bc50:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00U;
 800bc54:	2300      	movs	r3, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bc56:	f8df 91c4 	ldr.w	r9, [pc, #452]	@ 800be1c <HAL_GPIO_Init+0x1cc>
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800bc5a:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800bc5e:	680a      	ldr	r2, [r1, #0]
 800bc60:	fa32 f503 	lsrs.w	r5, r2, r3
 800bc64:	d102      	bne.n	800bc6c <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 800bc66:	b003      	add	sp, #12
 800bc68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 800bc6c:	2501      	movs	r5, #1
 800bc6e:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00U)
 800bc72:	ea18 0202 	ands.w	r2, r8, r2
 800bc76:	f000 80bb 	beq.w	800bdf0 <HAL_GPIO_Init+0x1a0>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bc7a:	684e      	ldr	r6, [r1, #4]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bc7c:	2703      	movs	r7, #3
 800bc7e:	ea4f 0e43 	mov.w	lr, r3, lsl #1
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bc82:	f006 0503 	and.w	r5, r6, #3
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bc86:	fa07 fc0e 	lsl.w	ip, r7, lr
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bc8a:	1e6f      	subs	r7, r5, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bc8c:	ea6f 0c0c 	mvn.w	ip, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800bc90:	2f01      	cmp	r7, #1
 800bc92:	d834      	bhi.n	800bcfe <HAL_GPIO_Init+0xae>
        temp = GPIOx->OSPEEDR;
 800bc94:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800bc96:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 800bc9a:	68cf      	ldr	r7, [r1, #12]
 800bc9c:	fa07 f70e 	lsl.w	r7, r7, lr
 800bca0:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 800bca4:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 800bca6:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800bca8:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800bcac:	f3c6 1700 	ubfx	r7, r6, #4, #1
 800bcb0:	409f      	lsls	r7, r3
 800bcb2:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 800bcb6:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 800bcb8:	68c7      	ldr	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800bcba:	2d02      	cmp	r5, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800bcbc:	ea07 080c 	and.w	r8, r7, ip
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800bcc0:	688f      	ldr	r7, [r1, #8]
 800bcc2:	fa07 f70e 	lsl.w	r7, r7, lr
 800bcc6:	ea47 0708 	orr.w	r7, r7, r8
      GPIOx->PUPDR = temp;
 800bcca:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800bccc:	d119      	bne.n	800bd02 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->AFR[position >> 3U];
 800bcce:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800bcd2:	f003 0a07 	and.w	sl, r3, #7
 800bcd6:	f04f 0b0f 	mov.w	fp, #15
 800bcda:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 800bcde:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3U];
 800bce2:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800bce6:	fa0b fb0a 	lsl.w	fp, fp, sl
 800bcea:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800bcee:	690f      	ldr	r7, [r1, #16]
 800bcf0:	fa07 f70a 	lsl.w	r7, r7, sl
 800bcf4:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3U] = temp;
 800bcf8:	f8c8 7020 	str.w	r7, [r8, #32]
 800bcfc:	e001      	b.n	800bd02 <HAL_GPIO_Init+0xb2>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800bcfe:	2d03      	cmp	r5, #3
 800bd00:	d1da      	bne.n	800bcb8 <HAL_GPIO_Init+0x68>
      temp = GPIOx->MODER;
 800bd02:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800bd04:	fa05 f50e 	lsl.w	r5, r5, lr
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800bd08:	f416 3f40 	tst.w	r6, #196608	@ 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800bd0c:	ea07 070c 	and.w	r7, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800bd10:	ea45 0507 	orr.w	r5, r5, r7
      GPIOx->MODER = temp;
 800bd14:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800bd16:	d06b      	beq.n	800bdf0 <HAL_GPIO_Init+0x1a0>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bd18:	f8d9 50f4 	ldr.w	r5, [r9, #244]	@ 0xf4
 800bd1c:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800bd20:	f003 0c03 	and.w	ip, r3, #3
 800bd24:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bd28:	f045 0502 	orr.w	r5, r5, #2
 800bd2c:	f107 47b0 	add.w	r7, r7, #1476395008	@ 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800bd30:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bd34:	f8c9 50f4 	str.w	r5, [r9, #244]	@ 0xf4
 800bd38:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
 800bd3c:	f8d9 50f4 	ldr.w	r5, [r9, #244]	@ 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800bd40:	fa0e fe0c 	lsl.w	lr, lr, ip
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bd44:	f005 0502 	and.w	r5, r5, #2
 800bd48:	9501      	str	r5, [sp, #4]
 800bd4a:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 800bd4c:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800bd4e:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800bd52:	4d31      	ldr	r5, [pc, #196]	@ (800be18 <HAL_GPIO_Init+0x1c8>)
 800bd54:	42a8      	cmp	r0, r5
 800bd56:	d04d      	beq.n	800bdf4 <HAL_GPIO_Init+0x1a4>
 800bd58:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd5c:	42a8      	cmp	r0, r5
 800bd5e:	d04b      	beq.n	800bdf8 <HAL_GPIO_Init+0x1a8>
 800bd60:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd64:	42a8      	cmp	r0, r5
 800bd66:	d049      	beq.n	800bdfc <HAL_GPIO_Init+0x1ac>
 800bd68:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd6c:	42a8      	cmp	r0, r5
 800bd6e:	d047      	beq.n	800be00 <HAL_GPIO_Init+0x1b0>
 800bd70:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd74:	42a8      	cmp	r0, r5
 800bd76:	d045      	beq.n	800be04 <HAL_GPIO_Init+0x1b4>
 800bd78:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd7c:	42a8      	cmp	r0, r5
 800bd7e:	d043      	beq.n	800be08 <HAL_GPIO_Init+0x1b8>
 800bd80:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd84:	42a8      	cmp	r0, r5
 800bd86:	d041      	beq.n	800be0c <HAL_GPIO_Init+0x1bc>
 800bd88:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd8c:	42a8      	cmp	r0, r5
 800bd8e:	d03f      	beq.n	800be10 <HAL_GPIO_Init+0x1c0>
 800bd90:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd94:	42a8      	cmp	r0, r5
 800bd96:	d03d      	beq.n	800be14 <HAL_GPIO_Init+0x1c4>
 800bd98:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800bd9c:	42a8      	cmp	r0, r5
 800bd9e:	bf14      	ite	ne
 800bda0:	250a      	movne	r5, #10
 800bda2:	2509      	moveq	r5, #9
 800bda4:	fa05 f50c 	lsl.w	r5, r5, ip
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800bda8:	f416 1f80 	tst.w	r6, #1048576	@ 0x100000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800bdac:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 800bdb0:	60bd      	str	r5, [r7, #8]
        temp &= ~(iocurrent);
 800bdb2:	ea6f 0702 	mvn.w	r7, r2
        temp = EXTI->RTSR1;
 800bdb6:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 800bdb8:	bf0c      	ite	eq
 800bdba:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800bdbc:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800bdbe:	f416 1f00 	tst.w	r6, #2097152	@ 0x200000
        EXTI->RTSR1 = temp;
 800bdc2:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 800bdc4:	6865      	ldr	r5, [r4, #4]
        temp &= ~(iocurrent);
 800bdc6:	bf0c      	ite	eq
 800bdc8:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800bdca:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800bdcc:	f416 3f00 	tst.w	r6, #131072	@ 0x20000
        EXTI->FTSR1 = temp;
 800bdd0:	6065      	str	r5, [r4, #4]
        temp = EXTI_CurrentCPU->EMR1;
 800bdd2:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
        temp &= ~(iocurrent);
 800bdd6:	bf0c      	ite	eq
 800bdd8:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800bdda:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800bddc:	03f6      	lsls	r6, r6, #15
        EXTI_CurrentCPU->EMR1 = temp;
 800bdde:	f8c4 5084 	str.w	r5, [r4, #132]	@ 0x84
        temp = EXTI_CurrentCPU->IMR1;
 800bde2:	f8d4 5080 	ldr.w	r5, [r4, #128]	@ 0x80
        temp &= ~(iocurrent);
 800bde6:	bf54      	ite	pl
 800bde8:	403d      	andpl	r5, r7
          temp |= iocurrent;
 800bdea:	4315      	orrmi	r5, r2
        EXTI_CurrentCPU->IMR1 = temp;
 800bdec:	f8c4 5080 	str.w	r5, [r4, #128]	@ 0x80
    position++;
 800bdf0:	3301      	adds	r3, #1
 800bdf2:	e734      	b.n	800bc5e <HAL_GPIO_Init+0xe>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800bdf4:	2500      	movs	r5, #0
 800bdf6:	e7d5      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800bdf8:	2501      	movs	r5, #1
 800bdfa:	e7d3      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800bdfc:	2502      	movs	r5, #2
 800bdfe:	e7d1      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be00:	2503      	movs	r5, #3
 800be02:	e7cf      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be04:	2504      	movs	r5, #4
 800be06:	e7cd      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be08:	2505      	movs	r5, #5
 800be0a:	e7cb      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be0c:	2506      	movs	r5, #6
 800be0e:	e7c9      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be10:	2507      	movs	r5, #7
 800be12:	e7c7      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be14:	2508      	movs	r5, #8
 800be16:	e7c5      	b.n	800bda4 <HAL_GPIO_Init+0x154>
 800be18:	58020000 	.word	0x58020000
 800be1c:	58024400 	.word	0x58024400

0800be20 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 800be20:	6903      	ldr	r3, [r0, #16]
 800be22:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 800be24:	bf14      	ite	ne
 800be26:	2001      	movne	r0, #1
 800be28:	2000      	moveq	r0, #0
 800be2a:	4770      	bx	lr

0800be2c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800be2c:	b10a      	cbz	r2, 800be32 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800be2e:	6181      	str	r1, [r0, #24]
  }
}
 800be30:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800be32:	0409      	lsls	r1, r1, #16
 800be34:	e7fb      	b.n	800be2e <HAL_GPIO_WritePin+0x2>

0800be36 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800be36:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800be38:	ea01 0203 	and.w	r2, r1, r3
 800be3c:	ea21 0103 	bic.w	r1, r1, r3
 800be40:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 800be44:	6181      	str	r1, [r0, #24]
}
 800be46:	4770      	bx	lr

0800be48 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 800be48:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 800be4a:	4c10      	ldr	r4, [pc, #64]	@ (800be8c <HAL_PWREx_ConfigSupply+0x44>)
 800be4c:	68e3      	ldr	r3, [r4, #12]
 800be4e:	f013 0f04 	tst.w	r3, #4
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800be52:	68e3      	ldr	r3, [r4, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 800be54:	d105      	bne.n	800be62 <HAL_PWREx_ConfigSupply+0x1a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800be56:	f003 0307 	and.w	r3, r3, #7
 800be5a:	1a18      	subs	r0, r3, r0
 800be5c:	bf18      	it	ne
 800be5e:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 800be60:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 800be62:	f023 0307 	bic.w	r3, r3, #7
 800be66:	4318      	orrs	r0, r3
 800be68:	60e0      	str	r0, [r4, #12]
  tickstart = HAL_GetTick ();
 800be6a:	f7ff f96f 	bl	800b14c <HAL_GetTick>
 800be6e:	4605      	mov	r5, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 800be70:	6863      	ldr	r3, [r4, #4]
 800be72:	049b      	lsls	r3, r3, #18
 800be74:	d501      	bpl.n	800be7a <HAL_PWREx_ConfigSupply+0x32>
      return HAL_OK;
 800be76:	2000      	movs	r0, #0
 800be78:	e7f2      	b.n	800be60 <HAL_PWREx_ConfigSupply+0x18>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 800be7a:	f7ff f967 	bl	800b14c <HAL_GetTick>
 800be7e:	1b40      	subs	r0, r0, r5
 800be80:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 800be84:	d9f4      	bls.n	800be70 <HAL_PWREx_ConfigSupply+0x28>
      return HAL_ERROR;
 800be86:	2001      	movs	r0, #1
 800be88:	e7ea      	b.n	800be60 <HAL_PWREx_ConfigSupply+0x18>
 800be8a:	bf00      	nop
 800be8c:	58024800 	.word	0x58024800

0800be90 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800be90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800be92:	4604      	mov	r4, r0
 800be94:	2800      	cmp	r0, #0
 800be96:	d074      	beq.n	800bf82 <HAL_RCC_OscConfig+0xf2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800be98:	6803      	ldr	r3, [r0, #0]
 800be9a:	07d8      	lsls	r0, r3, #31
 800be9c:	d45e      	bmi.n	800bf5c <HAL_RCC_OscConfig+0xcc>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800be9e:	6823      	ldr	r3, [r4, #0]
 800bea0:	0799      	lsls	r1, r3, #30
 800bea2:	f100 80ad 	bmi.w	800c000 <HAL_RCC_OscConfig+0x170>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800bea6:	6823      	ldr	r3, [r4, #0]
 800bea8:	06da      	lsls	r2, r3, #27
 800beaa:	d527      	bpl.n	800befc <HAL_RCC_OscConfig+0x6c>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800beac:	4a9c      	ldr	r2, [pc, #624]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800beae:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800beb0:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800beb2:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 800beb6:	2b08      	cmp	r3, #8
 800beb8:	d007      	beq.n	800beca <HAL_RCC_OscConfig+0x3a>
 800beba:	2b18      	cmp	r3, #24
 800bebc:	f040 8103 	bne.w	800c0c6 <HAL_RCC_OscConfig+0x236>
 800bec0:	f001 0303 	and.w	r3, r1, #3
 800bec4:	2b01      	cmp	r3, #1
 800bec6:	f040 80fe 	bne.w	800c0c6 <HAL_RCC_OscConfig+0x236>
    {
      /* When CSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800beca:	6813      	ldr	r3, [r2, #0]
 800becc:	05db      	lsls	r3, r3, #23
 800bece:	d502      	bpl.n	800bed6 <HAL_RCC_OscConfig+0x46>
 800bed0:	69e3      	ldr	r3, [r4, #28]
 800bed2:	2b80      	cmp	r3, #128	@ 0x80
 800bed4:	d155      	bne.n	800bf82 <HAL_RCC_OscConfig+0xf2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800bed6:	f7ff f959 	bl	800b18c <HAL_GetREVID>
 800beda:	f241 0303 	movw	r3, #4099	@ 0x1003
 800bede:	6a21      	ldr	r1, [r4, #32]
 800bee0:	4298      	cmp	r0, r3
 800bee2:	4b8f      	ldr	r3, [pc, #572]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800bee4:	f200 80e8 	bhi.w	800c0b8 <HAL_RCC_OscConfig+0x228>
 800bee8:	685a      	ldr	r2, [r3, #4]
 800beea:	2920      	cmp	r1, #32
 800beec:	f022 42f8 	bic.w	r2, r2, #2080374784	@ 0x7c000000
 800bef0:	bf0c      	ite	eq
 800bef2:	f042 4280 	orreq.w	r2, r2, #1073741824	@ 0x40000000
 800bef6:	ea42 6281 	orrne.w	r2, r2, r1, lsl #26
 800befa:	605a      	str	r2, [r3, #4]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800befc:	6823      	ldr	r3, [r4, #0]
 800befe:	0719      	lsls	r1, r3, #28
 800bf00:	f100 8123 	bmi.w	800c14a <HAL_RCC_OscConfig+0x2ba>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800bf04:	6823      	ldr	r3, [r4, #0]
 800bf06:	069a      	lsls	r2, r3, #26
 800bf08:	f100 8144 	bmi.w	800c194 <HAL_RCC_OscConfig+0x304>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800bf0c:	6823      	ldr	r3, [r4, #0]
 800bf0e:	075d      	lsls	r5, r3, #29
 800bf10:	d51e      	bpl.n	800bf50 <HAL_RCC_OscConfig+0xc0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800bf12:	4d84      	ldr	r5, [pc, #528]	@ (800c124 <HAL_RCC_OscConfig+0x294>)
 800bf14:	682b      	ldr	r3, [r5, #0]
 800bf16:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800bf1a:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800bf1c:	f7ff f916 	bl	800b14c <HAL_GetTick>
 800bf20:	4606      	mov	r6, r0

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800bf22:	682b      	ldr	r3, [r5, #0]
 800bf24:	05da      	lsls	r2, r3, #23
 800bf26:	f140 815a 	bpl.w	800c1de <HAL_RCC_OscConfig+0x34e>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800bf2a:	68a3      	ldr	r3, [r4, #8]
 800bf2c:	4d7c      	ldr	r5, [pc, #496]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800bf2e:	2b01      	cmp	r3, #1
 800bf30:	f040 815c 	bne.w	800c1ec <HAL_RCC_OscConfig+0x35c>
 800bf34:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800bf36:	f043 0301 	orr.w	r3, r3, #1
 800bf3a:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800bf3c:	f241 3788 	movw	r7, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 800bf40:	f7ff f904 	bl	800b14c <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800bf44:	4e76      	ldr	r6, [pc, #472]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
      tickstart = HAL_GetTick();
 800bf46:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800bf48:	6f33      	ldr	r3, [r6, #112]	@ 0x70
 800bf4a:	079b      	lsls	r3, r3, #30
 800bf4c:	f140 8174 	bpl.w	800c238 <HAL_RCC_OscConfig+0x3a8>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800bf50:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800bf52:	2900      	cmp	r1, #0
 800bf54:	f040 8177 	bne.w	800c246 <HAL_RCC_OscConfig+0x3b6>
          __HAL_RCC_PLLFRACN_ENABLE();
        }
      }
    }
  }
  return HAL_OK;
 800bf58:	2000      	movs	r0, #0
 800bf5a:	e02b      	b.n	800bfb4 <HAL_RCC_OscConfig+0x124>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800bf5c:	4a70      	ldr	r2, [pc, #448]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800bf5e:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800bf60:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800bf62:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 800bf66:	2b10      	cmp	r3, #16
 800bf68:	d005      	beq.n	800bf76 <HAL_RCC_OscConfig+0xe6>
 800bf6a:	2b18      	cmp	r3, #24
 800bf6c:	d10b      	bne.n	800bf86 <HAL_RCC_OscConfig+0xf6>
 800bf6e:	f001 0303 	and.w	r3, r1, #3
 800bf72:	2b02      	cmp	r3, #2
 800bf74:	d107      	bne.n	800bf86 <HAL_RCC_OscConfig+0xf6>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800bf76:	6813      	ldr	r3, [r2, #0]
 800bf78:	039a      	lsls	r2, r3, #14
 800bf7a:	d590      	bpl.n	800be9e <HAL_RCC_OscConfig+0xe>
 800bf7c:	6863      	ldr	r3, [r4, #4]
 800bf7e:	2b00      	cmp	r3, #0
 800bf80:	d18d      	bne.n	800be9e <HAL_RCC_OscConfig+0xe>
    return HAL_ERROR;
 800bf82:	2001      	movs	r0, #1
 800bf84:	e016      	b.n	800bfb4 <HAL_RCC_OscConfig+0x124>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bf86:	6863      	ldr	r3, [r4, #4]
 800bf88:	4d65      	ldr	r5, [pc, #404]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800bf8a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800bf8e:	d112      	bne.n	800bfb6 <HAL_RCC_OscConfig+0x126>
 800bf90:	682b      	ldr	r3, [r5, #0]
 800bf92:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800bf96:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800bf98:	f7ff f8d8 	bl	800b14c <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800bf9c:	4e60      	ldr	r6, [pc, #384]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
        tickstart = HAL_GetTick();
 800bf9e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800bfa0:	6833      	ldr	r3, [r6, #0]
 800bfa2:	039b      	lsls	r3, r3, #14
 800bfa4:	f53f af7b 	bmi.w	800be9e <HAL_RCC_OscConfig+0xe>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800bfa8:	f7ff f8d0 	bl	800b14c <HAL_GetTick>
 800bfac:	1b40      	subs	r0, r0, r5
 800bfae:	2864      	cmp	r0, #100	@ 0x64
 800bfb0:	d9f6      	bls.n	800bfa0 <HAL_RCC_OscConfig+0x110>
            return HAL_TIMEOUT;
 800bfb2:	2003      	movs	r0, #3
}
 800bfb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bfb6:	b9a3      	cbnz	r3, 800bfe2 <HAL_RCC_OscConfig+0x152>
 800bfb8:	682b      	ldr	r3, [r5, #0]
 800bfba:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800bfbe:	602b      	str	r3, [r5, #0]
 800bfc0:	682b      	ldr	r3, [r5, #0]
 800bfc2:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800bfc6:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800bfc8:	f7ff f8c0 	bl	800b14c <HAL_GetTick>
 800bfcc:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800bfce:	682b      	ldr	r3, [r5, #0]
 800bfd0:	039f      	lsls	r7, r3, #14
 800bfd2:	f57f af64 	bpl.w	800be9e <HAL_RCC_OscConfig+0xe>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800bfd6:	f7ff f8b9 	bl	800b14c <HAL_GetTick>
 800bfda:	1b80      	subs	r0, r0, r6
 800bfdc:	2864      	cmp	r0, #100	@ 0x64
 800bfde:	d9f6      	bls.n	800bfce <HAL_RCC_OscConfig+0x13e>
 800bfe0:	e7e7      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bfe2:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800bfe6:	682b      	ldr	r3, [r5, #0]
 800bfe8:	d103      	bne.n	800bff2 <HAL_RCC_OscConfig+0x162>
 800bfea:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800bfee:	602b      	str	r3, [r5, #0]
 800bff0:	e7ce      	b.n	800bf90 <HAL_RCC_OscConfig+0x100>
 800bff2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800bff6:	602b      	str	r3, [r5, #0]
 800bff8:	682b      	ldr	r3, [r5, #0]
 800bffa:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800bffe:	e7ca      	b.n	800bf96 <HAL_RCC_OscConfig+0x106>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c000:	4947      	ldr	r1, [pc, #284]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800c002:	68e2      	ldr	r2, [r4, #12]
 800c004:	690b      	ldr	r3, [r1, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800c006:	6a88      	ldr	r0, [r1, #40]	@ 0x28
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800c008:	f013 0338 	ands.w	r3, r3, #56	@ 0x38
 800c00c:	d003      	beq.n	800c016 <HAL_RCC_OscConfig+0x186>
 800c00e:	2b18      	cmp	r3, #24
 800c010:	d12a      	bne.n	800c068 <HAL_RCC_OscConfig+0x1d8>
 800c012:	0780      	lsls	r0, r0, #30
 800c014:	d128      	bne.n	800c068 <HAL_RCC_OscConfig+0x1d8>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800c016:	680b      	ldr	r3, [r1, #0]
 800c018:	075b      	lsls	r3, r3, #29
 800c01a:	d501      	bpl.n	800c020 <HAL_RCC_OscConfig+0x190>
 800c01c:	2a00      	cmp	r2, #0
 800c01e:	d0b0      	beq.n	800bf82 <HAL_RCC_OscConfig+0xf2>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800c020:	4d3f      	ldr	r5, [pc, #252]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800c022:	682b      	ldr	r3, [r5, #0]
 800c024:	f023 0319 	bic.w	r3, r3, #25
 800c028:	4313      	orrs	r3, r2
 800c02a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c02c:	f7ff f88e 	bl	800b14c <HAL_GetTick>
 800c030:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c032:	682b      	ldr	r3, [r5, #0]
 800c034:	075f      	lsls	r7, r3, #29
 800c036:	d511      	bpl.n	800c05c <HAL_RCC_OscConfig+0x1cc>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800c038:	f7ff f8a8 	bl	800b18c <HAL_GetREVID>
 800c03c:	f241 0303 	movw	r3, #4099	@ 0x1003
 800c040:	6922      	ldr	r2, [r4, #16]
 800c042:	4298      	cmp	r0, r3
 800c044:	686b      	ldr	r3, [r5, #4]
 800c046:	d822      	bhi.n	800c08e <HAL_RCC_OscConfig+0x1fe>
 800c048:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 800c04c:	2a40      	cmp	r2, #64	@ 0x40
 800c04e:	bf0c      	ite	eq
 800c050:	f443 3300 	orreq.w	r3, r3, #131072	@ 0x20000
 800c054:	ea43 3302 	orrne.w	r3, r3, r2, lsl #12
 800c058:	606b      	str	r3, [r5, #4]
 800c05a:	e724      	b.n	800bea6 <HAL_RCC_OscConfig+0x16>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c05c:	f7ff f876 	bl	800b14c <HAL_GetTick>
 800c060:	1b80      	subs	r0, r0, r6
 800c062:	2802      	cmp	r0, #2
 800c064:	d9e5      	bls.n	800c032 <HAL_RCC_OscConfig+0x1a2>
 800c066:	e7a4      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800c068:	4d2d      	ldr	r5, [pc, #180]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800c06a:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800c06c:	b1a2      	cbz	r2, 800c098 <HAL_RCC_OscConfig+0x208>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800c06e:	f023 0319 	bic.w	r3, r3, #25
 800c072:	4313      	orrs	r3, r2
 800c074:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c076:	f7ff f869 	bl	800b14c <HAL_GetTick>
 800c07a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c07c:	682b      	ldr	r3, [r5, #0]
 800c07e:	0758      	lsls	r0, r3, #29
 800c080:	d4da      	bmi.n	800c038 <HAL_RCC_OscConfig+0x1a8>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c082:	f7ff f863 	bl	800b14c <HAL_GetTick>
 800c086:	1b80      	subs	r0, r0, r6
 800c088:	2802      	cmp	r0, #2
 800c08a:	d9f7      	bls.n	800c07c <HAL_RCC_OscConfig+0x1ec>
 800c08c:	e791      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800c08e:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 800c092:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c096:	e7df      	b.n	800c058 <HAL_RCC_OscConfig+0x1c8>
        __HAL_RCC_HSI_DISABLE();
 800c098:	f023 0301 	bic.w	r3, r3, #1
 800c09c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c09e:	f7ff f855 	bl	800b14c <HAL_GetTick>
 800c0a2:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800c0a4:	682b      	ldr	r3, [r5, #0]
 800c0a6:	0759      	lsls	r1, r3, #29
 800c0a8:	f57f aefd 	bpl.w	800bea6 <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c0ac:	f7ff f84e 	bl	800b14c <HAL_GetTick>
 800c0b0:	1b80      	subs	r0, r0, r6
 800c0b2:	2802      	cmp	r0, #2
 800c0b4:	d9f6      	bls.n	800c0a4 <HAL_RCC_OscConfig+0x214>
 800c0b6:	e77c      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800c0b8:	68da      	ldr	r2, [r3, #12]
 800c0ba:	f022 527c 	bic.w	r2, r2, #1056964608	@ 0x3f000000
 800c0be:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800c0c2:	60da      	str	r2, [r3, #12]
 800c0c4:	e71a      	b.n	800befc <HAL_RCC_OscConfig+0x6c>
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
 800c0c6:	69e3      	ldr	r3, [r4, #28]
 800c0c8:	4d15      	ldr	r5, [pc, #84]	@ (800c120 <HAL_RCC_OscConfig+0x290>)
 800c0ca:	b36b      	cbz	r3, 800c128 <HAL_RCC_OscConfig+0x298>
        __HAL_RCC_CSI_ENABLE();
 800c0cc:	682b      	ldr	r3, [r5, #0]
 800c0ce:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800c0d2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c0d4:	f7ff f83a 	bl	800b14c <HAL_GetTick>
 800c0d8:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800c0da:	682b      	ldr	r3, [r5, #0]
 800c0dc:	05df      	lsls	r7, r3, #23
 800c0de:	d511      	bpl.n	800c104 <HAL_RCC_OscConfig+0x274>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800c0e0:	f7ff f854 	bl	800b18c <HAL_GetREVID>
 800c0e4:	f241 0303 	movw	r3, #4099	@ 0x1003
 800c0e8:	6a22      	ldr	r2, [r4, #32]
 800c0ea:	4298      	cmp	r0, r3
 800c0ec:	d810      	bhi.n	800c110 <HAL_RCC_OscConfig+0x280>
 800c0ee:	686b      	ldr	r3, [r5, #4]
 800c0f0:	2a20      	cmp	r2, #32
 800c0f2:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 800c0f6:	bf0c      	ite	eq
 800c0f8:	f043 4380 	orreq.w	r3, r3, #1073741824	@ 0x40000000
 800c0fc:	ea43 6382 	orrne.w	r3, r3, r2, lsl #26
 800c100:	606b      	str	r3, [r5, #4]
 800c102:	e6fb      	b.n	800befc <HAL_RCC_OscConfig+0x6c>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 800c104:	f7ff f822 	bl	800b14c <HAL_GetTick>
 800c108:	1b80      	subs	r0, r0, r6
 800c10a:	2802      	cmp	r0, #2
 800c10c:	d9e5      	bls.n	800c0da <HAL_RCC_OscConfig+0x24a>
 800c10e:	e750      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800c110:	68eb      	ldr	r3, [r5, #12]
 800c112:	f023 537c 	bic.w	r3, r3, #1056964608	@ 0x3f000000
 800c116:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c11a:	60eb      	str	r3, [r5, #12]
 800c11c:	e6ee      	b.n	800befc <HAL_RCC_OscConfig+0x6c>
 800c11e:	bf00      	nop
 800c120:	58024400 	.word	0x58024400
 800c124:	58024800 	.word	0x58024800
        __HAL_RCC_CSI_DISABLE();
 800c128:	682b      	ldr	r3, [r5, #0]
 800c12a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800c12e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c130:	f7ff f80c 	bl	800b14c <HAL_GetTick>
 800c134:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800c136:	682b      	ldr	r3, [r5, #0]
 800c138:	05d8      	lsls	r0, r3, #23
 800c13a:	f57f aedf 	bpl.w	800befc <HAL_RCC_OscConfig+0x6c>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 800c13e:	f7ff f805 	bl	800b14c <HAL_GetTick>
 800c142:	1b80      	subs	r0, r0, r6
 800c144:	2802      	cmp	r0, #2
 800c146:	d9f6      	bls.n	800c136 <HAL_RCC_OscConfig+0x2a6>
 800c148:	e733      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800c14a:	6963      	ldr	r3, [r4, #20]
 800c14c:	4da3      	ldr	r5, [pc, #652]	@ (800c3dc <HAL_RCC_OscConfig+0x54c>)
 800c14e:	b183      	cbz	r3, 800c172 <HAL_RCC_OscConfig+0x2e2>
      __HAL_RCC_LSI_ENABLE();
 800c150:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c152:	f043 0301 	orr.w	r3, r3, #1
 800c156:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 800c158:	f7fe fff8 	bl	800b14c <HAL_GetTick>
 800c15c:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800c15e:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c160:	079b      	lsls	r3, r3, #30
 800c162:	f53f aecf 	bmi.w	800bf04 <HAL_RCC_OscConfig+0x74>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800c166:	f7fe fff1 	bl	800b14c <HAL_GetTick>
 800c16a:	1b80      	subs	r0, r0, r6
 800c16c:	2802      	cmp	r0, #2
 800c16e:	d9f6      	bls.n	800c15e <HAL_RCC_OscConfig+0x2ce>
 800c170:	e71f      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_LSI_DISABLE();
 800c172:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c174:	f023 0301 	bic.w	r3, r3, #1
 800c178:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 800c17a:	f7fe ffe7 	bl	800b14c <HAL_GetTick>
 800c17e:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800c180:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 800c182:	079f      	lsls	r7, r3, #30
 800c184:	f57f aebe 	bpl.w	800bf04 <HAL_RCC_OscConfig+0x74>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800c188:	f7fe ffe0 	bl	800b14c <HAL_GetTick>
 800c18c:	1b80      	subs	r0, r0, r6
 800c18e:	2802      	cmp	r0, #2
 800c190:	d9f6      	bls.n	800c180 <HAL_RCC_OscConfig+0x2f0>
 800c192:	e70e      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)
 800c194:	69a3      	ldr	r3, [r4, #24]
 800c196:	4d91      	ldr	r5, [pc, #580]	@ (800c3dc <HAL_RCC_OscConfig+0x54c>)
 800c198:	b183      	cbz	r3, 800c1bc <HAL_RCC_OscConfig+0x32c>
      __HAL_RCC_HSI48_ENABLE();
 800c19a:	682b      	ldr	r3, [r5, #0]
 800c19c:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800c1a0:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800c1a2:	f7fe ffd3 	bl	800b14c <HAL_GetTick>
 800c1a6:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800c1a8:	682b      	ldr	r3, [r5, #0]
 800c1aa:	0498      	lsls	r0, r3, #18
 800c1ac:	f53f aeae 	bmi.w	800bf0c <HAL_RCC_OscConfig+0x7c>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800c1b0:	f7fe ffcc 	bl	800b14c <HAL_GetTick>
 800c1b4:	1b80      	subs	r0, r0, r6
 800c1b6:	2802      	cmp	r0, #2
 800c1b8:	d9f6      	bls.n	800c1a8 <HAL_RCC_OscConfig+0x318>
 800c1ba:	e6fa      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
      __HAL_RCC_HSI48_DISABLE();
 800c1bc:	682b      	ldr	r3, [r5, #0]
 800c1be:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800c1c2:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800c1c4:	f7fe ffc2 	bl	800b14c <HAL_GetTick>
 800c1c8:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800c1ca:	682b      	ldr	r3, [r5, #0]
 800c1cc:	0499      	lsls	r1, r3, #18
 800c1ce:	f57f ae9d 	bpl.w	800bf0c <HAL_RCC_OscConfig+0x7c>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800c1d2:	f7fe ffbb 	bl	800b14c <HAL_GetTick>
 800c1d6:	1b80      	subs	r0, r0, r6
 800c1d8:	2802      	cmp	r0, #2
 800c1da:	d9f6      	bls.n	800c1ca <HAL_RCC_OscConfig+0x33a>
 800c1dc:	e6e9      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c1de:	f7fe ffb5 	bl	800b14c <HAL_GetTick>
 800c1e2:	1b80      	subs	r0, r0, r6
 800c1e4:	2864      	cmp	r0, #100	@ 0x64
 800c1e6:	f67f ae9c 	bls.w	800bf22 <HAL_RCC_OscConfig+0x92>
 800c1ea:	e6e2      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c1ec:	b9b3      	cbnz	r3, 800c21c <HAL_RCC_OscConfig+0x38c>
 800c1ee:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c1f0:	f241 3788 	movw	r7, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c1f4:	f023 0301 	bic.w	r3, r3, #1
 800c1f8:	672b      	str	r3, [r5, #112]	@ 0x70
 800c1fa:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c1fc:	f023 0304 	bic.w	r3, r3, #4
 800c200:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();
 800c202:	f7fe ffa3 	bl	800b14c <HAL_GetTick>
 800c206:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800c208:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c20a:	0798      	lsls	r0, r3, #30
 800c20c:	f57f aea0 	bpl.w	800bf50 <HAL_RCC_OscConfig+0xc0>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c210:	f7fe ff9c 	bl	800b14c <HAL_GetTick>
 800c214:	1b80      	subs	r0, r0, r6
 800c216:	42b8      	cmp	r0, r7
 800c218:	d9f6      	bls.n	800c208 <HAL_RCC_OscConfig+0x378>
 800c21a:	e6ca      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c21c:	2b05      	cmp	r3, #5
 800c21e:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c220:	d103      	bne.n	800c22a <HAL_RCC_OscConfig+0x39a>
 800c222:	f043 0304 	orr.w	r3, r3, #4
 800c226:	672b      	str	r3, [r5, #112]	@ 0x70
 800c228:	e684      	b.n	800bf34 <HAL_RCC_OscConfig+0xa4>
 800c22a:	f023 0301 	bic.w	r3, r3, #1
 800c22e:	672b      	str	r3, [r5, #112]	@ 0x70
 800c230:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800c232:	f023 0304 	bic.w	r3, r3, #4
 800c236:	e680      	b.n	800bf3a <HAL_RCC_OscConfig+0xaa>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c238:	f7fe ff88 	bl	800b14c <HAL_GetTick>
 800c23c:	1b40      	subs	r0, r0, r5
 800c23e:	42b8      	cmp	r0, r7
 800c240:	f67f ae82 	bls.w	800bf48 <HAL_RCC_OscConfig+0xb8>
 800c244:	e6b5      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 800c246:	4d65      	ldr	r5, [pc, #404]	@ (800c3dc <HAL_RCC_OscConfig+0x54c>)
 800c248:	692b      	ldr	r3, [r5, #16]
 800c24a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800c24e:	2b18      	cmp	r3, #24
 800c250:	d078      	beq.n	800c344 <HAL_RCC_OscConfig+0x4b4>
        __HAL_RCC_PLL_DISABLE();
 800c252:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800c254:	2902      	cmp	r1, #2
        __HAL_RCC_PLL_DISABLE();
 800c256:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 800c25a:	602b      	str	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800c25c:	d165      	bne.n	800c32a <HAL_RCC_OscConfig+0x49a>
        tickstart = HAL_GetTick();
 800c25e:	f7fe ff75 	bl	800b14c <HAL_GetTick>
 800c262:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800c264:	682b      	ldr	r3, [r5, #0]
 800c266:	0199      	lsls	r1, r3, #6
 800c268:	d459      	bmi.n	800c31e <HAL_RCC_OscConfig+0x48e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800c26a:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 800c26c:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 800c26e:	f423 737c 	bic.w	r3, r3, #1008	@ 0x3f0
 800c272:	f023 0303 	bic.w	r3, r3, #3
 800c276:	4313      	orrs	r3, r2
 800c278:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 800c27a:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800c27e:	62ab      	str	r3, [r5, #40]	@ 0x28
 800c280:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800c282:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800c284:	3b01      	subs	r3, #1
 800c286:	3a01      	subs	r2, #1
 800c288:	025b      	lsls	r3, r3, #9
 800c28a:	0412      	lsls	r2, r2, #16
 800c28c:	b29b      	uxth	r3, r3
 800c28e:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 800c292:	4313      	orrs	r3, r2
 800c294:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800c296:	3a01      	subs	r2, #1
 800c298:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800c29c:	4313      	orrs	r3, r2
 800c29e:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 800c2a0:	3a01      	subs	r2, #1
 800c2a2:	0612      	lsls	r2, r2, #24
 800c2a4:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 800c2a8:	4313      	orrs	r3, r2
 800c2aa:	632b      	str	r3, [r5, #48]	@ 0x30
        __HAL_RCC_PLLFRACN_DISABLE();
 800c2ac:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2ae:	f023 0301 	bic.w	r3, r3, #1
 800c2b2:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800c2b4:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
 800c2b6:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800c2b8:	f36f 03cf 	bfc	r3, #3, #13
 800c2bc:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800c2c0:	636b      	str	r3, [r5, #52]	@ 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 800c2c2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2c4:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 800c2c6:	f023 030c 	bic.w	r3, r3, #12
 800c2ca:	4313      	orrs	r3, r2
 800c2cc:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 800c2ce:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2d0:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 800c2d2:	f023 0302 	bic.w	r3, r3, #2
 800c2d6:	4313      	orrs	r3, r2
 800c2d8:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800c2da:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2dc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800c2e0:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800c2e2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2e4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800c2e8:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 800c2ea:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2ec:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800c2f0:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLLFRACN_ENABLE();
 800c2f2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c2f4:	f043 0301 	orr.w	r3, r3, #1
 800c2f8:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLL_ENABLE();
 800c2fa:	682b      	ldr	r3, [r5, #0]
 800c2fc:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800c300:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800c302:	f7fe ff23 	bl	800b14c <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800c306:	4d35      	ldr	r5, [pc, #212]	@ (800c3dc <HAL_RCC_OscConfig+0x54c>)
        tickstart = HAL_GetTick();
 800c308:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800c30a:	682b      	ldr	r3, [r5, #0]
 800c30c:	019a      	lsls	r2, r3, #6
 800c30e:	f53f ae23 	bmi.w	800bf58 <HAL_RCC_OscConfig+0xc8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c312:	f7fe ff1b 	bl	800b14c <HAL_GetTick>
 800c316:	1b00      	subs	r0, r0, r4
 800c318:	2802      	cmp	r0, #2
 800c31a:	d9f6      	bls.n	800c30a <HAL_RCC_OscConfig+0x47a>
 800c31c:	e649      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c31e:	f7fe ff15 	bl	800b14c <HAL_GetTick>
 800c322:	1b80      	subs	r0, r0, r6
 800c324:	2802      	cmp	r0, #2
 800c326:	d99d      	bls.n	800c264 <HAL_RCC_OscConfig+0x3d4>
 800c328:	e643      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
        tickstart = HAL_GetTick();
 800c32a:	f7fe ff0f 	bl	800b14c <HAL_GetTick>
 800c32e:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800c330:	682b      	ldr	r3, [r5, #0]
 800c332:	019b      	lsls	r3, r3, #6
 800c334:	f57f ae10 	bpl.w	800bf58 <HAL_RCC_OscConfig+0xc8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c338:	f7fe ff08 	bl	800b14c <HAL_GetTick>
 800c33c:	1b00      	subs	r0, r0, r4
 800c33e:	2802      	cmp	r0, #2
 800c340:	d9f6      	bls.n	800c330 <HAL_RCC_OscConfig+0x4a0>
 800c342:	e636      	b.n	800bfb2 <HAL_RCC_OscConfig+0x122>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800c344:	2901      	cmp	r1, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
 800c346:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 800c348:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800c34a:	f43f ae1a 	beq.w	800bf82 <HAL_RCC_OscConfig+0xf2>
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800c34e:	f002 0103 	and.w	r1, r2, #3
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800c352:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 800c354:	4281      	cmp	r1, r0
 800c356:	f47f ae14 	bne.w	800bf82 <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800c35a:	f3c2 1205 	ubfx	r2, r2, #4, #6
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800c35e:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800c360:	428a      	cmp	r2, r1
 800c362:	f47f ae0e 	bne.w	800bf82 <HAL_RCC_OscConfig+0xf2>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800c366:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800c368:	f3c3 0108 	ubfx	r1, r3, #0, #9
 800c36c:	3a01      	subs	r2, #1
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800c36e:	4291      	cmp	r1, r2
 800c370:	f47f ae07 	bne.w	800bf82 <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800c374:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 800c376:	f3c3 2146 	ubfx	r1, r3, #9, #7
 800c37a:	3a01      	subs	r2, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800c37c:	4291      	cmp	r1, r2
 800c37e:	f47f ae00 	bne.w	800bf82 <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800c382:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800c384:	f3c3 4106 	ubfx	r1, r3, #16, #7
 800c388:	3a01      	subs	r2, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800c38a:	4291      	cmp	r1, r2
 800c38c:	f47f adf9 	bne.w	800bf82 <HAL_RCC_OscConfig+0xf2>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800c390:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 800c392:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800c396:	3a01      	subs	r2, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800c398:	4293      	cmp	r3, r2
 800c39a:	f47f adf2 	bne.w	800bf82 <HAL_RCC_OscConfig+0xf2>
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 800c39e:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 800c3a0:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 800c3a2:	f3c3 03cc 	ubfx	r3, r3, #3, #13
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 800c3a6:	429a      	cmp	r2, r3
 800c3a8:	f43f add6 	beq.w	800bf58 <HAL_RCC_OscConfig+0xc8>
          __HAL_RCC_PLLFRACN_DISABLE();
 800c3ac:	4d0b      	ldr	r5, [pc, #44]	@ (800c3dc <HAL_RCC_OscConfig+0x54c>)
 800c3ae:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3b0:	f023 0301 	bic.w	r3, r3, #1
 800c3b4:	62eb      	str	r3, [r5, #44]	@ 0x2c
          tickstart = HAL_GetTick();
 800c3b6:	f7fe fec9 	bl	800b14c <HAL_GetTick>
 800c3ba:	4606      	mov	r6, r0
          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)
 800c3bc:	f7fe fec6 	bl	800b14c <HAL_GetTick>
 800c3c0:	42b0      	cmp	r0, r6
 800c3c2:	d0fb      	beq.n	800c3bc <HAL_RCC_OscConfig+0x52c>
          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800c3c4:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
 800c3c6:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800c3c8:	f36f 03cf 	bfc	r3, #3, #13
 800c3cc:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800c3d0:	636b      	str	r3, [r5, #52]	@ 0x34
          __HAL_RCC_PLLFRACN_ENABLE();
 800c3d2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 800c3d4:	f043 0301 	orr.w	r3, r3, #1
 800c3d8:	62eb      	str	r3, [r5, #44]	@ 0x2c
 800c3da:	e5bd      	b.n	800bf58 <HAL_RCC_OscConfig+0xc8>
 800c3dc:	58024400 	.word	0x58024400

0800c3e0 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 800c3e0:	4b49      	ldr	r3, [pc, #292]	@ (800c508 <HAL_RCC_GetSysClockFreq+0x128>)
 800c3e2:	691a      	ldr	r2, [r3, #16]
 800c3e4:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 800c3e8:	2a10      	cmp	r2, #16
{
 800c3ea:	b530      	push	{r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800c3ec:	f000 8088 	beq.w	800c500 <HAL_RCC_GetSysClockFreq+0x120>
 800c3f0:	2a18      	cmp	r2, #24
 800c3f2:	d00c      	beq.n	800c40e <HAL_RCC_GetSysClockFreq+0x2e>
 800c3f4:	2a00      	cmp	r2, #0
 800c3f6:	f040 8085 	bne.w	800c504 <HAL_RCC_GetSysClockFreq+0x124>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c3fa:	681a      	ldr	r2, [r3, #0]
 800c3fc:	4843      	ldr	r0, [pc, #268]	@ (800c50c <HAL_RCC_GetSysClockFreq+0x12c>)
 800c3fe:	f012 0f20 	tst.w	r2, #32
 800c402:	d003      	beq.n	800c40c <HAL_RCC_GetSysClockFreq+0x2c>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c404:	681b      	ldr	r3, [r3, #0]
 800c406:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800c40a:	40d8      	lsrs	r0, r3
      sysclockfreq = CSI_VALUE;
      break;
  }

  return sysclockfreq;
}
 800c40c:	bd30      	pop	{r4, r5, pc}
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c40e:	6a99      	ldr	r1, [r3, #40]	@ 0x28
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 800c410:	6a9d      	ldr	r5, [r3, #40]	@ 0x28
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 800c412:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
      if (pllm != 0U)
 800c414:	f415 7f7c 	tst.w	r5, #1008	@ 0x3f0
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 800c418:	f3c5 1005 	ubfx	r0, r5, #4, #6
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800c41c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
      if (pllm != 0U)
 800c41e:	d0f5      	beq.n	800c40c <HAL_RCC_GetSysClockFreq+0x2c>
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800c420:	f3c2 02cc 	ubfx	r2, r2, #3, #13
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 800c424:	f004 0401 	and.w	r4, r4, #1
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c428:	f001 0103 	and.w	r1, r1, #3
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c42c:	ee07 0a90 	vmov	s15, r0
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800c430:	4362      	muls	r2, r4
 800c432:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
        switch (pllsource)
 800c436:	2901      	cmp	r1, #1
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c438:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800c43c:	ee06 2a90 	vmov	s13, r2
 800c440:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
        switch (pllsource)
 800c444:	d04e      	beq.n	800c4e4 <HAL_RCC_GetSysClockFreq+0x104>
 800c446:	2902      	cmp	r1, #2
 800c448:	d03e      	beq.n	800c4c8 <HAL_RCC_GetSysClockFreq+0xe8>
 800c44a:	2900      	cmp	r1, #0
 800c44c:	d14a      	bne.n	800c4e4 <HAL_RCC_GetSysClockFreq+0x104>
            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c44e:	681a      	ldr	r2, [r3, #0]
 800c450:	0692      	lsls	r2, r2, #26
 800c452:	d527      	bpl.n	800c4a4 <HAL_RCC_GetSysClockFreq+0xc4>
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c454:	6819      	ldr	r1, [r3, #0]
 800c456:	4a2d      	ldr	r2, [pc, #180]	@ (800c50c <HAL_RCC_GetSysClockFreq+0x12c>)
 800c458:	f3c1 01c1 	ubfx	r1, r1, #3, #2
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c45c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c45e:	40ca      	lsrs	r2, r1
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c460:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c464:	ee07 2a90 	vmov	s15, r2
 800c468:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 800c46c:	eec5 7a87 	vdiv.f32	s15, s11, s14
 800c470:	ee07 3a10 	vmov	s14, r3
 800c474:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c478:	ee37 7a26 	vadd.f32	s14, s14, s13
 800c47c:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c480:	ee67 7a87 	vmul.f32	s15, s15, s14
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 800c484:	4b20      	ldr	r3, [pc, #128]	@ (800c508 <HAL_RCC_GetSysClockFreq+0x128>)
 800c486:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c488:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800c48c:	3301      	adds	r3, #1
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 800c48e:	ee07 3a10 	vmov	s14, r3
 800c492:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 800c496:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800c49a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800c49e:	ee17 0a90 	vmov	r0, s15
 800c4a2:	e7b3      	b.n	800c40c <HAL_RCC_GetSysClockFreq+0x2c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c4a4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c4a6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c4aa:	ee07 3a90 	vmov	s15, r3
 800c4ae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c4b2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c4b6:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c4ba:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 800c510 <HAL_RCC_GetSysClockFreq+0x130>
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c4be:	eec6 6a07 	vdiv.f32	s13, s12, s14
 800c4c2:	ee67 7aa6 	vmul.f32	s15, s15, s13
            break;
 800c4c6:	e7dd      	b.n	800c484 <HAL_RCC_GetSysClockFreq+0xa4>
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c4c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c4ca:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c4ce:	ee07 3a90 	vmov	s15, r3
 800c4d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c4d6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c4da:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c4de:	ed9f 6a0d 	vldr	s12, [pc, #52]	@ 800c514 <HAL_RCC_GetSysClockFreq+0x134>
 800c4e2:	e7ec      	b.n	800c4be <HAL_RCC_GetSysClockFreq+0xde>
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800c4e4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c4e6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c4ea:	ee07 3a90 	vmov	s15, r3
 800c4ee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c4f2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c4f6:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c4fa:	ed9f 6a07 	vldr	s12, [pc, #28]	@ 800c518 <HAL_RCC_GetSysClockFreq+0x138>
 800c4fe:	e7de      	b.n	800c4be <HAL_RCC_GetSysClockFreq+0xde>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800c500:	4806      	ldr	r0, [pc, #24]	@ (800c51c <HAL_RCC_GetSysClockFreq+0x13c>)
 800c502:	e783      	b.n	800c40c <HAL_RCC_GetSysClockFreq+0x2c>
      sysclockfreq = CSI_VALUE;
 800c504:	4806      	ldr	r0, [pc, #24]	@ (800c520 <HAL_RCC_GetSysClockFreq+0x140>)
 800c506:	e781      	b.n	800c40c <HAL_RCC_GetSysClockFreq+0x2c>
 800c508:	58024400 	.word	0x58024400
 800c50c:	03d09000 	.word	0x03d09000
 800c510:	4c742400 	.word	0x4c742400
 800c514:	4af42400 	.word	0x4af42400
 800c518:	4a742400 	.word	0x4a742400
 800c51c:	007a1200 	.word	0x007a1200
 800c520:	003d0900 	.word	0x003d0900

0800c524 <HAL_RCC_ClockConfig>:
{
 800c524:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c528:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 800c52a:	4604      	mov	r4, r0
 800c52c:	b910      	cbnz	r0, 800c534 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 800c52e:	2001      	movs	r0, #1
}
 800c530:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800c534:	4a88      	ldr	r2, [pc, #544]	@ (800c758 <HAL_RCC_ClockConfig+0x234>)
 800c536:	6813      	ldr	r3, [r2, #0]
 800c538:	f003 030f 	and.w	r3, r3, #15
 800c53c:	428b      	cmp	r3, r1
 800c53e:	f0c0 8093 	bcc.w	800c668 <HAL_RCC_ClockConfig+0x144>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800c542:	6823      	ldr	r3, [r4, #0]
 800c544:	075f      	lsls	r7, r3, #29
 800c546:	f100 809b 	bmi.w	800c680 <HAL_RCC_ClockConfig+0x15c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800c54a:	071e      	lsls	r6, r3, #28
 800c54c:	d50b      	bpl.n	800c566 <HAL_RCC_ClockConfig+0x42>
    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800c54e:	4983      	ldr	r1, [pc, #524]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c550:	6960      	ldr	r0, [r4, #20]
 800c552:	69ca      	ldr	r2, [r1, #28]
 800c554:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c558:	4290      	cmp	r0, r2
 800c55a:	d904      	bls.n	800c566 <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800c55c:	69ca      	ldr	r2, [r1, #28]
 800c55e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c562:	4302      	orrs	r2, r0
 800c564:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800c566:	06d8      	lsls	r0, r3, #27
 800c568:	d50b      	bpl.n	800c582 <HAL_RCC_ClockConfig+0x5e>
    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800c56a:	497c      	ldr	r1, [pc, #496]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c56c:	69a0      	ldr	r0, [r4, #24]
 800c56e:	69ca      	ldr	r2, [r1, #28]
 800c570:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 800c574:	4290      	cmp	r0, r2
 800c576:	d904      	bls.n	800c582 <HAL_RCC_ClockConfig+0x5e>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800c578:	69ca      	ldr	r2, [r1, #28]
 800c57a:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c57e:	4302      	orrs	r2, r0
 800c580:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800c582:	0699      	lsls	r1, r3, #26
 800c584:	d50b      	bpl.n	800c59e <HAL_RCC_ClockConfig+0x7a>
    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800c586:	4975      	ldr	r1, [pc, #468]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c588:	69e0      	ldr	r0, [r4, #28]
 800c58a:	6a0a      	ldr	r2, [r1, #32]
 800c58c:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c590:	4290      	cmp	r0, r2
 800c592:	d904      	bls.n	800c59e <HAL_RCC_ClockConfig+0x7a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 800c594:	6a0a      	ldr	r2, [r1, #32]
 800c596:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c59a:	4302      	orrs	r2, r0
 800c59c:	620a      	str	r2, [r1, #32]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800c59e:	079a      	lsls	r2, r3, #30
 800c5a0:	d50b      	bpl.n	800c5ba <HAL_RCC_ClockConfig+0x96>
    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800c5a2:	496e      	ldr	r1, [pc, #440]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c5a4:	68e0      	ldr	r0, [r4, #12]
 800c5a6:	698a      	ldr	r2, [r1, #24]
 800c5a8:	f002 020f 	and.w	r2, r2, #15
 800c5ac:	4290      	cmp	r0, r2
 800c5ae:	d904      	bls.n	800c5ba <HAL_RCC_ClockConfig+0x96>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800c5b0:	698a      	ldr	r2, [r1, #24]
 800c5b2:	f022 020f 	bic.w	r2, r2, #15
 800c5b6:	4302      	orrs	r2, r0
 800c5b8:	618a      	str	r2, [r1, #24]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800c5ba:	07df      	lsls	r7, r3, #31
 800c5bc:	d46e      	bmi.n	800c69c <HAL_RCC_ClockConfig+0x178>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800c5be:	6823      	ldr	r3, [r4, #0]
 800c5c0:	079e      	lsls	r6, r3, #30
 800c5c2:	f100 80a1 	bmi.w	800c708 <HAL_RCC_ClockConfig+0x1e4>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800c5c6:	4964      	ldr	r1, [pc, #400]	@ (800c758 <HAL_RCC_ClockConfig+0x234>)
 800c5c8:	680a      	ldr	r2, [r1, #0]
 800c5ca:	f002 020f 	and.w	r2, r2, #15
 800c5ce:	42aa      	cmp	r2, r5
 800c5d0:	f200 80a8 	bhi.w	800c724 <HAL_RCC_ClockConfig+0x200>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800c5d4:	0758      	lsls	r0, r3, #29
 800c5d6:	f100 80b1 	bmi.w	800c73c <HAL_RCC_ClockConfig+0x218>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800c5da:	0719      	lsls	r1, r3, #28
 800c5dc:	d50b      	bpl.n	800c5f6 <HAL_RCC_ClockConfig+0xd2>
    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800c5de:	495f      	ldr	r1, [pc, #380]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c5e0:	6960      	ldr	r0, [r4, #20]
 800c5e2:	69ca      	ldr	r2, [r1, #28]
 800c5e4:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c5e8:	4290      	cmp	r0, r2
 800c5ea:	d204      	bcs.n	800c5f6 <HAL_RCC_ClockConfig+0xd2>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800c5ec:	69ca      	ldr	r2, [r1, #28]
 800c5ee:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c5f2:	4302      	orrs	r2, r0
 800c5f4:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800c5f6:	06da      	lsls	r2, r3, #27
 800c5f8:	d50b      	bpl.n	800c612 <HAL_RCC_ClockConfig+0xee>
    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800c5fa:	4958      	ldr	r1, [pc, #352]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c5fc:	69a0      	ldr	r0, [r4, #24]
 800c5fe:	69ca      	ldr	r2, [r1, #28]
 800c600:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 800c604:	4290      	cmp	r0, r2
 800c606:	d204      	bcs.n	800c612 <HAL_RCC_ClockConfig+0xee>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800c608:	69ca      	ldr	r2, [r1, #28]
 800c60a:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c60e:	4302      	orrs	r2, r0
 800c610:	61ca      	str	r2, [r1, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800c612:	069b      	lsls	r3, r3, #26
 800c614:	d50b      	bpl.n	800c62e <HAL_RCC_ClockConfig+0x10a>
    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800c616:	4a51      	ldr	r2, [pc, #324]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c618:	69e1      	ldr	r1, [r4, #28]
 800c61a:	6a13      	ldr	r3, [r2, #32]
 800c61c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800c620:	4299      	cmp	r1, r3
 800c622:	d204      	bcs.n	800c62e <HAL_RCC_ClockConfig+0x10a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 800c624:	6a13      	ldr	r3, [r2, #32]
 800c626:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800c62a:	430b      	orrs	r3, r1
 800c62c:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800c62e:	f7ff fed7 	bl	800c3e0 <HAL_RCC_GetSysClockFreq>
 800c632:	494a      	ldr	r1, [pc, #296]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c634:	4a4a      	ldr	r2, [pc, #296]	@ (800c760 <HAL_RCC_ClockConfig+0x23c>)
 800c636:	698b      	ldr	r3, [r1, #24]
 800c638:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800c63c:	5cd3      	ldrb	r3, [r2, r3]
 800c63e:	f003 031f 	and.w	r3, r3, #31
 800c642:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c644:	698b      	ldr	r3, [r1, #24]
 800c646:	f003 030f 	and.w	r3, r3, #15
 800c64a:	5cd3      	ldrb	r3, [r2, r3]
 800c64c:	4a45      	ldr	r2, [pc, #276]	@ (800c764 <HAL_RCC_ClockConfig+0x240>)
 800c64e:	f003 031f 	and.w	r3, r3, #31
 800c652:	fa20 f303 	lsr.w	r3, r0, r3
 800c656:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 800c658:	4b43      	ldr	r3, [pc, #268]	@ (800c768 <HAL_RCC_ClockConfig+0x244>)
 800c65a:	6018      	str	r0, [r3, #0]
  halstatus = HAL_InitTick(uwTickPrio);
 800c65c:	4b43      	ldr	r3, [pc, #268]	@ (800c76c <HAL_RCC_ClockConfig+0x248>)
}
 800c65e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick(uwTickPrio);
 800c662:	6818      	ldr	r0, [r3, #0]
 800c664:	f7fe bd14 	b.w	800b090 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800c668:	6813      	ldr	r3, [r2, #0]
 800c66a:	f023 030f 	bic.w	r3, r3, #15
 800c66e:	430b      	orrs	r3, r1
 800c670:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800c672:	6813      	ldr	r3, [r2, #0]
 800c674:	f003 030f 	and.w	r3, r3, #15
 800c678:	428b      	cmp	r3, r1
 800c67a:	f47f af58 	bne.w	800c52e <HAL_RCC_ClockConfig+0xa>
 800c67e:	e760      	b.n	800c542 <HAL_RCC_ClockConfig+0x1e>
    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800c680:	4936      	ldr	r1, [pc, #216]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c682:	6920      	ldr	r0, [r4, #16]
 800c684:	698a      	ldr	r2, [r1, #24]
 800c686:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c68a:	4290      	cmp	r0, r2
 800c68c:	f67f af5d 	bls.w	800c54a <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800c690:	698a      	ldr	r2, [r1, #24]
 800c692:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c696:	4302      	orrs	r2, r0
 800c698:	618a      	str	r2, [r1, #24]
 800c69a:	e756      	b.n	800c54a <HAL_RCC_ClockConfig+0x26>
    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 800c69c:	4b2f      	ldr	r3, [pc, #188]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c69e:	68a1      	ldr	r1, [r4, #8]
 800c6a0:	699a      	ldr	r2, [r3, #24]
 800c6a2:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00
 800c6a6:	430a      	orrs	r2, r1
 800c6a8:	619a      	str	r2, [r3, #24]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c6aa:	6861      	ldr	r1, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800c6ac:	681a      	ldr	r2, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c6ae:	2902      	cmp	r1, #2
 800c6b0:	d11d      	bne.n	800c6ee <HAL_RCC_ClockConfig+0x1ca>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800c6b2:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c6b6:	f43f af3a 	beq.w	800c52e <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800c6ba:	691a      	ldr	r2, [r3, #16]
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800c6bc:	f241 3888 	movw	r8, #5000	@ 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800c6c0:	4f26      	ldr	r7, [pc, #152]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800c6c2:	f022 0207 	bic.w	r2, r2, #7
 800c6c6:	430a      	orrs	r2, r1
 800c6c8:	611a      	str	r2, [r3, #16]
    tickstart = HAL_GetTick();
 800c6ca:	f7fe fd3f 	bl	800b14c <HAL_GetTick>
 800c6ce:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800c6d0:	693b      	ldr	r3, [r7, #16]
 800c6d2:	6862      	ldr	r2, [r4, #4]
 800c6d4:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800c6d8:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 800c6dc:	f43f af6f 	beq.w	800c5be <HAL_RCC_ClockConfig+0x9a>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800c6e0:	f7fe fd34 	bl	800b14c <HAL_GetTick>
 800c6e4:	1b80      	subs	r0, r0, r6
 800c6e6:	4540      	cmp	r0, r8
 800c6e8:	d9f2      	bls.n	800c6d0 <HAL_RCC_ClockConfig+0x1ac>
        return HAL_TIMEOUT;
 800c6ea:	2003      	movs	r0, #3
 800c6ec:	e720      	b.n	800c530 <HAL_RCC_ClockConfig+0xc>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800c6ee:	2903      	cmp	r1, #3
 800c6f0:	d102      	bne.n	800c6f8 <HAL_RCC_ClockConfig+0x1d4>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800c6f2:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
 800c6f6:	e7de      	b.n	800c6b6 <HAL_RCC_ClockConfig+0x192>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 800c6f8:	2901      	cmp	r1, #1
 800c6fa:	d102      	bne.n	800c702 <HAL_RCC_ClockConfig+0x1de>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800c6fc:	f412 7f80 	tst.w	r2, #256	@ 0x100
 800c700:	e7d9      	b.n	800c6b6 <HAL_RCC_ClockConfig+0x192>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800c702:	f012 0f04 	tst.w	r2, #4
 800c706:	e7d6      	b.n	800c6b6 <HAL_RCC_ClockConfig+0x192>
    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800c708:	4914      	ldr	r1, [pc, #80]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c70a:	68e0      	ldr	r0, [r4, #12]
 800c70c:	698a      	ldr	r2, [r1, #24]
 800c70e:	f002 020f 	and.w	r2, r2, #15
 800c712:	4290      	cmp	r0, r2
 800c714:	f4bf af57 	bcs.w	800c5c6 <HAL_RCC_ClockConfig+0xa2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800c718:	698a      	ldr	r2, [r1, #24]
 800c71a:	f022 020f 	bic.w	r2, r2, #15
 800c71e:	4302      	orrs	r2, r0
 800c720:	618a      	str	r2, [r1, #24]
 800c722:	e750      	b.n	800c5c6 <HAL_RCC_ClockConfig+0xa2>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800c724:	680a      	ldr	r2, [r1, #0]
 800c726:	f022 020f 	bic.w	r2, r2, #15
 800c72a:	432a      	orrs	r2, r5
 800c72c:	600a      	str	r2, [r1, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800c72e:	680a      	ldr	r2, [r1, #0]
 800c730:	f002 020f 	and.w	r2, r2, #15
 800c734:	42aa      	cmp	r2, r5
 800c736:	f47f aefa 	bne.w	800c52e <HAL_RCC_ClockConfig+0xa>
 800c73a:	e74b      	b.n	800c5d4 <HAL_RCC_ClockConfig+0xb0>
    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800c73c:	4907      	ldr	r1, [pc, #28]	@ (800c75c <HAL_RCC_ClockConfig+0x238>)
 800c73e:	6920      	ldr	r0, [r4, #16]
 800c740:	698a      	ldr	r2, [r1, #24]
 800c742:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800c746:	4290      	cmp	r0, r2
 800c748:	f4bf af47 	bcs.w	800c5da <HAL_RCC_ClockConfig+0xb6>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800c74c:	698a      	ldr	r2, [r1, #24]
 800c74e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800c752:	4302      	orrs	r2, r0
 800c754:	618a      	str	r2, [r1, #24]
 800c756:	e740      	b.n	800c5da <HAL_RCC_ClockConfig+0xb6>
 800c758:	52002000 	.word	0x52002000
 800c75c:	58024400 	.word	0x58024400
 800c760:	0800e42e 	.word	0x0800e42e
 800c764:	2000111c 	.word	0x2000111c
 800c768:	20001120 	.word	0x20001120
 800c76c:	20001128 	.word	0x20001128

0800c770 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800c770:	b508      	push	{r3, lr}
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800c772:	f7ff fe35 	bl	800c3e0 <HAL_RCC_GetSysClockFreq>
 800c776:	4a0b      	ldr	r2, [pc, #44]	@ (800c7a4 <HAL_RCC_GetHCLKFreq+0x34>)
 800c778:	490b      	ldr	r1, [pc, #44]	@ (800c7a8 <HAL_RCC_GetHCLKFreq+0x38>)
 800c77a:	6993      	ldr	r3, [r2, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c77c:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800c77e:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c782:	f002 020f 	and.w	r2, r2, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800c786:	5ccb      	ldrb	r3, [r1, r3]
 800c788:	f003 031f 	and.w	r3, r3, #31
 800c78c:	fa20 f303 	lsr.w	r3, r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800c790:	5c88      	ldrb	r0, [r1, r2]
 800c792:	4a06      	ldr	r2, [pc, #24]	@ (800c7ac <HAL_RCC_GetHCLKFreq+0x3c>)
 800c794:	f000 001f 	and.w	r0, r0, #31
 800c798:	fa23 f000 	lsr.w	r0, r3, r0
 800c79c:	6010      	str	r0, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800c79e:	4a04      	ldr	r2, [pc, #16]	@ (800c7b0 <HAL_RCC_GetHCLKFreq+0x40>)
 800c7a0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 800c7a2:	bd08      	pop	{r3, pc}
 800c7a4:	58024400 	.word	0x58024400
 800c7a8:	0800e42e 	.word	0x0800e42e
 800c7ac:	2000111c 	.word	0x2000111c
 800c7b0:	20001120 	.word	0x20001120

0800c7b4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800c7b4:	b508      	push	{r3, lr}
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 800c7b6:	f7ff ffdb 	bl	800c770 <HAL_RCC_GetHCLKFreq>
 800c7ba:	4b05      	ldr	r3, [pc, #20]	@ (800c7d0 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800c7bc:	4a05      	ldr	r2, [pc, #20]	@ (800c7d4 <HAL_RCC_GetPCLK1Freq+0x20>)
 800c7be:	69db      	ldr	r3, [r3, #28]
 800c7c0:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800c7c4:	5cd3      	ldrb	r3, [r2, r3]
 800c7c6:	f003 031f 	and.w	r3, r3, #31
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 800c7ca:	40d8      	lsrs	r0, r3
 800c7cc:	bd08      	pop	{r3, pc}
 800c7ce:	bf00      	nop
 800c7d0:	58024400 	.word	0x58024400
 800c7d4:	0800e42e 	.word	0x0800e42e

0800c7d8 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800c7d8:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 800c7da:	f7ff ffc9 	bl	800c770 <HAL_RCC_GetHCLKFreq>
 800c7de:	4b05      	ldr	r3, [pc, #20]	@ (800c7f4 <HAL_RCC_GetPCLK2Freq+0x1c>)
 800c7e0:	4a05      	ldr	r2, [pc, #20]	@ (800c7f8 <HAL_RCC_GetPCLK2Freq+0x20>)
 800c7e2:	69db      	ldr	r3, [r3, #28]
 800c7e4:	f3c3 2302 	ubfx	r3, r3, #8, #3
 800c7e8:	5cd3      	ldrb	r3, [r2, r3]
 800c7ea:	f003 031f 	and.w	r3, r3, #31
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 800c7ee:	40d8      	lsrs	r0, r3
 800c7f0:	bd08      	pop	{r3, pc}
 800c7f2:	bf00      	nop
 800c7f4:	58024400 	.word	0x58024400
 800c7f8:	0800e42e 	.word	0x0800e42e

0800c7fc <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 800c7fc:	b508      	push	{r3, lr}
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 800c7fe:	f7ff ffb7 	bl	800c770 <HAL_RCC_GetHCLKFreq>
 800c802:	4b05      	ldr	r3, [pc, #20]	@ (800c818 <HAL_RCCEx_GetD3PCLK1Freq+0x1c>)
 800c804:	4a05      	ldr	r2, [pc, #20]	@ (800c81c <HAL_RCCEx_GetD3PCLK1Freq+0x20>)
 800c806:	6a1b      	ldr	r3, [r3, #32]
 800c808:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800c80c:	5cd3      	ldrb	r3, [r2, r3]
 800c80e:	f003 031f 	and.w	r3, r3, #31
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 800c812:	40d8      	lsrs	r0, r3
 800c814:	bd08      	pop	{r3, pc}
 800c816:	bf00      	nop
 800c818:	58024400 	.word	0x58024400
 800c81c:	0800e42e 	.word	0x0800e42e

0800c820 <HAL_RCCEx_GetPLL2ClockFreq>:
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c820:	494f      	ldr	r1, [pc, #316]	@ (800c960 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
{
 800c822:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c824:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 800c826:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800c828:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));

  if (pll2m != 0U)
 800c82a:	f416 3f7c 	tst.w	r6, #258048	@ 0x3f000
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 800c82e:	f3c6 3305 	ubfx	r3, r6, #12, #6
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c832:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
  if (pll2m != 0U)
 800c834:	f000 8090 	beq.w	800c958 <HAL_RCCEx_GetPLL2ClockFreq+0x138>
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c838:	ee07 3a90 	vmov	s15, r3
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c83c:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800c840:	f3c5 1200 	ubfx	r2, r5, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c844:	f004 0403 	and.w	r4, r4, #3
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c848:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c84c:	4353      	muls	r3, r2
    switch (pllsource)
 800c84e:	2c01      	cmp	r4, #1
 800c850:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c854:	ee06 3a90 	vmov	s13, r3
 800c858:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
 800c85c:	d06e      	beq.n	800c93c <HAL_RCCEx_GetPLL2ClockFreq+0x11c>
 800c85e:	2c02      	cmp	r4, #2
 800c860:	d05e      	beq.n	800c920 <HAL_RCCEx_GetPLL2ClockFreq+0x100>
 800c862:	2c00      	cmp	r4, #0
 800c864:	d16a      	bne.n	800c93c <HAL_RCCEx_GetPLL2ClockFreq+0x11c>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c866:	680b      	ldr	r3, [r1, #0]
 800c868:	069b      	lsls	r3, r3, #26
 800c86a:	d547      	bpl.n	800c8fc <HAL_RCCEx_GetPLL2ClockFreq+0xdc>
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c86c:	680a      	ldr	r2, [r1, #0]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c86e:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c870:	f3c2 01c1 	ubfx	r1, r2, #3, #2
 800c874:	4a3b      	ldr	r2, [pc, #236]	@ (800c964 <HAL_RCCEx_GetPLL2ClockFreq+0x144>)
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c876:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c87a:	40ca      	lsrs	r2, r1
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c87c:	ee07 2a90 	vmov	s15, r2
 800c880:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 800c884:	eec5 7a87 	vdiv.f32	s15, s11, s14
 800c888:	ee07 3a10 	vmov	s14, r3
 800c88c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c890:	ee37 7a26 	vadd.f32	s14, s14, s13
 800c894:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c898:	ee67 7a87 	vmul.f32	s15, s15, s14

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        break;
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 800c89c:	4a30      	ldr	r2, [pc, #192]	@ (800c960 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
 800c89e:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800c8a0:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800c8a4:	ee07 3a10 	vmov	s14, r3
 800c8a8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c8ac:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c8b0:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800c8b4:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800c8b8:	edc0 6a00 	vstr	s13, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 800c8bc:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800c8be:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800c8c2:	ee07 3a10 	vmov	s14, r3
 800c8c6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c8ca:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c8ce:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800c8d2:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800c8d6:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 800c8da:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800c8dc:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800c8e0:	ee06 3a90 	vmov	s13, r3
 800c8e4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800c8e8:	ee76 6a86 	vadd.f32	s13, s13, s12
 800c8ec:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800c8f0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800c8f4:	ee17 3a90 	vmov	r3, s15
 800c8f8:	6083      	str	r3, [r0, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 800c8fa:	bd70      	pop	{r4, r5, r6, pc}
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c8fc:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 800c8fe:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 800c968 <HAL_RCCEx_GetPLL2ClockFreq+0x148>
 800c902:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c906:	ee07 3a90 	vmov	s15, r3
 800c90a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c90e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c912:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c916:	eec5 6a87 	vdiv.f32	s13, s11, s14
 800c91a:	ee67 7aa6 	vmul.f32	s15, s15, s13
        break;
 800c91e:	e7bd      	b.n	800c89c <HAL_RCCEx_GetPLL2ClockFreq+0x7c>
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c920:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 800c922:	eddf 5a12 	vldr	s11, [pc, #72]	@ 800c96c <HAL_RCCEx_GetPLL2ClockFreq+0x14c>
 800c926:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c92a:	ee07 3a90 	vmov	s15, r3
 800c92e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c932:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c936:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c93a:	e7ec      	b.n	800c916 <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c93c:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 800c93e:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 800c970 <HAL_RCCEx_GetPLL2ClockFreq+0x150>
 800c942:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c946:	ee07 3a90 	vmov	s15, r3
 800c94a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c94e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c952:	ee77 7a86 	vadd.f32	s15, s15, s12
 800c956:	e7de      	b.n	800c916 <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800c958:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 800c95c:	e7cc      	b.n	800c8f8 <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
 800c95e:	bf00      	nop
 800c960:	58024400 	.word	0x58024400
 800c964:	03d09000 	.word	0x03d09000
 800c968:	4c742400 	.word	0x4c742400
 800c96c:	4af42400 	.word	0x4af42400
 800c970:	4a742400 	.word	0x4a742400

0800c974 <HAL_RCCEx_GetPLL3ClockFreq>:
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c974:	494f      	ldr	r1, [pc, #316]	@ (800cab4 <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
{
 800c976:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c978:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 800c97a:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800c97c:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));

  if (pll3m != 0U)
 800c97e:	f016 7f7c 	tst.w	r6, #66060288	@ 0x3f00000
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 800c982:	f3c6 5305 	ubfx	r3, r6, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800c986:	6c4a      	ldr	r2, [r1, #68]	@ 0x44
  if (pll3m != 0U)
 800c988:	f000 8090 	beq.w	800caac <HAL_RCCEx_GetPLL3ClockFreq+0x138>
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c98c:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800c990:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800c994:	f3c5 2200 	ubfx	r2, r5, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c998:	f004 0403 	and.w	r4, r4, #3
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c99c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800c9a0:	4353      	muls	r3, r2
    switch (pllsource)
 800c9a2:	2c01      	cmp	r4, #1
 800c9a4:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c9a8:	ee06 3a90 	vmov	s13, r3
 800c9ac:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
 800c9b0:	d06e      	beq.n	800ca90 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>
 800c9b2:	2c02      	cmp	r4, #2
 800c9b4:	d05e      	beq.n	800ca74 <HAL_RCCEx_GetPLL3ClockFreq+0x100>
 800c9b6:	2c00      	cmp	r4, #0
 800c9b8:	d16a      	bne.n	800ca90 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c9ba:	680b      	ldr	r3, [r1, #0]
 800c9bc:	069b      	lsls	r3, r3, #26
 800c9be:	d547      	bpl.n	800ca50 <HAL_RCCEx_GetPLL3ClockFreq+0xdc>
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c9c0:	680a      	ldr	r2, [r1, #0]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c9c2:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c9c4:	f3c2 01c1 	ubfx	r1, r2, #3, #2
 800c9c8:	4a3b      	ldr	r2, [pc, #236]	@ (800cab8 <HAL_RCCEx_GetPLL3ClockFreq+0x144>)
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c9ca:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c9ce:	40ca      	lsrs	r2, r1
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c9d0:	ee07 2a90 	vmov	s15, r2
 800c9d4:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 800c9d8:	eec5 7a87 	vdiv.f32	s15, s11, s14
 800c9dc:	ee07 3a10 	vmov	s14, r3
 800c9e0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c9e4:	ee37 7a26 	vadd.f32	s14, s14, s13
 800c9e8:	ee37 7a06 	vadd.f32	s14, s14, s12
 800c9ec:	ee67 7a87 	vmul.f32	s15, s15, s14

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        break;
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 800c9f0:	4a30      	ldr	r2, [pc, #192]	@ (800cab4 <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
 800c9f2:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800c9f4:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800c9f8:	ee07 3a10 	vmov	s14, r3
 800c9fc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800ca00:	ee37 7a06 	vadd.f32	s14, s14, s12
 800ca04:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800ca08:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800ca0c:	edc0 6a00 	vstr	s13, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 800ca10:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800ca12:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800ca16:	ee07 3a10 	vmov	s14, r3
 800ca1a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800ca1e:	ee37 7a06 	vadd.f32	s14, s14, s12
 800ca22:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800ca26:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800ca2a:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 800ca2e:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800ca30:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800ca34:	ee06 3a90 	vmov	s13, r3
 800ca38:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800ca3c:	ee76 6a86 	vadd.f32	s13, s13, s12
 800ca40:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800ca44:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800ca48:	ee17 3a90 	vmov	r3, s15
 800ca4c:	6083      	str	r3, [r0, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 800ca4e:	bd70      	pop	{r4, r5, r6, pc}
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca50:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800ca52:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 800cabc <HAL_RCCEx_GetPLL3ClockFreq+0x148>
 800ca56:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ca5a:	ee07 3a90 	vmov	s15, r3
 800ca5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ca62:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800ca66:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca6a:	eec5 6a87 	vdiv.f32	s13, s11, s14
 800ca6e:	ee67 7aa6 	vmul.f32	s15, s15, s13
        break;
 800ca72:	e7bd      	b.n	800c9f0 <HAL_RCCEx_GetPLL3ClockFreq+0x7c>
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca74:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800ca76:	eddf 5a12 	vldr	s11, [pc, #72]	@ 800cac0 <HAL_RCCEx_GetPLL3ClockFreq+0x14c>
 800ca7a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ca7e:	ee07 3a90 	vmov	s15, r3
 800ca82:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ca86:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800ca8a:	ee77 7a86 	vadd.f32	s15, s15, s12
 800ca8e:	e7ec      	b.n	800ca6a <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800ca90:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800ca92:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 800cac4 <HAL_RCCEx_GetPLL3ClockFreq+0x150>
 800ca96:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ca9a:	ee07 3a90 	vmov	s15, r3
 800ca9e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800caa2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800caa6:	ee77 7a86 	vadd.f32	s15, s15, s12
 800caaa:	e7de      	b.n	800ca6a <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800caac:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800cab0:	e7cc      	b.n	800ca4c <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
 800cab2:	bf00      	nop
 800cab4:	58024400 	.word	0x58024400
 800cab8:	03d09000 	.word	0x03d09000
 800cabc:	4c742400 	.word	0x4c742400
 800cac0:	4af42400 	.word	0x4af42400
 800cac4:	4a742400 	.word	0x4a742400

0800cac8 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800cac8:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800caca:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800cacc:	e852 3f00 	ldrex	r3, [r2]
 800cad0:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800cad4:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 800cad8:	6802      	ldr	r2, [r0, #0]
 800cada:	2900      	cmp	r1, #0
 800cadc:	d1f5      	bne.n	800caca <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800cade:	4c0f      	ldr	r4, [pc, #60]	@ (800cb1c <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800cae0:	f102 0308 	add.w	r3, r2, #8
 800cae4:	e853 3f00 	ldrex	r3, [r3]
 800cae8:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800caea:	f102 0c08 	add.w	ip, r2, #8
 800caee:	e84c 3100 	strex	r1, r3, [ip]
 800caf2:	2900      	cmp	r1, #0
 800caf4:	d1f4      	bne.n	800cae0 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800caf6:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 800caf8:	2b01      	cmp	r3, #1
 800cafa:	d107      	bne.n	800cb0c <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800cafc:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800cb00:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800cb04:	e842 3100 	strex	r1, r3, [r2]
 800cb08:	2900      	cmp	r1, #0
 800cb0a:	d1f7      	bne.n	800cafc <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800cb0c:	2320      	movs	r3, #32
 800cb0e:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800cb12:	2300      	movs	r3, #0
 800cb14:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800cb16:	6743      	str	r3, [r0, #116]	@ 0x74
}
 800cb18:	bd10      	pop	{r4, pc}
 800cb1a:	bf00      	nop
 800cb1c:	effffffe 	.word	0xeffffffe

0800cb20 <UART_SetConfig>:
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cb20:	6802      	ldr	r2, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cb22:	69c3      	ldr	r3, [r0, #28]
 800cb24:	6881      	ldr	r1, [r0, #8]
{
 800cb26:	b530      	push	{r4, r5, lr}
 800cb28:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cb2a:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cb2c:	6815      	ldr	r5, [r2, #0]
{
 800cb2e:	b087      	sub	sp, #28
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cb30:	4301      	orrs	r1, r0
 800cb32:	6960      	ldr	r0, [r4, #20]
 800cb34:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cb36:	48a5      	ldr	r0, [pc, #660]	@ (800cdcc <UART_SetConfig+0x2ac>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cb38:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cb3a:	4028      	ands	r0, r5
 800cb3c:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cb3e:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cb40:	6011      	str	r1, [r2, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cb42:	6851      	ldr	r1, [r2, #4]
 800cb44:	f421 5140 	bic.w	r1, r1, #12288	@ 0x3000
 800cb48:	4301      	orrs	r1, r0
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800cb4a:	69a0      	ldr	r0, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cb4c:	6051      	str	r1, [r2, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800cb4e:	49a0      	ldr	r1, [pc, #640]	@ (800cdd0 <UART_SetConfig+0x2b0>)
 800cb50:	428a      	cmp	r2, r1
    tmpreg |= huart->Init.OneBitSampling;
 800cb52:	bf1c      	itt	ne
 800cb54:	6a21      	ldrne	r1, [r4, #32]
 800cb56:	4308      	orrne	r0, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800cb58:	6891      	ldr	r1, [r2, #8]
 800cb5a:	f021 416e 	bic.w	r1, r1, #3992977408	@ 0xee000000
 800cb5e:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 800cb62:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800cb64:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800cb66:	6091      	str	r1, [r2, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800cb68:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
 800cb6a:	f021 010f 	bic.w	r1, r1, #15
 800cb6e:	4301      	orrs	r1, r0
 800cb70:	62d1      	str	r1, [r2, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 800cb72:	4998      	ldr	r1, [pc, #608]	@ (800cdd4 <UART_SetConfig+0x2b4>)
 800cb74:	428a      	cmp	r2, r1
 800cb76:	d112      	bne.n	800cb9e <UART_SetConfig+0x7e>
 800cb78:	4a97      	ldr	r2, [pc, #604]	@ (800cdd8 <UART_SetConfig+0x2b8>)
 800cb7a:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 800cb7c:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 800cb80:	2a18      	cmp	r2, #24
 800cb82:	f000 8101 	beq.w	800cd88 <UART_SetConfig+0x268>
 800cb86:	d83b      	bhi.n	800cc00 <UART_SetConfig+0xe0>
 800cb88:	2a08      	cmp	r2, #8
 800cb8a:	f000 80f5 	beq.w	800cd78 <UART_SetConfig+0x258>
 800cb8e:	2a10      	cmp	r2, #16
 800cb90:	f000 813a 	beq.w	800ce08 <UART_SetConfig+0x2e8>
 800cb94:	2a00      	cmp	r2, #0
 800cb96:	f000 80e9 	beq.w	800cd6c <UART_SetConfig+0x24c>
        ret = HAL_ERROR;
 800cb9a:	2001      	movs	r0, #1
 800cb9c:	e06a      	b.n	800cc74 <UART_SetConfig+0x154>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800cb9e:	498f      	ldr	r1, [pc, #572]	@ (800cddc <UART_SetConfig+0x2bc>)
 800cba0:	428a      	cmp	r2, r1
 800cba2:	d10d      	bne.n	800cbc0 <UART_SetConfig+0xa0>
 800cba4:	4a8c      	ldr	r2, [pc, #560]	@ (800cdd8 <UART_SetConfig+0x2b8>)
 800cba6:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 800cba8:	f002 0207 	and.w	r2, r2, #7
 800cbac:	2a05      	cmp	r2, #5
 800cbae:	d8f4      	bhi.n	800cb9a <UART_SetConfig+0x7a>
 800cbb0:	e8df f012 	tbh	[pc, r2, lsl #1]
 800cbb4:	00e2007e 	.word	0x00e2007e
 800cbb8:	00ea012a 	.word	0x00ea012a
 800cbbc:	002b0107 	.word	0x002b0107
 800cbc0:	4987      	ldr	r1, [pc, #540]	@ (800cde0 <UART_SetConfig+0x2c0>)
 800cbc2:	428a      	cmp	r2, r1
 800cbc4:	d0ee      	beq.n	800cba4 <UART_SetConfig+0x84>
 800cbc6:	4987      	ldr	r1, [pc, #540]	@ (800cde4 <UART_SetConfig+0x2c4>)
 800cbc8:	428a      	cmp	r2, r1
 800cbca:	d0eb      	beq.n	800cba4 <UART_SetConfig+0x84>
 800cbcc:	4986      	ldr	r1, [pc, #536]	@ (800cde8 <UART_SetConfig+0x2c8>)
 800cbce:	428a      	cmp	r2, r1
 800cbd0:	d0e8      	beq.n	800cba4 <UART_SetConfig+0x84>
 800cbd2:	4986      	ldr	r1, [pc, #536]	@ (800cdec <UART_SetConfig+0x2cc>)
 800cbd4:	428a      	cmp	r2, r1
 800cbd6:	d0cf      	beq.n	800cb78 <UART_SetConfig+0x58>
 800cbd8:	4985      	ldr	r1, [pc, #532]	@ (800cdf0 <UART_SetConfig+0x2d0>)
 800cbda:	428a      	cmp	r2, r1
 800cbdc:	d0e2      	beq.n	800cba4 <UART_SetConfig+0x84>
 800cbde:	4985      	ldr	r1, [pc, #532]	@ (800cdf4 <UART_SetConfig+0x2d4>)
 800cbe0:	428a      	cmp	r2, r1
 800cbe2:	d0df      	beq.n	800cba4 <UART_SetConfig+0x84>
 800cbe4:	4b7a      	ldr	r3, [pc, #488]	@ (800cdd0 <UART_SetConfig+0x2b0>)
 800cbe6:	429a      	cmp	r2, r3
 800cbe8:	d1d7      	bne.n	800cb9a <UART_SetConfig+0x7a>
 800cbea:	4a7b      	ldr	r2, [pc, #492]	@ (800cdd8 <UART_SetConfig+0x2b8>)
 800cbec:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 800cbee:	f003 0307 	and.w	r3, r3, #7
 800cbf2:	2b05      	cmp	r3, #5
 800cbf4:	d8d1      	bhi.n	800cb9a <UART_SetConfig+0x7a>
 800cbf6:	e8df f003 	tbb	[pc, r3]
 800cbfa:	4538      	.short	0x4538
 800cbfc:	0f594f4a 	.word	0x0f594f4a
 800cc00:	2a20      	cmp	r2, #32
 800cc02:	f000 80de 	beq.w	800cdc2 <UART_SetConfig+0x2a2>
 800cc06:	2a28      	cmp	r2, #40	@ 0x28
 800cc08:	d1c7      	bne.n	800cb9a <UART_SetConfig+0x7a>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cc0a:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cc0e:	f000 808a 	beq.w	800cd26 <UART_SetConfig+0x206>
 800cc12:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 800cc16:	e0c4      	b.n	800cda2 <UART_SetConfig+0x282>
        pclk = (uint32_t) LSE_VALUE;
 800cc18:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800cc1c:	4b76      	ldr	r3, [pc, #472]	@ (800cdf8 <UART_SetConfig+0x2d8>)
 800cc1e:	6a62      	ldr	r2, [r4, #36]	@ 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800cc20:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800cc22:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800cc26:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800cc2a:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800cc2e:	4299      	cmp	r1, r3
 800cc30:	d8b3      	bhi.n	800cb9a <UART_SetConfig+0x7a>
 800cc32:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 800cc36:	d8b0      	bhi.n	800cb9a <UART_SetConfig+0x7a>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800cc38:	2300      	movs	r3, #0
 800cc3a:	4619      	mov	r1, r3
 800cc3c:	f7fb ff58 	bl	8008af0 <__aeabi_uldivmod>
 800cc40:	462a      	mov	r2, r5
 800cc42:	0209      	lsls	r1, r1, #8
 800cc44:	086b      	lsrs	r3, r5, #1
 800cc46:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 800cc4a:	0200      	lsls	r0, r0, #8
 800cc4c:	18c0      	adds	r0, r0, r3
 800cc4e:	f04f 0300 	mov.w	r3, #0
 800cc52:	f141 0100 	adc.w	r1, r1, #0
 800cc56:	f7fb ff4b 	bl	8008af0 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800cc5a:	4b68      	ldr	r3, [pc, #416]	@ (800cdfc <UART_SetConfig+0x2dc>)
 800cc5c:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800cc60:	429a      	cmp	r2, r3
 800cc62:	d89a      	bhi.n	800cb9a <UART_SetConfig+0x7a>
        huart->Instance->BRR = (uint16_t)usartdiv;
 800cc64:	6823      	ldr	r3, [r4, #0]
 800cc66:	60d8      	str	r0, [r3, #12]
 800cc68:	e003      	b.n	800cc72 <UART_SetConfig+0x152>
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 800cc6a:	f7ff fdc7 	bl	800c7fc <HAL_RCCEx_GetD3PCLK1Freq>
    if (pclk != 0U)
 800cc6e:	2800      	cmp	r0, #0
 800cc70:	d1d4      	bne.n	800cc1c <UART_SetConfig+0xfc>
          pclk = (uint32_t) HSI_VALUE;
 800cc72:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 800cc74:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
 800cc78:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 800cc7a:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 800cc7c:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
 800cc80:	b007      	add	sp, #28
 800cc82:	bd30      	pop	{r4, r5, pc}
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800cc84:	4668      	mov	r0, sp
 800cc86:	f7ff fdcb 	bl	800c820 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800cc8a:	9801      	ldr	r0, [sp, #4]
        break;
 800cc8c:	e7ef      	b.n	800cc6e <UART_SetConfig+0x14e>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800cc8e:	a803      	add	r0, sp, #12
 800cc90:	f7ff fe70 	bl	800c974 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800cc94:	9804      	ldr	r0, [sp, #16]
        break;
 800cc96:	e7ea      	b.n	800cc6e <UART_SetConfig+0x14e>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cc98:	6813      	ldr	r3, [r2, #0]
 800cc9a:	4859      	ldr	r0, [pc, #356]	@ (800ce00 <UART_SetConfig+0x2e0>)
 800cc9c:	f013 0f20 	tst.w	r3, #32
 800cca0:	d0bc      	beq.n	800cc1c <UART_SetConfig+0xfc>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800cca2:	6813      	ldr	r3, [r2, #0]
 800cca4:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800cca8:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 800ccaa:	e7b7      	b.n	800cc1c <UART_SetConfig+0xfc>
        pclk = (uint32_t) CSI_VALUE;
 800ccac:	4855      	ldr	r0, [pc, #340]	@ (800ce04 <UART_SetConfig+0x2e4>)
 800ccae:	e7b5      	b.n	800cc1c <UART_SetConfig+0xfc>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ccb0:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ccb4:	d155      	bne.n	800cd62 <UART_SetConfig+0x242>
 800ccb6:	2300      	movs	r3, #0
    switch (clocksource)
 800ccb8:	2b08      	cmp	r3, #8
 800ccba:	f63f af6e 	bhi.w	800cb9a <UART_SetConfig+0x7a>
 800ccbe:	a201      	add	r2, pc, #4	@ (adr r2, 800ccc4 <UART_SetConfig+0x1a4>)
 800ccc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ccc4:	0800ccf1 	.word	0x0800ccf1
 800ccc8:	0800ccfd 	.word	0x0800ccfd
 800cccc:	0800cb9b 	.word	0x0800cb9b
 800ccd0:	0800cb9b 	.word	0x0800cb9b
 800ccd4:	0800cd03 	.word	0x0800cd03
 800ccd8:	0800cb9b 	.word	0x0800cb9b
 800ccdc:	0800cb9b 	.word	0x0800cb9b
 800cce0:	0800cb9b 	.word	0x0800cb9b
 800cce4:	0800cd0d 	.word	0x0800cd0d
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cce8:	2304      	movs	r3, #4
 800ccea:	e7e5      	b.n	800ccb8 <UART_SetConfig+0x198>
 800ccec:	2308      	movs	r3, #8
 800ccee:	e7e3      	b.n	800ccb8 <UART_SetConfig+0x198>
        pclk = HAL_RCC_GetPCLK1Freq();
 800ccf0:	f7ff fd60 	bl	800c7b4 <HAL_RCC_GetPCLK1Freq>
        pclk = HAL_RCC_GetPCLK2Freq();
 800ccf4:	4603      	mov	r3, r0
    if (pclk != 0U)
 800ccf6:	2b00      	cmp	r3, #0
 800ccf8:	d0bb      	beq.n	800cc72 <UART_SetConfig+0x152>
 800ccfa:	e014      	b.n	800cd26 <UART_SetConfig+0x206>
        pclk = HAL_RCC_GetPCLK2Freq();
 800ccfc:	f7ff fd6c 	bl	800c7d8 <HAL_RCC_GetPCLK2Freq>
 800cd00:	e7f8      	b.n	800ccf4 <UART_SetConfig+0x1d4>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800cd02:	4668      	mov	r0, sp
 800cd04:	f7ff fd8c 	bl	800c820 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800cd08:	9b01      	ldr	r3, [sp, #4]
        break;
 800cd0a:	e7f4      	b.n	800ccf6 <UART_SetConfig+0x1d6>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800cd0c:	a803      	add	r0, sp, #12
 800cd0e:	f7ff fe31 	bl	800c974 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800cd12:	9b04      	ldr	r3, [sp, #16]
        break;
 800cd14:	e7ef      	b.n	800ccf6 <UART_SetConfig+0x1d6>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cd16:	f013 0f20 	tst.w	r3, #32
 800cd1a:	4b39      	ldr	r3, [pc, #228]	@ (800ce00 <UART_SetConfig+0x2e0>)
 800cd1c:	d003      	beq.n	800cd26 <UART_SetConfig+0x206>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800cd1e:	6812      	ldr	r2, [r2, #0]
 800cd20:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 800cd24:	40d3      	lsrs	r3, r2
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800cd26:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 800cd28:	4a33      	ldr	r2, [pc, #204]	@ (800cdf8 <UART_SetConfig+0x2d8>)
 800cd2a:	6861      	ldr	r1, [r4, #4]
 800cd2c:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 800cd30:	fbb3 f3f2 	udiv	r3, r3, r2
 800cd34:	084a      	lsrs	r2, r1, #1
 800cd36:	eb02 0343 	add.w	r3, r2, r3, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800cd3a:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800cd3e:	fbb3 f3f1 	udiv	r3, r3, r1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800cd42:	f1a3 0110 	sub.w	r1, r3, #16
 800cd46:	4291      	cmp	r1, r2
 800cd48:	f63f af27 	bhi.w	800cb9a <UART_SetConfig+0x7a>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800cd4c:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800cd50:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 800cd54:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800cd56:	b292      	uxth	r2, r2
        huart->Instance->BRR = brrtemp;
 800cd58:	4313      	orrs	r3, r2
 800cd5a:	60cb      	str	r3, [r1, #12]
 800cd5c:	e789      	b.n	800cc72 <UART_SetConfig+0x152>
        pclk = (uint32_t) CSI_VALUE;
 800cd5e:	4b29      	ldr	r3, [pc, #164]	@ (800ce04 <UART_SetConfig+0x2e4>)
 800cd60:	e7e1      	b.n	800cd26 <UART_SetConfig+0x206>
        pclk = HAL_RCC_GetPCLK1Freq();
 800cd62:	f7ff fd27 	bl	800c7b4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800cd66:	2800      	cmp	r0, #0
 800cd68:	d083      	beq.n	800cc72 <UART_SetConfig+0x152>
 800cd6a:	e01a      	b.n	800cda2 <UART_SetConfig+0x282>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cd6c:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cd70:	d0c4      	beq.n	800ccfc <UART_SetConfig+0x1dc>
        pclk = HAL_RCC_GetPCLK2Freq();
 800cd72:	f7ff fd31 	bl	800c7d8 <HAL_RCC_GetPCLK2Freq>
        break;
 800cd76:	e7f6      	b.n	800cd66 <UART_SetConfig+0x246>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cd78:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cd7c:	d0b4      	beq.n	800cce8 <UART_SetConfig+0x1c8>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800cd7e:	4668      	mov	r0, sp
 800cd80:	f7ff fd4e 	bl	800c820 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800cd84:	9801      	ldr	r0, [sp, #4]
        break;
 800cd86:	e7ee      	b.n	800cd66 <UART_SetConfig+0x246>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cd88:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cd8c:	4a12      	ldr	r2, [pc, #72]	@ (800cdd8 <UART_SetConfig+0x2b8>)
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cd8e:	6813      	ldr	r3, [r2, #0]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cd90:	d0c1      	beq.n	800cd16 <UART_SetConfig+0x1f6>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cd92:	f013 0f20 	tst.w	r3, #32
 800cd96:	481a      	ldr	r0, [pc, #104]	@ (800ce00 <UART_SetConfig+0x2e0>)
 800cd98:	d003      	beq.n	800cda2 <UART_SetConfig+0x282>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800cd9a:	6813      	ldr	r3, [r2, #0]
 800cd9c:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800cda0:	40d8      	lsrs	r0, r3
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800cda2:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800cda4:	4a14      	ldr	r2, [pc, #80]	@ (800cdf8 <UART_SetConfig+0x2d8>)
 800cda6:	6863      	ldr	r3, [r4, #4]
 800cda8:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 800cdac:	fbb0 f0f2 	udiv	r0, r0, r2
 800cdb0:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800cdb4:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800cdb8:	f64f 73ef 	movw	r3, #65519	@ 0xffef
 800cdbc:	f1a0 0210 	sub.w	r2, r0, #16
 800cdc0:	e74e      	b.n	800cc60 <UART_SetConfig+0x140>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cdc2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800cdc6:	d0ca      	beq.n	800cd5e <UART_SetConfig+0x23e>
        pclk = (uint32_t) CSI_VALUE;
 800cdc8:	480e      	ldr	r0, [pc, #56]	@ (800ce04 <UART_SetConfig+0x2e4>)
 800cdca:	e7ea      	b.n	800cda2 <UART_SetConfig+0x282>
 800cdcc:	cfff69f3 	.word	0xcfff69f3
 800cdd0:	58000c00 	.word	0x58000c00
 800cdd4:	40011000 	.word	0x40011000
 800cdd8:	58024400 	.word	0x58024400
 800cddc:	40004400 	.word	0x40004400
 800cde0:	40004800 	.word	0x40004800
 800cde4:	40004c00 	.word	0x40004c00
 800cde8:	40005000 	.word	0x40005000
 800cdec:	40011400 	.word	0x40011400
 800cdf0:	40007800 	.word	0x40007800
 800cdf4:	40007c00 	.word	0x40007c00
 800cdf8:	0800e43e 	.word	0x0800e43e
 800cdfc:	000ffcff 	.word	0x000ffcff
 800ce00:	03d09000 	.word	0x03d09000
 800ce04:	003d0900 	.word	0x003d0900
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ce08:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800ce0c:	f43f af6e 	beq.w	800ccec <UART_SetConfig+0x1cc>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800ce10:	a803      	add	r0, sp, #12
 800ce12:	f7ff fdaf 	bl	800c974 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800ce16:	9804      	ldr	r0, [sp, #16]
        break;
 800ce18:	e7a5      	b.n	800cd66 <UART_SetConfig+0x246>
 800ce1a:	bf00      	nop

0800ce1c <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800ce1c:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800ce1e:	071a      	lsls	r2, r3, #28
{
 800ce20:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800ce22:	d506      	bpl.n	800ce32 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800ce24:	6801      	ldr	r1, [r0, #0]
 800ce26:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 800ce28:	684a      	ldr	r2, [r1, #4]
 800ce2a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800ce2e:	4322      	orrs	r2, r4
 800ce30:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800ce32:	07dc      	lsls	r4, r3, #31
 800ce34:	d506      	bpl.n	800ce44 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800ce36:	6801      	ldr	r1, [r0, #0]
 800ce38:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 800ce3a:	684a      	ldr	r2, [r1, #4]
 800ce3c:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 800ce40:	4322      	orrs	r2, r4
 800ce42:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800ce44:	0799      	lsls	r1, r3, #30
 800ce46:	d506      	bpl.n	800ce56 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800ce48:	6801      	ldr	r1, [r0, #0]
 800ce4a:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 800ce4c:	684a      	ldr	r2, [r1, #4]
 800ce4e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 800ce52:	4322      	orrs	r2, r4
 800ce54:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800ce56:	075a      	lsls	r2, r3, #29
 800ce58:	d506      	bpl.n	800ce68 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800ce5a:	6801      	ldr	r1, [r0, #0]
 800ce5c:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 800ce5e:	684a      	ldr	r2, [r1, #4]
 800ce60:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800ce64:	4322      	orrs	r2, r4
 800ce66:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800ce68:	06dc      	lsls	r4, r3, #27
 800ce6a:	d506      	bpl.n	800ce7a <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800ce6c:	6801      	ldr	r1, [r0, #0]
 800ce6e:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 800ce70:	688a      	ldr	r2, [r1, #8]
 800ce72:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 800ce76:	4322      	orrs	r2, r4
 800ce78:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800ce7a:	0699      	lsls	r1, r3, #26
 800ce7c:	d506      	bpl.n	800ce8c <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800ce7e:	6801      	ldr	r1, [r0, #0]
 800ce80:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 800ce82:	688a      	ldr	r2, [r1, #8]
 800ce84:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 800ce88:	4322      	orrs	r2, r4
 800ce8a:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800ce8c:	065a      	lsls	r2, r3, #25
 800ce8e:	d510      	bpl.n	800ceb2 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800ce90:	6801      	ldr	r1, [r0, #0]
 800ce92:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 800ce94:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800ce96:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800ce9a:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 800ce9e:	ea42 0204 	orr.w	r2, r2, r4
 800cea2:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800cea4:	d105      	bne.n	800ceb2 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800cea6:	684a      	ldr	r2, [r1, #4]
 800cea8:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 800ceaa:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 800ceae:	4322      	orrs	r2, r4
 800ceb0:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800ceb2:	061b      	lsls	r3, r3, #24
 800ceb4:	d506      	bpl.n	800cec4 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800ceb6:	6802      	ldr	r2, [r0, #0]
 800ceb8:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 800ceba:	6853      	ldr	r3, [r2, #4]
 800cebc:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 800cec0:	430b      	orrs	r3, r1
 800cec2:	6053      	str	r3, [r2, #4]
}
 800cec4:	bd10      	pop	{r4, pc}

0800cec6 <UART_WaitOnFlagUntilTimeout>:
{
 800cec6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ceca:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800cece:	4604      	mov	r4, r0
 800ced0:	460d      	mov	r5, r1
 800ced2:	4617      	mov	r7, r2
 800ced4:	4698      	mov	r8, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ced6:	6822      	ldr	r2, [r4, #0]
 800ced8:	69d3      	ldr	r3, [r2, #28]
 800ceda:	ea35 0303 	bics.w	r3, r5, r3
 800cede:	bf0c      	ite	eq
 800cee0:	2301      	moveq	r3, #1
 800cee2:	2300      	movne	r3, #0
 800cee4:	42bb      	cmp	r3, r7
 800cee6:	d001      	beq.n	800ceec <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 800cee8:	2000      	movs	r0, #0
 800ceea:	e022      	b.n	800cf32 <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
 800ceec:	f1b9 3fff 	cmp.w	r9, #4294967295
 800cef0:	d0f2      	beq.n	800ced8 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800cef2:	f7fe f92b 	bl	800b14c <HAL_GetTick>
 800cef6:	eba0 0008 	sub.w	r0, r0, r8
 800cefa:	4548      	cmp	r0, r9
 800cefc:	d829      	bhi.n	800cf52 <UART_WaitOnFlagUntilTimeout+0x8c>
 800cefe:	f1b9 0f00 	cmp.w	r9, #0
 800cf02:	d026      	beq.n	800cf52 <UART_WaitOnFlagUntilTimeout+0x8c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 800cf04:	6821      	ldr	r1, [r4, #0]
 800cf06:	680b      	ldr	r3, [r1, #0]
 800cf08:	075a      	lsls	r2, r3, #29
 800cf0a:	d5e4      	bpl.n	800ced6 <UART_WaitOnFlagUntilTimeout+0x10>
 800cf0c:	2d80      	cmp	r5, #128	@ 0x80
 800cf0e:	d0e2      	beq.n	800ced6 <UART_WaitOnFlagUntilTimeout+0x10>
 800cf10:	2d40      	cmp	r5, #64	@ 0x40
 800cf12:	d0e0      	beq.n	800ced6 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 800cf14:	69ce      	ldr	r6, [r1, #28]
 800cf16:	f016 0608 	ands.w	r6, r6, #8
 800cf1a:	d00c      	beq.n	800cf36 <UART_WaitOnFlagUntilTimeout+0x70>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800cf1c:	2508      	movs	r5, #8
          UART_EndRxTransfer(huart);
 800cf1e:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800cf20:	620d      	str	r5, [r1, #32]
          UART_EndRxTransfer(huart);
 800cf22:	f7ff fdd1 	bl	800cac8 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
 800cf26:	2300      	movs	r3, #0
          return HAL_ERROR;
 800cf28:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 800cf2a:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
 800cf2e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 800cf32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800cf36:	69cb      	ldr	r3, [r1, #28]
 800cf38:	051b      	lsls	r3, r3, #20
 800cf3a:	d5cc      	bpl.n	800ced6 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800cf3c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
          UART_EndRxTransfer(huart);
 800cf40:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800cf42:	620b      	str	r3, [r1, #32]
          UART_EndRxTransfer(huart);
 800cf44:	f7ff fdc0 	bl	800cac8 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800cf48:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
 800cf4a:	f884 6084 	strb.w	r6, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800cf4e:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
 800cf52:	2003      	movs	r0, #3
 800cf54:	e7ed      	b.n	800cf32 <UART_WaitOnFlagUntilTimeout+0x6c>

0800cf56 <HAL_UART_Transmit>:
{
 800cf56:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800cf5a:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 800cf5c:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 800cf60:	4604      	mov	r4, r0
 800cf62:	460e      	mov	r6, r1
  if (huart->gState == HAL_UART_STATE_READY)
 800cf64:	2b20      	cmp	r3, #32
{
 800cf66:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 800cf68:	d146      	bne.n	800cff8 <HAL_UART_Transmit+0xa2>
    if ((pData == NULL) || (Size == 0U))
 800cf6a:	2900      	cmp	r1, #0
 800cf6c:	d046      	beq.n	800cffc <HAL_UART_Transmit+0xa6>
 800cf6e:	2a00      	cmp	r2, #0
 800cf70:	d044      	beq.n	800cffc <HAL_UART_Transmit+0xa6>
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800cf72:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800cf74:	2500      	movs	r5, #0
 800cf76:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800cf7a:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
 800cf7e:	f7fe f8e5 	bl	800b14c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cf82:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 800cf84:	4681      	mov	r9, r0
    huart->TxXferSize  = Size;
 800cf86:	f8a4 7054 	strh.w	r7, [r4, #84]	@ 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cf8a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
 800cf8e:	f8a4 7056 	strh.w	r7, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cf92:	d103      	bne.n	800cf9c <HAL_UART_Transmit+0x46>
 800cf94:	6923      	ldr	r3, [r4, #16]
 800cf96:	b90b      	cbnz	r3, 800cf9c <HAL_UART_Transmit+0x46>
      pdata16bits = (const uint16_t *) pData;
 800cf98:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 800cf9a:	461e      	mov	r6, r3
    while (huart->TxXferCount > 0U)
 800cf9c:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800cfa0:	464b      	mov	r3, r9
 800cfa2:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 800cfa6:	b292      	uxth	r2, r2
 800cfa8:	b942      	cbnz	r2, 800cfbc <HAL_UART_Transmit+0x66>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800cfaa:	2140      	movs	r1, #64	@ 0x40
 800cfac:	4620      	mov	r0, r4
 800cfae:	f7ff ff8a 	bl	800cec6 <UART_WaitOnFlagUntilTimeout>
 800cfb2:	2320      	movs	r3, #32
 800cfb4:	b948      	cbnz	r0, 800cfca <HAL_UART_Transmit+0x74>
    huart->gState = HAL_UART_STATE_READY;
 800cfb6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
 800cfba:	e009      	b.n	800cfd0 <HAL_UART_Transmit+0x7a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800cfbc:	2200      	movs	r2, #0
 800cfbe:	2180      	movs	r1, #128	@ 0x80
 800cfc0:	4620      	mov	r0, r4
 800cfc2:	f7ff ff80 	bl	800cec6 <UART_WaitOnFlagUntilTimeout>
 800cfc6:	b130      	cbz	r0, 800cfd6 <HAL_UART_Transmit+0x80>
        huart->gState = HAL_UART_STATE_READY;
 800cfc8:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 800cfca:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 800cfcc:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
 800cfd0:	b003      	add	sp, #12
 800cfd2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800cfd6:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 800cfd8:	b95e      	cbnz	r6, 800cff2 <HAL_UART_Transmit+0x9c>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800cfda:	f835 3b02 	ldrh.w	r3, [r5], #2
 800cfde:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800cfe2:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 800cfe4:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
 800cfe8:	3a01      	subs	r2, #1
 800cfea:	b292      	uxth	r2, r2
 800cfec:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
 800cff0:	e7d4      	b.n	800cf9c <HAL_UART_Transmit+0x46>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800cff2:	f816 3b01 	ldrb.w	r3, [r6], #1
 800cff6:	e7f4      	b.n	800cfe2 <HAL_UART_Transmit+0x8c>
    return HAL_BUSY;
 800cff8:	2002      	movs	r0, #2
 800cffa:	e7e9      	b.n	800cfd0 <HAL_UART_Transmit+0x7a>
      return  HAL_ERROR;
 800cffc:	2001      	movs	r0, #1
 800cffe:	e7e7      	b.n	800cfd0 <HAL_UART_Transmit+0x7a>

0800d000 <HAL_UART_Receive>:
{
 800d000:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800d004:	4698      	mov	r8, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 800d006:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
 800d00a:	4604      	mov	r4, r0
 800d00c:	460f      	mov	r7, r1
  if (huart->RxState == HAL_UART_STATE_READY)
 800d00e:	2b20      	cmp	r3, #32
{
 800d010:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 800d012:	d15c      	bne.n	800d0ce <HAL_UART_Receive+0xce>
    if ((pData == NULL) || (Size == 0U))
 800d014:	2900      	cmp	r1, #0
 800d016:	d05c      	beq.n	800d0d2 <HAL_UART_Receive+0xd2>
 800d018:	2a00      	cmp	r2, #0
 800d01a:	d05a      	beq.n	800d0d2 <HAL_UART_Receive+0xd2>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800d01c:	2322      	movs	r3, #34	@ 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d01e:	2500      	movs	r5, #0
 800d020:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800d024:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d028:	66c5      	str	r5, [r0, #108]	@ 0x6c
    tickstart = HAL_GetTick();
 800d02a:	f7fe f88f 	bl	800b14c <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 800d02e:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 800d030:	4681      	mov	r9, r0
    huart->RxXferSize  = Size;
 800d032:	f8a4 605c 	strh.w	r6, [r4, #92]	@ 0x5c
    UART_MASK_COMPUTATION(huart);
 800d036:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->RxXferCount = Size;
 800d03a:	f8a4 605e 	strh.w	r6, [r4, #94]	@ 0x5e
    UART_MASK_COMPUTATION(huart);
 800d03e:	d10d      	bne.n	800d05c <HAL_UART_Receive+0x5c>
 800d040:	6923      	ldr	r3, [r4, #16]
 800d042:	b1db      	cbz	r3, 800d07c <HAL_UART_Receive+0x7c>
 800d044:	22ff      	movs	r2, #255	@ 0xff
    uhMask = huart->Mask;
 800d046:	4616      	mov	r6, r2
    UART_MASK_COMPUTATION(huart);
 800d048:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
    while (huart->RxXferCount > 0U)
 800d04c:	f8b4 005e 	ldrh.w	r0, [r4, #94]	@ 0x5e
 800d050:	b280      	uxth	r0, r0
 800d052:	b9e0      	cbnz	r0, 800d08e <HAL_UART_Receive+0x8e>
    huart->RxState = HAL_UART_STATE_READY;
 800d054:	2320      	movs	r3, #32
 800d056:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    return HAL_OK;
 800d05a:	e025      	b.n	800d0a8 <HAL_UART_Receive+0xa8>
    UART_MASK_COMPUTATION(huart);
 800d05c:	b933      	cbnz	r3, 800d06c <HAL_UART_Receive+0x6c>
 800d05e:	6925      	ldr	r5, [r4, #16]
 800d060:	2d00      	cmp	r5, #0
 800d062:	d0ef      	beq.n	800d044 <HAL_UART_Receive+0x44>
 800d064:	227f      	movs	r2, #127	@ 0x7f
      pdata16bits = NULL;
 800d066:	461d      	mov	r5, r3
    uhMask = huart->Mask;
 800d068:	4616      	mov	r6, r2
 800d06a:	e7ed      	b.n	800d048 <HAL_UART_Receive+0x48>
    UART_MASK_COMPUTATION(huart);
 800d06c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800d070:	d10a      	bne.n	800d088 <HAL_UART_Receive+0x88>
 800d072:	6923      	ldr	r3, [r4, #16]
 800d074:	2b00      	cmp	r3, #0
 800d076:	d0f5      	beq.n	800d064 <HAL_UART_Receive+0x64>
 800d078:	223f      	movs	r2, #63	@ 0x3f
 800d07a:	e7e4      	b.n	800d046 <HAL_UART_Receive+0x46>
 800d07c:	f240 12ff 	movw	r2, #511	@ 0x1ff
      pdata16bits = (uint16_t *) pData;
 800d080:	463d      	mov	r5, r7
      pdata8bits  = NULL;
 800d082:	461f      	mov	r7, r3
    uhMask = huart->Mask;
 800d084:	4616      	mov	r6, r2
 800d086:	e7df      	b.n	800d048 <HAL_UART_Receive+0x48>
 800d088:	462a      	mov	r2, r5
 800d08a:	462e      	mov	r6, r5
 800d08c:	e7dc      	b.n	800d048 <HAL_UART_Receive+0x48>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 800d08e:	464b      	mov	r3, r9
 800d090:	2200      	movs	r2, #0
 800d092:	2120      	movs	r1, #32
 800d094:	4620      	mov	r0, r4
 800d096:	f8cd 8000 	str.w	r8, [sp]
 800d09a:	f7ff ff14 	bl	800cec6 <UART_WaitOnFlagUntilTimeout>
 800d09e:	b130      	cbz	r0, 800d0ae <HAL_UART_Receive+0xae>
        huart->RxState = HAL_UART_STATE_READY;
 800d0a0:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 800d0a2:	2003      	movs	r0, #3
        huart->RxState = HAL_UART_STATE_READY;
 800d0a4:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
 800d0a8:	b003      	add	sp, #12
 800d0aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800d0ae:	6823      	ldr	r3, [r4, #0]
 800d0b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d0b2:	4033      	ands	r3, r6
      if (pdata8bits == NULL)
 800d0b4:	b947      	cbnz	r7, 800d0c8 <HAL_UART_Receive+0xc8>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800d0b6:	f825 3b02 	strh.w	r3, [r5], #2
      huart->RxXferCount--;
 800d0ba:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 800d0be:	3b01      	subs	r3, #1
 800d0c0:	b29b      	uxth	r3, r3
 800d0c2:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
 800d0c6:	e7c1      	b.n	800d04c <HAL_UART_Receive+0x4c>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 800d0c8:	f807 3b01 	strb.w	r3, [r7], #1
        pdata8bits++;
 800d0cc:	e7f5      	b.n	800d0ba <HAL_UART_Receive+0xba>
    return HAL_BUSY;
 800d0ce:	2002      	movs	r0, #2
 800d0d0:	e7ea      	b.n	800d0a8 <HAL_UART_Receive+0xa8>
      return  HAL_ERROR;
 800d0d2:	2001      	movs	r0, #1
 800d0d4:	e7e8      	b.n	800d0a8 <HAL_UART_Receive+0xa8>

0800d0d6 <UART_CheckIdleState>:
{
 800d0d6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d0d8:	2600      	movs	r6, #0
{
 800d0da:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d0dc:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
 800d0e0:	f7fe f834 	bl	800b14c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d0e4:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800d0e6:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d0e8:	681b      	ldr	r3, [r3, #0]
 800d0ea:	071a      	lsls	r2, r3, #28
 800d0ec:	d51c      	bpl.n	800d128 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d0ee:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800d0f2:	4632      	mov	r2, r6
 800d0f4:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 800d0f8:	9300      	str	r3, [sp, #0]
 800d0fa:	4603      	mov	r3, r0
 800d0fc:	4620      	mov	r0, r4
 800d0fe:	f7ff fee2 	bl	800cec6 <UART_WaitOnFlagUntilTimeout>
 800d102:	b188      	cbz	r0, 800d128 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 800d104:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800d106:	e852 3f00 	ldrex	r3, [r2]
 800d10a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800d10e:	e842 3100 	strex	r1, r3, [r2]
 800d112:	2900      	cmp	r1, #0
 800d114:	d1f6      	bne.n	800d104 <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
 800d116:	2320      	movs	r3, #32
 800d118:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 800d11c:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
 800d11e:	2300      	movs	r3, #0
 800d120:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 800d124:	b002      	add	sp, #8
 800d126:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800d128:	6823      	ldr	r3, [r4, #0]
 800d12a:	681b      	ldr	r3, [r3, #0]
 800d12c:	075b      	lsls	r3, r3, #29
 800d12e:	d524      	bpl.n	800d17a <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d130:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800d134:	2200      	movs	r2, #0
 800d136:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 800d13a:	4620      	mov	r0, r4
 800d13c:	9300      	str	r3, [sp, #0]
 800d13e:	462b      	mov	r3, r5
 800d140:	f7ff fec1 	bl	800cec6 <UART_WaitOnFlagUntilTimeout>
 800d144:	b1c8      	cbz	r0, 800d17a <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800d146:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800d148:	e852 3f00 	ldrex	r3, [r2]
 800d14c:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800d150:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 800d154:	6822      	ldr	r2, [r4, #0]
 800d156:	2900      	cmp	r1, #0
 800d158:	d1f5      	bne.n	800d146 <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800d15a:	f102 0308 	add.w	r3, r2, #8
 800d15e:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d162:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800d166:	f102 0008 	add.w	r0, r2, #8
 800d16a:	e840 3100 	strex	r1, r3, [r0]
 800d16e:	2900      	cmp	r1, #0
 800d170:	d1f3      	bne.n	800d15a <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
 800d172:	2320      	movs	r3, #32
 800d174:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
 800d178:	e7d0      	b.n	800d11c <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
 800d17a:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d17c:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 800d17e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 800d182:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d186:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 800d188:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
 800d18a:	e7c8      	b.n	800d11e <UART_CheckIdleState+0x48>

0800d18c <HAL_UART_Init>:
{
 800d18c:	b510      	push	{r4, lr}
  if (huart == NULL)
 800d18e:	4604      	mov	r4, r0
 800d190:	b350      	cbz	r0, 800d1e8 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 800d192:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 800d196:	b91b      	cbnz	r3, 800d1a0 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 800d198:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 800d19c:	f7fb fecc 	bl	8008f38 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 800d1a0:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 800d1a2:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800d1a4:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 800d1a8:	6813      	ldr	r3, [r2, #0]
 800d1aa:	f023 0301 	bic.w	r3, r3, #1
 800d1ae:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800d1b0:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800d1b2:	b113      	cbz	r3, 800d1ba <HAL_UART_Init+0x2e>
    UART_AdvFeatureConfig(huart);
 800d1b4:	4620      	mov	r0, r4
 800d1b6:	f7ff fe31 	bl	800ce1c <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
 800d1ba:	4620      	mov	r0, r4
 800d1bc:	f7ff fcb0 	bl	800cb20 <UART_SetConfig>
 800d1c0:	2801      	cmp	r0, #1
 800d1c2:	d011      	beq.n	800d1e8 <HAL_UART_Init+0x5c>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800d1c4:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 800d1c6:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800d1c8:	685a      	ldr	r2, [r3, #4]
 800d1ca:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 800d1ce:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800d1d0:	689a      	ldr	r2, [r3, #8]
 800d1d2:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 800d1d6:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800d1d8:	681a      	ldr	r2, [r3, #0]
 800d1da:	f042 0201 	orr.w	r2, r2, #1
}
 800d1de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
 800d1e2:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 800d1e4:	f7ff bf77 	b.w	800d0d6 <UART_CheckIdleState>
}
 800d1e8:	2001      	movs	r0, #1
 800d1ea:	bd10      	pop	{r4, pc}

0800d1ec <std>:
 800d1ec:	2300      	movs	r3, #0
 800d1ee:	b510      	push	{r4, lr}
 800d1f0:	4604      	mov	r4, r0
 800d1f2:	e9c0 3300 	strd	r3, r3, [r0]
 800d1f6:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800d1fa:	6083      	str	r3, [r0, #8]
 800d1fc:	8181      	strh	r1, [r0, #12]
 800d1fe:	6643      	str	r3, [r0, #100]	@ 0x64
 800d200:	81c2      	strh	r2, [r0, #14]
 800d202:	6183      	str	r3, [r0, #24]
 800d204:	4619      	mov	r1, r3
 800d206:	2208      	movs	r2, #8
 800d208:	305c      	adds	r0, #92	@ 0x5c
 800d20a:	f000 fabd 	bl	800d788 <memset>
 800d20e:	4b0d      	ldr	r3, [pc, #52]	@ (800d244 <std+0x58>)
 800d210:	6263      	str	r3, [r4, #36]	@ 0x24
 800d212:	4b0d      	ldr	r3, [pc, #52]	@ (800d248 <std+0x5c>)
 800d214:	62a3      	str	r3, [r4, #40]	@ 0x28
 800d216:	4b0d      	ldr	r3, [pc, #52]	@ (800d24c <std+0x60>)
 800d218:	62e3      	str	r3, [r4, #44]	@ 0x2c
 800d21a:	4b0d      	ldr	r3, [pc, #52]	@ (800d250 <std+0x64>)
 800d21c:	6323      	str	r3, [r4, #48]	@ 0x30
 800d21e:	4b0d      	ldr	r3, [pc, #52]	@ (800d254 <std+0x68>)
 800d220:	6224      	str	r4, [r4, #32]
 800d222:	429c      	cmp	r4, r3
 800d224:	d006      	beq.n	800d234 <std+0x48>
 800d226:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 800d22a:	4294      	cmp	r4, r2
 800d22c:	d002      	beq.n	800d234 <std+0x48>
 800d22e:	33d0      	adds	r3, #208	@ 0xd0
 800d230:	429c      	cmp	r4, r3
 800d232:	d105      	bne.n	800d240 <std+0x54>
 800d234:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 800d238:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d23c:	f000 bb1c 	b.w	800d878 <__retarget_lock_init_recursive>
 800d240:	bd10      	pop	{r4, pc}
 800d242:	bf00      	nop
 800d244:	0800d5b9 	.word	0x0800d5b9
 800d248:	0800d5db 	.word	0x0800d5db
 800d24c:	0800d613 	.word	0x0800d613
 800d250:	0800d637 	.word	0x0800d637
 800d254:	20001d7c 	.word	0x20001d7c

0800d258 <stdio_exit_handler>:
 800d258:	4a02      	ldr	r2, [pc, #8]	@ (800d264 <stdio_exit_handler+0xc>)
 800d25a:	4903      	ldr	r1, [pc, #12]	@ (800d268 <stdio_exit_handler+0x10>)
 800d25c:	4803      	ldr	r0, [pc, #12]	@ (800d26c <stdio_exit_handler+0x14>)
 800d25e:	f000 b869 	b.w	800d334 <_fwalk_sglue>
 800d262:	bf00      	nop
 800d264:	2000112c 	.word	0x2000112c
 800d268:	0800e141 	.word	0x0800e141
 800d26c:	2000113c 	.word	0x2000113c

0800d270 <cleanup_stdio>:
 800d270:	6841      	ldr	r1, [r0, #4]
 800d272:	4b0c      	ldr	r3, [pc, #48]	@ (800d2a4 <cleanup_stdio+0x34>)
 800d274:	4299      	cmp	r1, r3
 800d276:	b510      	push	{r4, lr}
 800d278:	4604      	mov	r4, r0
 800d27a:	d001      	beq.n	800d280 <cleanup_stdio+0x10>
 800d27c:	f000 ff60 	bl	800e140 <_fflush_r>
 800d280:	68a1      	ldr	r1, [r4, #8]
 800d282:	4b09      	ldr	r3, [pc, #36]	@ (800d2a8 <cleanup_stdio+0x38>)
 800d284:	4299      	cmp	r1, r3
 800d286:	d002      	beq.n	800d28e <cleanup_stdio+0x1e>
 800d288:	4620      	mov	r0, r4
 800d28a:	f000 ff59 	bl	800e140 <_fflush_r>
 800d28e:	68e1      	ldr	r1, [r4, #12]
 800d290:	4b06      	ldr	r3, [pc, #24]	@ (800d2ac <cleanup_stdio+0x3c>)
 800d292:	4299      	cmp	r1, r3
 800d294:	d004      	beq.n	800d2a0 <cleanup_stdio+0x30>
 800d296:	4620      	mov	r0, r4
 800d298:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d29c:	f000 bf50 	b.w	800e140 <_fflush_r>
 800d2a0:	bd10      	pop	{r4, pc}
 800d2a2:	bf00      	nop
 800d2a4:	20001d7c 	.word	0x20001d7c
 800d2a8:	20001de4 	.word	0x20001de4
 800d2ac:	20001e4c 	.word	0x20001e4c

0800d2b0 <global_stdio_init.part.0>:
 800d2b0:	b510      	push	{r4, lr}
 800d2b2:	4b0b      	ldr	r3, [pc, #44]	@ (800d2e0 <global_stdio_init.part.0+0x30>)
 800d2b4:	4c0b      	ldr	r4, [pc, #44]	@ (800d2e4 <global_stdio_init.part.0+0x34>)
 800d2b6:	4a0c      	ldr	r2, [pc, #48]	@ (800d2e8 <global_stdio_init.part.0+0x38>)
 800d2b8:	601a      	str	r2, [r3, #0]
 800d2ba:	4620      	mov	r0, r4
 800d2bc:	2200      	movs	r2, #0
 800d2be:	2104      	movs	r1, #4
 800d2c0:	f7ff ff94 	bl	800d1ec <std>
 800d2c4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 800d2c8:	2201      	movs	r2, #1
 800d2ca:	2109      	movs	r1, #9
 800d2cc:	f7ff ff8e 	bl	800d1ec <std>
 800d2d0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 800d2d4:	2202      	movs	r2, #2
 800d2d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d2da:	2112      	movs	r1, #18
 800d2dc:	f7ff bf86 	b.w	800d1ec <std>
 800d2e0:	20001eb4 	.word	0x20001eb4
 800d2e4:	20001d7c 	.word	0x20001d7c
 800d2e8:	0800d259 	.word	0x0800d259

0800d2ec <__sfp_lock_acquire>:
 800d2ec:	4801      	ldr	r0, [pc, #4]	@ (800d2f4 <__sfp_lock_acquire+0x8>)
 800d2ee:	f000 bac4 	b.w	800d87a <__retarget_lock_acquire_recursive>
 800d2f2:	bf00      	nop
 800d2f4:	20001ebd 	.word	0x20001ebd

0800d2f8 <__sfp_lock_release>:
 800d2f8:	4801      	ldr	r0, [pc, #4]	@ (800d300 <__sfp_lock_release+0x8>)
 800d2fa:	f000 babf 	b.w	800d87c <__retarget_lock_release_recursive>
 800d2fe:	bf00      	nop
 800d300:	20001ebd 	.word	0x20001ebd

0800d304 <__sinit>:
 800d304:	b510      	push	{r4, lr}
 800d306:	4604      	mov	r4, r0
 800d308:	f7ff fff0 	bl	800d2ec <__sfp_lock_acquire>
 800d30c:	6a23      	ldr	r3, [r4, #32]
 800d30e:	b11b      	cbz	r3, 800d318 <__sinit+0x14>
 800d310:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d314:	f7ff bff0 	b.w	800d2f8 <__sfp_lock_release>
 800d318:	4b04      	ldr	r3, [pc, #16]	@ (800d32c <__sinit+0x28>)
 800d31a:	6223      	str	r3, [r4, #32]
 800d31c:	4b04      	ldr	r3, [pc, #16]	@ (800d330 <__sinit+0x2c>)
 800d31e:	681b      	ldr	r3, [r3, #0]
 800d320:	2b00      	cmp	r3, #0
 800d322:	d1f5      	bne.n	800d310 <__sinit+0xc>
 800d324:	f7ff ffc4 	bl	800d2b0 <global_stdio_init.part.0>
 800d328:	e7f2      	b.n	800d310 <__sinit+0xc>
 800d32a:	bf00      	nop
 800d32c:	0800d271 	.word	0x0800d271
 800d330:	20001eb4 	.word	0x20001eb4

0800d334 <_fwalk_sglue>:
 800d334:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d338:	4607      	mov	r7, r0
 800d33a:	4688      	mov	r8, r1
 800d33c:	4614      	mov	r4, r2
 800d33e:	2600      	movs	r6, #0
 800d340:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 800d344:	f1b9 0901 	subs.w	r9, r9, #1
 800d348:	d505      	bpl.n	800d356 <_fwalk_sglue+0x22>
 800d34a:	6824      	ldr	r4, [r4, #0]
 800d34c:	2c00      	cmp	r4, #0
 800d34e:	d1f7      	bne.n	800d340 <_fwalk_sglue+0xc>
 800d350:	4630      	mov	r0, r6
 800d352:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d356:	89ab      	ldrh	r3, [r5, #12]
 800d358:	2b01      	cmp	r3, #1
 800d35a:	d907      	bls.n	800d36c <_fwalk_sglue+0x38>
 800d35c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800d360:	3301      	adds	r3, #1
 800d362:	d003      	beq.n	800d36c <_fwalk_sglue+0x38>
 800d364:	4629      	mov	r1, r5
 800d366:	4638      	mov	r0, r7
 800d368:	47c0      	blx	r8
 800d36a:	4306      	orrs	r6, r0
 800d36c:	3568      	adds	r5, #104	@ 0x68
 800d36e:	e7e9      	b.n	800d344 <_fwalk_sglue+0x10>

0800d370 <iprintf>:
 800d370:	b40f      	push	{r0, r1, r2, r3}
 800d372:	b507      	push	{r0, r1, r2, lr}
 800d374:	4906      	ldr	r1, [pc, #24]	@ (800d390 <iprintf+0x20>)
 800d376:	ab04      	add	r3, sp, #16
 800d378:	6808      	ldr	r0, [r1, #0]
 800d37a:	f853 2b04 	ldr.w	r2, [r3], #4
 800d37e:	6881      	ldr	r1, [r0, #8]
 800d380:	9301      	str	r3, [sp, #4]
 800d382:	f000 fbb5 	bl	800daf0 <_vfiprintf_r>
 800d386:	b003      	add	sp, #12
 800d388:	f85d eb04 	ldr.w	lr, [sp], #4
 800d38c:	b004      	add	sp, #16
 800d38e:	4770      	bx	lr
 800d390:	20001138 	.word	0x20001138

0800d394 <_puts_r>:
 800d394:	6a03      	ldr	r3, [r0, #32]
 800d396:	b570      	push	{r4, r5, r6, lr}
 800d398:	6884      	ldr	r4, [r0, #8]
 800d39a:	4605      	mov	r5, r0
 800d39c:	460e      	mov	r6, r1
 800d39e:	b90b      	cbnz	r3, 800d3a4 <_puts_r+0x10>
 800d3a0:	f7ff ffb0 	bl	800d304 <__sinit>
 800d3a4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d3a6:	07db      	lsls	r3, r3, #31
 800d3a8:	d405      	bmi.n	800d3b6 <_puts_r+0x22>
 800d3aa:	89a3      	ldrh	r3, [r4, #12]
 800d3ac:	0598      	lsls	r0, r3, #22
 800d3ae:	d402      	bmi.n	800d3b6 <_puts_r+0x22>
 800d3b0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d3b2:	f000 fa62 	bl	800d87a <__retarget_lock_acquire_recursive>
 800d3b6:	89a3      	ldrh	r3, [r4, #12]
 800d3b8:	0719      	lsls	r1, r3, #28
 800d3ba:	d502      	bpl.n	800d3c2 <_puts_r+0x2e>
 800d3bc:	6923      	ldr	r3, [r4, #16]
 800d3be:	2b00      	cmp	r3, #0
 800d3c0:	d135      	bne.n	800d42e <_puts_r+0x9a>
 800d3c2:	4621      	mov	r1, r4
 800d3c4:	4628      	mov	r0, r5
 800d3c6:	f000 f979 	bl	800d6bc <__swsetup_r>
 800d3ca:	b380      	cbz	r0, 800d42e <_puts_r+0x9a>
 800d3cc:	f04f 35ff 	mov.w	r5, #4294967295
 800d3d0:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d3d2:	07da      	lsls	r2, r3, #31
 800d3d4:	d405      	bmi.n	800d3e2 <_puts_r+0x4e>
 800d3d6:	89a3      	ldrh	r3, [r4, #12]
 800d3d8:	059b      	lsls	r3, r3, #22
 800d3da:	d402      	bmi.n	800d3e2 <_puts_r+0x4e>
 800d3dc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d3de:	f000 fa4d 	bl	800d87c <__retarget_lock_release_recursive>
 800d3e2:	4628      	mov	r0, r5
 800d3e4:	bd70      	pop	{r4, r5, r6, pc}
 800d3e6:	2b00      	cmp	r3, #0
 800d3e8:	da04      	bge.n	800d3f4 <_puts_r+0x60>
 800d3ea:	69a2      	ldr	r2, [r4, #24]
 800d3ec:	429a      	cmp	r2, r3
 800d3ee:	dc17      	bgt.n	800d420 <_puts_r+0x8c>
 800d3f0:	290a      	cmp	r1, #10
 800d3f2:	d015      	beq.n	800d420 <_puts_r+0x8c>
 800d3f4:	6823      	ldr	r3, [r4, #0]
 800d3f6:	1c5a      	adds	r2, r3, #1
 800d3f8:	6022      	str	r2, [r4, #0]
 800d3fa:	7019      	strb	r1, [r3, #0]
 800d3fc:	68a3      	ldr	r3, [r4, #8]
 800d3fe:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800d402:	3b01      	subs	r3, #1
 800d404:	60a3      	str	r3, [r4, #8]
 800d406:	2900      	cmp	r1, #0
 800d408:	d1ed      	bne.n	800d3e6 <_puts_r+0x52>
 800d40a:	2b00      	cmp	r3, #0
 800d40c:	da11      	bge.n	800d432 <_puts_r+0x9e>
 800d40e:	4622      	mov	r2, r4
 800d410:	210a      	movs	r1, #10
 800d412:	4628      	mov	r0, r5
 800d414:	f000 f913 	bl	800d63e <__swbuf_r>
 800d418:	3001      	adds	r0, #1
 800d41a:	d0d7      	beq.n	800d3cc <_puts_r+0x38>
 800d41c:	250a      	movs	r5, #10
 800d41e:	e7d7      	b.n	800d3d0 <_puts_r+0x3c>
 800d420:	4622      	mov	r2, r4
 800d422:	4628      	mov	r0, r5
 800d424:	f000 f90b 	bl	800d63e <__swbuf_r>
 800d428:	3001      	adds	r0, #1
 800d42a:	d1e7      	bne.n	800d3fc <_puts_r+0x68>
 800d42c:	e7ce      	b.n	800d3cc <_puts_r+0x38>
 800d42e:	3e01      	subs	r6, #1
 800d430:	e7e4      	b.n	800d3fc <_puts_r+0x68>
 800d432:	6823      	ldr	r3, [r4, #0]
 800d434:	1c5a      	adds	r2, r3, #1
 800d436:	6022      	str	r2, [r4, #0]
 800d438:	220a      	movs	r2, #10
 800d43a:	701a      	strb	r2, [r3, #0]
 800d43c:	e7ee      	b.n	800d41c <_puts_r+0x88>
	...

0800d440 <puts>:
 800d440:	4b02      	ldr	r3, [pc, #8]	@ (800d44c <puts+0xc>)
 800d442:	4601      	mov	r1, r0
 800d444:	6818      	ldr	r0, [r3, #0]
 800d446:	f7ff bfa5 	b.w	800d394 <_puts_r>
 800d44a:	bf00      	nop
 800d44c:	20001138 	.word	0x20001138

0800d450 <setvbuf>:
 800d450:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800d454:	461d      	mov	r5, r3
 800d456:	4b57      	ldr	r3, [pc, #348]	@ (800d5b4 <setvbuf+0x164>)
 800d458:	681f      	ldr	r7, [r3, #0]
 800d45a:	4604      	mov	r4, r0
 800d45c:	460e      	mov	r6, r1
 800d45e:	4690      	mov	r8, r2
 800d460:	b127      	cbz	r7, 800d46c <setvbuf+0x1c>
 800d462:	6a3b      	ldr	r3, [r7, #32]
 800d464:	b913      	cbnz	r3, 800d46c <setvbuf+0x1c>
 800d466:	4638      	mov	r0, r7
 800d468:	f7ff ff4c 	bl	800d304 <__sinit>
 800d46c:	f1b8 0f02 	cmp.w	r8, #2
 800d470:	d006      	beq.n	800d480 <setvbuf+0x30>
 800d472:	f1b8 0f01 	cmp.w	r8, #1
 800d476:	f200 809a 	bhi.w	800d5ae <setvbuf+0x15e>
 800d47a:	2d00      	cmp	r5, #0
 800d47c:	f2c0 8097 	blt.w	800d5ae <setvbuf+0x15e>
 800d480:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d482:	07d9      	lsls	r1, r3, #31
 800d484:	d405      	bmi.n	800d492 <setvbuf+0x42>
 800d486:	89a3      	ldrh	r3, [r4, #12]
 800d488:	059a      	lsls	r2, r3, #22
 800d48a:	d402      	bmi.n	800d492 <setvbuf+0x42>
 800d48c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d48e:	f000 f9f4 	bl	800d87a <__retarget_lock_acquire_recursive>
 800d492:	4621      	mov	r1, r4
 800d494:	4638      	mov	r0, r7
 800d496:	f000 fe53 	bl	800e140 <_fflush_r>
 800d49a:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800d49c:	b141      	cbz	r1, 800d4b0 <setvbuf+0x60>
 800d49e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800d4a2:	4299      	cmp	r1, r3
 800d4a4:	d002      	beq.n	800d4ac <setvbuf+0x5c>
 800d4a6:	4638      	mov	r0, r7
 800d4a8:	f000 f9f8 	bl	800d89c <_free_r>
 800d4ac:	2300      	movs	r3, #0
 800d4ae:	6363      	str	r3, [r4, #52]	@ 0x34
 800d4b0:	2300      	movs	r3, #0
 800d4b2:	61a3      	str	r3, [r4, #24]
 800d4b4:	6063      	str	r3, [r4, #4]
 800d4b6:	89a3      	ldrh	r3, [r4, #12]
 800d4b8:	061b      	lsls	r3, r3, #24
 800d4ba:	d503      	bpl.n	800d4c4 <setvbuf+0x74>
 800d4bc:	6921      	ldr	r1, [r4, #16]
 800d4be:	4638      	mov	r0, r7
 800d4c0:	f000 f9ec 	bl	800d89c <_free_r>
 800d4c4:	89a3      	ldrh	r3, [r4, #12]
 800d4c6:	f423 634a 	bic.w	r3, r3, #3232	@ 0xca0
 800d4ca:	f023 0303 	bic.w	r3, r3, #3
 800d4ce:	f1b8 0f02 	cmp.w	r8, #2
 800d4d2:	81a3      	strh	r3, [r4, #12]
 800d4d4:	d061      	beq.n	800d59a <setvbuf+0x14a>
 800d4d6:	ab01      	add	r3, sp, #4
 800d4d8:	466a      	mov	r2, sp
 800d4da:	4621      	mov	r1, r4
 800d4dc:	4638      	mov	r0, r7
 800d4de:	f000 fe57 	bl	800e190 <__swhatbuf_r>
 800d4e2:	89a3      	ldrh	r3, [r4, #12]
 800d4e4:	4318      	orrs	r0, r3
 800d4e6:	81a0      	strh	r0, [r4, #12]
 800d4e8:	bb2d      	cbnz	r5, 800d536 <setvbuf+0xe6>
 800d4ea:	9d00      	ldr	r5, [sp, #0]
 800d4ec:	4628      	mov	r0, r5
 800d4ee:	f000 fa1f 	bl	800d930 <malloc>
 800d4f2:	4606      	mov	r6, r0
 800d4f4:	2800      	cmp	r0, #0
 800d4f6:	d152      	bne.n	800d59e <setvbuf+0x14e>
 800d4f8:	f8dd 9000 	ldr.w	r9, [sp]
 800d4fc:	45a9      	cmp	r9, r5
 800d4fe:	d140      	bne.n	800d582 <setvbuf+0x132>
 800d500:	f04f 35ff 	mov.w	r5, #4294967295
 800d504:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d508:	f043 0202 	orr.w	r2, r3, #2
 800d50c:	81a2      	strh	r2, [r4, #12]
 800d50e:	2200      	movs	r2, #0
 800d510:	60a2      	str	r2, [r4, #8]
 800d512:	f104 0247 	add.w	r2, r4, #71	@ 0x47
 800d516:	6022      	str	r2, [r4, #0]
 800d518:	6122      	str	r2, [r4, #16]
 800d51a:	2201      	movs	r2, #1
 800d51c:	6162      	str	r2, [r4, #20]
 800d51e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800d520:	07d6      	lsls	r6, r2, #31
 800d522:	d404      	bmi.n	800d52e <setvbuf+0xde>
 800d524:	0598      	lsls	r0, r3, #22
 800d526:	d402      	bmi.n	800d52e <setvbuf+0xde>
 800d528:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d52a:	f000 f9a7 	bl	800d87c <__retarget_lock_release_recursive>
 800d52e:	4628      	mov	r0, r5
 800d530:	b003      	add	sp, #12
 800d532:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d536:	2e00      	cmp	r6, #0
 800d538:	d0d8      	beq.n	800d4ec <setvbuf+0x9c>
 800d53a:	6a3b      	ldr	r3, [r7, #32]
 800d53c:	b913      	cbnz	r3, 800d544 <setvbuf+0xf4>
 800d53e:	4638      	mov	r0, r7
 800d540:	f7ff fee0 	bl	800d304 <__sinit>
 800d544:	f1b8 0f01 	cmp.w	r8, #1
 800d548:	bf08      	it	eq
 800d54a:	89a3      	ldrheq	r3, [r4, #12]
 800d54c:	6026      	str	r6, [r4, #0]
 800d54e:	bf04      	itt	eq
 800d550:	f043 0301 	orreq.w	r3, r3, #1
 800d554:	81a3      	strheq	r3, [r4, #12]
 800d556:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d55a:	f013 0208 	ands.w	r2, r3, #8
 800d55e:	e9c4 6504 	strd	r6, r5, [r4, #16]
 800d562:	d01e      	beq.n	800d5a2 <setvbuf+0x152>
 800d564:	07d9      	lsls	r1, r3, #31
 800d566:	bf41      	itttt	mi
 800d568:	2200      	movmi	r2, #0
 800d56a:	426d      	negmi	r5, r5
 800d56c:	60a2      	strmi	r2, [r4, #8]
 800d56e:	61a5      	strmi	r5, [r4, #24]
 800d570:	bf58      	it	pl
 800d572:	60a5      	strpl	r5, [r4, #8]
 800d574:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800d576:	07d2      	lsls	r2, r2, #31
 800d578:	d401      	bmi.n	800d57e <setvbuf+0x12e>
 800d57a:	059b      	lsls	r3, r3, #22
 800d57c:	d513      	bpl.n	800d5a6 <setvbuf+0x156>
 800d57e:	2500      	movs	r5, #0
 800d580:	e7d5      	b.n	800d52e <setvbuf+0xde>
 800d582:	4648      	mov	r0, r9
 800d584:	f000 f9d4 	bl	800d930 <malloc>
 800d588:	4606      	mov	r6, r0
 800d58a:	2800      	cmp	r0, #0
 800d58c:	d0b8      	beq.n	800d500 <setvbuf+0xb0>
 800d58e:	89a3      	ldrh	r3, [r4, #12]
 800d590:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800d594:	81a3      	strh	r3, [r4, #12]
 800d596:	464d      	mov	r5, r9
 800d598:	e7cf      	b.n	800d53a <setvbuf+0xea>
 800d59a:	2500      	movs	r5, #0
 800d59c:	e7b2      	b.n	800d504 <setvbuf+0xb4>
 800d59e:	46a9      	mov	r9, r5
 800d5a0:	e7f5      	b.n	800d58e <setvbuf+0x13e>
 800d5a2:	60a2      	str	r2, [r4, #8]
 800d5a4:	e7e6      	b.n	800d574 <setvbuf+0x124>
 800d5a6:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800d5a8:	f000 f968 	bl	800d87c <__retarget_lock_release_recursive>
 800d5ac:	e7e7      	b.n	800d57e <setvbuf+0x12e>
 800d5ae:	f04f 35ff 	mov.w	r5, #4294967295
 800d5b2:	e7bc      	b.n	800d52e <setvbuf+0xde>
 800d5b4:	20001138 	.word	0x20001138

0800d5b8 <__sread>:
 800d5b8:	b510      	push	{r4, lr}
 800d5ba:	460c      	mov	r4, r1
 800d5bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d5c0:	f000 f90c 	bl	800d7dc <_read_r>
 800d5c4:	2800      	cmp	r0, #0
 800d5c6:	bfab      	itete	ge
 800d5c8:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 800d5ca:	89a3      	ldrhlt	r3, [r4, #12]
 800d5cc:	181b      	addge	r3, r3, r0
 800d5ce:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 800d5d2:	bfac      	ite	ge
 800d5d4:	6563      	strge	r3, [r4, #84]	@ 0x54
 800d5d6:	81a3      	strhlt	r3, [r4, #12]
 800d5d8:	bd10      	pop	{r4, pc}

0800d5da <__swrite>:
 800d5da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d5de:	461f      	mov	r7, r3
 800d5e0:	898b      	ldrh	r3, [r1, #12]
 800d5e2:	05db      	lsls	r3, r3, #23
 800d5e4:	4605      	mov	r5, r0
 800d5e6:	460c      	mov	r4, r1
 800d5e8:	4616      	mov	r6, r2
 800d5ea:	d505      	bpl.n	800d5f8 <__swrite+0x1e>
 800d5ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d5f0:	2302      	movs	r3, #2
 800d5f2:	2200      	movs	r2, #0
 800d5f4:	f000 f8e0 	bl	800d7b8 <_lseek_r>
 800d5f8:	89a3      	ldrh	r3, [r4, #12]
 800d5fa:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800d5fe:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800d602:	81a3      	strh	r3, [r4, #12]
 800d604:	4632      	mov	r2, r6
 800d606:	463b      	mov	r3, r7
 800d608:	4628      	mov	r0, r5
 800d60a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800d60e:	f000 b8f7 	b.w	800d800 <_write_r>

0800d612 <__sseek>:
 800d612:	b510      	push	{r4, lr}
 800d614:	460c      	mov	r4, r1
 800d616:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d61a:	f000 f8cd 	bl	800d7b8 <_lseek_r>
 800d61e:	1c43      	adds	r3, r0, #1
 800d620:	89a3      	ldrh	r3, [r4, #12]
 800d622:	bf15      	itete	ne
 800d624:	6560      	strne	r0, [r4, #84]	@ 0x54
 800d626:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 800d62a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 800d62e:	81a3      	strheq	r3, [r4, #12]
 800d630:	bf18      	it	ne
 800d632:	81a3      	strhne	r3, [r4, #12]
 800d634:	bd10      	pop	{r4, pc}

0800d636 <__sclose>:
 800d636:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d63a:	f000 b8ad 	b.w	800d798 <_close_r>

0800d63e <__swbuf_r>:
 800d63e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d640:	460e      	mov	r6, r1
 800d642:	4614      	mov	r4, r2
 800d644:	4605      	mov	r5, r0
 800d646:	b118      	cbz	r0, 800d650 <__swbuf_r+0x12>
 800d648:	6a03      	ldr	r3, [r0, #32]
 800d64a:	b90b      	cbnz	r3, 800d650 <__swbuf_r+0x12>
 800d64c:	f7ff fe5a 	bl	800d304 <__sinit>
 800d650:	69a3      	ldr	r3, [r4, #24]
 800d652:	60a3      	str	r3, [r4, #8]
 800d654:	89a3      	ldrh	r3, [r4, #12]
 800d656:	071a      	lsls	r2, r3, #28
 800d658:	d501      	bpl.n	800d65e <__swbuf_r+0x20>
 800d65a:	6923      	ldr	r3, [r4, #16]
 800d65c:	b943      	cbnz	r3, 800d670 <__swbuf_r+0x32>
 800d65e:	4621      	mov	r1, r4
 800d660:	4628      	mov	r0, r5
 800d662:	f000 f82b 	bl	800d6bc <__swsetup_r>
 800d666:	b118      	cbz	r0, 800d670 <__swbuf_r+0x32>
 800d668:	f04f 37ff 	mov.w	r7, #4294967295
 800d66c:	4638      	mov	r0, r7
 800d66e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d670:	6823      	ldr	r3, [r4, #0]
 800d672:	6922      	ldr	r2, [r4, #16]
 800d674:	1a98      	subs	r0, r3, r2
 800d676:	6963      	ldr	r3, [r4, #20]
 800d678:	b2f6      	uxtb	r6, r6
 800d67a:	4283      	cmp	r3, r0
 800d67c:	4637      	mov	r7, r6
 800d67e:	dc05      	bgt.n	800d68c <__swbuf_r+0x4e>
 800d680:	4621      	mov	r1, r4
 800d682:	4628      	mov	r0, r5
 800d684:	f000 fd5c 	bl	800e140 <_fflush_r>
 800d688:	2800      	cmp	r0, #0
 800d68a:	d1ed      	bne.n	800d668 <__swbuf_r+0x2a>
 800d68c:	68a3      	ldr	r3, [r4, #8]
 800d68e:	3b01      	subs	r3, #1
 800d690:	60a3      	str	r3, [r4, #8]
 800d692:	6823      	ldr	r3, [r4, #0]
 800d694:	1c5a      	adds	r2, r3, #1
 800d696:	6022      	str	r2, [r4, #0]
 800d698:	701e      	strb	r6, [r3, #0]
 800d69a:	6962      	ldr	r2, [r4, #20]
 800d69c:	1c43      	adds	r3, r0, #1
 800d69e:	429a      	cmp	r2, r3
 800d6a0:	d004      	beq.n	800d6ac <__swbuf_r+0x6e>
 800d6a2:	89a3      	ldrh	r3, [r4, #12]
 800d6a4:	07db      	lsls	r3, r3, #31
 800d6a6:	d5e1      	bpl.n	800d66c <__swbuf_r+0x2e>
 800d6a8:	2e0a      	cmp	r6, #10
 800d6aa:	d1df      	bne.n	800d66c <__swbuf_r+0x2e>
 800d6ac:	4621      	mov	r1, r4
 800d6ae:	4628      	mov	r0, r5
 800d6b0:	f000 fd46 	bl	800e140 <_fflush_r>
 800d6b4:	2800      	cmp	r0, #0
 800d6b6:	d0d9      	beq.n	800d66c <__swbuf_r+0x2e>
 800d6b8:	e7d6      	b.n	800d668 <__swbuf_r+0x2a>
	...

0800d6bc <__swsetup_r>:
 800d6bc:	b538      	push	{r3, r4, r5, lr}
 800d6be:	4b29      	ldr	r3, [pc, #164]	@ (800d764 <__swsetup_r+0xa8>)
 800d6c0:	4605      	mov	r5, r0
 800d6c2:	6818      	ldr	r0, [r3, #0]
 800d6c4:	460c      	mov	r4, r1
 800d6c6:	b118      	cbz	r0, 800d6d0 <__swsetup_r+0x14>
 800d6c8:	6a03      	ldr	r3, [r0, #32]
 800d6ca:	b90b      	cbnz	r3, 800d6d0 <__swsetup_r+0x14>
 800d6cc:	f7ff fe1a 	bl	800d304 <__sinit>
 800d6d0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d6d4:	0719      	lsls	r1, r3, #28
 800d6d6:	d422      	bmi.n	800d71e <__swsetup_r+0x62>
 800d6d8:	06da      	lsls	r2, r3, #27
 800d6da:	d407      	bmi.n	800d6ec <__swsetup_r+0x30>
 800d6dc:	2209      	movs	r2, #9
 800d6de:	602a      	str	r2, [r5, #0]
 800d6e0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800d6e4:	81a3      	strh	r3, [r4, #12]
 800d6e6:	f04f 30ff 	mov.w	r0, #4294967295
 800d6ea:	e033      	b.n	800d754 <__swsetup_r+0x98>
 800d6ec:	0758      	lsls	r0, r3, #29
 800d6ee:	d512      	bpl.n	800d716 <__swsetup_r+0x5a>
 800d6f0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800d6f2:	b141      	cbz	r1, 800d706 <__swsetup_r+0x4a>
 800d6f4:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800d6f8:	4299      	cmp	r1, r3
 800d6fa:	d002      	beq.n	800d702 <__swsetup_r+0x46>
 800d6fc:	4628      	mov	r0, r5
 800d6fe:	f000 f8cd 	bl	800d89c <_free_r>
 800d702:	2300      	movs	r3, #0
 800d704:	6363      	str	r3, [r4, #52]	@ 0x34
 800d706:	89a3      	ldrh	r3, [r4, #12]
 800d708:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 800d70c:	81a3      	strh	r3, [r4, #12]
 800d70e:	2300      	movs	r3, #0
 800d710:	6063      	str	r3, [r4, #4]
 800d712:	6923      	ldr	r3, [r4, #16]
 800d714:	6023      	str	r3, [r4, #0]
 800d716:	89a3      	ldrh	r3, [r4, #12]
 800d718:	f043 0308 	orr.w	r3, r3, #8
 800d71c:	81a3      	strh	r3, [r4, #12]
 800d71e:	6923      	ldr	r3, [r4, #16]
 800d720:	b94b      	cbnz	r3, 800d736 <__swsetup_r+0x7a>
 800d722:	89a3      	ldrh	r3, [r4, #12]
 800d724:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 800d728:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d72c:	d003      	beq.n	800d736 <__swsetup_r+0x7a>
 800d72e:	4621      	mov	r1, r4
 800d730:	4628      	mov	r0, r5
 800d732:	f000 fd53 	bl	800e1dc <__smakebuf_r>
 800d736:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d73a:	f013 0201 	ands.w	r2, r3, #1
 800d73e:	d00a      	beq.n	800d756 <__swsetup_r+0x9a>
 800d740:	2200      	movs	r2, #0
 800d742:	60a2      	str	r2, [r4, #8]
 800d744:	6962      	ldr	r2, [r4, #20]
 800d746:	4252      	negs	r2, r2
 800d748:	61a2      	str	r2, [r4, #24]
 800d74a:	6922      	ldr	r2, [r4, #16]
 800d74c:	b942      	cbnz	r2, 800d760 <__swsetup_r+0xa4>
 800d74e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 800d752:	d1c5      	bne.n	800d6e0 <__swsetup_r+0x24>
 800d754:	bd38      	pop	{r3, r4, r5, pc}
 800d756:	0799      	lsls	r1, r3, #30
 800d758:	bf58      	it	pl
 800d75a:	6962      	ldrpl	r2, [r4, #20]
 800d75c:	60a2      	str	r2, [r4, #8]
 800d75e:	e7f4      	b.n	800d74a <__swsetup_r+0x8e>
 800d760:	2000      	movs	r0, #0
 800d762:	e7f7      	b.n	800d754 <__swsetup_r+0x98>
 800d764:	20001138 	.word	0x20001138

0800d768 <memcmp>:
 800d768:	b510      	push	{r4, lr}
 800d76a:	3901      	subs	r1, #1
 800d76c:	4402      	add	r2, r0
 800d76e:	4290      	cmp	r0, r2
 800d770:	d101      	bne.n	800d776 <memcmp+0xe>
 800d772:	2000      	movs	r0, #0
 800d774:	e005      	b.n	800d782 <memcmp+0x1a>
 800d776:	7803      	ldrb	r3, [r0, #0]
 800d778:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800d77c:	42a3      	cmp	r3, r4
 800d77e:	d001      	beq.n	800d784 <memcmp+0x1c>
 800d780:	1b18      	subs	r0, r3, r4
 800d782:	bd10      	pop	{r4, pc}
 800d784:	3001      	adds	r0, #1
 800d786:	e7f2      	b.n	800d76e <memcmp+0x6>

0800d788 <memset>:
 800d788:	4402      	add	r2, r0
 800d78a:	4603      	mov	r3, r0
 800d78c:	4293      	cmp	r3, r2
 800d78e:	d100      	bne.n	800d792 <memset+0xa>
 800d790:	4770      	bx	lr
 800d792:	f803 1b01 	strb.w	r1, [r3], #1
 800d796:	e7f9      	b.n	800d78c <memset+0x4>

0800d798 <_close_r>:
 800d798:	b538      	push	{r3, r4, r5, lr}
 800d79a:	4d06      	ldr	r5, [pc, #24]	@ (800d7b4 <_close_r+0x1c>)
 800d79c:	2300      	movs	r3, #0
 800d79e:	4604      	mov	r4, r0
 800d7a0:	4608      	mov	r0, r1
 800d7a2:	602b      	str	r3, [r5, #0]
 800d7a4:	f7fb fc06 	bl	8008fb4 <_close>
 800d7a8:	1c43      	adds	r3, r0, #1
 800d7aa:	d102      	bne.n	800d7b2 <_close_r+0x1a>
 800d7ac:	682b      	ldr	r3, [r5, #0]
 800d7ae:	b103      	cbz	r3, 800d7b2 <_close_r+0x1a>
 800d7b0:	6023      	str	r3, [r4, #0]
 800d7b2:	bd38      	pop	{r3, r4, r5, pc}
 800d7b4:	20001eb8 	.word	0x20001eb8

0800d7b8 <_lseek_r>:
 800d7b8:	b538      	push	{r3, r4, r5, lr}
 800d7ba:	4d07      	ldr	r5, [pc, #28]	@ (800d7d8 <_lseek_r+0x20>)
 800d7bc:	4604      	mov	r4, r0
 800d7be:	4608      	mov	r0, r1
 800d7c0:	4611      	mov	r1, r2
 800d7c2:	2200      	movs	r2, #0
 800d7c4:	602a      	str	r2, [r5, #0]
 800d7c6:	461a      	mov	r2, r3
 800d7c8:	f7fb fbfe 	bl	8008fc8 <_lseek>
 800d7cc:	1c43      	adds	r3, r0, #1
 800d7ce:	d102      	bne.n	800d7d6 <_lseek_r+0x1e>
 800d7d0:	682b      	ldr	r3, [r5, #0]
 800d7d2:	b103      	cbz	r3, 800d7d6 <_lseek_r+0x1e>
 800d7d4:	6023      	str	r3, [r4, #0]
 800d7d6:	bd38      	pop	{r3, r4, r5, pc}
 800d7d8:	20001eb8 	.word	0x20001eb8

0800d7dc <_read_r>:
 800d7dc:	b538      	push	{r3, r4, r5, lr}
 800d7de:	4d07      	ldr	r5, [pc, #28]	@ (800d7fc <_read_r+0x20>)
 800d7e0:	4604      	mov	r4, r0
 800d7e2:	4608      	mov	r0, r1
 800d7e4:	4611      	mov	r1, r2
 800d7e6:	2200      	movs	r2, #0
 800d7e8:	602a      	str	r2, [r5, #0]
 800d7ea:	461a      	mov	r2, r3
 800d7ec:	f7fb fbab 	bl	8008f46 <_read>
 800d7f0:	1c43      	adds	r3, r0, #1
 800d7f2:	d102      	bne.n	800d7fa <_read_r+0x1e>
 800d7f4:	682b      	ldr	r3, [r5, #0]
 800d7f6:	b103      	cbz	r3, 800d7fa <_read_r+0x1e>
 800d7f8:	6023      	str	r3, [r4, #0]
 800d7fa:	bd38      	pop	{r3, r4, r5, pc}
 800d7fc:	20001eb8 	.word	0x20001eb8

0800d800 <_write_r>:
 800d800:	b538      	push	{r3, r4, r5, lr}
 800d802:	4d07      	ldr	r5, [pc, #28]	@ (800d820 <_write_r+0x20>)
 800d804:	4604      	mov	r4, r0
 800d806:	4608      	mov	r0, r1
 800d808:	4611      	mov	r1, r2
 800d80a:	2200      	movs	r2, #0
 800d80c:	602a      	str	r2, [r5, #0]
 800d80e:	461a      	mov	r2, r3
 800d810:	f7fb fba7 	bl	8008f62 <_write>
 800d814:	1c43      	adds	r3, r0, #1
 800d816:	d102      	bne.n	800d81e <_write_r+0x1e>
 800d818:	682b      	ldr	r3, [r5, #0]
 800d81a:	b103      	cbz	r3, 800d81e <_write_r+0x1e>
 800d81c:	6023      	str	r3, [r4, #0]
 800d81e:	bd38      	pop	{r3, r4, r5, pc}
 800d820:	20001eb8 	.word	0x20001eb8

0800d824 <__errno>:
 800d824:	4b01      	ldr	r3, [pc, #4]	@ (800d82c <__errno+0x8>)
 800d826:	6818      	ldr	r0, [r3, #0]
 800d828:	4770      	bx	lr
 800d82a:	bf00      	nop
 800d82c:	20001138 	.word	0x20001138

0800d830 <__libc_init_array>:
 800d830:	b570      	push	{r4, r5, r6, lr}
 800d832:	4d0d      	ldr	r5, [pc, #52]	@ (800d868 <__libc_init_array+0x38>)
 800d834:	4c0d      	ldr	r4, [pc, #52]	@ (800d86c <__libc_init_array+0x3c>)
 800d836:	1b64      	subs	r4, r4, r5
 800d838:	10a4      	asrs	r4, r4, #2
 800d83a:	2600      	movs	r6, #0
 800d83c:	42a6      	cmp	r6, r4
 800d83e:	d109      	bne.n	800d854 <__libc_init_array+0x24>
 800d840:	4d0b      	ldr	r5, [pc, #44]	@ (800d870 <__libc_init_array+0x40>)
 800d842:	4c0c      	ldr	r4, [pc, #48]	@ (800d874 <__libc_init_array+0x44>)
 800d844:	f000 fd38 	bl	800e2b8 <_init>
 800d848:	1b64      	subs	r4, r4, r5
 800d84a:	10a4      	asrs	r4, r4, #2
 800d84c:	2600      	movs	r6, #0
 800d84e:	42a6      	cmp	r6, r4
 800d850:	d105      	bne.n	800d85e <__libc_init_array+0x2e>
 800d852:	bd70      	pop	{r4, r5, r6, pc}
 800d854:	f855 3b04 	ldr.w	r3, [r5], #4
 800d858:	4798      	blx	r3
 800d85a:	3601      	adds	r6, #1
 800d85c:	e7ee      	b.n	800d83c <__libc_init_array+0xc>
 800d85e:	f855 3b04 	ldr.w	r3, [r5], #4
 800d862:	4798      	blx	r3
 800d864:	3601      	adds	r6, #1
 800d866:	e7f2      	b.n	800d84e <__libc_init_array+0x1e>
 800d868:	0800ed70 	.word	0x0800ed70
 800d86c:	0800ed70 	.word	0x0800ed70
 800d870:	0800ed70 	.word	0x0800ed70
 800d874:	0800ed74 	.word	0x0800ed74

0800d878 <__retarget_lock_init_recursive>:
 800d878:	4770      	bx	lr

0800d87a <__retarget_lock_acquire_recursive>:
 800d87a:	4770      	bx	lr

0800d87c <__retarget_lock_release_recursive>:
 800d87c:	4770      	bx	lr

0800d87e <memcpy>:
 800d87e:	440a      	add	r2, r1
 800d880:	4291      	cmp	r1, r2
 800d882:	f100 33ff 	add.w	r3, r0, #4294967295
 800d886:	d100      	bne.n	800d88a <memcpy+0xc>
 800d888:	4770      	bx	lr
 800d88a:	b510      	push	{r4, lr}
 800d88c:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d890:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d894:	4291      	cmp	r1, r2
 800d896:	d1f9      	bne.n	800d88c <memcpy+0xe>
 800d898:	bd10      	pop	{r4, pc}
	...

0800d89c <_free_r>:
 800d89c:	b538      	push	{r3, r4, r5, lr}
 800d89e:	4605      	mov	r5, r0
 800d8a0:	2900      	cmp	r1, #0
 800d8a2:	d041      	beq.n	800d928 <_free_r+0x8c>
 800d8a4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800d8a8:	1f0c      	subs	r4, r1, #4
 800d8aa:	2b00      	cmp	r3, #0
 800d8ac:	bfb8      	it	lt
 800d8ae:	18e4      	addlt	r4, r4, r3
 800d8b0:	f000 f8e8 	bl	800da84 <__malloc_lock>
 800d8b4:	4a1d      	ldr	r2, [pc, #116]	@ (800d92c <_free_r+0x90>)
 800d8b6:	6813      	ldr	r3, [r2, #0]
 800d8b8:	b933      	cbnz	r3, 800d8c8 <_free_r+0x2c>
 800d8ba:	6063      	str	r3, [r4, #4]
 800d8bc:	6014      	str	r4, [r2, #0]
 800d8be:	4628      	mov	r0, r5
 800d8c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800d8c4:	f000 b8e4 	b.w	800da90 <__malloc_unlock>
 800d8c8:	42a3      	cmp	r3, r4
 800d8ca:	d908      	bls.n	800d8de <_free_r+0x42>
 800d8cc:	6820      	ldr	r0, [r4, #0]
 800d8ce:	1821      	adds	r1, r4, r0
 800d8d0:	428b      	cmp	r3, r1
 800d8d2:	bf01      	itttt	eq
 800d8d4:	6819      	ldreq	r1, [r3, #0]
 800d8d6:	685b      	ldreq	r3, [r3, #4]
 800d8d8:	1809      	addeq	r1, r1, r0
 800d8da:	6021      	streq	r1, [r4, #0]
 800d8dc:	e7ed      	b.n	800d8ba <_free_r+0x1e>
 800d8de:	461a      	mov	r2, r3
 800d8e0:	685b      	ldr	r3, [r3, #4]
 800d8e2:	b10b      	cbz	r3, 800d8e8 <_free_r+0x4c>
 800d8e4:	42a3      	cmp	r3, r4
 800d8e6:	d9fa      	bls.n	800d8de <_free_r+0x42>
 800d8e8:	6811      	ldr	r1, [r2, #0]
 800d8ea:	1850      	adds	r0, r2, r1
 800d8ec:	42a0      	cmp	r0, r4
 800d8ee:	d10b      	bne.n	800d908 <_free_r+0x6c>
 800d8f0:	6820      	ldr	r0, [r4, #0]
 800d8f2:	4401      	add	r1, r0
 800d8f4:	1850      	adds	r0, r2, r1
 800d8f6:	4283      	cmp	r3, r0
 800d8f8:	6011      	str	r1, [r2, #0]
 800d8fa:	d1e0      	bne.n	800d8be <_free_r+0x22>
 800d8fc:	6818      	ldr	r0, [r3, #0]
 800d8fe:	685b      	ldr	r3, [r3, #4]
 800d900:	6053      	str	r3, [r2, #4]
 800d902:	4408      	add	r0, r1
 800d904:	6010      	str	r0, [r2, #0]
 800d906:	e7da      	b.n	800d8be <_free_r+0x22>
 800d908:	d902      	bls.n	800d910 <_free_r+0x74>
 800d90a:	230c      	movs	r3, #12
 800d90c:	602b      	str	r3, [r5, #0]
 800d90e:	e7d6      	b.n	800d8be <_free_r+0x22>
 800d910:	6820      	ldr	r0, [r4, #0]
 800d912:	1821      	adds	r1, r4, r0
 800d914:	428b      	cmp	r3, r1
 800d916:	bf04      	itt	eq
 800d918:	6819      	ldreq	r1, [r3, #0]
 800d91a:	685b      	ldreq	r3, [r3, #4]
 800d91c:	6063      	str	r3, [r4, #4]
 800d91e:	bf04      	itt	eq
 800d920:	1809      	addeq	r1, r1, r0
 800d922:	6021      	streq	r1, [r4, #0]
 800d924:	6054      	str	r4, [r2, #4]
 800d926:	e7ca      	b.n	800d8be <_free_r+0x22>
 800d928:	bd38      	pop	{r3, r4, r5, pc}
 800d92a:	bf00      	nop
 800d92c:	20001ec4 	.word	0x20001ec4

0800d930 <malloc>:
 800d930:	4b02      	ldr	r3, [pc, #8]	@ (800d93c <malloc+0xc>)
 800d932:	4601      	mov	r1, r0
 800d934:	6818      	ldr	r0, [r3, #0]
 800d936:	f000 b825 	b.w	800d984 <_malloc_r>
 800d93a:	bf00      	nop
 800d93c:	20001138 	.word	0x20001138

0800d940 <sbrk_aligned>:
 800d940:	b570      	push	{r4, r5, r6, lr}
 800d942:	4e0f      	ldr	r6, [pc, #60]	@ (800d980 <sbrk_aligned+0x40>)
 800d944:	460c      	mov	r4, r1
 800d946:	6831      	ldr	r1, [r6, #0]
 800d948:	4605      	mov	r5, r0
 800d94a:	b911      	cbnz	r1, 800d952 <sbrk_aligned+0x12>
 800d94c:	f000 fca4 	bl	800e298 <_sbrk_r>
 800d950:	6030      	str	r0, [r6, #0]
 800d952:	4621      	mov	r1, r4
 800d954:	4628      	mov	r0, r5
 800d956:	f000 fc9f 	bl	800e298 <_sbrk_r>
 800d95a:	1c43      	adds	r3, r0, #1
 800d95c:	d103      	bne.n	800d966 <sbrk_aligned+0x26>
 800d95e:	f04f 34ff 	mov.w	r4, #4294967295
 800d962:	4620      	mov	r0, r4
 800d964:	bd70      	pop	{r4, r5, r6, pc}
 800d966:	1cc4      	adds	r4, r0, #3
 800d968:	f024 0403 	bic.w	r4, r4, #3
 800d96c:	42a0      	cmp	r0, r4
 800d96e:	d0f8      	beq.n	800d962 <sbrk_aligned+0x22>
 800d970:	1a21      	subs	r1, r4, r0
 800d972:	4628      	mov	r0, r5
 800d974:	f000 fc90 	bl	800e298 <_sbrk_r>
 800d978:	3001      	adds	r0, #1
 800d97a:	d1f2      	bne.n	800d962 <sbrk_aligned+0x22>
 800d97c:	e7ef      	b.n	800d95e <sbrk_aligned+0x1e>
 800d97e:	bf00      	nop
 800d980:	20001ec0 	.word	0x20001ec0

0800d984 <_malloc_r>:
 800d984:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d988:	1ccd      	adds	r5, r1, #3
 800d98a:	f025 0503 	bic.w	r5, r5, #3
 800d98e:	3508      	adds	r5, #8
 800d990:	2d0c      	cmp	r5, #12
 800d992:	bf38      	it	cc
 800d994:	250c      	movcc	r5, #12
 800d996:	2d00      	cmp	r5, #0
 800d998:	4606      	mov	r6, r0
 800d99a:	db01      	blt.n	800d9a0 <_malloc_r+0x1c>
 800d99c:	42a9      	cmp	r1, r5
 800d99e:	d904      	bls.n	800d9aa <_malloc_r+0x26>
 800d9a0:	230c      	movs	r3, #12
 800d9a2:	6033      	str	r3, [r6, #0]
 800d9a4:	2000      	movs	r0, #0
 800d9a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d9aa:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 800da80 <_malloc_r+0xfc>
 800d9ae:	f000 f869 	bl	800da84 <__malloc_lock>
 800d9b2:	f8d8 3000 	ldr.w	r3, [r8]
 800d9b6:	461c      	mov	r4, r3
 800d9b8:	bb44      	cbnz	r4, 800da0c <_malloc_r+0x88>
 800d9ba:	4629      	mov	r1, r5
 800d9bc:	4630      	mov	r0, r6
 800d9be:	f7ff ffbf 	bl	800d940 <sbrk_aligned>
 800d9c2:	1c43      	adds	r3, r0, #1
 800d9c4:	4604      	mov	r4, r0
 800d9c6:	d158      	bne.n	800da7a <_malloc_r+0xf6>
 800d9c8:	f8d8 4000 	ldr.w	r4, [r8]
 800d9cc:	4627      	mov	r7, r4
 800d9ce:	2f00      	cmp	r7, #0
 800d9d0:	d143      	bne.n	800da5a <_malloc_r+0xd6>
 800d9d2:	2c00      	cmp	r4, #0
 800d9d4:	d04b      	beq.n	800da6e <_malloc_r+0xea>
 800d9d6:	6823      	ldr	r3, [r4, #0]
 800d9d8:	4639      	mov	r1, r7
 800d9da:	4630      	mov	r0, r6
 800d9dc:	eb04 0903 	add.w	r9, r4, r3
 800d9e0:	f000 fc5a 	bl	800e298 <_sbrk_r>
 800d9e4:	4581      	cmp	r9, r0
 800d9e6:	d142      	bne.n	800da6e <_malloc_r+0xea>
 800d9e8:	6821      	ldr	r1, [r4, #0]
 800d9ea:	1a6d      	subs	r5, r5, r1
 800d9ec:	4629      	mov	r1, r5
 800d9ee:	4630      	mov	r0, r6
 800d9f0:	f7ff ffa6 	bl	800d940 <sbrk_aligned>
 800d9f4:	3001      	adds	r0, #1
 800d9f6:	d03a      	beq.n	800da6e <_malloc_r+0xea>
 800d9f8:	6823      	ldr	r3, [r4, #0]
 800d9fa:	442b      	add	r3, r5
 800d9fc:	6023      	str	r3, [r4, #0]
 800d9fe:	f8d8 3000 	ldr.w	r3, [r8]
 800da02:	685a      	ldr	r2, [r3, #4]
 800da04:	bb62      	cbnz	r2, 800da60 <_malloc_r+0xdc>
 800da06:	f8c8 7000 	str.w	r7, [r8]
 800da0a:	e00f      	b.n	800da2c <_malloc_r+0xa8>
 800da0c:	6822      	ldr	r2, [r4, #0]
 800da0e:	1b52      	subs	r2, r2, r5
 800da10:	d420      	bmi.n	800da54 <_malloc_r+0xd0>
 800da12:	2a0b      	cmp	r2, #11
 800da14:	d917      	bls.n	800da46 <_malloc_r+0xc2>
 800da16:	1961      	adds	r1, r4, r5
 800da18:	42a3      	cmp	r3, r4
 800da1a:	6025      	str	r5, [r4, #0]
 800da1c:	bf18      	it	ne
 800da1e:	6059      	strne	r1, [r3, #4]
 800da20:	6863      	ldr	r3, [r4, #4]
 800da22:	bf08      	it	eq
 800da24:	f8c8 1000 	streq.w	r1, [r8]
 800da28:	5162      	str	r2, [r4, r5]
 800da2a:	604b      	str	r3, [r1, #4]
 800da2c:	4630      	mov	r0, r6
 800da2e:	f000 f82f 	bl	800da90 <__malloc_unlock>
 800da32:	f104 000b 	add.w	r0, r4, #11
 800da36:	1d23      	adds	r3, r4, #4
 800da38:	f020 0007 	bic.w	r0, r0, #7
 800da3c:	1ac2      	subs	r2, r0, r3
 800da3e:	bf1c      	itt	ne
 800da40:	1a1b      	subne	r3, r3, r0
 800da42:	50a3      	strne	r3, [r4, r2]
 800da44:	e7af      	b.n	800d9a6 <_malloc_r+0x22>
 800da46:	6862      	ldr	r2, [r4, #4]
 800da48:	42a3      	cmp	r3, r4
 800da4a:	bf0c      	ite	eq
 800da4c:	f8c8 2000 	streq.w	r2, [r8]
 800da50:	605a      	strne	r2, [r3, #4]
 800da52:	e7eb      	b.n	800da2c <_malloc_r+0xa8>
 800da54:	4623      	mov	r3, r4
 800da56:	6864      	ldr	r4, [r4, #4]
 800da58:	e7ae      	b.n	800d9b8 <_malloc_r+0x34>
 800da5a:	463c      	mov	r4, r7
 800da5c:	687f      	ldr	r7, [r7, #4]
 800da5e:	e7b6      	b.n	800d9ce <_malloc_r+0x4a>
 800da60:	461a      	mov	r2, r3
 800da62:	685b      	ldr	r3, [r3, #4]
 800da64:	42a3      	cmp	r3, r4
 800da66:	d1fb      	bne.n	800da60 <_malloc_r+0xdc>
 800da68:	2300      	movs	r3, #0
 800da6a:	6053      	str	r3, [r2, #4]
 800da6c:	e7de      	b.n	800da2c <_malloc_r+0xa8>
 800da6e:	230c      	movs	r3, #12
 800da70:	6033      	str	r3, [r6, #0]
 800da72:	4630      	mov	r0, r6
 800da74:	f000 f80c 	bl	800da90 <__malloc_unlock>
 800da78:	e794      	b.n	800d9a4 <_malloc_r+0x20>
 800da7a:	6005      	str	r5, [r0, #0]
 800da7c:	e7d6      	b.n	800da2c <_malloc_r+0xa8>
 800da7e:	bf00      	nop
 800da80:	20001ec4 	.word	0x20001ec4

0800da84 <__malloc_lock>:
 800da84:	4801      	ldr	r0, [pc, #4]	@ (800da8c <__malloc_lock+0x8>)
 800da86:	f7ff bef8 	b.w	800d87a <__retarget_lock_acquire_recursive>
 800da8a:	bf00      	nop
 800da8c:	20001ebc 	.word	0x20001ebc

0800da90 <__malloc_unlock>:
 800da90:	4801      	ldr	r0, [pc, #4]	@ (800da98 <__malloc_unlock+0x8>)
 800da92:	f7ff bef3 	b.w	800d87c <__retarget_lock_release_recursive>
 800da96:	bf00      	nop
 800da98:	20001ebc 	.word	0x20001ebc

0800da9c <__sfputc_r>:
 800da9c:	6893      	ldr	r3, [r2, #8]
 800da9e:	3b01      	subs	r3, #1
 800daa0:	2b00      	cmp	r3, #0
 800daa2:	b410      	push	{r4}
 800daa4:	6093      	str	r3, [r2, #8]
 800daa6:	da08      	bge.n	800daba <__sfputc_r+0x1e>
 800daa8:	6994      	ldr	r4, [r2, #24]
 800daaa:	42a3      	cmp	r3, r4
 800daac:	db01      	blt.n	800dab2 <__sfputc_r+0x16>
 800daae:	290a      	cmp	r1, #10
 800dab0:	d103      	bne.n	800daba <__sfputc_r+0x1e>
 800dab2:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dab6:	f7ff bdc2 	b.w	800d63e <__swbuf_r>
 800daba:	6813      	ldr	r3, [r2, #0]
 800dabc:	1c58      	adds	r0, r3, #1
 800dabe:	6010      	str	r0, [r2, #0]
 800dac0:	7019      	strb	r1, [r3, #0]
 800dac2:	4608      	mov	r0, r1
 800dac4:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dac8:	4770      	bx	lr

0800daca <__sfputs_r>:
 800daca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dacc:	4606      	mov	r6, r0
 800dace:	460f      	mov	r7, r1
 800dad0:	4614      	mov	r4, r2
 800dad2:	18d5      	adds	r5, r2, r3
 800dad4:	42ac      	cmp	r4, r5
 800dad6:	d101      	bne.n	800dadc <__sfputs_r+0x12>
 800dad8:	2000      	movs	r0, #0
 800dada:	e007      	b.n	800daec <__sfputs_r+0x22>
 800dadc:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dae0:	463a      	mov	r2, r7
 800dae2:	4630      	mov	r0, r6
 800dae4:	f7ff ffda 	bl	800da9c <__sfputc_r>
 800dae8:	1c43      	adds	r3, r0, #1
 800daea:	d1f3      	bne.n	800dad4 <__sfputs_r+0xa>
 800daec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800daf0 <_vfiprintf_r>:
 800daf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800daf4:	460d      	mov	r5, r1
 800daf6:	b09d      	sub	sp, #116	@ 0x74
 800daf8:	4614      	mov	r4, r2
 800dafa:	4698      	mov	r8, r3
 800dafc:	4606      	mov	r6, r0
 800dafe:	b118      	cbz	r0, 800db08 <_vfiprintf_r+0x18>
 800db00:	6a03      	ldr	r3, [r0, #32]
 800db02:	b90b      	cbnz	r3, 800db08 <_vfiprintf_r+0x18>
 800db04:	f7ff fbfe 	bl	800d304 <__sinit>
 800db08:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800db0a:	07d9      	lsls	r1, r3, #31
 800db0c:	d405      	bmi.n	800db1a <_vfiprintf_r+0x2a>
 800db0e:	89ab      	ldrh	r3, [r5, #12]
 800db10:	059a      	lsls	r2, r3, #22
 800db12:	d402      	bmi.n	800db1a <_vfiprintf_r+0x2a>
 800db14:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800db16:	f7ff feb0 	bl	800d87a <__retarget_lock_acquire_recursive>
 800db1a:	89ab      	ldrh	r3, [r5, #12]
 800db1c:	071b      	lsls	r3, r3, #28
 800db1e:	d501      	bpl.n	800db24 <_vfiprintf_r+0x34>
 800db20:	692b      	ldr	r3, [r5, #16]
 800db22:	b99b      	cbnz	r3, 800db4c <_vfiprintf_r+0x5c>
 800db24:	4629      	mov	r1, r5
 800db26:	4630      	mov	r0, r6
 800db28:	f7ff fdc8 	bl	800d6bc <__swsetup_r>
 800db2c:	b170      	cbz	r0, 800db4c <_vfiprintf_r+0x5c>
 800db2e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800db30:	07dc      	lsls	r4, r3, #31
 800db32:	d504      	bpl.n	800db3e <_vfiprintf_r+0x4e>
 800db34:	f04f 30ff 	mov.w	r0, #4294967295
 800db38:	b01d      	add	sp, #116	@ 0x74
 800db3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800db3e:	89ab      	ldrh	r3, [r5, #12]
 800db40:	0598      	lsls	r0, r3, #22
 800db42:	d4f7      	bmi.n	800db34 <_vfiprintf_r+0x44>
 800db44:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800db46:	f7ff fe99 	bl	800d87c <__retarget_lock_release_recursive>
 800db4a:	e7f3      	b.n	800db34 <_vfiprintf_r+0x44>
 800db4c:	2300      	movs	r3, #0
 800db4e:	9309      	str	r3, [sp, #36]	@ 0x24
 800db50:	2320      	movs	r3, #32
 800db52:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 800db56:	f8cd 800c 	str.w	r8, [sp, #12]
 800db5a:	2330      	movs	r3, #48	@ 0x30
 800db5c:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 800dd0c <_vfiprintf_r+0x21c>
 800db60:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 800db64:	f04f 0901 	mov.w	r9, #1
 800db68:	4623      	mov	r3, r4
 800db6a:	469a      	mov	sl, r3
 800db6c:	f813 2b01 	ldrb.w	r2, [r3], #1
 800db70:	b10a      	cbz	r2, 800db76 <_vfiprintf_r+0x86>
 800db72:	2a25      	cmp	r2, #37	@ 0x25
 800db74:	d1f9      	bne.n	800db6a <_vfiprintf_r+0x7a>
 800db76:	ebba 0b04 	subs.w	fp, sl, r4
 800db7a:	d00b      	beq.n	800db94 <_vfiprintf_r+0xa4>
 800db7c:	465b      	mov	r3, fp
 800db7e:	4622      	mov	r2, r4
 800db80:	4629      	mov	r1, r5
 800db82:	4630      	mov	r0, r6
 800db84:	f7ff ffa1 	bl	800daca <__sfputs_r>
 800db88:	3001      	adds	r0, #1
 800db8a:	f000 80a7 	beq.w	800dcdc <_vfiprintf_r+0x1ec>
 800db8e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800db90:	445a      	add	r2, fp
 800db92:	9209      	str	r2, [sp, #36]	@ 0x24
 800db94:	f89a 3000 	ldrb.w	r3, [sl]
 800db98:	2b00      	cmp	r3, #0
 800db9a:	f000 809f 	beq.w	800dcdc <_vfiprintf_r+0x1ec>
 800db9e:	2300      	movs	r3, #0
 800dba0:	f04f 32ff 	mov.w	r2, #4294967295
 800dba4:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800dba8:	f10a 0a01 	add.w	sl, sl, #1
 800dbac:	9304      	str	r3, [sp, #16]
 800dbae:	9307      	str	r3, [sp, #28]
 800dbb0:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 800dbb4:	931a      	str	r3, [sp, #104]	@ 0x68
 800dbb6:	4654      	mov	r4, sl
 800dbb8:	2205      	movs	r2, #5
 800dbba:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dbbe:	4853      	ldr	r0, [pc, #332]	@ (800dd0c <_vfiprintf_r+0x21c>)
 800dbc0:	f7fa ff46 	bl	8008a50 <memchr>
 800dbc4:	9a04      	ldr	r2, [sp, #16]
 800dbc6:	b9d8      	cbnz	r0, 800dc00 <_vfiprintf_r+0x110>
 800dbc8:	06d1      	lsls	r1, r2, #27
 800dbca:	bf44      	itt	mi
 800dbcc:	2320      	movmi	r3, #32
 800dbce:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800dbd2:	0713      	lsls	r3, r2, #28
 800dbd4:	bf44      	itt	mi
 800dbd6:	232b      	movmi	r3, #43	@ 0x2b
 800dbd8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800dbdc:	f89a 3000 	ldrb.w	r3, [sl]
 800dbe0:	2b2a      	cmp	r3, #42	@ 0x2a
 800dbe2:	d015      	beq.n	800dc10 <_vfiprintf_r+0x120>
 800dbe4:	9a07      	ldr	r2, [sp, #28]
 800dbe6:	4654      	mov	r4, sl
 800dbe8:	2000      	movs	r0, #0
 800dbea:	f04f 0c0a 	mov.w	ip, #10
 800dbee:	4621      	mov	r1, r4
 800dbf0:	f811 3b01 	ldrb.w	r3, [r1], #1
 800dbf4:	3b30      	subs	r3, #48	@ 0x30
 800dbf6:	2b09      	cmp	r3, #9
 800dbf8:	d94b      	bls.n	800dc92 <_vfiprintf_r+0x1a2>
 800dbfa:	b1b0      	cbz	r0, 800dc2a <_vfiprintf_r+0x13a>
 800dbfc:	9207      	str	r2, [sp, #28]
 800dbfe:	e014      	b.n	800dc2a <_vfiprintf_r+0x13a>
 800dc00:	eba0 0308 	sub.w	r3, r0, r8
 800dc04:	fa09 f303 	lsl.w	r3, r9, r3
 800dc08:	4313      	orrs	r3, r2
 800dc0a:	9304      	str	r3, [sp, #16]
 800dc0c:	46a2      	mov	sl, r4
 800dc0e:	e7d2      	b.n	800dbb6 <_vfiprintf_r+0xc6>
 800dc10:	9b03      	ldr	r3, [sp, #12]
 800dc12:	1d19      	adds	r1, r3, #4
 800dc14:	681b      	ldr	r3, [r3, #0]
 800dc16:	9103      	str	r1, [sp, #12]
 800dc18:	2b00      	cmp	r3, #0
 800dc1a:	bfbb      	ittet	lt
 800dc1c:	425b      	neglt	r3, r3
 800dc1e:	f042 0202 	orrlt.w	r2, r2, #2
 800dc22:	9307      	strge	r3, [sp, #28]
 800dc24:	9307      	strlt	r3, [sp, #28]
 800dc26:	bfb8      	it	lt
 800dc28:	9204      	strlt	r2, [sp, #16]
 800dc2a:	7823      	ldrb	r3, [r4, #0]
 800dc2c:	2b2e      	cmp	r3, #46	@ 0x2e
 800dc2e:	d10a      	bne.n	800dc46 <_vfiprintf_r+0x156>
 800dc30:	7863      	ldrb	r3, [r4, #1]
 800dc32:	2b2a      	cmp	r3, #42	@ 0x2a
 800dc34:	d132      	bne.n	800dc9c <_vfiprintf_r+0x1ac>
 800dc36:	9b03      	ldr	r3, [sp, #12]
 800dc38:	1d1a      	adds	r2, r3, #4
 800dc3a:	681b      	ldr	r3, [r3, #0]
 800dc3c:	9203      	str	r2, [sp, #12]
 800dc3e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 800dc42:	3402      	adds	r4, #2
 800dc44:	9305      	str	r3, [sp, #20]
 800dc46:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 800dd1c <_vfiprintf_r+0x22c>
 800dc4a:	7821      	ldrb	r1, [r4, #0]
 800dc4c:	2203      	movs	r2, #3
 800dc4e:	4650      	mov	r0, sl
 800dc50:	f7fa fefe 	bl	8008a50 <memchr>
 800dc54:	b138      	cbz	r0, 800dc66 <_vfiprintf_r+0x176>
 800dc56:	9b04      	ldr	r3, [sp, #16]
 800dc58:	eba0 000a 	sub.w	r0, r0, sl
 800dc5c:	2240      	movs	r2, #64	@ 0x40
 800dc5e:	4082      	lsls	r2, r0
 800dc60:	4313      	orrs	r3, r2
 800dc62:	3401      	adds	r4, #1
 800dc64:	9304      	str	r3, [sp, #16]
 800dc66:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dc6a:	4829      	ldr	r0, [pc, #164]	@ (800dd10 <_vfiprintf_r+0x220>)
 800dc6c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 800dc70:	2206      	movs	r2, #6
 800dc72:	f7fa feed 	bl	8008a50 <memchr>
 800dc76:	2800      	cmp	r0, #0
 800dc78:	d03f      	beq.n	800dcfa <_vfiprintf_r+0x20a>
 800dc7a:	4b26      	ldr	r3, [pc, #152]	@ (800dd14 <_vfiprintf_r+0x224>)
 800dc7c:	bb1b      	cbnz	r3, 800dcc6 <_vfiprintf_r+0x1d6>
 800dc7e:	9b03      	ldr	r3, [sp, #12]
 800dc80:	3307      	adds	r3, #7
 800dc82:	f023 0307 	bic.w	r3, r3, #7
 800dc86:	3308      	adds	r3, #8
 800dc88:	9303      	str	r3, [sp, #12]
 800dc8a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800dc8c:	443b      	add	r3, r7
 800dc8e:	9309      	str	r3, [sp, #36]	@ 0x24
 800dc90:	e76a      	b.n	800db68 <_vfiprintf_r+0x78>
 800dc92:	fb0c 3202 	mla	r2, ip, r2, r3
 800dc96:	460c      	mov	r4, r1
 800dc98:	2001      	movs	r0, #1
 800dc9a:	e7a8      	b.n	800dbee <_vfiprintf_r+0xfe>
 800dc9c:	2300      	movs	r3, #0
 800dc9e:	3401      	adds	r4, #1
 800dca0:	9305      	str	r3, [sp, #20]
 800dca2:	4619      	mov	r1, r3
 800dca4:	f04f 0c0a 	mov.w	ip, #10
 800dca8:	4620      	mov	r0, r4
 800dcaa:	f810 2b01 	ldrb.w	r2, [r0], #1
 800dcae:	3a30      	subs	r2, #48	@ 0x30
 800dcb0:	2a09      	cmp	r2, #9
 800dcb2:	d903      	bls.n	800dcbc <_vfiprintf_r+0x1cc>
 800dcb4:	2b00      	cmp	r3, #0
 800dcb6:	d0c6      	beq.n	800dc46 <_vfiprintf_r+0x156>
 800dcb8:	9105      	str	r1, [sp, #20]
 800dcba:	e7c4      	b.n	800dc46 <_vfiprintf_r+0x156>
 800dcbc:	fb0c 2101 	mla	r1, ip, r1, r2
 800dcc0:	4604      	mov	r4, r0
 800dcc2:	2301      	movs	r3, #1
 800dcc4:	e7f0      	b.n	800dca8 <_vfiprintf_r+0x1b8>
 800dcc6:	ab03      	add	r3, sp, #12
 800dcc8:	9300      	str	r3, [sp, #0]
 800dcca:	462a      	mov	r2, r5
 800dccc:	4b12      	ldr	r3, [pc, #72]	@ (800dd18 <_vfiprintf_r+0x228>)
 800dcce:	a904      	add	r1, sp, #16
 800dcd0:	4630      	mov	r0, r6
 800dcd2:	f3af 8000 	nop.w
 800dcd6:	4607      	mov	r7, r0
 800dcd8:	1c78      	adds	r0, r7, #1
 800dcda:	d1d6      	bne.n	800dc8a <_vfiprintf_r+0x19a>
 800dcdc:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800dcde:	07d9      	lsls	r1, r3, #31
 800dce0:	d405      	bmi.n	800dcee <_vfiprintf_r+0x1fe>
 800dce2:	89ab      	ldrh	r3, [r5, #12]
 800dce4:	059a      	lsls	r2, r3, #22
 800dce6:	d402      	bmi.n	800dcee <_vfiprintf_r+0x1fe>
 800dce8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800dcea:	f7ff fdc7 	bl	800d87c <__retarget_lock_release_recursive>
 800dcee:	89ab      	ldrh	r3, [r5, #12]
 800dcf0:	065b      	lsls	r3, r3, #25
 800dcf2:	f53f af1f 	bmi.w	800db34 <_vfiprintf_r+0x44>
 800dcf6:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800dcf8:	e71e      	b.n	800db38 <_vfiprintf_r+0x48>
 800dcfa:	ab03      	add	r3, sp, #12
 800dcfc:	9300      	str	r3, [sp, #0]
 800dcfe:	462a      	mov	r2, r5
 800dd00:	4b05      	ldr	r3, [pc, #20]	@ (800dd18 <_vfiprintf_r+0x228>)
 800dd02:	a904      	add	r1, sp, #16
 800dd04:	4630      	mov	r0, r6
 800dd06:	f000 f879 	bl	800ddfc <_printf_i>
 800dd0a:	e7e4      	b.n	800dcd6 <_vfiprintf_r+0x1e6>
 800dd0c:	0800ed33 	.word	0x0800ed33
 800dd10:	0800ed3d 	.word	0x0800ed3d
 800dd14:	00000000 	.word	0x00000000
 800dd18:	0800dacb 	.word	0x0800dacb
 800dd1c:	0800ed39 	.word	0x0800ed39

0800dd20 <_printf_common>:
 800dd20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800dd24:	4616      	mov	r6, r2
 800dd26:	4698      	mov	r8, r3
 800dd28:	688a      	ldr	r2, [r1, #8]
 800dd2a:	690b      	ldr	r3, [r1, #16]
 800dd2c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800dd30:	4293      	cmp	r3, r2
 800dd32:	bfb8      	it	lt
 800dd34:	4613      	movlt	r3, r2
 800dd36:	6033      	str	r3, [r6, #0]
 800dd38:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 800dd3c:	4607      	mov	r7, r0
 800dd3e:	460c      	mov	r4, r1
 800dd40:	b10a      	cbz	r2, 800dd46 <_printf_common+0x26>
 800dd42:	3301      	adds	r3, #1
 800dd44:	6033      	str	r3, [r6, #0]
 800dd46:	6823      	ldr	r3, [r4, #0]
 800dd48:	0699      	lsls	r1, r3, #26
 800dd4a:	bf42      	ittt	mi
 800dd4c:	6833      	ldrmi	r3, [r6, #0]
 800dd4e:	3302      	addmi	r3, #2
 800dd50:	6033      	strmi	r3, [r6, #0]
 800dd52:	6825      	ldr	r5, [r4, #0]
 800dd54:	f015 0506 	ands.w	r5, r5, #6
 800dd58:	d106      	bne.n	800dd68 <_printf_common+0x48>
 800dd5a:	f104 0a19 	add.w	sl, r4, #25
 800dd5e:	68e3      	ldr	r3, [r4, #12]
 800dd60:	6832      	ldr	r2, [r6, #0]
 800dd62:	1a9b      	subs	r3, r3, r2
 800dd64:	42ab      	cmp	r3, r5
 800dd66:	dc26      	bgt.n	800ddb6 <_printf_common+0x96>
 800dd68:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 800dd6c:	6822      	ldr	r2, [r4, #0]
 800dd6e:	3b00      	subs	r3, #0
 800dd70:	bf18      	it	ne
 800dd72:	2301      	movne	r3, #1
 800dd74:	0692      	lsls	r2, r2, #26
 800dd76:	d42b      	bmi.n	800ddd0 <_printf_common+0xb0>
 800dd78:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 800dd7c:	4641      	mov	r1, r8
 800dd7e:	4638      	mov	r0, r7
 800dd80:	47c8      	blx	r9
 800dd82:	3001      	adds	r0, #1
 800dd84:	d01e      	beq.n	800ddc4 <_printf_common+0xa4>
 800dd86:	6823      	ldr	r3, [r4, #0]
 800dd88:	6922      	ldr	r2, [r4, #16]
 800dd8a:	f003 0306 	and.w	r3, r3, #6
 800dd8e:	2b04      	cmp	r3, #4
 800dd90:	bf02      	ittt	eq
 800dd92:	68e5      	ldreq	r5, [r4, #12]
 800dd94:	6833      	ldreq	r3, [r6, #0]
 800dd96:	1aed      	subeq	r5, r5, r3
 800dd98:	68a3      	ldr	r3, [r4, #8]
 800dd9a:	bf0c      	ite	eq
 800dd9c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800dda0:	2500      	movne	r5, #0
 800dda2:	4293      	cmp	r3, r2
 800dda4:	bfc4      	itt	gt
 800dda6:	1a9b      	subgt	r3, r3, r2
 800dda8:	18ed      	addgt	r5, r5, r3
 800ddaa:	2600      	movs	r6, #0
 800ddac:	341a      	adds	r4, #26
 800ddae:	42b5      	cmp	r5, r6
 800ddb0:	d11a      	bne.n	800dde8 <_printf_common+0xc8>
 800ddb2:	2000      	movs	r0, #0
 800ddb4:	e008      	b.n	800ddc8 <_printf_common+0xa8>
 800ddb6:	2301      	movs	r3, #1
 800ddb8:	4652      	mov	r2, sl
 800ddba:	4641      	mov	r1, r8
 800ddbc:	4638      	mov	r0, r7
 800ddbe:	47c8      	blx	r9
 800ddc0:	3001      	adds	r0, #1
 800ddc2:	d103      	bne.n	800ddcc <_printf_common+0xac>
 800ddc4:	f04f 30ff 	mov.w	r0, #4294967295
 800ddc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ddcc:	3501      	adds	r5, #1
 800ddce:	e7c6      	b.n	800dd5e <_printf_common+0x3e>
 800ddd0:	18e1      	adds	r1, r4, r3
 800ddd2:	1c5a      	adds	r2, r3, #1
 800ddd4:	2030      	movs	r0, #48	@ 0x30
 800ddd6:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 800ddda:	4422      	add	r2, r4
 800dddc:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 800dde0:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 800dde4:	3302      	adds	r3, #2
 800dde6:	e7c7      	b.n	800dd78 <_printf_common+0x58>
 800dde8:	2301      	movs	r3, #1
 800ddea:	4622      	mov	r2, r4
 800ddec:	4641      	mov	r1, r8
 800ddee:	4638      	mov	r0, r7
 800ddf0:	47c8      	blx	r9
 800ddf2:	3001      	adds	r0, #1
 800ddf4:	d0e6      	beq.n	800ddc4 <_printf_common+0xa4>
 800ddf6:	3601      	adds	r6, #1
 800ddf8:	e7d9      	b.n	800ddae <_printf_common+0x8e>
	...

0800ddfc <_printf_i>:
 800ddfc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800de00:	7e0f      	ldrb	r7, [r1, #24]
 800de02:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 800de04:	2f78      	cmp	r7, #120	@ 0x78
 800de06:	4691      	mov	r9, r2
 800de08:	4680      	mov	r8, r0
 800de0a:	460c      	mov	r4, r1
 800de0c:	469a      	mov	sl, r3
 800de0e:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 800de12:	d807      	bhi.n	800de24 <_printf_i+0x28>
 800de14:	2f62      	cmp	r7, #98	@ 0x62
 800de16:	d80a      	bhi.n	800de2e <_printf_i+0x32>
 800de18:	2f00      	cmp	r7, #0
 800de1a:	f000 80d1 	beq.w	800dfc0 <_printf_i+0x1c4>
 800de1e:	2f58      	cmp	r7, #88	@ 0x58
 800de20:	f000 80b8 	beq.w	800df94 <_printf_i+0x198>
 800de24:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800de28:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 800de2c:	e03a      	b.n	800dea4 <_printf_i+0xa8>
 800de2e:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 800de32:	2b15      	cmp	r3, #21
 800de34:	d8f6      	bhi.n	800de24 <_printf_i+0x28>
 800de36:	a101      	add	r1, pc, #4	@ (adr r1, 800de3c <_printf_i+0x40>)
 800de38:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800de3c:	0800de95 	.word	0x0800de95
 800de40:	0800dea9 	.word	0x0800dea9
 800de44:	0800de25 	.word	0x0800de25
 800de48:	0800de25 	.word	0x0800de25
 800de4c:	0800de25 	.word	0x0800de25
 800de50:	0800de25 	.word	0x0800de25
 800de54:	0800dea9 	.word	0x0800dea9
 800de58:	0800de25 	.word	0x0800de25
 800de5c:	0800de25 	.word	0x0800de25
 800de60:	0800de25 	.word	0x0800de25
 800de64:	0800de25 	.word	0x0800de25
 800de68:	0800dfa7 	.word	0x0800dfa7
 800de6c:	0800ded3 	.word	0x0800ded3
 800de70:	0800df61 	.word	0x0800df61
 800de74:	0800de25 	.word	0x0800de25
 800de78:	0800de25 	.word	0x0800de25
 800de7c:	0800dfc9 	.word	0x0800dfc9
 800de80:	0800de25 	.word	0x0800de25
 800de84:	0800ded3 	.word	0x0800ded3
 800de88:	0800de25 	.word	0x0800de25
 800de8c:	0800de25 	.word	0x0800de25
 800de90:	0800df69 	.word	0x0800df69
 800de94:	6833      	ldr	r3, [r6, #0]
 800de96:	1d1a      	adds	r2, r3, #4
 800de98:	681b      	ldr	r3, [r3, #0]
 800de9a:	6032      	str	r2, [r6, #0]
 800de9c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800dea0:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 800dea4:	2301      	movs	r3, #1
 800dea6:	e09c      	b.n	800dfe2 <_printf_i+0x1e6>
 800dea8:	6833      	ldr	r3, [r6, #0]
 800deaa:	6820      	ldr	r0, [r4, #0]
 800deac:	1d19      	adds	r1, r3, #4
 800deae:	6031      	str	r1, [r6, #0]
 800deb0:	0606      	lsls	r6, r0, #24
 800deb2:	d501      	bpl.n	800deb8 <_printf_i+0xbc>
 800deb4:	681d      	ldr	r5, [r3, #0]
 800deb6:	e003      	b.n	800dec0 <_printf_i+0xc4>
 800deb8:	0645      	lsls	r5, r0, #25
 800deba:	d5fb      	bpl.n	800deb4 <_printf_i+0xb8>
 800debc:	f9b3 5000 	ldrsh.w	r5, [r3]
 800dec0:	2d00      	cmp	r5, #0
 800dec2:	da03      	bge.n	800decc <_printf_i+0xd0>
 800dec4:	232d      	movs	r3, #45	@ 0x2d
 800dec6:	426d      	negs	r5, r5
 800dec8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800decc:	4858      	ldr	r0, [pc, #352]	@ (800e030 <_printf_i+0x234>)
 800dece:	230a      	movs	r3, #10
 800ded0:	e011      	b.n	800def6 <_printf_i+0xfa>
 800ded2:	6821      	ldr	r1, [r4, #0]
 800ded4:	6833      	ldr	r3, [r6, #0]
 800ded6:	0608      	lsls	r0, r1, #24
 800ded8:	f853 5b04 	ldr.w	r5, [r3], #4
 800dedc:	d402      	bmi.n	800dee4 <_printf_i+0xe8>
 800dede:	0649      	lsls	r1, r1, #25
 800dee0:	bf48      	it	mi
 800dee2:	b2ad      	uxthmi	r5, r5
 800dee4:	2f6f      	cmp	r7, #111	@ 0x6f
 800dee6:	4852      	ldr	r0, [pc, #328]	@ (800e030 <_printf_i+0x234>)
 800dee8:	6033      	str	r3, [r6, #0]
 800deea:	bf14      	ite	ne
 800deec:	230a      	movne	r3, #10
 800deee:	2308      	moveq	r3, #8
 800def0:	2100      	movs	r1, #0
 800def2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 800def6:	6866      	ldr	r6, [r4, #4]
 800def8:	60a6      	str	r6, [r4, #8]
 800defa:	2e00      	cmp	r6, #0
 800defc:	db05      	blt.n	800df0a <_printf_i+0x10e>
 800defe:	6821      	ldr	r1, [r4, #0]
 800df00:	432e      	orrs	r6, r5
 800df02:	f021 0104 	bic.w	r1, r1, #4
 800df06:	6021      	str	r1, [r4, #0]
 800df08:	d04b      	beq.n	800dfa2 <_printf_i+0x1a6>
 800df0a:	4616      	mov	r6, r2
 800df0c:	fbb5 f1f3 	udiv	r1, r5, r3
 800df10:	fb03 5711 	mls	r7, r3, r1, r5
 800df14:	5dc7      	ldrb	r7, [r0, r7]
 800df16:	f806 7d01 	strb.w	r7, [r6, #-1]!
 800df1a:	462f      	mov	r7, r5
 800df1c:	42bb      	cmp	r3, r7
 800df1e:	460d      	mov	r5, r1
 800df20:	d9f4      	bls.n	800df0c <_printf_i+0x110>
 800df22:	2b08      	cmp	r3, #8
 800df24:	d10b      	bne.n	800df3e <_printf_i+0x142>
 800df26:	6823      	ldr	r3, [r4, #0]
 800df28:	07df      	lsls	r7, r3, #31
 800df2a:	d508      	bpl.n	800df3e <_printf_i+0x142>
 800df2c:	6923      	ldr	r3, [r4, #16]
 800df2e:	6861      	ldr	r1, [r4, #4]
 800df30:	4299      	cmp	r1, r3
 800df32:	bfde      	ittt	le
 800df34:	2330      	movle	r3, #48	@ 0x30
 800df36:	f806 3c01 	strble.w	r3, [r6, #-1]
 800df3a:	f106 36ff 	addle.w	r6, r6, #4294967295
 800df3e:	1b92      	subs	r2, r2, r6
 800df40:	6122      	str	r2, [r4, #16]
 800df42:	f8cd a000 	str.w	sl, [sp]
 800df46:	464b      	mov	r3, r9
 800df48:	aa03      	add	r2, sp, #12
 800df4a:	4621      	mov	r1, r4
 800df4c:	4640      	mov	r0, r8
 800df4e:	f7ff fee7 	bl	800dd20 <_printf_common>
 800df52:	3001      	adds	r0, #1
 800df54:	d14a      	bne.n	800dfec <_printf_i+0x1f0>
 800df56:	f04f 30ff 	mov.w	r0, #4294967295
 800df5a:	b004      	add	sp, #16
 800df5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800df60:	6823      	ldr	r3, [r4, #0]
 800df62:	f043 0320 	orr.w	r3, r3, #32
 800df66:	6023      	str	r3, [r4, #0]
 800df68:	4832      	ldr	r0, [pc, #200]	@ (800e034 <_printf_i+0x238>)
 800df6a:	2778      	movs	r7, #120	@ 0x78
 800df6c:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 800df70:	6823      	ldr	r3, [r4, #0]
 800df72:	6831      	ldr	r1, [r6, #0]
 800df74:	061f      	lsls	r7, r3, #24
 800df76:	f851 5b04 	ldr.w	r5, [r1], #4
 800df7a:	d402      	bmi.n	800df82 <_printf_i+0x186>
 800df7c:	065f      	lsls	r7, r3, #25
 800df7e:	bf48      	it	mi
 800df80:	b2ad      	uxthmi	r5, r5
 800df82:	6031      	str	r1, [r6, #0]
 800df84:	07d9      	lsls	r1, r3, #31
 800df86:	bf44      	itt	mi
 800df88:	f043 0320 	orrmi.w	r3, r3, #32
 800df8c:	6023      	strmi	r3, [r4, #0]
 800df8e:	b11d      	cbz	r5, 800df98 <_printf_i+0x19c>
 800df90:	2310      	movs	r3, #16
 800df92:	e7ad      	b.n	800def0 <_printf_i+0xf4>
 800df94:	4826      	ldr	r0, [pc, #152]	@ (800e030 <_printf_i+0x234>)
 800df96:	e7e9      	b.n	800df6c <_printf_i+0x170>
 800df98:	6823      	ldr	r3, [r4, #0]
 800df9a:	f023 0320 	bic.w	r3, r3, #32
 800df9e:	6023      	str	r3, [r4, #0]
 800dfa0:	e7f6      	b.n	800df90 <_printf_i+0x194>
 800dfa2:	4616      	mov	r6, r2
 800dfa4:	e7bd      	b.n	800df22 <_printf_i+0x126>
 800dfa6:	6833      	ldr	r3, [r6, #0]
 800dfa8:	6825      	ldr	r5, [r4, #0]
 800dfaa:	6961      	ldr	r1, [r4, #20]
 800dfac:	1d18      	adds	r0, r3, #4
 800dfae:	6030      	str	r0, [r6, #0]
 800dfb0:	062e      	lsls	r6, r5, #24
 800dfb2:	681b      	ldr	r3, [r3, #0]
 800dfb4:	d501      	bpl.n	800dfba <_printf_i+0x1be>
 800dfb6:	6019      	str	r1, [r3, #0]
 800dfb8:	e002      	b.n	800dfc0 <_printf_i+0x1c4>
 800dfba:	0668      	lsls	r0, r5, #25
 800dfbc:	d5fb      	bpl.n	800dfb6 <_printf_i+0x1ba>
 800dfbe:	8019      	strh	r1, [r3, #0]
 800dfc0:	2300      	movs	r3, #0
 800dfc2:	6123      	str	r3, [r4, #16]
 800dfc4:	4616      	mov	r6, r2
 800dfc6:	e7bc      	b.n	800df42 <_printf_i+0x146>
 800dfc8:	6833      	ldr	r3, [r6, #0]
 800dfca:	1d1a      	adds	r2, r3, #4
 800dfcc:	6032      	str	r2, [r6, #0]
 800dfce:	681e      	ldr	r6, [r3, #0]
 800dfd0:	6862      	ldr	r2, [r4, #4]
 800dfd2:	2100      	movs	r1, #0
 800dfd4:	4630      	mov	r0, r6
 800dfd6:	f7fa fd3b 	bl	8008a50 <memchr>
 800dfda:	b108      	cbz	r0, 800dfe0 <_printf_i+0x1e4>
 800dfdc:	1b80      	subs	r0, r0, r6
 800dfde:	6060      	str	r0, [r4, #4]
 800dfe0:	6863      	ldr	r3, [r4, #4]
 800dfe2:	6123      	str	r3, [r4, #16]
 800dfe4:	2300      	movs	r3, #0
 800dfe6:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800dfea:	e7aa      	b.n	800df42 <_printf_i+0x146>
 800dfec:	6923      	ldr	r3, [r4, #16]
 800dfee:	4632      	mov	r2, r6
 800dff0:	4649      	mov	r1, r9
 800dff2:	4640      	mov	r0, r8
 800dff4:	47d0      	blx	sl
 800dff6:	3001      	adds	r0, #1
 800dff8:	d0ad      	beq.n	800df56 <_printf_i+0x15a>
 800dffa:	6823      	ldr	r3, [r4, #0]
 800dffc:	079b      	lsls	r3, r3, #30
 800dffe:	d413      	bmi.n	800e028 <_printf_i+0x22c>
 800e000:	68e0      	ldr	r0, [r4, #12]
 800e002:	9b03      	ldr	r3, [sp, #12]
 800e004:	4298      	cmp	r0, r3
 800e006:	bfb8      	it	lt
 800e008:	4618      	movlt	r0, r3
 800e00a:	e7a6      	b.n	800df5a <_printf_i+0x15e>
 800e00c:	2301      	movs	r3, #1
 800e00e:	4632      	mov	r2, r6
 800e010:	4649      	mov	r1, r9
 800e012:	4640      	mov	r0, r8
 800e014:	47d0      	blx	sl
 800e016:	3001      	adds	r0, #1
 800e018:	d09d      	beq.n	800df56 <_printf_i+0x15a>
 800e01a:	3501      	adds	r5, #1
 800e01c:	68e3      	ldr	r3, [r4, #12]
 800e01e:	9903      	ldr	r1, [sp, #12]
 800e020:	1a5b      	subs	r3, r3, r1
 800e022:	42ab      	cmp	r3, r5
 800e024:	dcf2      	bgt.n	800e00c <_printf_i+0x210>
 800e026:	e7eb      	b.n	800e000 <_printf_i+0x204>
 800e028:	2500      	movs	r5, #0
 800e02a:	f104 0619 	add.w	r6, r4, #25
 800e02e:	e7f5      	b.n	800e01c <_printf_i+0x220>
 800e030:	0800ed44 	.word	0x0800ed44
 800e034:	0800ed55 	.word	0x0800ed55

0800e038 <__sflush_r>:
 800e038:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 800e03c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e040:	0716      	lsls	r6, r2, #28
 800e042:	4605      	mov	r5, r0
 800e044:	460c      	mov	r4, r1
 800e046:	d454      	bmi.n	800e0f2 <__sflush_r+0xba>
 800e048:	684b      	ldr	r3, [r1, #4]
 800e04a:	2b00      	cmp	r3, #0
 800e04c:	dc02      	bgt.n	800e054 <__sflush_r+0x1c>
 800e04e:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800e050:	2b00      	cmp	r3, #0
 800e052:	dd48      	ble.n	800e0e6 <__sflush_r+0xae>
 800e054:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 800e056:	2e00      	cmp	r6, #0
 800e058:	d045      	beq.n	800e0e6 <__sflush_r+0xae>
 800e05a:	2300      	movs	r3, #0
 800e05c:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 800e060:	682f      	ldr	r7, [r5, #0]
 800e062:	6a21      	ldr	r1, [r4, #32]
 800e064:	602b      	str	r3, [r5, #0]
 800e066:	d030      	beq.n	800e0ca <__sflush_r+0x92>
 800e068:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800e06a:	89a3      	ldrh	r3, [r4, #12]
 800e06c:	0759      	lsls	r1, r3, #29
 800e06e:	d505      	bpl.n	800e07c <__sflush_r+0x44>
 800e070:	6863      	ldr	r3, [r4, #4]
 800e072:	1ad2      	subs	r2, r2, r3
 800e074:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800e076:	b10b      	cbz	r3, 800e07c <__sflush_r+0x44>
 800e078:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 800e07a:	1ad2      	subs	r2, r2, r3
 800e07c:	2300      	movs	r3, #0
 800e07e:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 800e080:	6a21      	ldr	r1, [r4, #32]
 800e082:	4628      	mov	r0, r5
 800e084:	47b0      	blx	r6
 800e086:	1c43      	adds	r3, r0, #1
 800e088:	89a3      	ldrh	r3, [r4, #12]
 800e08a:	d106      	bne.n	800e09a <__sflush_r+0x62>
 800e08c:	6829      	ldr	r1, [r5, #0]
 800e08e:	291d      	cmp	r1, #29
 800e090:	d82b      	bhi.n	800e0ea <__sflush_r+0xb2>
 800e092:	4a2a      	ldr	r2, [pc, #168]	@ (800e13c <__sflush_r+0x104>)
 800e094:	40ca      	lsrs	r2, r1
 800e096:	07d6      	lsls	r6, r2, #31
 800e098:	d527      	bpl.n	800e0ea <__sflush_r+0xb2>
 800e09a:	2200      	movs	r2, #0
 800e09c:	6062      	str	r2, [r4, #4]
 800e09e:	04d9      	lsls	r1, r3, #19
 800e0a0:	6922      	ldr	r2, [r4, #16]
 800e0a2:	6022      	str	r2, [r4, #0]
 800e0a4:	d504      	bpl.n	800e0b0 <__sflush_r+0x78>
 800e0a6:	1c42      	adds	r2, r0, #1
 800e0a8:	d101      	bne.n	800e0ae <__sflush_r+0x76>
 800e0aa:	682b      	ldr	r3, [r5, #0]
 800e0ac:	b903      	cbnz	r3, 800e0b0 <__sflush_r+0x78>
 800e0ae:	6560      	str	r0, [r4, #84]	@ 0x54
 800e0b0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800e0b2:	602f      	str	r7, [r5, #0]
 800e0b4:	b1b9      	cbz	r1, 800e0e6 <__sflush_r+0xae>
 800e0b6:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800e0ba:	4299      	cmp	r1, r3
 800e0bc:	d002      	beq.n	800e0c4 <__sflush_r+0x8c>
 800e0be:	4628      	mov	r0, r5
 800e0c0:	f7ff fbec 	bl	800d89c <_free_r>
 800e0c4:	2300      	movs	r3, #0
 800e0c6:	6363      	str	r3, [r4, #52]	@ 0x34
 800e0c8:	e00d      	b.n	800e0e6 <__sflush_r+0xae>
 800e0ca:	2301      	movs	r3, #1
 800e0cc:	4628      	mov	r0, r5
 800e0ce:	47b0      	blx	r6
 800e0d0:	4602      	mov	r2, r0
 800e0d2:	1c50      	adds	r0, r2, #1
 800e0d4:	d1c9      	bne.n	800e06a <__sflush_r+0x32>
 800e0d6:	682b      	ldr	r3, [r5, #0]
 800e0d8:	2b00      	cmp	r3, #0
 800e0da:	d0c6      	beq.n	800e06a <__sflush_r+0x32>
 800e0dc:	2b1d      	cmp	r3, #29
 800e0de:	d001      	beq.n	800e0e4 <__sflush_r+0xac>
 800e0e0:	2b16      	cmp	r3, #22
 800e0e2:	d11e      	bne.n	800e122 <__sflush_r+0xea>
 800e0e4:	602f      	str	r7, [r5, #0]
 800e0e6:	2000      	movs	r0, #0
 800e0e8:	e022      	b.n	800e130 <__sflush_r+0xf8>
 800e0ea:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800e0ee:	b21b      	sxth	r3, r3
 800e0f0:	e01b      	b.n	800e12a <__sflush_r+0xf2>
 800e0f2:	690f      	ldr	r7, [r1, #16]
 800e0f4:	2f00      	cmp	r7, #0
 800e0f6:	d0f6      	beq.n	800e0e6 <__sflush_r+0xae>
 800e0f8:	0793      	lsls	r3, r2, #30
 800e0fa:	680e      	ldr	r6, [r1, #0]
 800e0fc:	bf08      	it	eq
 800e0fe:	694b      	ldreq	r3, [r1, #20]
 800e100:	600f      	str	r7, [r1, #0]
 800e102:	bf18      	it	ne
 800e104:	2300      	movne	r3, #0
 800e106:	eba6 0807 	sub.w	r8, r6, r7
 800e10a:	608b      	str	r3, [r1, #8]
 800e10c:	f1b8 0f00 	cmp.w	r8, #0
 800e110:	dde9      	ble.n	800e0e6 <__sflush_r+0xae>
 800e112:	6a21      	ldr	r1, [r4, #32]
 800e114:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 800e116:	4643      	mov	r3, r8
 800e118:	463a      	mov	r2, r7
 800e11a:	4628      	mov	r0, r5
 800e11c:	47b0      	blx	r6
 800e11e:	2800      	cmp	r0, #0
 800e120:	dc08      	bgt.n	800e134 <__sflush_r+0xfc>
 800e122:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e126:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800e12a:	81a3      	strh	r3, [r4, #12]
 800e12c:	f04f 30ff 	mov.w	r0, #4294967295
 800e130:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e134:	4407      	add	r7, r0
 800e136:	eba8 0800 	sub.w	r8, r8, r0
 800e13a:	e7e7      	b.n	800e10c <__sflush_r+0xd4>
 800e13c:	20400001 	.word	0x20400001

0800e140 <_fflush_r>:
 800e140:	b538      	push	{r3, r4, r5, lr}
 800e142:	690b      	ldr	r3, [r1, #16]
 800e144:	4605      	mov	r5, r0
 800e146:	460c      	mov	r4, r1
 800e148:	b913      	cbnz	r3, 800e150 <_fflush_r+0x10>
 800e14a:	2500      	movs	r5, #0
 800e14c:	4628      	mov	r0, r5
 800e14e:	bd38      	pop	{r3, r4, r5, pc}
 800e150:	b118      	cbz	r0, 800e15a <_fflush_r+0x1a>
 800e152:	6a03      	ldr	r3, [r0, #32]
 800e154:	b90b      	cbnz	r3, 800e15a <_fflush_r+0x1a>
 800e156:	f7ff f8d5 	bl	800d304 <__sinit>
 800e15a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e15e:	2b00      	cmp	r3, #0
 800e160:	d0f3      	beq.n	800e14a <_fflush_r+0xa>
 800e162:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800e164:	07d0      	lsls	r0, r2, #31
 800e166:	d404      	bmi.n	800e172 <_fflush_r+0x32>
 800e168:	0599      	lsls	r1, r3, #22
 800e16a:	d402      	bmi.n	800e172 <_fflush_r+0x32>
 800e16c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800e16e:	f7ff fb84 	bl	800d87a <__retarget_lock_acquire_recursive>
 800e172:	4628      	mov	r0, r5
 800e174:	4621      	mov	r1, r4
 800e176:	f7ff ff5f 	bl	800e038 <__sflush_r>
 800e17a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800e17c:	07da      	lsls	r2, r3, #31
 800e17e:	4605      	mov	r5, r0
 800e180:	d4e4      	bmi.n	800e14c <_fflush_r+0xc>
 800e182:	89a3      	ldrh	r3, [r4, #12]
 800e184:	059b      	lsls	r3, r3, #22
 800e186:	d4e1      	bmi.n	800e14c <_fflush_r+0xc>
 800e188:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800e18a:	f7ff fb77 	bl	800d87c <__retarget_lock_release_recursive>
 800e18e:	e7dd      	b.n	800e14c <_fflush_r+0xc>

0800e190 <__swhatbuf_r>:
 800e190:	b570      	push	{r4, r5, r6, lr}
 800e192:	460c      	mov	r4, r1
 800e194:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800e198:	2900      	cmp	r1, #0
 800e19a:	b096      	sub	sp, #88	@ 0x58
 800e19c:	4615      	mov	r5, r2
 800e19e:	461e      	mov	r6, r3
 800e1a0:	da0d      	bge.n	800e1be <__swhatbuf_r+0x2e>
 800e1a2:	89a3      	ldrh	r3, [r4, #12]
 800e1a4:	f013 0f80 	tst.w	r3, #128	@ 0x80
 800e1a8:	f04f 0100 	mov.w	r1, #0
 800e1ac:	bf14      	ite	ne
 800e1ae:	2340      	movne	r3, #64	@ 0x40
 800e1b0:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 800e1b4:	2000      	movs	r0, #0
 800e1b6:	6031      	str	r1, [r6, #0]
 800e1b8:	602b      	str	r3, [r5, #0]
 800e1ba:	b016      	add	sp, #88	@ 0x58
 800e1bc:	bd70      	pop	{r4, r5, r6, pc}
 800e1be:	466a      	mov	r2, sp
 800e1c0:	f000 f848 	bl	800e254 <_fstat_r>
 800e1c4:	2800      	cmp	r0, #0
 800e1c6:	dbec      	blt.n	800e1a2 <__swhatbuf_r+0x12>
 800e1c8:	9901      	ldr	r1, [sp, #4]
 800e1ca:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 800e1ce:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 800e1d2:	4259      	negs	r1, r3
 800e1d4:	4159      	adcs	r1, r3
 800e1d6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800e1da:	e7eb      	b.n	800e1b4 <__swhatbuf_r+0x24>

0800e1dc <__smakebuf_r>:
 800e1dc:	898b      	ldrh	r3, [r1, #12]
 800e1de:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e1e0:	079d      	lsls	r5, r3, #30
 800e1e2:	4606      	mov	r6, r0
 800e1e4:	460c      	mov	r4, r1
 800e1e6:	d507      	bpl.n	800e1f8 <__smakebuf_r+0x1c>
 800e1e8:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 800e1ec:	6023      	str	r3, [r4, #0]
 800e1ee:	6123      	str	r3, [r4, #16]
 800e1f0:	2301      	movs	r3, #1
 800e1f2:	6163      	str	r3, [r4, #20]
 800e1f4:	b003      	add	sp, #12
 800e1f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e1f8:	ab01      	add	r3, sp, #4
 800e1fa:	466a      	mov	r2, sp
 800e1fc:	f7ff ffc8 	bl	800e190 <__swhatbuf_r>
 800e200:	9f00      	ldr	r7, [sp, #0]
 800e202:	4605      	mov	r5, r0
 800e204:	4639      	mov	r1, r7
 800e206:	4630      	mov	r0, r6
 800e208:	f7ff fbbc 	bl	800d984 <_malloc_r>
 800e20c:	b948      	cbnz	r0, 800e222 <__smakebuf_r+0x46>
 800e20e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e212:	059a      	lsls	r2, r3, #22
 800e214:	d4ee      	bmi.n	800e1f4 <__smakebuf_r+0x18>
 800e216:	f023 0303 	bic.w	r3, r3, #3
 800e21a:	f043 0302 	orr.w	r3, r3, #2
 800e21e:	81a3      	strh	r3, [r4, #12]
 800e220:	e7e2      	b.n	800e1e8 <__smakebuf_r+0xc>
 800e222:	89a3      	ldrh	r3, [r4, #12]
 800e224:	6020      	str	r0, [r4, #0]
 800e226:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800e22a:	81a3      	strh	r3, [r4, #12]
 800e22c:	9b01      	ldr	r3, [sp, #4]
 800e22e:	e9c4 0704 	strd	r0, r7, [r4, #16]
 800e232:	b15b      	cbz	r3, 800e24c <__smakebuf_r+0x70>
 800e234:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800e238:	4630      	mov	r0, r6
 800e23a:	f000 f81d 	bl	800e278 <_isatty_r>
 800e23e:	b128      	cbz	r0, 800e24c <__smakebuf_r+0x70>
 800e240:	89a3      	ldrh	r3, [r4, #12]
 800e242:	f023 0303 	bic.w	r3, r3, #3
 800e246:	f043 0301 	orr.w	r3, r3, #1
 800e24a:	81a3      	strh	r3, [r4, #12]
 800e24c:	89a3      	ldrh	r3, [r4, #12]
 800e24e:	431d      	orrs	r5, r3
 800e250:	81a5      	strh	r5, [r4, #12]
 800e252:	e7cf      	b.n	800e1f4 <__smakebuf_r+0x18>

0800e254 <_fstat_r>:
 800e254:	b538      	push	{r3, r4, r5, lr}
 800e256:	4d07      	ldr	r5, [pc, #28]	@ (800e274 <_fstat_r+0x20>)
 800e258:	2300      	movs	r3, #0
 800e25a:	4604      	mov	r4, r0
 800e25c:	4608      	mov	r0, r1
 800e25e:	4611      	mov	r1, r2
 800e260:	602b      	str	r3, [r5, #0]
 800e262:	f7fa feaa 	bl	8008fba <_fstat>
 800e266:	1c43      	adds	r3, r0, #1
 800e268:	d102      	bne.n	800e270 <_fstat_r+0x1c>
 800e26a:	682b      	ldr	r3, [r5, #0]
 800e26c:	b103      	cbz	r3, 800e270 <_fstat_r+0x1c>
 800e26e:	6023      	str	r3, [r4, #0]
 800e270:	bd38      	pop	{r3, r4, r5, pc}
 800e272:	bf00      	nop
 800e274:	20001eb8 	.word	0x20001eb8

0800e278 <_isatty_r>:
 800e278:	b538      	push	{r3, r4, r5, lr}
 800e27a:	4d06      	ldr	r5, [pc, #24]	@ (800e294 <_isatty_r+0x1c>)
 800e27c:	2300      	movs	r3, #0
 800e27e:	4604      	mov	r4, r0
 800e280:	4608      	mov	r0, r1
 800e282:	602b      	str	r3, [r5, #0]
 800e284:	f7fa fe9e 	bl	8008fc4 <_isatty>
 800e288:	1c43      	adds	r3, r0, #1
 800e28a:	d102      	bne.n	800e292 <_isatty_r+0x1a>
 800e28c:	682b      	ldr	r3, [r5, #0]
 800e28e:	b103      	cbz	r3, 800e292 <_isatty_r+0x1a>
 800e290:	6023      	str	r3, [r4, #0]
 800e292:	bd38      	pop	{r3, r4, r5, pc}
 800e294:	20001eb8 	.word	0x20001eb8

0800e298 <_sbrk_r>:
 800e298:	b538      	push	{r3, r4, r5, lr}
 800e29a:	4d06      	ldr	r5, [pc, #24]	@ (800e2b4 <_sbrk_r+0x1c>)
 800e29c:	2300      	movs	r3, #0
 800e29e:	4604      	mov	r4, r0
 800e2a0:	4608      	mov	r0, r1
 800e2a2:	602b      	str	r3, [r5, #0]
 800e2a4:	f7fa fe6c 	bl	8008f80 <_sbrk>
 800e2a8:	1c43      	adds	r3, r0, #1
 800e2aa:	d102      	bne.n	800e2b2 <_sbrk_r+0x1a>
 800e2ac:	682b      	ldr	r3, [r5, #0]
 800e2ae:	b103      	cbz	r3, 800e2b2 <_sbrk_r+0x1a>
 800e2b0:	6023      	str	r3, [r4, #0]
 800e2b2:	bd38      	pop	{r3, r4, r5, pc}
 800e2b4:	20001eb8 	.word	0x20001eb8

0800e2b8 <_init>:
 800e2b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e2ba:	bf00      	nop
 800e2bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e2be:	bc08      	pop	{r3}
 800e2c0:	469e      	mov	lr, r3
 800e2c2:	4770      	bx	lr

0800e2c4 <_fini>:
 800e2c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e2c6:	bf00      	nop
 800e2c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e2ca:	bc08      	pop	{r3}
 800e2cc:	469e      	mov	lr, r3
 800e2ce:	4770      	bx	lr

0800e2d0 <__SFU_LL_SECU_ActivateSecUser_veneer>:
 800e2d0:	f85f f000 	ldr.w	pc, [pc]	@ 800e2d4 <__SFU_LL_SECU_ActivateSecUser_veneer+0x4>
 800e2d4:	20001001 	.word	0x20001001

Disassembly of section .RamFunc:

20001000 <SFU_LL_SECU_ActivateSecUser>:
#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LOADER) || defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION) */
#endif /* SFU_MPU_PROTECT_ENABLE */

#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    /* Reset FPU context */
    SCB->CPACR &= ~((3UL << 10*2)|(3UL << 11*2));  /* reset CP10 and CP11 Full Access */
20001000:	4c14      	ldr	r4, [pc, #80]	@ (20001054 <SFU_LL_SECU_ActivateSecUser+0x54>)
{
20001002:	4605      	mov	r5, r0
20001004:	b508      	push	{r3, lr}
  (void) HAL_FLASH_Unlock();
20001006:	f000 f847 	bl	20001098 <__HAL_FLASH_Unlock_veneer>
    SCB->CPACR &= ~((3UL << 10*2)|(3UL << 11*2));  /* reset CP10 and CP11 Full Access */
2000100a:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
2000100e:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
20001012:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk; /* Disable automatic lazy state preservation for floating-point context */
20001016:	4b10      	ldr	r3, [pc, #64]	@ (20001058 <SFU_LL_SECU_ActivateSecUser+0x58>)
20001018:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
2000101a:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
2000101e:	635a      	str	r2, [r3, #52]	@ 0x34
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk; /* Clear the lazy state preservation for floating-point context */
20001020:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
20001022:	f022 0201 	bic.w	r2, r2, #1
20001026:	635a      	str	r2, [r3, #52]	@ 0x34
  __ASM volatile ("MRS %0, control" : "=r" (result) );
20001028:	f3ef 8314 	mrs	r3, CONTROL
#endif /* (__FPU_PRESENT == 1) && (__FPU_USED == 1) */

    /* clear process stack & unprivileged bit */
    __set_CONTROL(__get_CONTROL() & ~0x3U);
2000102c:	f023 0303 	bic.w	r3, r3, #3
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
20001030:	f383 8814 	msr	CONTROL, r3

    /* returns from interrupt into application */
    launch_application(Address, (uint32_t)jump_to_function);
20001034:	4909      	ldr	r1, [pc, #36]	@ (2000105c <SFU_LL_SECU_ActivateSecUser+0x5c>)
20001036:	4628      	mov	r0, r5
20001038:	f000 f818 	bl	2000106c <launch_application>
  __ASM volatile ("dsb 0xF":::"memory");
2000103c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20001040:	68e2      	ldr	r2, [r4, #12]
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20001042:	4b07      	ldr	r3, [pc, #28]	@ (20001060 <SFU_LL_SECU_ActivateSecUser+0x60>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20001044:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20001048:	4313      	orrs	r3, r2
2000104a:	60e3      	str	r3, [r4, #12]
2000104c:	f3bf 8f4f 	dsb	sy
    __NOP();
20001050:	bf00      	nop
  for(;;)                                                           /* wait until reset */
20001052:	e7fd      	b.n	20001050 <SFU_LL_SECU_ActivateSecUser+0x50>
20001054:	e000ed00 	.word	0xe000ed00
20001058:	e000ef00 	.word	0xe000ef00
2000105c:	20001064 	.word	0x20001064
20001060:	05fa0004 	.word	0x05fa0004

20001064 <jump_to_function>:

        .section  .RamFunc,"ax",%progbits
        .global jump_to_function
jump_to_function:
        LDR SP, [R0]
20001064:	f8d0 d000 	ldr.w	sp, [r0]
        LDR PC, [R0,#4]
20001068:	f8d0 f004 	ldr.w	pc, [r0, #4]

2000106c <launch_application>:
* return from exception to application launch function
* R0: application vector address
* R1: exit function address
* push interrupt context R0 R1 R2 R3 R12 LR PC xPSR
*******************************************************/
        MOV R2, #0x01000000 /* xPSR activate Thumb bit */
2000106c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
        PUSH {R2}
20001070:	b404      	push	{r2}
        MOV R2, #1
20001072:	f04f 0201 	mov.w	r2, #1
        BIC R1, R1, R2      /* clear least significant bit of exit function */
20001076:	ea21 0102 	bic.w	r1, r1, r2
        PUSH {R1}           /* return address = application entry point */
2000107a:	b402      	push	{r1}
        MOV R1, #0          /* clear other context registers */
2000107c:	f04f 0100 	mov.w	r1, #0
        PUSH {R1}
20001080:	b402      	push	{r1}
        PUSH {R1}
20001082:	b402      	push	{r1}
        PUSH {R1}
20001084:	b402      	push	{r1}
        PUSH {R1}
20001086:	b402      	push	{r1}
        PUSH {R1}
20001088:	b402      	push	{r1}
        PUSH {R0}           /* R0 = application entry point */
2000108a:	b401      	push	{r0}
        MOV LR, #0xFFFFFFF9 /* set LR to return to thread mode with main stack */
2000108c:	f06f 0e06 	mvn.w	lr, #6
        BX LR               /* return from interrupt */
20001090:	4770      	bx	lr
20001092:	0000      	movs	r0, r0
20001094:	0000      	movs	r0, r0
	...

20001098 <__HAL_FLASH_Unlock_veneer>:
20001098:	f85f f000 	ldr.w	pc, [pc]	@ 2000109c <__HAL_FLASH_Unlock_veneer+0x4>
2000109c:	0800b421 	.word	0x0800b421
